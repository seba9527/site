(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{428:function(v,_,a){v.exports=a.p+"assets/img/Snipaste_2020-05-20_13-55-00.711db87c.png"},429:function(v,_,a){v.exports=a.p+"assets/img/Snipaste_2020-05-20_14-46-28.122bf230.png"},430:function(v,_,a){v.exports=a.p+"assets/img/Snipaste_2020-05-20_14-21-01.6f999381.png"},538:function(v,_,a){"use strict";a.r(_);var t=a(14),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("blockquote",[t("p",[v._v("论文名称：FANS: Fuzzing Android Native System Services via Automated Interface Analysis")]),v._v(" "),t("p",[v._v("关键词：安卓系统服务 模糊测试")]),v._v(" "),t("p",[v._v("论文类型：期刊")]),v._v(" "),t("p",[v._v("发表位置：usenix")]),v._v(" "),t("p",[v._v("发表年份：2020")])]),v._v(" "),t("h2",{attrs:{id:"详细阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#详细阅读"}},[v._v("#")]),v._v(" 详细阅读")]),v._v(" "),t("h3",{attrs:{id:"摘要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[v._v("#")]),v._v(" 摘要")]),v._v(" "),t("p",[v._v("现状：安卓原生系统服务给用户应用提供了必要的支持和基本的函数功能，找到这里面的漏洞对分析安卓的安全非常重要。 "),t("code",[v._v("Fuzz")]),v._v(" 是非常好的一个方法，但是会面临很多问题。")]),v._v(" "),t("ol",[t("li",[v._v("这些服务是通过 "),t("code",[v._v("binder")]),v._v(" 调用")]),v._v(" "),t("li",[t("code",[v._v("fuzzer")]),v._v(" 必须生成接口相关的测试样例")]),v._v(" "),t("li",[v._v("测试样例必须满足语法规则")])]),v._v(" "),t("p",[v._v("对于这些问题，文章提出了一种自动化的基于生成的 "),t("code",[v._v("fuzz")]),v._v(" 方法。主要功能有")]),v._v(" "),t("ol",[t("li",[v._v("收集目标系统中的所有服务接口，发现多层嵌套的接口，并进行测试")]),v._v(" "),t("li",[v._v("自动化从目标接口的 "),t("code",[v._v("AST")]),v._v(" 中解析接口的数据模型，包括可行的事务代码，事务数据中的变量名称和类型")]),v._v(" "),t("li",[v._v("通过变量名称和类型的知识，判断事务中的变量依赖关系；通过生成和使用关系推断接口的依赖性")]),v._v(" "),t("li",[v._v("使用接口模型和依赖性知识，生成具有有效格式和语义的事务序列，以测试目标服务的接口")])]),v._v(" "),t("p",[v._v("同时发现了30多个漏洞和138个 "),t("code",[v._v("Java")]),v._v(" 异常。")]),v._v(" "),t("h3",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),t("p",[v._v("首先说明了安卓原始系统服务的漏洞百出，但是没有很多工作去分析安卓原生系统服务中的问题，介绍了两种自动化的 "),t("code",[v._v("fuzz")]),v._v(" 手段，说明其不完整和不准确性，或者是需要反射来获取变量类型，均不能用来恢复输入的模型。")]),v._v(" "),t("p",[v._v("在安卓中，系统服务被注册到 "),t("code",[v._v("Service Manager")]),v._v(" 中，用户态应用可以通过查询来获取目标服务的接口，然后通过 RPC 调用各种不同的事务，"),t("code",[v._v("IBinder::transact(code,data,reply,flags)")]),v._v(" ，参数包含目标事务的代码和序列化的数据，然后通过这种方法测试所有的系统服务。这里会面临三个挑战。")]),v._v(" "),t("ol",[t("li",[v._v("多层接口的识别。除了在 "),t("code",[v._v("Service Manager")]),v._v(" 注册过的接口，有很多多层嵌套的接口，还要考虑到很多编译时动态生成的代码，比如 "),t("code",[v._v("Android Interface Definition Language (AIDL)")]),v._v(" 。")]),v._v(" "),t("li",[v._v("接口模型的解析。")]),v._v(" "),t("li",[v._v("生成语义正确的输入。")])]),v._v(" "),t("p",[v._v("主要贡献")]),v._v(" "),t("ol",[t("li",[v._v("我们系统地研究了 "),t("code",[v._v("Android")]),v._v(" 本机系统服务中的接口与未挖掘的更深层次的接口之间的依赖关系。")]),v._v(" "),t("li",[v._v("我们提出了一种从 "),t("code",[v._v("AST")]),v._v(" 中自动提取输入接口模型和语义的解决方案。 此方法可以应用于其他基于接口的程序。")]),v._v(" "),t("li",[v._v("我们提出了一种解决方案，可以通过利用不同事务中的序列化和反序列化对中的变量名和类型知识来推断事务间的依赖性。")]),v._v(" "),t("li",[v._v("我们实现了 "),t("code",[v._v("FANS")]),v._v(" 的原型，以系统地模糊 "),t("code",[v._v("Android")]),v._v(" 本机系统服务，并且发现了30个独特的本机漏洞和138个独特的 "),t("code",[v._v("Java")]),v._v(" 异常。")])]),v._v(" "),t("h3",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[v._v("#")]),v._v(" 背景")]),v._v(" "),t("p",[v._v("介绍安卓的系统服务。")]),v._v(" "),t("h4",{attrs:{id:"android系统服务的系统化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android系统服务的系统化"}},[v._v("#")]),v._v(" Android系统服务的系统化")]),v._v(" "),t("p",[v._v("安卓里的服务可以分为2部分，一个是 "),t("code",[v._v("Java")]),v._v(" 服务，是由 "),t("code",[v._v("Java")]),v._v(" 实现的， 一个是原生服务，基本是由 "),t("code",[v._v("C++")]),v._v(" 实现的。从另一个角度看，可以分为正常域、服务商域、硬件域。正常域中的服务是  "),t("code",[v._v("Android Open Source Project (AOSP)")]),v._v(" 中的，其他的是和服务商或者硬件相关的。")]),v._v(" "),t("h4",{attrs:{id:"应用程序-服务通信模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用程序-服务通信模型"}},[v._v("#")]),v._v(" 应用程序-服务通信模型")]),v._v(" "),t("p",[v._v("该图展示了应用和服务是如何通信的。")]),v._v(" "),t("p",[t("img",{attrs:{src:a(428),alt:"安卓应用于服务通信"}})]),v._v(" "),t("h4",{attrs:{id:"android系统服务中的接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android系统服务中的接口"}},[v._v("#")]),v._v(" Android系统服务中的接口")]),v._v(" "),t("p",[v._v("每个服务都有一系列的服务可以通过 "),t("code",[v._v("RPC")]),v._v(" 来调用。")]),v._v(" "),t("h4",{attrs:{id:"研究范围"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#研究范围"}},[v._v("#")]),v._v(" 研究范围")]),v._v(" "),t("p",[v._v("文章主要讨论在正确域中的系统服务，主要是在 "),t("code",[v._v("service manager")]),v._v(" 中注册过的。同时，由于所有 "),t("code",[v._v("Android")]),v._v(" 系统服务在通信和接口实现方面都共享相同的体系结构，因此本文提出的方案也可以应用于其他类型的服务。")]),v._v(" "),t("h3",{attrs:{id:"设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计"}},[v._v("#")]),v._v(" 设计")]),v._v(" "),t("p",[v._v("主要讨论这个 "),t("code",[v._v("Fans")]),v._v(" 是如何设计的。")]),v._v(" "),t("ol",[t("li",[v._v("以 "),t("code",[v._v("RPC")]),v._v(" 为中心的测试，减少难度，并且尽可能提高可靠性，因为传统的注入攻击会生成任意事件，在实际的过程中通常不可能。")]),v._v(" "),t("li",[v._v("基于生成的 "),t("code",[v._v("Fuzz")]),v._v(" ，不采用基于变异的 "),t("code",[v._v("Fuzz")]),v._v(" ，因为基于变异的数据生成通常会生成很多无格式意义的数据，代码覆盖率较低。")]),v._v(" "),t("li",[v._v("从代码中学习输入模型，因为采用基于生成的模糊测试，所以需要根据输入模型，但是现有的 "),t("code",[v._v("Fuzz")]),v._v(" 的数据都是通过人为努力，提取出来的数据，对安卓服务不可用。还有的一些方法从现有的事务中提取输入，但是总体上是不完整和不准确的。最后考虑到，输入模型知识将被隐藏在源代码中，所以选择分析 "),t("code",[v._v("Android")]),v._v(" 源代码来自动化恢复输入模型。")])]),v._v(" "),t("p",[t("img",{attrs:{src:a(429),alt:"FANS"}})]),v._v(" "),t("p",[v._v("整个系统分为4部分，接口收集器负责收集整个系统的顶层接口和多层嵌套接口；然后接口模型解析器负责解析输入和输出格式，以及变量语义、名字和类型等信息，同时还收集一些结构体的信息；然后依赖推测器推测接口间、接口内部的变量依赖。最后基于上面的信息，模糊测试器随机生成事务并调用相关的接口，来测试系统服务，该模块还有一个管理器负责同步主机和手机间的数据。")]),v._v(" "),t("h4",{attrs:{id:"接口收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口收集器"}},[v._v("#")]),v._v(" 接口收集器")]),v._v(" "),t("p",[v._v("顶层或多层的接口都有 onTransact 方法来分发事务，利用这一特性，检查了在AOSP编译命令中作为源出现的每个C / C ++文件，这样就能收集到由AIDL动态生成的接口。")]),v._v(" "),t("h4",{attrs:{id:"接口模型提取器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口模型提取器"}},[v._v("#")]),v._v(" 接口模型提取器")]),v._v(" "),t("h4",{attrs:{id:"依赖推测器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖推测器"}},[v._v("#")]),v._v(" 依赖推测器")]),v._v(" "),t("p",[v._v("主要解决2个依赖，一是接口依赖，如何识别和生成多级接口，以及接口之间的调用关系；二是变量依赖，事务中变量之间的依赖关系。")]),v._v(" "),t("h5",{attrs:{id:"接口依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口依赖"}},[v._v("#")]),v._v(" 接口依赖")]),v._v(" "),t("h5",{attrs:{id:"变量依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量依赖"}},[v._v("#")]),v._v(" 变量依赖")]),v._v(" "),t("h4",{attrs:{id:"模糊测试引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模糊测试引擎"}},[v._v("#")]),v._v(" 模糊测试引擎")]),v._v(" "),t("h3",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[v._v("#")]),v._v(" 实现")]),v._v(" "),t("p",[v._v("实现的话，并没有采用 "),t("code",[v._v("AFL")]),v._v(" ，因为转换到安卓要话很多的工作；其次测试大量的服务需要一个一个编译；最后 "),t("code",[v._v("AFL")]),v._v(" 不擅长测试这种基于服务的应用。")]),v._v(" "),t("p",[t("img",{attrs:{src:a(430),alt:"代码量"}})]),v._v(" "),t("ol",[t("li",[v._v("接口收集器，首先编译 "),t("code",[v._v("ASOP")]),v._v(" 代码库，记录编译命令，然后找出特性。")]),v._v(" "),t("li",[v._v("接口模型解析器，在 "),t("code",[v._v("AST")]),v._v(" 上做一个近似切片，仅保留与输入和输出变量相关的语句，而忽略其他语句。")]),v._v(" "),t("li",[v._v("依赖推测器，给定使用 "),t("code",[v._v("JSON")]),v._v(" 描述的接口模型，将遍历该模型并进行接口依赖性推断")]),v._v(" "),t("li",[v._v("模糊测试引擎，实现了一个简单的模糊器管理器，以便在多部电话上运行，并在主机和智能手机之间同步数据。由于某些 "),t("code",[v._v("Android")]),v._v(" 本机系统服务在接收 "),t("code",[v._v("RPC")]),v._v(" 请求时会检查调用方的权限，因此模糊检查程序将以root特权执行。同时采用异步的 "),t("code",[v._v("RPC")]),v._v(" 。为了分析触发的崩溃，我们使用 "),t("code",[v._v("Android")]),v._v(" 的内置 "),t("code",[v._v("logcat")]),v._v(" 工具进行日志记录。")])]),v._v(" "),t("h3",{attrs:{id:"评估"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#评估"}},[v._v("#")]),v._v(" 评估")]),v._v(" "),t("p",[v._v("评估需要评估3个问题。")]),v._v(" "),t("ol",[t("li",[v._v("能找到多少个接口，接口间的关系是什么。")]),v._v(" "),t("li",[v._v("所提取的接口模型是什么样的，模型是否完整和与精确。")]),v._v(" "),t("li",[t("code",[v._v("FANS")]),v._v(" 能多高效得找到这些服务接口。")])]),v._v(" "),t("h3",{attrs:{id:"讨论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讨论"}},[v._v("#")]),v._v(" 讨论")]),v._v(" "),t("p",[v._v("讨论 FANS 的局限性和进一步工作。")]),v._v(" "),t("h4",{attrs:{id:"接口模型的精度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口模型的精度"}},[v._v("#")]),v._v(" 接口模型的精度")]),v._v(" "),t("p",[v._v("一是接口模型的精度仍需确认，比如对列表的循环遍历操作，循环大小不确定。二是开发人员在某处定义了语义类型，他也可能会使用原始类型而不是类型别名，因此无法获得更多的语义类型，这将影响变量依赖的生成。三是得到的依赖关系可能不完整，因为在事务调用之间可能存在特定的顺序，服务可以看作是状态机，但是，在测试的过程中，如果我们始终遵循指定的顺序，则可能会错过一些漏洞。这说明服务状态机处理不完整，而引起一些漏洞。")]),v._v(" "),t("h4",{attrs:{id:"覆盖率指导下的检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#覆盖率指导下的检测"}},[v._v("#")]),v._v(" 覆盖率指导下的检测")]),v._v(" "),t("p",[v._v("由于系统服务是状态敏感的，因此其覆盖率可能会受到前面生成的输入或其他应用调用的影响。")]),v._v(" "),t("h4",{attrs:{id:"提高fuzz的效率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提高fuzz的效率"}},[v._v("#")]),v._v(" 提高fuzz的效率")]),v._v(" "),t("p",[v._v("由于某些 Android 系统服务是守护程序运行的，或者可能会检查调用者的权限。以 root 用户身份进行测试会导致一些问题。发现即使在启动Fuzzer 10分钟之后，手机也可以进入恢复模式，需要手动刷新手机，这极大地影响了FANS的效率。")]),v._v(" "),t("h4",{attrs:{id:"基于接口的模糊测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于接口的模糊测试"}},[v._v("#")]),v._v(" 基于接口的模糊测试")]),v._v(" "),t("p",[v._v("在 Android 9 中，主要存在三种位于不同域中的服务：普通域，供应商域和硬件域，本文主要关注普通域中的本机系统服务。但是，这三种服务在通信和接口实现方面共享相同的体系结构。因此可以轻松地将该方法转移到其他服务中。")]),v._v(" "),t("p",[v._v("此外，还存在一些不属于上述部分的类似接口，即定制接口。 这些接口旨在由应用程序实现和实例化，并由客户端传递到服务器端，文章没有实现的原因是需要手动实例化这些接口。")]),v._v(" "),t("h3",{attrs:{id:"相关工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关工作"}},[v._v("#")]),v._v(" 相关工作")]),v._v(" "),t("h4",{attrs:{id:"进程间通信-ipc-和-服务安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信-ipc-和-服务安全"}},[v._v("#")]),v._v(" 进程间通信 IPC 和 服务安全")]),v._v(" "),t("p",[v._v("指出前人的工作是基于 "),t("code",[v._v("intent")]),v._v(" 的安全分析，关于 "),t("code",[v._v("binder")]),v._v(" 这方面的工作不足。事实上 "),t("code",[v._v("binder")]),v._v(" 才是安卓系统中的实际安全边界，有去分析 "),t("code",[v._v("AIDL")]),v._v(" 文件的，有分析输入验证漏洞和访问控制不一致的，还有从 "),t("code",[v._v("IPC")]),v._v(" 流量中试图理解输入模型和事务依赖关系的，但是这些方法缺乏完整性和准确性。")]),v._v(" "),t("h4",{attrs:{id:"fuzzing-for-structured-input"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fuzzing-for-structured-input"}},[v._v("#")]),v._v(" Fuzzing for Structured Input")]),v._v(" "),t("p",[v._v("如何去 "),t("code",[v._v("fuzz")]),v._v(" 一个输入的结构体是关键的问题之一。通常有两种方法。")]),v._v(" "),t("ol",[t("li",[v._v("基于生成的 "),t("code",[v._v("fuzzer")]),v._v(" ，采用模板和预先定义的语法。比如 "),t("code",[v._v("Peach")]),v._v(" ， 这些方法需要人工参与且拓展性较差。")]),v._v(" "),t("li",[v._v("基于突变的 "),t("code",[v._v("fuzzer")]),v._v(" ，突变现有的测试样例，生成一个没有规则的新样例，通过动态污点分析找到输入的共同特点，也有结合符号执行进行模糊测试的。")])]),v._v(" "),t("h2",{attrs:{id:"文章综述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文章综述"}},[v._v("#")]),v._v(" 文章综述")]),v._v(" "),t("p",[v._v("该文章提出了一种 "),t("code",[v._v("fuzz")]),v._v(" 安卓原生系统服务的方法。能自动化的生成事务，并调用相应的接口。 "),t("code",[v._v("fans")]),v._v(" 能自动化处理接口间的复杂依赖。这种依赖性体现在三方面：变量模式、类型别名和变量依赖性。最后发现了30多个漏洞，138个 "),t("code",[v._v("Java")]),v._v(" 异常，这些东西要 "),t("code",[v._v("fuzz")]),v._v(" 到，必须要有一个精确的接口模型。")]),v._v(" "),t("h2",{attrs:{id:"关键部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关键部分"}},[v._v("#")]),v._v(" 关键部分")]),v._v(" "),t("blockquote",[t("p",[v._v("用来记录本篇文章关键的地方，标注好内容和页码")])]),v._v(" "),t("h2",{attrs:{id:"研究方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#研究方法"}},[v._v("#")]),v._v(" 研究方法")]),v._v(" "),t("blockquote",[t("p",[v._v("可以看出此类问题，大家都是采用一个什么样的方法去解决的")])]),v._v(" "),t("h2",{attrs:{id:"存在问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[v._v("#")]),v._v(" 存在问题")]),v._v(" "),t("p",[v._v("如何解决面临的挑战")]),v._v(" "),t("ol",[t("li",[v._v("多层接口的识别")]),v._v(" "),t("li",[v._v("接口模型的解析")]),v._v(" "),t("li",[v._v("语义正确的输入生成")])]),v._v(" "),t("h2",{attrs:{id:"产生原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[v._v("#")]),v._v(" 产生原因")]),v._v(" "),t("h2",{attrs:{id:"解决方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[v._v("#")]),v._v(" 解决方法")]),v._v(" "),t("h2",{attrs:{id:"创新点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创新点"}},[v._v("#")]),v._v(" 创新点")]),v._v(" "),t("p",[v._v("自动化进行 "),t("code",[v._v("fuzz")])]),v._v(" "),t("p",[v._v("正确处理事务之间的依赖")]),v._v(" "),t("h2",{attrs:{id:"不足之处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不足之处"}},[v._v("#")]),v._v(" 不足之处")]),v._v(" "),t("blockquote",[t("p",[v._v("别人论文里的不足可能是你 "),t("code",[v._v("idea")]),v._v(" 的来源")])])])}),[],!1,null,null,null);_.default=r.exports}}]);