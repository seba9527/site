(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{428:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_13-55-00.711db87c.png"},429:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_14-46-28.122bf230.png"},430:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_21-51-38.660f2b54.png"},431:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_21-52-28.95fba800.png"},432:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_21-52-36.ae213da2.png"},433:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_21-52-40.5a9274c2.png"},434:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_21-52-51.268adfcf.png"},435:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-20_14-21-01.6f999381.png"},543:function(_,v,a){"use strict";a.r(v);var t=a(14),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("blockquote",[t("p",[_._v("论文名称：FANS: Fuzzing Android Native System Services via Automated Interface Analysis")]),_._v(" "),t("p",[_._v("关键词：安卓系统服务 模糊测试")]),_._v(" "),t("p",[_._v("论文类型：会议")]),_._v(" "),t("p",[_._v("发表位置：usenix")]),_._v(" "),t("p",[_._v("发表年份：2020")])]),_._v(" "),t("h2",{attrs:{id:"详细阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#详细阅读"}},[_._v("#")]),_._v(" 详细阅读")]),_._v(" "),t("h3",{attrs:{id:"摘要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[_._v("#")]),_._v(" 摘要")]),_._v(" "),t("p",[_._v("现状：安卓原生系统服务给用户应用提供了必要的支持和基本的函数功能，找到这里面的漏洞对分析安卓的安全非常重要。 "),t("code",[_._v("Fuzz")]),_._v(" 是非常好的一个方法，但是会面临很多问题。")]),_._v(" "),t("ol",[t("li",[_._v("这些服务是通过 "),t("code",[_._v("binder")]),_._v(" 调用，也就是 IPC")]),_._v(" "),t("li",[t("code",[_._v("fuzzer")]),_._v(" 必须自动化分辨接口，并生成接口相关的测试样例")]),_._v(" "),t("li",[_._v("测试样例仍必须满足语法规则，包含变量依赖和接口依赖")])]),_._v(" "),t("p",[_._v("对于这些问题，文章提出了一种自动化的基于生成的 "),t("code",[_._v("fuzz")]),_._v(" 方法，发现安卓系统中的服务漏洞，主要的特点有：")]),_._v(" "),t("ol",[t("li",[_._v("收集目标系统中的所有服务接口，发现多层嵌套的接口，并进行测试")]),_._v(" "),t("li",[_._v("自动化从目标接口的 "),t("code",[_._v("AST")]),_._v(" 中提取接口的数据模型，包括可行的事务代码，事务数据中的变量名称和类型")]),_._v(" "),t("li",[_._v("通过变量名称和类型的知识，判断事务中的变量依赖关系；通过生成和使用关系推断接口的依赖性")]),_._v(" "),t("li",[_._v("使用接口模型和依赖性知识，生成具有有效格式和语义的事务序列，以测试目标服务的接口")])]),_._v(" "),t("h3",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[_._v("#")]),_._v(" 介绍")]),_._v(" "),t("p",[_._v("首先说明了安卓原始系统服务的漏洞百出，但是没有很多工作去分析安卓原生系统服务中的问题，介绍了两种自动化的 "),t("code",[_._v("fuzz")]),_._v(" 手段，说明其不完整和不准确性，或者是需要反射来获取变量类型，均不能用来恢复输入的模型。")]),_._v(" "),t("p",[_._v("在安卓中，系统服务被注册到 "),t("code",[_._v("Service Manager")]),_._v(" 中，用户态应用可以通过查询来获取目标服务的接口，然后通过 RPC 调用各种不同的事务 "),t("code",[_._v("IBinder::transact(code,data,reply,flags)")]),_._v(" ，参数包含目标事务的代码和序列化的数据，然后通过这种方法测试所有的系统服务，这里会面临三个挑战。")]),_._v(" "),t("ol",[t("li",[_._v("多层接口的识别。除了在 "),t("code",[_._v("Service Manager")]),_._v(" 注册过的接口，有很多多层嵌套的接口，还要考虑到很多编译时动态生成的代码，比如 "),t("code",[_._v("Android Interface Definition Language (AIDL)")]),_._v(" 。")]),_._v(" "),t("li",[_._v("接口模型的提取。对每一个接口，需要获取其支持的所有事务，为了提高效率，数据必须满足目标接口的语法规则，但是手动去生成这样的规则是不可拓展的。但是由于语法规则是和接口相关的，就需要每一个都去提取语法规则；其次由于语法规则和路径约束共存，分支条件、循环条件以及嵌套循环使得整个过程难以提取。")]),_._v(" "),t("li",[_._v("生成语义正确的输入。安卓本身有很多安全检测，如果不满足输入规则，则打不到去自动化挖掘漏洞的效果。语义要求有很多类型，包括变量名称和类型，甚至变量或接口之间的依赖关系。枚举类型的变量只能具有一组有限的候选值，当前事务中的一个变量可能取决于当前或前一个事务中的另一个变量，甚至一个接口也可能取决于另一个接口。")])]),_._v(" "),t("h4",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[_._v("#")]),_._v(" 方法")]),_._v(" "),t("p",[_._v("为了解决挑战1，首先通过扫描服务注册操作来识别所有顶级接口，然后基于一个事实，即所有的多层接口，均会调用 writeStrongBinder 函数，监听其即可。为了解决挑战2，由于安卓使用一系列的反序列化方法来解析输入数据，通过识别调用的序列，可以推测合法输入的语法。为了解决挑战3，利用从 AST 中保存的变量名和类型规则，生成合适的输入，并识别事务间的变量依赖。这是由于一个依赖的事务，会将另一个依赖的事务序列化的数据反序列化。通过这种方式识别事务间变量依赖性。")]),_._v(" "),t("h4",{attrs:{id:"主要贡献"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主要贡献"}},[_._v("#")]),_._v(" 主要贡献")]),_._v(" "),t("ol",[t("li",[_._v("系统地研究了 "),t("code",[_._v("Android")]),_._v(" 本机系统服务中的接口与未挖掘的更深层次的接口之间的依赖关系。")]),_._v(" "),t("li",[_._v("提出了一种从 "),t("code",[_._v("AST")]),_._v(" 中自动提取输入接口模型和语义的解决方案，此方法可以应用于其他基于接口的程序。")]),_._v(" "),t("li",[_._v("提出了一种解决方案，可以利用不同事务中的序列化和反序列化对中的变量名和类型知识，来推测事务间的依赖性。")]),_._v(" "),t("li",[_._v("实现了 "),t("code",[_._v("FANS")]),_._v(" 的原型，以系统地模糊测试 "),t("code",[_._v("Android")]),_._v(" 本机系统服务，并且发现了30个本机漏洞和138个的 "),t("code",[_._v("Java")]),_._v(" 异常。")])]),_._v(" "),t("h3",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[_._v("#")]),_._v(" 背景")]),_._v(" "),t("p",[_._v("介绍安卓的系统服务和研究范围。文章主要讨论在正确域中的系统服务，主要是在 "),t("code",[_._v("service manager")]),_._v(" 中注册过的。同时，由于所有 "),t("code",[_._v("Android")]),_._v(" 系统服务在通信和接口实现方面都共享相同的体系结构，因此本文提出的方案也可以应用于其他类型的服务。")]),_._v(" "),t("h4",{attrs:{id:"android系统服务的系统化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android系统服务的系统化"}},[_._v("#")]),_._v(" Android系统服务的系统化")]),_._v(" "),t("p",[_._v("安卓里的服务可以分为2部分，一个是 "),t("code",[_._v("Java")]),_._v(" 服务，是由 "),t("code",[_._v("Java")]),_._v(" 实现的，一个是原生服务，基本是由 "),t("code",[_._v("C++")]),_._v(" 实现的。从另一个角度看，可以分为正常域、服务商域、硬件域。正常域中的服务是  "),t("code",[_._v("Android Open Source Project (AOSP)")]),_._v(" 中的，其他的是和服务商或者硬件相关的。")]),_._v(" "),t("h4",{attrs:{id:"应用程序-服务通信模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用程序-服务通信模型"}},[_._v("#")]),_._v(" 应用程序-服务通信模型")]),_._v(" "),t("p",[t("img",{attrs:{src:a(428),alt:"安卓应用于服务通信"}})]),_._v(" "),t("p",[_._v("该图展示了应用和服务是如何通信的。")]),_._v(" "),t("ol",[t("li",[_._v("服务首先注册到服务管理器中，然后监听并处理应用的请求。")]),_._v(" "),t("li",[_._v("另一方面，应用会查询服务管理器来获得目标服务的接口，封装在 Binder 中，这种是顶层的接口。")]),_._v(" "),t("li",[_._v("然后，应用可以利用顶级接口检索多级接口，或调用该接口提供的事务以执行操作。")]),_._v(" "),t("li",[_._v("应用还可以检索更深的多层接口并调用相应的事务。")])]),_._v(" "),t("h4",{attrs:{id:"android系统服务中的接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android系统服务中的接口"}},[_._v("#")]),_._v(" Android系统服务中的接口")]),_._v(" "),t("p",[_._v("应用通过统一的 RPC 接口在顶级接口中调用目标事务 IBinder::transact(code, data,reply,flags). 这就意味着，在服务端有一个分发器，根据代码处理不同的响应。分发器定义为一个完整的过程 onTransact(code, data, reply, flags). 然后就会反序列化输入数据，并执行相应的操作。每个服务都有一系列方法可以通过 RPC 进行调用。该机制也适用于多级接口，因为多级接口与顶级接口共享相同的体系结构。")]),_._v(" "),t("h3",{attrs:{id:"设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计"}},[_._v("#")]),_._v(" 设计")]),_._v(" "),t("p",[_._v("主要讨论这个 "),t("code",[_._v("Fans")]),_._v(" 是如何设计的。")]),_._v(" "),t("ol",[t("li",[_._v("以 "),t("code",[_._v("RPC")]),_._v(" 为中心的测试，减少难度，并且尽可能提高可靠性，因为传统的注入攻击工程难度较大，不能生成任意事件，在实际的过程中通常不可能。")]),_._v(" "),t("li",[_._v("基于生成的 "),t("code",[_._v("Fuzz")]),_._v(" ，不采用基于变异的 "),t("code",[_._v("Fuzz")]),_._v(" ，因为基于变异的数据生成通常会生成很多无格式意义的数据，代码覆盖率较低。")]),_._v(" "),t("li",[_._v("从代码中学习输入模型，因为采用基于生成的模糊测试，所以需要根据输入模型，但是现有的 "),t("code",[_._v("Fuzz")]),_._v(" 的数据都是通过人工提取出来的数据，对安卓服务不可用。还有的一些方法从现有的事务中提取输入，但是总体上是不完整和不准确的。最后考虑到，输入模型知识被隐藏在源代码中，所以选择分析 "),t("code",[_._v("Android")]),_._v(" 源代码来自动化恢复输入模型。")])]),_._v(" "),t("p",[t("img",{attrs:{src:a(429),alt:"FANS"}})]),_._v(" "),t("p",[_._v("整个系统分为4部分。")]),_._v(" "),t("ol",[t("li",[_._v("接口收集器负责收集整个系统的顶层接口和多层嵌套接口")]),_._v(" "),t("li",[_._v("接口模型提取器负责解析输入和输出格式，以及变量语义、名字和类型等信息，同时还收集一些结构体的信息")]),_._v(" "),t("li",[_._v("依赖推测器推测接口之间、接口内部的变量依赖")]),_._v(" "),t("li",[_._v("模糊测试器随机生成事务并调用相关的接口，来测试系统服务，该模块还有一个管理器负责同步主机和手机间的数据。")])]),_._v(" "),t("h4",{attrs:{id:"接口收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口收集器"}},[_._v("#")]),_._v(" 接口收集器")]),_._v(" "),t("p",[_._v("顶层或多层的接口都有 onTransact 方法来分发事务，利用这一特性，检查了在AOSP编译命令中作为源出现的每个C / C ++文件，这样就能收集到由AIDL动态生成的接口。")]),_._v(" "),t("h4",{attrs:{id:"接口模型提取器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口模型提取器"}},[_._v("#")]),_._v(" 接口模型提取器")]),_._v(" "),t("p",[_._v("提取需要有几个原则，分别是完整性、精确性、方便性。")]),_._v(" "),t("h5",{attrs:{id:"提取器的设计选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提取器的设计选择"}},[_._v("#")]),_._v(" 提取器的设计选择")]),_._v(" "),t("p",[_._v("选择从服务端提取数据。这是由于在服务端，会处理 RPC 调用的方法，根据相关性，可以在两侧都提取数据。只在服务端提取数据的原因在于：模糊测试的目标就是服务，直接与服务器端打交道将使我们更准确地了解服务器端代码期望输入什么，以及服务如何使用从数据中反序列化输入，并序列化为输出。二是接口具有多个事务，这些事务的定义和实现通常分布在服务器端代码中。另一方面，客户端代码可能以分散的方式调用它们，如果从客户端提取数据，会给接口模型提取带来麻烦。")]),_._v(" "),t("p",[_._v("其次是从 AST 表达式中提取数据。由于一部分代码采用 AIDL 实现，另一部分是 C++ 实现，这里选择将 AIDL 文件转换为 C++ 文件，这样信息不会缺失，而且倒过来会降低精确性。一种选择是可以采用 IR 来表示这些信息，但其优化的原因，导致部分信息丢失，所以不考虑。而在AST中，变量名称和变量类型保持不变。此外，每个类型转换表达式都记录在AST中。此外， AST 提供了 onTransact 调度程序中每个接口的所有事务代码的清晰视图。")]),_._v(" "),t("p",[_._v("分派过程通常在 C++ 代码中作为 switch 语句实现，并在 AST 中转换为多个 case 节点，每个 case 代表要调用的事务。因此，我们可以通过分析 AST 中的节点轻松识别目标接口的所有事务，并识别关联的常量事务代码。")]),_._v(" "),t("h5",{attrs:{id:"输入和输出变量提取"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#输入和输出变量提取"}},[_._v("#")]),_._v(" 输入和输出变量提取")]),_._v(" "),t("p",[_._v("确定事务代码后，我们需要从每个事务的数据中提取反序列化的输入。此外，由于我们要推断事务间的依赖关系，因此我们还需要提取事务的输出，并将其输出序列化到输出中。主要有3类变量。顺序变量、条件变量和循环变量，分别对应了3个语句，顺序语句，条件语句和循环语句。")]),_._v(" "),t("p",[t("img",{attrs:{src:a(430),alt:"顺序语句"}})]),_._v(" "),t("p",[t("img",{attrs:{src:a(431),alt:"条件语句"}})]),_._v(" "),t("p",[t("img",{attrs:{src:a(432),alt:"循环语句"}})]),_._v(" "),t("p",[t("img",{attrs:{src:a(433),alt:"返回语句"}})]),_._v(" "),t("h5",{attrs:{id:"类型定义的提取"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型定义的提取"}},[_._v("#")]),_._v(" 类型定义的提取")]),_._v(" "),t("p",[_._v("有3中类型需要分析，分别是结构化的定义、枚举类型和类型别名。")]),_._v(" "),t("p",[t("img",{attrs:{src:a(434),alt:"定义语句"}})]),_._v(" "),t("p",[_._v("此外，由编译器保证，C/C++ 文件使用的所有头文件将按顺序包含在 AST 中，就可以收集所有相关类型的定义。")]),_._v(" "),t("h4",{attrs:{id:"依赖推测器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖推测器"}},[_._v("#")]),_._v(" 依赖推测器")]),_._v(" "),t("p",[_._v("主要解决2个依赖，一是接口依赖，如何识别和生成多级接口，以及接口之间的调用关系；二是变量依赖，事务中变量之间的依赖关系。")]),_._v(" "),t("h5",{attrs:{id:"接口依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口依赖"}},[_._v("#")]),_._v(" 接口依赖")]),_._v(" "),t("p",[_._v("第一个是生成依赖，如果可以通过一个接口检索另一个接口，则说这两个接口之间存在依赖。对于顶层接口，可以直接从服务管理器获取 Android 系统服务接口。对于多层接口，我们发现上级接口将调用 writeStrongBinder 将深度接口序列化为参数中的 reply 。这样，我们可以收集接口的所有依赖关系。")]),_._v(" "),t("p",[_._v("第二个是使用依赖，如果一个接口被另一个接口使用，那就说这2个接口间有使用依赖关系。我们发现，当一个接口 A 被另一个接口B使用时， B 将调用 readStrongBinder 从数据包中反序列化 A 。可以利用这种模式来推断使用依赖关系。")]),_._v(" "),t("h5",{attrs:{id:"变量依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量依赖"}},[_._v("#")]),_._v(" 变量依赖")]),_._v(" "),t("p",[_._v("变量依赖也是有2种，首先是事务内部的变量依赖。就是上面说的各种语句所产生的变量之间的依赖关系。")]),_._v(" "),t("p",[_._v("其次是事务间的变量依赖。下面是算法实现，原则是变量在不同的事务中；变量类型一致；变量类型复杂。")]),_._v(" "),t("p",[t("img",{attrs:{src:"assets/usenix-2020-fans/Snipaste_2020-05-20_22-20-29.png",alt:"算法"}})]),_._v(" "),t("h4",{attrs:{id:"模糊测试引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模糊测试引擎"}},[_._v("#")]),_._v(" 模糊测试引擎")]),_._v(" "),t("p",[_._v("fuzzer 开始生成测试用例，比如一个事务和其相关的接口。当 fuzz Android 系统服务时，我们会将事务代码指定的事务模糊测试。因此，我们可以随机生成一个事务，然后调用其相应的接口。我们可以基于接口模型一一生成事务的输入。在生成过程中，我们遵循以下原则。约束第一，依赖第二，类型与名字第三。")]),_._v(" "),t("h3",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[_._v("#")]),_._v(" 实现")]),_._v(" "),t("p",[_._v("实现的话，并没有采用 "),t("code",[_._v("AFL")]),_._v(" ，因为转换到安卓需要很多额外的工作；其次测试大量的服务需要一个一个编译；最后 "),t("code",[_._v("AFL")]),_._v(" 不擅长测试这种基于服务的应用。")]),_._v(" "),t("p",[t("img",{attrs:{src:a(435),alt:"代码量"}})]),_._v(" "),t("ol",[t("li",[_._v("接口收集器，首先编译 "),t("code",[_._v("ASOP")]),_._v(" 代码库，记录编译命令，然后找出特性之前说到的特性。")]),_._v(" "),t("li",[_._v("接口模型提取器，在 "),t("code",[_._v("AST")]),_._v(" 上做一个近似切片，仅保留与输入和输出变量相关的语句，而忽略其他语句。")]),_._v(" "),t("li",[_._v("依赖推测器，给定使用 "),t("code",[_._v("JSON")]),_._v(" 描述的接口模型，将遍历该模型并进行接口依赖性推断")]),_._v(" "),t("li",[_._v("模糊测试引擎，实现了一个简单的模糊器管理器，在多个手机上运行，并在主机和智能手机之间同步数据。由于某些 "),t("code",[_._v("Android")]),_._v(" 系统服务在接收 "),t("code",[_._v("RPC")]),_._v(" 请求时会检查调用方的权限，因此模糊检查程序将以 root 特权执行。同时采用异步的 "),t("code",[_._v("RPC")]),_._v(" 。为了分析触发的崩溃，我们使用 "),t("code",[_._v("Android")]),_._v(" 的内置 "),t("code",[_._v("logcat")]),_._v(" 工具进行日志记录。")])]),_._v(" "),t("h3",{attrs:{id:"评估"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#评估"}},[_._v("#")]),_._v(" 评估")]),_._v(" "),t("p",[_._v("评估需要评估3个问题。")]),_._v(" "),t("ol",[t("li",[_._v("能找到多少个接口，接口间的关系是什么。")]),_._v(" "),t("li",[_._v("所提取的接口模型是什么样的，模型是否完整和与精确。")]),_._v(" "),t("li",[t("code",[_._v("FANS")]),_._v(" 能多高效得找到这些服务接口。")])]),_._v(" "),t("p",[_._v("详细的就不写了。")]),_._v(" "),t("h3",{attrs:{id:"讨论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讨论"}},[_._v("#")]),_._v(" 讨论")]),_._v(" "),t("p",[_._v("讨论 FANS 的局限性和进一步工作。")]),_._v(" "),t("h4",{attrs:{id:"接口模型的精度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口模型的精度"}},[_._v("#")]),_._v(" 接口模型的精度")]),_._v(" "),t("p",[_._v("一是接口模型的精度仍需确认，比如对列表的循环遍历操作，循环大小不确定。二是开发人员在某处定义了语义类型，他也可能会使用原始类型而不是类型别名，因此无法获得更多的语义类型，这将影响变量依赖的生成。三是得到的依赖关系可能不完整，因为在事务调用之间可能存在特定的顺序，服务可以看作是状态机，但是，在测试的过程中，如果我们始终遵循指定的顺序，则可能会错过一些漏洞。这说明服务状态机处理不完整，而引起一些漏洞。")]),_._v(" "),t("h4",{attrs:{id:"覆盖率指导下的检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#覆盖率指导下的检测"}},[_._v("#")]),_._v(" 覆盖率指导下的检测")]),_._v(" "),t("p",[_._v("由于系统服务是状态敏感的，因此其覆盖率可能会受到前面生成的输入或其他应用调用的影响。")]),_._v(" "),t("h4",{attrs:{id:"提高fuzz的效率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提高fuzz的效率"}},[_._v("#")]),_._v(" 提高fuzz的效率")]),_._v(" "),t("p",[_._v("由于某些 Android 系统服务是守护程序运行的，或者可能会检查调用者的权限。以 root 用户身份进行测试会导致一些问题。发现即使在启动 Fuzzer 10分钟之后，手机也可以进入恢复模式，需要手动刷新手机，这极大地影响了FANS的效率。")]),_._v(" "),t("h4",{attrs:{id:"基于接口的模糊测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于接口的模糊测试"}},[_._v("#")]),_._v(" 基于接口的模糊测试")]),_._v(" "),t("p",[_._v("在 Android 9 中，主要存在三种位于不同域中的服务：普通域，供应商域和硬件域，本文主要关注普通域中的本机系统服务。但是，这三种服务在通信和接口实现方面共享相同的体系结构，可以轻松地将该方法转移到其他服务中。")]),_._v(" "),t("p",[_._v("此外，还存在一些不属于上述部分的类似接口，即定制接口。 这些接口旨在由应用程序实现和实例化，并由客户端传递到服务器端，文章没有实现的原因是需要手动实例化这些接口。")]),_._v(" "),t("h3",{attrs:{id:"相关工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关工作"}},[_._v("#")]),_._v(" 相关工作")]),_._v(" "),t("h4",{attrs:{id:"进程间通信-ipc-和-服务安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信-ipc-和-服务安全"}},[_._v("#")]),_._v(" 进程间通信 IPC 和 服务安全")]),_._v(" "),t("p",[_._v("指出前人的工作是基于 "),t("code",[_._v("intent")]),_._v(" 的安全分析，关于 "),t("code",[_._v("binder")]),_._v(" 这方面的工作不足。事实上 "),t("code",[_._v("binder")]),_._v(" 才是安卓系统中的实际安全边界，有去分析 "),t("code",[_._v("AIDL")]),_._v(" 文件的，有分析输入验证漏洞和访问控制不一致的，还有从 "),t("code",[_._v("IPC")]),_._v(" 流量中试图理解输入模型和事务依赖关系的，但是这些方法缺乏完整性和准确性。")]),_._v(" "),t("h4",{attrs:{id:"对结构化输入进行模糊测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对结构化输入进行模糊测试"}},[_._v("#")]),_._v(" 对结构化输入进行模糊测试")]),_._v(" "),t("p",[_._v("如何去 "),t("code",[_._v("fuzz")]),_._v(" 一个输入的结构体是关键的问题之一。通常有两种方法。")]),_._v(" "),t("ol",[t("li",[_._v("基于生成的 "),t("code",[_._v("fuzzer")]),_._v(" ，采用模板和预先定义的语法。比如 "),t("code",[_._v("Peach")]),_._v(" ， 这些方法需要人工参与且拓展性较差。")]),_._v(" "),t("li",[_._v("基于突变的 "),t("code",[_._v("fuzzer")]),_._v(" ，突变现有的测试样例，生成一个没有规则的新样例，通过动态污点分析找到输入的共同特点，也有结合符号执行进行模糊测试的。")])]),_._v(" "),t("h3",{attrs:{id:"结论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[_._v("#")]),_._v(" 结论")]),_._v(" "),t("p",[_._v("在这项工作中， FANS 旨在对 Android 本机系统服务进行 fuzz 。实验已经验证，它能自动生成事务并调用相应接口，这极大地有助于测试 Android 的系统服务。评估表明， FANS 还能够推断这些接口之间的复杂依赖。接口模型在三个方面非常复杂，变量模式，类型别名和变量依赖。")]),_._v(" "),t("p",[_._v("该项目在六台手机上运行了 FANS 约30天，并向 Google 报告了30个本地漏洞，其中20个已被确认。这些漏洞表明，如果没有精确的接口模型，我们就无法深入测试 Android 本机系统服务。")]),_._v(" "),t("h2",{attrs:{id:"文章综述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文章综述"}},[_._v("#")]),_._v(" 文章综述")]),_._v(" "),t("p",[_._v("该文章提出了一种 "),t("code",[_._v("fuzz")]),_._v(" 安卓原生系统服务的方法。能自动化的生成事务，并调用相应的接口。 "),t("code",[_._v("fans")]),_._v(" 能自动化处理接口间的复杂依赖。这种依赖性体现在三方面：变量模式、类型别名和变量依赖性。最后发现了30多个漏洞，138个 "),t("code",[_._v("Java")]),_._v(" 异常，这些东西要 "),t("code",[_._v("fuzz")]),_._v(" 到，必须要有一个精确的接口模型。")]),_._v(" "),t("h2",{attrs:{id:"关键部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关键部分"}},[_._v("#")]),_._v(" 关键部分")]),_._v(" "),t("blockquote",[t("p",[_._v("用来记录本篇文章关键的地方，标注好内容和页码")])]),_._v(" "),t("h2",{attrs:{id:"研究方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#研究方法"}},[_._v("#")]),_._v(" 研究方法")]),_._v(" "),t("blockquote",[t("p",[_._v("可以看出此类问题，大家都是采用一个什么样的方法去解决的")])]),_._v(" "),t("h2",{attrs:{id:"存在问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[_._v("#")]),_._v(" 存在问题")]),_._v(" "),t("p",[_._v("如何解决面临的挑战")]),_._v(" "),t("ol",[t("li",[_._v("多层接口的识别")]),_._v(" "),t("li",[_._v("接口模型的解析")]),_._v(" "),t("li",[_._v("语义正确的输入生成")])]),_._v(" "),t("h2",{attrs:{id:"产生原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[_._v("#")]),_._v(" 产生原因")]),_._v(" "),t("h2",{attrs:{id:"解决方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[_._v("#")]),_._v(" 解决方法")]),_._v(" "),t("h2",{attrs:{id:"创新点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创新点"}},[_._v("#")]),_._v(" 创新点")]),_._v(" "),t("p",[_._v("自动化进行 "),t("code",[_._v("fuzz")])]),_._v(" "),t("p",[_._v("正确处理事务之间的依赖")]),_._v(" "),t("h2",{attrs:{id:"不足之处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不足之处"}},[_._v("#")]),_._v(" 不足之处")]),_._v(" "),t("blockquote",[t("p",[_._v("别人论文里的不足可能是你 "),t("code",[_._v("idea")]),_._v(" 的来源")])])])}),[],!1,null,null,null);v.default=r.exports}}]);