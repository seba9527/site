(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{478:function(t,n,s){"use strict";s.r(n);var a=s(14),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("hr"),t._v(" "),s("blockquote",[s("p",[t._v("读书笔记——《Python灰帽子-黑客与逆向工程师的python编程之道》\n由于书上采用的是immunity debugger作为调试器，而我感觉现在已经过期了，所以在阅读的时候并没有实现，简单的阅读看了看就完了，还有fuzz和sulley等模糊测试框架技术，虽然也可以和漏洞挖掘结合起来，但是感觉用的比较少吧，这里没有写。（其实并不清楚-_-）。\nHOOK，DLL注入，IDC脚本编程是以后要着重掌握的。")])]),t._v(" "),s("h2",{attrs:{id:"关于调试器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于调试器"}},[t._v("#")]),t._v(" 关于调试器")]),t._v(" "),s("h3",{attrs:{id:"软件断点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#软件断点"}},[t._v("#")]),t._v(" 软件断点")]),t._v(" "),s("p",[t._v("软件断点只能中止执行。软件断点由于"),s("br"),t._v("\n缺乏硬件支持，一般都是模拟出来的。软件断点用触发寄存器的指令替换原来的指令。在x86处理器里，这条新指令通常是INT 3（0xCC）。调试器必须记录原来的指令。\n当软件断点被触发时，INT 3指令把控制权传给寄存器。寄存器在内部表里查找断点，并用原来的指令替换INT 3，然后恢复指令指针，使保存的指令成为下一条要执行的指令。整个过程对用户来说是不可见的，调试器将显示包含原来的指令的反汇编。")]),t._v(" "),s("h3",{attrs:{id:"硬件断点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#硬件断点"}},[t._v("#")]),t._v(" 硬件断点")]),t._v(" "),s("p",[t._v("X86系列处理器支持4种硬件断点。硬件断点使用特殊的调试寄存器。这些寄存器包含断点地址、控制信息及断点类型。\n断点地址保存在调试寄存器D0至D3中。为了设置断点，需要有一个字段，大小可以是1、2或4字节。执行中断使用的大小为1字节。\n在64位CPU上，大小已经扩展到8字节。有多种条件可以出发断点：\n一、执行中断；\n二、内存访问中断（读内存或写内存）；\n三、仅写内存时中断；\n四、I/O端口访问中断（很少被使用，很多调试器没有这个设置）")]),t._v(" "),s("h3",{attrs:{id:"内存断点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存断点"}},[t._v("#")]),t._v(" 内存断点")]),t._v(" "),s("p",[t._v("内存断电本质上不是断点，只是依靠操作系统对内存页的分配权限和调试器收到的返回异常来下断。操作系统美分配一个内存页的时候，都会为这个内存页设置相应的访问权限，该权限取决鱼这个内存页被访问的方式。主要有以下几个：页可执行：如果试图读写这个页将导致非法内存操作异常。页可读：只能读取数据，企图写入数据或者执行代码都会导致内存操作异常。页可写：只允许写数据。保护页：对保护页的任何一次操作都会导致一次异常。")]),t._v(" "),s("h3",{attrs:{id:"使用断点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用断点"}},[t._v("#")]),t._v(" 使用断点")]),t._v(" "),s("p",[t._v("调试器使用软件断点要多于硬件断点。最主要的理由是软件断点没有数量的限制。有些反调试技术会通过计算代码的校验和判断是否有指令被修改了。\n硬件断点可以设在内存地址上，这点与软件断点不一样。我们可以通过中断内存访问寻找使用的表或内存崩溃。")]),t._v(" "),s("h2",{attrs:{id:"关于hook和dll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于hook和dll"}},[t._v("#")]),t._v(" 关于HOOK和DLL")]),t._v(" "),s("p",[t._v("这部分内容由于书写的比较老，自己只知道了一些基础知识，对于怎么具体使用并没有心得，是之后的学习中需要加强的一部分，尤其是HOOK技术，在apk逆向中使用比较多，结合xposed可以实现快速自动化分析。")]),t._v(" "),s("h2",{attrs:{id:"idapython脚本编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#idapython脚本编程"}},[t._v("#")]),t._v(" IDAPython脚本编程")]),t._v(" "),s("h3",{attrs:{id:"两个工具函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两个工具函数"}},[t._v("#")]),t._v(" 两个工具函数")]),t._v(" "),s("p",[t._v("ScreanEA()\n获取鼠标所停留的地址，可以通过这个来为脚本指定起始地址。hex(ScreanEA())\nGetInputFileMD5()\n计算当前载入文件的MD5值，可以用来检测文件是否被更改，尤其是patch的时候，尽管有patch_list显示。")]),t._v(" "),s("h3",{attrs:{id:"段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#段"}},[t._v("#")]),t._v(" 段")]),t._v(" "),s("p",[t._v("Firstseg()\n返回文件中首个段的起始地址。hex(Firstseg())\nNextseg(long Address)\n根据当前位置，返回下一个段的起始位置。\nSegByName(string SegmentName)\n根据段名称，返回段的起始地址。试了一下好像有问题。\nSegEnd(long Address)\n根据地址返回该段的结束地址\nSegStart(long Address)\n根据地址返回该段的起始地址\nSegName(long Address)\n根据地址，返回该地址的段名称\nSegments()\n返回段首地址的列表")]),t._v(" "),s("h3",{attrs:{id:"函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),s("p",[t._v("Function(long StartAddress, long EndAddress)\n返回函数地址列表，在起始地址和结束地址之间。\nChunks(long FunctionAddrss)\n根据地址返回块列表，以python二元组的形式（chunks start,chunks end）存储每个函数块的起始结束地址。\nLocByName(string FunctionName)\n根据函数名称返回函数地址\nGetFuncOffset(long Address)\n将函数内部地址转换成函数名后跟偏移的字符串\nGetFuncitonName(long Address)\n根据地址返回函数名称")]),t._v(" "),s("h3",{attrs:{id:"交叉引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#交叉引用"}},[t._v("#")]),t._v(" 交叉引用")]),t._v(" "),s("p",[t._v("CodeRefsTo(long Address,bool Flow)\n根据地址返回指向此处的交叉引用列表，Flow表示是否返回顺序执行代码引用地址。\nCodeRefsFrom(long Address,bool Flow)\n根据地址，返回由此出发的交叉引用列表，Flow表示是否返回顺序执行代码引用地址。\nDataRefsTo(long Address)\n根据目标地址，返回一个指向此处的数据引用列表\nDataRefsFrom(long Address)\n根据目标地址，返回一个由此出发的数据引用列表")]),t._v(" "),s("h3",{attrs:{id:"hook"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hook"}},[t._v("#")]),t._v(" HOOK")]),t._v(" "),s("p",[t._v("AddBpt(long Address)\n根据地址下软件断点。\nGetBptQty()\n返回下断点个数\nGetRegValue(string Register)\n根据寄存器名称返回相应的值\nSetRegValue(long Value, String Register)\n设置相应寄存器的值。")])])}),[],!1,null,null,null);n.default=e.exports}}]);