(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{544:function(t,e,a){"use strict";a.r(e);var _=a(14),v=Object(_.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("论文名称：Speculator：A Tool to Analyze Speculative Execution Attacks and Mitigations")]),t._v(" "),a("p",[t._v("论文类型：期刊")]),t._v(" "),a("p",[t._v("发表位置：Proceedings of the 35th Annual Computer Security Applications Conference")]),t._v(" "),a("p",[t._v("发表年份：2019")])]),t._v(" "),a("h2",{attrs:{id:"文章综述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文章综述"}},[t._v("#")]),t._v(" 文章综述")]),t._v(" "),a("p",[t._v("该文章提出了一种 fuzz 安卓原生系统服务的方法。能自动化的生成事务，并调用相应的接口。fans能自动化处理接口间的复杂依赖。这种依赖性体现在三方面：变量模式、类型别名和变量依赖性。最后发现了30多个漏洞，138个Java异常，这些东西要fuzz到，必须要有一个精确的接口模型。")]),t._v(" "),a("h2",{attrs:{id:"关键部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键部分"}},[t._v("#")]),t._v(" 关键部分")]),t._v(" "),a("blockquote",[a("p",[t._v("用来记录本篇文章关键的地方，标注好内容和页码")])]),t._v(" "),a("h2",{attrs:{id:"研究方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#研究方法"}},[t._v("#")]),t._v(" 研究方法")]),t._v(" "),a("blockquote",[a("p",[t._v("可以看出此类问题，大家都是采用一个什么样的方法去解决的")])]),t._v(" "),a("h2",{attrs:{id:"存在问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[t._v("#")]),t._v(" 存在问题")]),t._v(" "),a("p",[t._v("如何解决面临的挑战")]),t._v(" "),a("ol",[a("li",[t._v("多层接口的识别")]),t._v(" "),a("li",[t._v("接口模型的解析")]),t._v(" "),a("li",[t._v("语义正确的输入生成")])]),t._v(" "),a("h2",{attrs:{id:"产生原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[t._v("#")]),t._v(" 产生原因")]),t._v(" "),a("h2",{attrs:{id:"解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),a("h2",{attrs:{id:"创新点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创新点"}},[t._v("#")]),t._v(" 创新点")]),t._v(" "),a("p",[t._v("自动化进行 fuzz")]),t._v(" "),a("p",[t._v("正确处理事务之间的依赖")]),t._v(" "),a("h2",{attrs:{id:"不足之处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不足之处"}},[t._v("#")]),t._v(" 不足之处")]),t._v(" "),a("blockquote",[a("p",[t._v("别人论文里的不足可能是你idea的来源")])]),t._v(" "),a("h2",{attrs:{id:"详细部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#详细部分"}},[t._v("#")]),t._v(" 详细部分")]),t._v(" "),a("h3",{attrs:{id:"相关工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关工作"}},[t._v("#")]),t._v(" 相关工作")]),t._v(" "),a("h4",{attrs:{id:"摘要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[t._v("#")]),t._v(" 摘要")]),t._v(" "),a("p",[t._v("现状：新的推测执行攻击基本上每个月都会出现新的，同时仍旧存在很多未被发现的微体系结构攻击\nSpeculator：一个新的工具，用于审查新的微体系结构攻击和相应的缓解方法（GDB of speculative execution）\n通过利用一些可被观察到的性能计数器，speculator可以了解代码片段或者复杂攻击常见在推测执行过程中的微体系结构行为")]),t._v(" "),a("h3",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("目前推测式攻击和防御的需求：")]),t._v(" "),a("p",[t._v("为了开发新的攻击，通常会需要分析调试一些PoC代码的片段，此时就需要一个类似于推测执行攻击的工具，能够直接检查微体系结构状态的变化，从而判断攻击是否成功")]),t._v(" "),a("p",[t._v("当测试防御策略的有效性时，目前的选择是执行攻击的PoC代码或者选择相信一些提供的CPU flags或者内核配置。此时也需要一个更细粒度的工具能够检查微体系结构状态的变化，从而判断防御策略的有效性")]),t._v(" "),a("p",[t._v("推测执行攻击的步骤")]),t._v(" "),a("ol",[a("li",[t._v("准备侧信道：执行一些操作用于增加攻击成功的机会。例如对于prime-and-probe的攻击，需要实现刷新cache。")]),t._v(" "),a("li",[t._v("准备侧信道攻击：执行一些代码，引导受害者进行推测执行")]),t._v(" "),a("li",[t._v("开始推测执行：CPU执行一条指令，并且该指令的输出将会决定下一条指令的执行，例如条件分支。")]),t._v(" "),a("li",[t._v("推测执行，通过侧信道发送数据：推测执行某些指令，修改微体系结构状态（侧信道）")]),t._v(" "),a("li",[t._v("通过侧信道接收数据：CPU执行某些指令，将微体系结构状态的变化转换为数据。")])]),t._v(" "),a("p",[t._v("推测执行攻击可以跨域的特权边界：")]),t._v(" "),a("ol",[a("li",[t._v("kernel vs. user-mode code")]),t._v(" "),a("li",[t._v("hardware enclave(SGX) vs. user-mode or kernel-mode code")]),t._v(" "),a("li",[t._v("sandboxed code in the same process, (JavaScript JIT code)")]),t._v(" "),a("li",[t._v("processes-to-process boundary")]),t._v(" "),a("li",[t._v("remote node to local node boundary")])]),t._v(" "),a("p",[t._v("Speculator：通过性能计数器记录或者推断微体系结构行为，支持增量分析(在代码片段(code snippet)上的微体系结构状态的演化)，在Intel和AMD cpu上运行，支持并发执行(在SMT环境中两个线程的交互)")]),t._v(" "),a("p",[t._v("文章工作:")]),t._v(" "),a("ol",[a("li",[t._v("提出了一种基于性能计数器的方法和工具，speculator，用于分析攻击和缓解策略")]),t._v(" "),a("li",[t._v("利用speculator验证了RAS的大小，嵌套的推测执行的有效性，推测执行不会跨越系统调用，clflush在推测执行过程中无效等。同时也测量了对于间接分支，间接控制流转移和store-to-load前递导致的推测窗口的大小。最后测试了页面权限，内存保护扩展和特殊指令（例如lfence）对推测执行的影响")]),t._v(" "),a("li",[t._v("给出了一些利用speculator分析的攻击和缓解示例")])]),t._v(" "),a("h3",{attrs:{id:"performance-monitor-capabilities"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performance-monitor-capabilities"}},[t._v("#")]),t._v(" Performance Monitor Capabilities")]),t._v(" "),a("p",[t._v("现在处理器提供了一组寄存器（固定的和可编程的），用于展示执行的各个方面的信息。这些寄存器或者计数器用于记录一些和微体系结构状态变化相关的时间或者持续时间，例如提交指令数，转移预测错误次数等。")]),t._v(" "),a("p",[t._v("使用性能计数器的流程：")]),t._v(" "),a("ol",[a("li",[t._v("setup阶段，开发人员选择一些事件由可编程的计数器测量")]),t._v(" "),a("li",[t._v("start和stop，测量过程可以通过编程控制开始和结束，从而准确的控制事件记录的过程")]),t._v(" "),a("li",[t._v("access阶段，获取计数器的值")]),t._v(" "),a("li",[t._v("setup，start，stop通常需要supervisor模式（ring 0），access在用户模式即可")])]),t._v(" "),a("h3",{attrs:{id:"objectives-of-speculator-目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#objectives-of-speculator-目的"}},[t._v("#")]),t._v(" Objectives of Speculator (目的)")]),t._v(" "),a("p",[t._v("主要目的：准确测量代码片段中推测部分相关的微体系结构状态属性。精度是指工具能够将代码片段所引起的微体系结构状态变化和工具本身以及系统其余部分隔离开的程度（外界的影响）。")]),t._v(" "),a("p",[t._v("Speculator可观察到的部分信息：")]),t._v(" "),a("ol",[a("li",[t._v("代码中那些部分是被推测执行的")]),t._v(" "),a("li",[t._v("引发推测执行和结束推测执行的原因")]),t._v(" "),a("li",[t._v("影响推测执行指令数量/指令窗口的参数")]),t._v(" "),a("li",[t._v("特定的指令如何影响推测执行的行为")]),t._v(" "),a("li",[t._v("那些安全边界可以有效的阻止推测执行")]),t._v(" "),a("li",[t._v("CPU在同一个体系结构内以及跨体系结构和供应商的行为如何保持一致（consistency）")])]),t._v(" "),a("p",[t._v("Speculator的另一个目标：为代码片段的生成和操作（manipulation）提供一个工具。Speculator可以在推测执行期间检查单个代码片段或者代码片段组，从而使得用户只需要专注于特定用例相关的指令组合。")]),t._v(" "),a("h3",{attrs:{id:"speculator的设计和实现："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#speculator的设计和实现："}},[t._v("#")]),t._v(" Speculator的设计和实现：")]),t._v(" "),a("p",[t._v("三个主要部件：预处理单元，运行时单元（Monitor），后期处理单元")]),t._v(" "),a("p",[t._v("预处理单元：将提供的输入编译成合适的执行格式，从而引入性能监视器接口所需要的代码/工具，以便能够观察所选的计数器的值。")]),t._v(" "),a("ol",[a("li",[t._v("输入：一段C或者汇编代码")]),t._v(" "),a("li",[t._v("处理：将预先编译的json文件中的指令添加到输入代码的特定位置（在source template中定义的位置中）")])]),t._v(" "),a("p",[t._v("Runtime 单元：主要由speculator monitor负责初始化和读取生成代码中使用到的计数器")]),t._v(" "),a("ol",[a("li",[t._v("生成的代码片段和monitor会放在不同的核上执行，以减少相互之间的干扰")]),t._v(" "),a("li",[t._v("当Monitor建立好环境后，就会加载并在另一个进程中执行snippet，直到结束")]),t._v(" "),a("li",[t._v("代码片段的开头和结尾会对计数器进行reset，start和stop的操作")])]),t._v(" "),a("p",[t._v("后期处理单元：")]),t._v(" "),a("ol",[a("li",[t._v("当代码片段执行完成后，OS通知monitor。之后Monitor将获取这些计数器的值，将结果写入文件中")]),t._v(" "),a("li",[t._v("在多次运行之后，统计收集所有结果，并且去除其中的可疑点")])]),t._v(" "),a("h3",{attrs:{id:"触发推测执行："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发推测执行："}},[t._v("#")]),t._v(" 触发推测执行：")]),t._v(" "),a("p",[t._v("为了自动生成测试样例，speculator为用户提供了一系列的模板，能够用于重现各种触发推测执行的方式，包括BTI（branch target injection），spectre v1， RAS等。")]),t._v(" "),a("p",[t._v("下图为利用branch触发推测执行的样例。setup用于将BP设置为指定的状态，可以导致之后的分支发生错误预测，并且推测执行之后的snippet代码")]),t._v(" "),a("h3",{attrs:{id:"推测执行标记（markers）：各种可被使用的计数器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推测执行标记（markers）：各种可被使用的计数器"}},[t._v("#")]),t._v(" 推测执行标记（markers）：各种可被使用的计数器")]),t._v(" "),a("p",[t._v("推测执行标记是指某些特殊的指令或者序列，他们在未提交之前就可以被性能计数器检测到。通常情况下，这些标记会引发一些微体系结构事件，从而可以被计数器捕获到。例如计数器可以测量某些类型的指令的发射/执行的数量，同时不需要指令一定会被提交。\n通过在代码片段中增加这样的标记，Speculator通过检测性能计数将可以判断CPU是否执行了该代码片段。\nIntel处理器中一些可用的标记：\nUOPS_EXECUTED.CORE/THREAD ：通过减去最终提交的指令数量，就可以直到被推测执行但是未提交的指令的数量。该计数器不计数不需要执行的指令，例如NOP，但是不包括FNOP（not understand）\nUOPS_ISSUED.SINGLE_MUL ：当使用了XMM寄存器的单精度浮点指令发射时，进行计数。在最近的CPU中会删除了，例如Skylake\nUOPS_ISSUED.SLOW_LEA ：计数带有三个源操作数的lea指令。（clflush也被认为是该类型的指令）\nLD_BLOCKS.STORE_FORWARD ：当store前递的结果失败后，计数器+1\nAMD Zen可用的计数器\nDIV_OP_COUNT ：被执行的div指令的数量\nNUMBER_ OF_ MOVE_ ELIMINATION_ AND_ SCALAR_ OP_OPTIMIZATION： 类似于LD_BLOCKS.STORE_FORWARD，但是相对而言统计的是这种指令序列出现的情况，他统计了move elimination成功的次数。")]),t._v(" "),a("h3",{attrs:{id:"利用speculator分析微体系结构状态的变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用speculator分析微体系结构状态的变化"}},[t._v("#")]),t._v(" 利用Speculator分析微体系结构状态的变化")]),t._v(" "),a("p",[t._v("Return Stack Buffer Size ：RSB的大小通常已知，因此可以用于衡量speculator的准确性")]),t._v(" "),a("p",[t._v("设计：snippet代码片段包含在call和ret之间，在代码中调用filler函数，该函数会增加嵌套调用的层数。每一层call都会在RSB中增加一个表项，如果表项数使用完了，最外层的call指令将找不到对应的ret指令，导致CPU无法执行实现设置的标记")]),t._v(" "),a("p",[t._v("在Intel的Kabylake处理器中的测试结果")]),t._v(" "),a("h3",{attrs:{id:"可执行的页权限：executable-page-permission"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可执行的页权限：executable-page-permission"}},[t._v("#")]),t._v(" 可执行的页权限：executable page permission")]),t._v(" "),a("p",[t._v("问题：在推测执行过程中，是否可以推测执行不具有执行权限的页内的指令\n实现：在推测执行过程中（branch mis-prediction），增加控制流转移指令跳转到non-executable的内存区域。在实验中，首先保证该内存区域中要被使用的数据会在L2 cache中，同时地址也在TLB中\n结论：研究的所有架构中，页的可执行权限检查都会被满足，即如果该页面是不可执行的，则该页面中的指令也不会被推测执行。")]),t._v(" "),a("h3",{attrs:{id:"内存保护扩展（mpx-指令系统扩展）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存保护扩展（mpx-指令系统扩展）"}},[t._v("#")]),t._v(" 内存保护扩展（MPX 指令系统扩展）")]),t._v(" "),a("p",[t._v("MPX的功能：efficiently keeping track of bounds information associated with pointers and corresponding spatial memory checks before dereferencing pointers 。如果边界检查失败，会触发一个#BR异常，CPU自陷入kernel")]),t._v(" "),a("p",[t._v("实验：测量在边界检查分支之后有多少代码会被推测执行")]),t._v(" "),a("p",[t._v("结果：MPX的FNOP指令在增加到22个之后，执行的指令数量不在发生变化")])])}),[],!1,null,null,null);e.default=v.exports}}]);