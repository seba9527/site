(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{520:function(_,t,v){_.exports=v.p+"assets/img/Snipaste_2020-05-22_15-12-48.b9444827.png"},521:function(_,t,v){_.exports=v.p+"assets/img/Snipaste_2020-05-22_15-34-22.b5e610e8.png"},522:function(_,t,v){_.exports=v.p+"assets/img/Snipaste_2020-05-22_15-48-59.87e85e7a.png"},523:function(_,t,v){_.exports=v.p+"assets/img/Snipaste_2020-05-22_17-18-50.96fc16e8.png"},524:function(_,t,v){_.exports=v.p+"assets/img/Snipaste_2020-05-22_17-36-51.a0e4480a.png"},525:function(_,t,v){_.exports=v.p+"assets/img/Snipaste_2020-05-22_20-09-40.04bfba7c.png"},526:function(_,t,v){_.exports=v.p+"assets/img/Snipaste_2020-05-22_20-22-14.8d2715d9.png"},830:function(_,t,v){"use strict";v.r(t);var a=v(6),s=Object(a.a)({},(function(){var _=this,t=_.$createElement,a=_._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("blockquote",[a("p",[_._v("论文名称：ROPOB: Obfuscating Binary Code via Return Oriented Programming")]),_._v(" "),a("p",[_._v("关键词：混淆 ROP 逆向")]),_._v(" "),a("p",[_._v("论文类型：会议")]),_._v(" "),a("p",[_._v("发表位置：S&P：IEEE Symposium on Security and Privacy")]),_._v(" "),a("p",[_._v("发表年份：2018")])]),_._v(" "),a("h2",{attrs:{id:"摘要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[_._v("#")]),_._v(" 摘要")]),_._v(" "),a("p",[_._v("软件逆向工程已广泛用于软件重用和恶意目的，例如软件窃取和恶意软件伪装。为了提高对手逆向工程的难度，需要将混淆处理引入保护的软件中，现有的混淆方法效率低下且难以部署。")]),_._v(" "),a("p",[_._v("在本文中，我们提出了一种基于 ROP 的二进制混淆处理方案，旨在作为一种高效且可部署的反逆向工程方法，基本思想是将直接控制流转换为间接控制流。")]),_._v(" "),a("p",[_._v("基本原理：静态分析通常不足以查明间接控制流的目标地址。")]),_._v(" "),a("p",[_._v("结果表明， ROPOB 可以成功地转换所有的直接控制流，而不会引起执行错误。开销可以接受：混淆覆盖率超过90％时，平均性能开销小于10％。")]),_._v(" "),a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[_._v("#")]),_._v(" 简介")]),_._v(" "),a("p",[_._v("首先介绍以下软件窃取与恶意软件伪装的概念，包括一些软件重打包的概念，以及造成的严重危害。然后说明了逆向工程和混淆的基本概念。总结一些现有的工作：")]),_._v(" "),a("ol",[a("li",[_._v("基于生成混淆代码的")]),_._v(" "),a("li",[_._v("利用信号机制来处理控制流的，但开销较大")]),_._v(" "),a("li",[_._v("利用特殊处理器的特性，即信息跟踪，来混淆代码，方式是异常处理")])]),_._v(" "),a("p",[_._v("然后介绍了 ROP 的基本原理，并介绍了 RopSteg ，一个代码保护方案，该代码试图通过执行位于其他位置的意外匹配，来隐藏选定的指令序列。说明了该方案的核心思想：利用 ROP 混淆控制流，粒度是基本块。")]),_._v(" "),a("ol",[a("li",[_._v("首先，反汇编一个要保护的 ELF 文件，并将可执行代码分成基本块。然后，对基本块进行插桩，转换成 gadget")]),_._v(" "),a("li",[_._v("通过 ret 指令，转换所有已识别的直接控制流")]),_._v(" "),a("li",[_._v("将所有 gadget 和设计好的有效负载添加到原始文件中，并利用二进制重写来生成混淆的文件。")])]),_._v(" "),a("p",[_._v("这里的有效负载将用于控制流转换，并将存储在一个新的负载代码段中。它是使用 ROP 进行混淆的一种轻量级方法。由于 ROP 仅在用户空间中起作用，不涉及信号处理或其他内核。因此转换控制流的过程比信号要快。而且 ROP 是线程安全的。")]),_._v(" "),a("p",[_._v("主要贡献")]),_._v(" "),a("ol",[a("li",[_._v("提出了一种新的基于 ROP 的方法来实现控制流混淆。实验证明，该方法对静态逆向工程分析是有效和实用的。")]),_._v(" "),a("li",[_._v("混淆方案高效并广泛使用。")]),_._v(" "),a("li",[_._v("实现了 ROPOB 的工具，实验证明，能正确转换直接控制流，混淆覆盖率超过90％时，平均性能开销小于10％。")])]),_._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),a("p",[_._v("假设3个前提")]),_._v(" "),a("ol",[a("li",[_._v("未混淆的代码是 ELF 文件格式的。")]),_._v(" "),a("li",[_._v("混淆文件在未修改的 Linux 系统上。")]),_._v(" "),a("li",[_._v("敌手只采用静态分析方法，如 IDA 。")])]),_._v(" "),a("p",[_._v("混淆方案步骤")]),_._v(" "),a("ol",[a("li",[_._v("反汇编代码段，切割成基本块粒度")]),_._v(" "),a("li",[_._v("在基本块粒度上插桩，转换成 gadget")]),_._v(" "),a("li",[_._v("将所有的 gadget 和设计的有效负载写入汇编器文件，然后将其组合成新的 ELF 文件。设计的有效负载是 gadget 的起始地址列表。其功能是指导所有 gadget 的执行。")]),_._v(" "),a("li",[_._v("复制新的 ELF 文件中的代码和所有的负载，生成混淆文件。")])]),_._v(" "),a("p",[a("img",{attrs:{src:v(520),alt:"混淆方案"}})]),_._v(" "),a("p",[_._v("然后擦除原生文件中的代码段，现在的段既有代码段，也有负载段，还有数据段不能被擦除，需要维持数据完整性。")]),_._v(" "),a("p",[_._v("总而言之，我们的所有工作都在用户空间中，不涉及内核空间。此外，由于静态分析中没有控制流信息，因此我们的方法可以使所有静态去混淆技术无效。同时增加动态去混淆方法的难度。因为在混淆处理的文件中没有函数调用，所以即使攻击者动态地找到执行路径，也很难提取高级语义。")]),_._v(" "),a("p",[_._v("挑战有3")]),_._v(" "),a("ol",[a("li",[_._v("基本块无法彻底分区。因此，一些间接控制流可能跳入基本块的内部，而不是入口，这将使有效载荷入口检查失败。？基本块的定义不是就一个入口吗？")]),_._v(" "),a("li",[_._v("间接的控制流图不能静态分析，有必要实现一个间接跳转表。")]),_._v(" "),a("li",[_._v("必须保持所有数据可用，设计一个重建的框架")])]),_._v(" "),a("p",[a("img",{attrs:{src:v(521),alt:"设计实例"}})]),_._v(" "),a("p",[_._v("虚线是原始的路径，实现是混淆后的路径，通过维持一个设计好的负载，进行检查和跳转。")]),_._v(" "),a("h2",{attrs:{id:"设计与实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计与实现"}},[_._v("#")]),_._v(" 设计与实现")]),_._v(" "),a("p",[_._v("工具主要包括三部分，一个基本的重建框架；基本块分割方法和控制流完整性检验。")]),_._v(" "),a("h3",{attrs:{id:"重建框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重建框架"}},[_._v("#")]),_._v(" 重建框架")]),_._v(" "),a("p",[_._v("基本原则是语义正确，设计了一个框架，同时支持汇编级别的插桩。主要是反汇编，再重新汇编到新的文件中。")]),_._v(" "),a("p",[a("img",{attrs:{src:v(522),alt:"重建框架"}})]),_._v(" "),a("p",[_._v("看图是比较清晰的。")]),_._v(" "),a("ol",[a("li",[_._v("首先提取原始文件的代码段，切割成基本块，同时收集控制流信息")]),_._v(" "),a("li",[_._v("然后应用汇编级别的插桩工具")]),_._v(" "),a("li",[_._v("之后使用重写的基本块和控制流信息生成汇编文件")]),_._v(" "),a("li",[_._v("将生成的代码段和原始的复制到一起，生成中间文件")]),_._v(" "),a("li",[_._v("擦除原始的代码段，保留数据段")])]),_._v(" "),a("h3",{attrs:{id:"基本块分割"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本块分割"}},[_._v("#")]),_._v(" 基本块分割")]),_._v(" "),a("p",[_._v("介绍了基本块的概念，切分基本块的原则")]),_._v(" "),a("ol",[a("li",[_._v("控制流相关的指令，比如 jmp/jcc/call/ret 指令，说明基本块结束，同时目标地址是基本块入口。")]),_._v(" "),a("li",[_._v("忽略间接跳转指令的目标操作数，如 jmp/jcc/call")]),_._v(" "),a("li",[_._v("jmp/jcc/call/ret 的下一条指令是基本块的入口")])]),_._v(" "),a("h3",{attrs:{id:"控制流映射表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制流映射表"}},[_._v("#")]),_._v(" 控制流映射表")]),_._v(" "),a("p",[_._v("不能解决间接的跳转指令，因为这些跳转指令的操作数由上下文决定。因为重用了原始文件中的所有数据部分，原始间接 CFRI 计算出的目标地址与 ROP 混淆后的间接 CFRI 的目标地址相同。在这种情况下，必须要对间接 CFRI 的地址进行转换才行，否则程序会崩溃。所以设计这样一个跳转表。")]),_._v(" "),a("p",[a("img",{attrs:{src:v(523),alt:"控制流映射表"}})]),_._v(" "),a("p",[_._v("如图所示，对于这样一个转换的 gadget ，如果间接 CFRI 的地址是 BB1 的入口，首先计算目标地址，然后检查控制流映射表在 Gadget1 的目标地址。如果我们的基本块分区错过了一个基本块（ BB1 中的入口为 0x804caca ，而间接 CFRI 跳转到 0x804caca ），将找不到任何表条目来匹配 0x804caca 。但是其与入口的的偏移量等于 0x7007e05 和 0x7007dff 之间的偏移量，并且还要确认仅在基本块的末尾而不是在中间块应用了插桩。因此可以正确找到入口。")]),_._v(" "),a("h3",{attrs:{id:"rop-插桩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rop-插桩"}},[_._v("#")]),_._v(" ROP 插桩")]),_._v(" "),a("p",[_._v("负载是 ROP gadget 的列表，同时还对不同的控制流设计不同的插桩原则。")]),_._v(" "),a("ol",[a("li",[_._v("对于不以 CFRI 结尾的基本块，将基本块入口地址压栈。")]),_._v(" "),a("li",[_._v("对于以直接 CRFI 结尾的基本块，基本就是 call/jmp 指令，将下一个 gadget 地址压栈；如果是 jcc 指令，一般有2条路径。")]),_._v(" "),a("li",[_._v("对于间接 CRFI ，采用控制流映射表。")]),_._v(" "),a("li",[_._v("对于 ret 结束的基本块，不需要其他操作。")])]),_._v(" "),a("p",[a("img",{attrs:{src:v(524),alt:"ROP 插桩"}})]),_._v(" "),a("p",[a("strong",[_._v("例外")]),_._v(" 大多数情况下，数据访问是绝对寻址，地址直接在数据部分中。但是，在某些特殊情况下，使用相对寻址访问数据。这会导致一个错误，作者的想法是不考虑这种情况，一定要考虑就静态考虑。")]),_._v(" "),a("h2",{attrs:{id:"评估"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#评估"}},[_._v("#")]),_._v(" 评估")]),_._v(" "),a("p",[_._v("评估三个方面的内容，控制流隐藏；程序大小；程序执行速度。")]),_._v(" "),a("p",[_._v("提出2种方法来检测混淆强度，是 CFG 级别和指令级别的隐藏。")]),_._v(" "),a("p",[_._v("一种是 CFG 的碎片化程度，通过比较混淆后和原始的 CFG，说明混淆后的程序足够碎片化，分析难度成倍提高。")]),_._v(" "),a("p",[_._v("二是指令级别的强度，通过将比较混淆前与混淆后的 jmp/jcc/call 指令数量，可以判断这些指令有多少被替换和混淆了。下降的数值越大，说明效果越好。")]),_._v(" "),a("p",[_._v("另外，程序种将不会有直接的跳转指令，call/jcc 还是有。")]),_._v(" "),a("p",[a("img",{attrs:{src:v(525),alt:"CFRI"}})]),_._v(" "),a("p",[_._v("然后是程序增大多小，经过分析，经过混淆后，代码段会增加1.81倍，程序整体会增大2.66倍。主要原因是代码段的插桩导致的，还有负载以及转换表导致的文件变大。")]),_._v(" "),a("p",[_._v("关于性能，当代码覆盖率达到100%后，性能会有较大的影响，平均会到500%左右，极大影响程序执行效率。然后开始优化，即减小混淆程度，当95%混淆的时候，平均开销在20%左右，当调整到90%时，开销在7%左右，当在85%左右时，基本没有影响。")]),_._v(" "),a("p",[a("img",{attrs:{src:v(526),alt:"性能开销"}})]),_._v(" "),a("p",[_._v("但是对于某些程序来说，混淆的影响较大，即使混淆的覆盖率为0%，甚至都有影响，经过深入研究，发现这些函数调用间接 CFRI 的频率非常高，而这个方法是通过一个函数来重定位间接的控制流，消耗时间很长。")]),_._v(" "),a("h2",{attrs:{id:"相关工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关工作"}},[_._v("#")]),_._v(" 相关工作")]),_._v(" "),a("p",[_._v("介绍了 ROP，代码混淆，控制流混淆，虚拟化保护。")]),_._v(" "),a("h2",{attrs:{id:"讨论与限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#讨论与限制"}},[_._v("#")]),_._v(" 讨论与限制")]),_._v(" "),a("p",[_._v("由于 gadget 本身对 ROP 攻击很有帮助，因此将原始程序的基本块转换为 gadget 很危险。我们从两个方面防止重复使用生成的 gadget 。一方面，我们的设计不适合 ROP 攻击，因为我们生成的 gadget 都执行相同的操作，从内存地址读取数据。另一方面，我们可以像二进制搅拌一样实现加载时基本块级 ASLR （？？？），因为我们生成的 gadget 彼此独立。")]),_._v(" "),a("p",[_._v("在这里，我们讨论 ROPOB 的潜在局限性：")]),_._v(" "),a("ol",[a("li",[_._v("动态分析，一些信息可以被提取，特别是间接跳转指令的操作数")]),_._v(" "),a("li",[_._v("负载隐藏，文章的工作是将生成的代码放在一个新的代码段中")]),_._v(" "),a("li",[_._v("与 ROP 缓解措施共存，但是违反了 CFI 的安全策略")])]),_._v(" "),a("h2",{attrs:{id:"结论与后期工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结论与后期工作"}},[_._v("#")]),_._v(" 结论与后期工作")]),_._v(" "),a("p",[_._v("本文实现了一个基于 ROP 的混淆方案，将原来的基本块转换成 gadget 链，证明其可以对抗静态分析，高效且实用。")]),_._v(" "),a("p",[_._v("关于 gadget 和代码重用，原始程序中函数的控制流图是独立的。如果像 ROP 攻击那样，我们可以在经过混淆的程序中重用 gadget ，或用库中的 gadget 替换 gadget ，则 CFG 的独立性将被破坏，并且每个功能的代码将交织在一起，难度提高。")]),_._v(" "),a("h2",{attrs:{id:"思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[_._v("#")]),_._v(" 思考")]),_._v(" "),a("h3",{attrs:{id:"文章综述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文章综述"}},[_._v("#")]),_._v(" 文章综述")]),_._v(" "),a("h3",{attrs:{id:"关键部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键部分"}},[_._v("#")]),_._v(" 关键部分")]),_._v(" "),a("blockquote",[a("p",[_._v("用来记录本篇文章关键的地方，标注好内容和页码")])]),_._v(" "),a("h3",{attrs:{id:"研究方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#研究方法"}},[_._v("#")]),_._v(" 研究方法")]),_._v(" "),a("blockquote",[a("p",[_._v("可以看出此类问题，大家都是采用一个什么样的方法去解决的")])]),_._v(" "),a("h3",{attrs:{id:"存在问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[_._v("#")]),_._v(" 存在问题")]),_._v(" "),a("h3",{attrs:{id:"产生原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[_._v("#")]),_._v(" 产生原因")]),_._v(" "),a("h3",{attrs:{id:"解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[_._v("#")]),_._v(" 解决方法")]),_._v(" "),a("h3",{attrs:{id:"创新点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创新点"}},[_._v("#")]),_._v(" 创新点")]),_._v(" "),a("h3",{attrs:{id:"不足之处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不足之处"}},[_._v("#")]),_._v(" 不足之处")]),_._v(" "),a("blockquote",[a("p",[_._v("别人论文里的不足可能是你 "),a("code",[_._v("idea")]),_._v(" 的来源")])])])}),[],!1,null,null,null);t.default=s.exports}}]);