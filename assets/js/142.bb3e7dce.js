(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{913:function(n,e,l){"use strict";l.r(e);var v=l(6),d=Object(v.a)({},(function(){var n=this,e=n.$createElement,l=n._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[l("blockquote",[l("p",[n._v("windbg手册")])]),n._v(" "),l("hr"),n._v(" "),l("h2",{attrs:{id:"查看变量"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#查看变量"}},[n._v("#")]),n._v(" 查看变量")]),n._v(" "),l("p",[l("code",[n._v("dv")]),n._v(" Display Variable的缩写, 查看局部变量.\n"),l("code",[n._v("dv /i")]),n._v(" 查看局部变量, 并显示符号的类型和参数类型.\n"),l("code",[n._v("dv /V")]),n._v(" 查看局部变量, 并显示变量的存储位置.\n"),l("code",[n._v("dv /V VariableName")]),n._v(" 指定需要查看的变量的名字\n"),l("code",[n._v("dv 02sample!gGlo*")]),n._v(" "),l("code",[n._v("dv")]),n._v("命令可以带有通配符, 来查看具有某命名模式的变量.")]),n._v(" "),l("p",[l("code",[n._v("dt")]),n._v(" Display Type的缩写. 当变量的类型为复合类型, 比如说结构体或者类, 那么dv命令只会显示变量的地址. dt命令可以将一块内存按照某个数据类型来解析, 其中的数据类型需要作为参数被传递给dt命令.\n"),l("code",[n._v("dt KBTest 0x000cff0c")]),n._v(" 将某内存地址按照某类型来解释并显示.\n"),l("code",[n._v("dt 02sample!gGlobal")]),n._v(" dt命令在显示内存块时, 解析对象的类型.")]),n._v(" "),l("h2",{attrs:{id:"断点"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#断点"}},[n._v("#")]),n._v(" 断点")]),n._v(" "),l("p",[n._v("WinDBG 提供了多种设断点的命令：bp, bu, bm, ba.\n"),l("code",[n._v("bp")]),n._v(" 命令是在某个地址下断点， 可以 "),l("code",[n._v("bp 0x7783FEB")]),n._v("也可以 "),l("code",[n._v("bp MyApp!SomeFunction")]),n._v(" 。 对于后者，WinDBG 会自动找到MyApp!SomeFunction 对应的地址并设置断点。\n但是使用bp的问题在于：1）当代码修改之后，函数地址改变，该断点仍然保持在相同位置，不一定继续有效； 2）WinDBG 不会把bp断点保存工作空间中 。所以，我比较喜欢用bu 命令。")]),n._v(" "),l("p",[l("code",[n._v("bu")]),n._v("命令是针对某个符号下断点。 比如 "),l("code",[n._v("bu MyApp!SomeFunction")]),n._v(" 。 在代码被修改之后， 该断点可以随着函数地址改变而自动更新到最新位置。  而且bu 断点会保存在WinDbg工作空间中， 下次启动 Windbg 的时候该断点会自动设置上去。另外，在模块没有被加载的时候，bp 断点会失败（因为函数地址不存在），而bu 断点则可以成功。 新版的WinDBG中 bp失败后会自动被转成bu 。")]),n._v(" "),l("p",[l("code",[n._v("bm")]),n._v(" 命令也是针对符号下断点。 但是它支持匹配表达式。 很多时候你下好几个断点。 比如，把MyClass 所有的成员函数都下断点： "),l("code",[n._v("bu MyApp!MyClass::*")]),n._v("， 或者把所有以CreateWindow开头的函数都下断点："),l("code",[n._v("bu user32!CreateWindow*")]),n._v(" 。")]),n._v(" "),l("p",[n._v("以上三个命令是对代码下断点， 我们还可以对数据下断点。\n"),l("code",[n._v("ba")]),n._v("命令就是针对数据下断点的命令， 该断点在指定内存被访问时触发。 命令格式为\n"),l("code",[n._v("ba Access Size [地址]")]),n._v("\nAccess 是访问的方式， 比如 e (执行)， r (读/写)， w (写)\nSize 是监控访问的位置的大小，以字节为单位。 值为 1、2或4，还可以是 8（64位机）。")]),n._v(" "),l("p",[n._v("比如要对内存0x0483DFE进行写操作的时候下断点，可以用命令 "),l("code",[n._v("ba w4 0x0483DFE")])]),n._v(" "),l("p",[n._v("其他断点命令:\n"),l("code",[n._v("bl")]),n._v("  列出所有断点\n"),l("code",[n._v("bc")]),n._v("  清除断点\n"),l("code",[n._v("bd")]),n._v(" 禁用断点\n"),l("code",[n._v("be")]),n._v(" 启动被bd 命令经用的断点")]),n._v(" "),l("h2",{attrs:{id:"符号"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#符号"}},[n._v("#")]),n._v(" 符号")]),n._v(" "),l("p",[n._v("ld ModuleName  加载指定模块的符号\nld *                  加载所有模块的符号\n!sym                获取符号加载状态\n!sym noisy       让调试器显示符号搜索详细信息\n!sym quiet        默认项，不显示符号搜索信息\n.sympath         显示和设置符号搜索路径\n.sympath+       增加符号搜索路径\n.sympath+ C:\\Symbols\n.symopt            显示当前符号可选项\n.symopt+ Flags  添加符号可选项\n.symopt- Flags   移除符号可选项\n.symfix                           设置符号库路径\n.sym+ DownstreamStore  添加符号库路径\nx [Options] Module!Symbol    模式匹配符号信息\nx /t ..            根据数据类型匹配\nx /v ..            显示详细信息\nx /a ..            按照地址排序\nx /n ..            按照名称排序\nx /z ..            按照大小排序\nx "),l("em",[n._v("!               列出所有模块\nx ntdll!")]),n._v("          列出 ntdll 模块\nx /t /v ntdll!*    列出 ntdll 模块数据类型和符号类型\n.reload                            重新加载符号信息\n.reload [/f | /v]                /f 强制立即加载符号 /v 显示详细信息\n.reload [/f | /v] "),l("em",[n._v("Module")]),n._v('     Module 为指定模块加载符号信息\n.reload /f @"ntdll.dll"\n.reload /f @"C:\\WINNT\\System32\\verifier.dll"')]),n._v(" "),l("h2",{attrs:{id:"模块"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[n._v("#")]),n._v(" 模块")]),n._v(" "),l("p",[n._v("lm[ v | l | k | u | f ] [m Pattern] 显示已加载的模块\nlm   显示所有加载和未加载的模块信息\nlmv 显示已加载模块的详细信息\nlml  同时显示加载的符号信息\nlmk 显示内核模块信息\nlmu 显示用户模块信息\nlmf  显示镜像路径\nlmm 匹配模块名称\nlmD 使用 DML 方式显示\nlmv m kernel32 显示 kernel32 模块详细信息\n!dlls         列出所有加载的模块和加载数量\n!dlls -i      根据初始化顺序\n!dlls -l      根据加载顺序（默认项）\n!dlls -m    根据内存顺序\n!dlls -v     显示更多详细信息\n!dlls -c _ModuleAddr  _仅显示 ModuleAddr 地址的模块信息\n!dlls -?     显示帮助\n!dlls -v -c kernel32 显示 kernel32.dll 的信息\n!lmi _Module    _显示模块的详细信息，包括加载符号信息\n!lmi kernel32  显示 kernel32.dll 模块的信息")])])}),[],!1,null,null,null);e.default=d.exports}}]);