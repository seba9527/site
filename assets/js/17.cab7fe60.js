(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{457:function(v,_,t){"use strict";t.r(_);var s=t(14),l=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("blockquote",[t("p",[v._v("pwn学习资料，来自ctf-wiki。\n栈介绍")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"栈介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈介绍"}},[v._v("#")]),v._v(" 栈介绍")]),v._v(" "),t("p",[v._v("高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，"),t("strong",[v._v("程序的栈是从进程地址空间的高地址向低地址增长的")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/2019-03/271650059007975.jpg",alt:"271650059007975"}})]),v._v(" "),t("p",[v._v("栈中需要掌握的有栈帧、函数调用过程、序言和结语、函数调用规则、传参顺序等等。需要注意的是，32 位和 64 位程序有以下简单的区别：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("x86")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("函数参数")]),v._v("在"),t("strong",[v._v("函数返回地址")]),v._v("的上方")])])]),v._v(" "),t("li",[t("strong",[v._v("x64")]),v._v(" "),t("ul",[t("li",[v._v("System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在** RDI, RSI, RDX, RCX, R8 和 R9 寄存器**中，如果还有更多的参数的话才会保存在栈上。")]),v._v(" "),t("li",[v._v("内存地址不能大于 0x00007FFFFFFFFFFF，"),t("strong",[v._v("6 个字节长度")]),v._v("，否则会抛出异常。")])])])]),v._v(" "),t("h2",{attrs:{id:"栈溢出介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈溢出介绍"}},[v._v("#")]),v._v(" 栈溢出介绍")]),v._v(" "),t("p",[v._v("栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是")]),v._v(" "),t("ul",[t("li",[v._v("程序必须向栈上写入数据。")]),v._v(" "),t("li",[v._v("写入的数据大小没有被良好地控制。")])]),v._v(" "),t("p",[v._v("这里的例子我就不做了，比较简单。")]),v._v(" "),t("p",[v._v("关于aslr，我们可以通过修改 "),t("code",[v._v("/proc/sys/kernel/randomize_va_space")]),v._v(" 来控制 ASLR 启动与否，具体的选项有")]),v._v(" "),t("ul",[t("li",[v._v("0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。")]),v._v(" "),t("li",[v._v("1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。")]),v._v(" "),t("li",[v._v("2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。")])]),v._v(" "),t("h3",{attrs:{id:"寻找漏洞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寻找漏洞"}},[v._v("#")]),v._v(" 寻找漏洞")]),v._v(" "),t("p",[v._v("通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下")]),v._v(" "),t("ul",[t("li",[v._v("输入\n"),t("ul",[t("li",[v._v("gets，直接读取一行，忽略'\\x00'")]),v._v(" "),t("li",[v._v("read，读取指定长度，可以读0")]),v._v(" "),t("li",[v._v("scanf")]),v._v(" "),t("li",[v._v("vscanf")])])]),v._v(" "),t("li",[v._v("输出\n"),t("ul",[t("li",[v._v("sprintf")])])]),v._v(" "),t("li",[v._v("字符串\n"),t("ul",[t("li",[v._v("strcpy，字符串复制，遇到'\\x00'停止")]),v._v(" "),t("li",[v._v("strcat，字符串拼接，遇到'\\x00'停止")]),v._v(" "),t("li",[v._v("bcopy")])])])]),v._v(" "),t("h3",{attrs:{id:"确定填充长度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定填充长度"}},[v._v("#")]),v._v(" 确定填充长度")]),v._v(" "),t("p",[v._v("这一部分主要是计算"),t("strong",[v._v("我们所要操作的地址与我们所要覆盖的地址的距离")]),v._v("。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式")]),v._v(" "),t("ul",[t("li",[v._v("相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得")]),v._v(" "),t("li",[v._v("相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。")]),v._v(" "),t("li",[v._v("直接地址索引，就相当于直接给定了地址。")])]),v._v(" "),t("p",[v._v("一般来说，我们会有如下的覆盖需求")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("覆盖函数返回地址")]),v._v("，这时候就是直接看 EBP 即可。")]),v._v(" "),t("li",[t("strong",[v._v("覆盖栈上某个变量的内容")]),v._v("，这时候就需要更加精细的计算了。")]),v._v(" "),t("li",[t("strong",[v._v("覆盖 bss 段某个变量的内容")]),v._v("。")]),v._v(" "),t("li",[v._v("根据现实执行情况，覆盖特定的变量或地址的内容。")])]),v._v(" "),t("p",[v._v("之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来"),t("strong",[v._v("直接或者间接地控制程序执行流程")]),v._v("。")])])}),[],!1,null,null,null);_.default=l.exports}}]);