(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{428:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-22_15-12-48.b9444827.png"},429:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-22_15-34-22.b5e610e8.png"},430:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-22_15-48-59.87e85e7a.png"},431:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-22_17-18-50.96fc16e8.png"},432:function(_,v,a){_.exports=a.p+"assets/img/Snipaste_2020-05-22_17-36-51.a0e4480a.png"},546:function(_,v,a){"use strict";a.r(v);var t=a(14),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("blockquote",[t("p",[_._v("论文名称：ROPOB: Obfuscating Binary Code via Return Oriented Programming")]),_._v(" "),t("p",[_._v("关键词：混淆 ROP 逆向")]),_._v(" "),t("p",[_._v("论文类型：会议")]),_._v(" "),t("p",[_._v("发表位置：S&P：IEEE Symposium on Security and Privacy")]),_._v(" "),t("p",[_._v("发表年份：2018")])]),_._v(" "),t("h2",{attrs:{id:"摘要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[_._v("#")]),_._v(" 摘要")]),_._v(" "),t("p",[_._v("软件逆向工程已广泛用于软件重用和恶意目的，例如软件窃取和恶意软件伪装。为了提高对手逆向工程的难度，需要将混淆处理引入保护的软件中，现有的混淆方法效率低下且难以部署。")]),_._v(" "),t("p",[_._v("在本文中，我们提出了一种基于 ROP 的二进制混淆处理方案，旨在作为一种高效且可部署的反逆向工程方法，基本思想是将直接控制流转换为间接控制流。")]),_._v(" "),t("p",[_._v("基本原理：静态分析通常不足以查明间接控制流的目标地址。")]),_._v(" "),t("p",[_._v("结果表明， ROPOB 可以成功地转换所有的直接控制流，而不会引起执行错误。开销可以接受：混淆覆盖率超过90％时，平均性能开销小于10％。")]),_._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[_._v("#")]),_._v(" 简介")]),_._v(" "),t("p",[_._v("首先介绍以下软件窃取与恶意软件伪装的概念，包括一些软件重打包的概念，以及造成的严重危害。然后说明了逆向工程和混淆的基本概念。总结一些现有的工作：")]),_._v(" "),t("ol",[t("li",[_._v("基于生成混淆代码的")]),_._v(" "),t("li",[_._v("利用信号机制来处理控制流的，但开销较大")]),_._v(" "),t("li",[_._v("利用特殊处理器的特性，即信息跟踪，来混淆代码，方式是异常处理")])]),_._v(" "),t("p",[_._v("然后介绍了 ROP 的基本原理，并介绍了 RopSteg ，一个代码保护方案，该代码试图通过执行位于其他位置的意外匹配，来隐藏选定的指令序列。说明了该方案的核心思想：利用 ROP 混淆控制流，粒度是基本块。")]),_._v(" "),t("ol",[t("li",[_._v("首先，反汇编一个要保护的 ELF 文件，并将可执行代码分成基本块。然后，对基本块进行插桩，转换成 gadget")]),_._v(" "),t("li",[_._v("通过 ret 指令，转换所有已识别的直接控制流")]),_._v(" "),t("li",[_._v("将所有 gadget 和设计好的有效负载添加到原始文件中，并利用二进制重写来生成混淆的文件。")])]),_._v(" "),t("p",[_._v("这里的有效负载将用于控制流转换，并将存储在一个新的负载代码段中。它是使用 ROP 进行混淆的一种轻量级方法。由于 ROP 仅在用户空间中起作用，不涉及信号处理或其他内核。因此转换控制流的过程比信号要快。而且 ROP 是线程安全的。")]),_._v(" "),t("p",[_._v("主要贡献")]),_._v(" "),t("ol",[t("li",[_._v("提出了一种新的基于 ROP 的方法来实现控制流混淆。实验证明，该方法对静态逆向工程分析是有效和实用的。")]),_._v(" "),t("li",[_._v("混淆方案高效并广泛使用。")]),_._v(" "),t("li",[_._v("实现了 ROPOB 的工具，实验证明，能正确转换直接控制流，混淆覆盖率超过90％时，平均性能开销小于10％。")])]),_._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),t("p",[_._v("假设3个前提")]),_._v(" "),t("ol",[t("li",[_._v("未混淆的代码是 ELF 文件格式的。")]),_._v(" "),t("li",[_._v("混淆文件在未修改的 Linux 系统上。")]),_._v(" "),t("li",[_._v("敌手只采用静态分析方法，如 IDA 。")])]),_._v(" "),t("p",[_._v("混淆方案步骤")]),_._v(" "),t("ol",[t("li",[_._v("反汇编代码段，切割成基本块粒度")]),_._v(" "),t("li",[_._v("在基本块粒度上插桩，转换成 gadget")]),_._v(" "),t("li",[_._v("将所有的 gadget 和设计的有效负载写入汇编器文件，然后将其组合成新的 ELF 文件。设计的有效负载是 gadget 的起始地址列表。其功能是指导所有 gadget 的执行。")]),_._v(" "),t("li",[_._v("复制新的 ELF 文件中的代码和所有的负载，生成混淆文件。")])]),_._v(" "),t("p",[t("img",{attrs:{src:a(428),alt:"混淆方案"}})]),_._v(" "),t("p",[_._v("然后擦除原生文件中的代码段，现在的段既有代码段，也有负载段，还有数据段不能被擦除，需要维持数据完整性。")]),_._v(" "),t("p",[_._v("总而言之，我们的所有工作都在用户空间中，不涉及内核空间。此外，由于静态分析中没有控制流信息，因此我们的方法可以使所有静态去混淆技术无效。同时增加动态去混淆方法的难度。因为在混淆处理的文件中没有函数调用，所以即使攻击者动态地找到执行路径，也很难提取高级语义。")]),_._v(" "),t("p",[_._v("挑战有3")]),_._v(" "),t("ol",[t("li",[_._v("基本块无法彻底分区。因此，一些间接控制流可能跳入基本块的内部，而不是入口，这将使有效载荷入口检查失败。？基本块的定义不是就一个入口吗？")]),_._v(" "),t("li",[_._v("间接的控制流图不能静态分析，有必要实现一个间接跳转表。")]),_._v(" "),t("li",[_._v("必须保持所有数据可用，设计一个重建的框架")])]),_._v(" "),t("p",[t("img",{attrs:{src:a(429),alt:"设计实例"}})]),_._v(" "),t("p",[_._v("虚线是原始的路径，实现是混淆后的路径，通过维持一个设计好的负载，进行检查和跳转。")]),_._v(" "),t("h2",{attrs:{id:"设计与实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计与实现"}},[_._v("#")]),_._v(" 设计与实现")]),_._v(" "),t("p",[_._v("工具主要包括三部分，一个基本的重建框架；基本块分割方法和控制流完整性检验。")]),_._v(" "),t("h3",{attrs:{id:"重建框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重建框架"}},[_._v("#")]),_._v(" 重建框架")]),_._v(" "),t("p",[_._v("基本原则是语义正确，设计了一个框架，同时支持汇编级别的插桩。主要是反汇编，再重新汇编到新的文件中。")]),_._v(" "),t("p",[t("img",{attrs:{src:a(430),alt:"重建框架"}})]),_._v(" "),t("p",[_._v("看图是比较清晰的。")]),_._v(" "),t("ol",[t("li",[_._v("首先提取原始文件的代码段，切割成基本块，同时收集控制流信息")]),_._v(" "),t("li",[_._v("然后应用汇编级别的插桩工具")]),_._v(" "),t("li",[_._v("之后使用重写的基本块和控制流信息生成汇编文件")]),_._v(" "),t("li",[_._v("将生成的代码段和原始的复制到一起，生成中间文件")]),_._v(" "),t("li",[_._v("擦除原始的代码段，保留数据段")])]),_._v(" "),t("h3",{attrs:{id:"基本块分割"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本块分割"}},[_._v("#")]),_._v(" 基本块分割")]),_._v(" "),t("p",[_._v("介绍了基本块的概念，切分基本块的原则")]),_._v(" "),t("ol",[t("li",[_._v("控制流相关的指令，比如 jmp/jcc/call/ret 指令，说明基本块结束，同时目标地址是基本块入口。")]),_._v(" "),t("li",[_._v("忽略间接跳转指令的目标操作数，如 jmp/jcc/call")]),_._v(" "),t("li",[_._v("jmp/jcc/call/ret 的下一条指令是基本块的入口")])]),_._v(" "),t("h3",{attrs:{id:"控制流映射表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制流映射表"}},[_._v("#")]),_._v(" 控制流映射表")]),_._v(" "),t("p",[_._v("不能解决间接的跳转指令，因为这些跳转指令的操作数由上下文决定。因为重用了原始文件中的所有数据部分，原始间接 CFRI 计算出的目标地址与 ROP 混淆后的间接 CFRI 的目标地址相同。在这种情况下，必须要对间接 CFRI 的地址进行转换才行，否则程序会崩溃。所以设计这样一个跳转表。")]),_._v(" "),t("p",[t("img",{attrs:{src:a(431),alt:"控制流映射表"}})]),_._v(" "),t("p",[_._v("如图所示，对于这样一个转换的 gadget ，如果间接 CFRI 的地址是 BB1 的入口，首先计算目标地址，然后检查控制流映射表在 Gadget1 的目标地址。如果我们的基本块分区错过了一个基本块（ BB1 中的入口为 0x804caca ，而间接 CFRI 跳转到 0x804caca ），将找不到任何表条目来匹配 0x804caca 。但是其与入口的的偏移量等于 0x7007e05 和 0x7007dff 之间的偏移量，并且还要确认仅在基本块的末尾而不是在中间块应用了插桩。因此可以正确找到入口。")]),_._v(" "),t("h3",{attrs:{id:"rop-插桩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rop-插桩"}},[_._v("#")]),_._v(" ROP 插桩")]),_._v(" "),t("p",[_._v("负载是 ROP gadget 的列表，同时还对不同的控制流设计不同的插桩原则。")]),_._v(" "),t("ol",[t("li",[_._v("对于不以 CFRI 结尾的基本块，将基本块入口地址压栈。")]),_._v(" "),t("li",[_._v("对于以直接 CRFI 结尾的基本块，基本就是 call/jmp 指令，将下一个 gadget 地址压栈；如果是 jcc 指令，一般有2条路径。")]),_._v(" "),t("li",[_._v("对于间接 CRFI ，采用控制流映射表。")]),_._v(" "),t("li",[_._v("对于 ret 结束的基本块，不需要其他操作。")])]),_._v(" "),t("p",[t("img",{attrs:{src:a(432),alt:"ROP 插桩"}})]),_._v(" "),t("h2",{attrs:{id:"评估"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#评估"}},[_._v("#")]),_._v(" 评估")]),_._v(" "),t("h2",{attrs:{id:"相关工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关工作"}},[_._v("#")]),_._v(" 相关工作")]),_._v(" "),t("h2",{attrs:{id:"讨论与限制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讨论与限制"}},[_._v("#")]),_._v(" 讨论与限制")]),_._v(" "),t("h2",{attrs:{id:"结论与后期工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结论与后期工作"}},[_._v("#")]),_._v(" 结论与后期工作")]),_._v(" "),t("h2",{attrs:{id:"思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[_._v("#")]),_._v(" 思考")]),_._v(" "),t("h3",{attrs:{id:"文章综述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文章综述"}},[_._v("#")]),_._v(" 文章综述")]),_._v(" "),t("p",[_._v("该文章提出了一种 "),t("code",[_._v("fuzz")]),_._v(" 安卓原生系统服务的方法。能自动化的生成事务，并调用相应的接口。 "),t("code",[_._v("fans")]),_._v(" 能自动化处理接口间的复杂依赖。这种依赖性体现在三方面：变量模式、类型别名和变量依赖性。最后发现了30多个漏洞，138个 "),t("code",[_._v("Java")]),_._v(" 异常，这些东西要 "),t("code",[_._v("fuzz")]),_._v(" 到，必须要有一个精确的接口模型。")]),_._v(" "),t("h3",{attrs:{id:"关键部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关键部分"}},[_._v("#")]),_._v(" 关键部分")]),_._v(" "),t("blockquote",[t("p",[_._v("用来记录本篇文章关键的地方，标注好内容和页码")])]),_._v(" "),t("h3",{attrs:{id:"研究方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#研究方法"}},[_._v("#")]),_._v(" 研究方法")]),_._v(" "),t("blockquote",[t("p",[_._v("可以看出此类问题，大家都是采用一个什么样的方法去解决的")])]),_._v(" "),t("h3",{attrs:{id:"存在问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[_._v("#")]),_._v(" 存在问题")]),_._v(" "),t("p",[_._v("如何解决面临的挑战")]),_._v(" "),t("ol",[t("li",[_._v("多层接口的识别")]),_._v(" "),t("li",[_._v("接口模型的解析")]),_._v(" "),t("li",[_._v("语义正确的输入生成")])]),_._v(" "),t("h3",{attrs:{id:"产生原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[_._v("#")]),_._v(" 产生原因")]),_._v(" "),t("h3",{attrs:{id:"解决方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[_._v("#")]),_._v(" 解决方法")]),_._v(" "),t("h3",{attrs:{id:"创新点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创新点"}},[_._v("#")]),_._v(" 创新点")]),_._v(" "),t("p",[_._v("自动化进行 "),t("code",[_._v("fuzz")])]),_._v(" "),t("p",[_._v("正确处理事务之间的依赖")]),_._v(" "),t("h3",{attrs:{id:"不足之处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不足之处"}},[_._v("#")]),_._v(" 不足之处")]),_._v(" "),t("blockquote",[t("p",[_._v("别人论文里的不足可能是你 "),t("code",[_._v("idea")]),_._v(" 的来源")])])])}),[],!1,null,null,null);v.default=s.exports}}]);