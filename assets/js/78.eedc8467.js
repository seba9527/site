(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{830:function(t,a,s){"use strict";s.r(a);var r=s(6),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("论文名称：PeX: A Permission Check Analysis Framework for Linux Kernel")]),t._v(" "),s("p",[t._v("论文类型：期刊")]),t._v(" "),s("p",[t._v("发表位置：usenix")]),t._v(" "),s("p",[t._v("发表年份：2019")])]),t._v(" "),s("h2",{attrs:{id:"摘要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[t._v("#")]),t._v(" 摘要")]),t._v(" "),s("p",[t._v("权限检查通过提供对特权功能的访问控制，在操作系统安全中起着至关重要的作用。 但是，由于内核的代码量大和复杂性高，因此对于内核开发人员而言，正确地应用新的权限检查并可伸缩地验证现有检查的合理性尤其具有挑战性。 实际上，Linux内核包含数百万行代码以及数百个权限检查，更糟糕的是它的复杂性正在快速增长。")]),t._v(" "),s("p",[t._v("本文介绍了PeX，它是LinuX的静态权限检查错误检测器，它以内核源代码为输入，并报告任何丢失，不一致和冗余的权限检查。  PeX使用KIRIN（基于内核接口的间接调用分析），这是一种新颖，精确且可扩展的间接调用分析技术，并利用了内核抽象接口中使用的通用编程范例。 在KIRIN构建的过程间控制流程图上，PeX自动识别所有权限检查，并推断权限检查和特权功能之间的映射。 对于每个特权函数，PeX会检查函数的所有可能路径，以检查在调用之前是否正确实施了必要的权限检查。")]),t._v(" "),s("h2",{attrs:{id:"介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),s("h2",{attrs:{id:"背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),s("h2",{attrs:{id:"权限检测错误的实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#权限检测错误的实例"}},[t._v("#")]),t._v(" 权限检测错误的实例")]),t._v(" "),s("h2",{attrs:{id:"挑战"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#挑战"}},[t._v("#")]),t._v(" 挑战")]),t._v(" "),s("h2",{attrs:{id:"间接调用分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#间接调用分析"}},[t._v("#")]),t._v(" 间接调用分析")]),t._v(" "),s("h2",{attrs:{id:"pex设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pex设计"}},[t._v("#")]),t._v(" pex设计")]),t._v(" "),s("h2",{attrs:{id:"实现与评估"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现与评估"}},[t._v("#")]),t._v(" 实现与评估")])])}),[],!1,null,null,null);a.default=e.exports}}]);