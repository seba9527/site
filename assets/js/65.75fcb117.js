(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{478:function(t,a,n){"use strict";n.r(a);var s=n(11),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("hr"),t._v(" "),n("blockquote",[n("p",[t._v("Android Jni调试")])]),t._v(" "),n("h2",{attrs:{id:"jni-onload"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jni-onload"}},[t._v("#")]),t._v(" JNI_OnLoad")]),t._v(" "),n("p",[t._v("JNI_ OnLoad函数大概功能就是在程序加载so的时候，会执行JNI_ OnLoad函数，做一系列的准备工作。\n很多时候，程序猿们会将一些重要信息放在此函数中，而不是通过某种事件来重复触发。包括说将反调试函数放置在此函数中。因此，调试手段发生了改变，上述调试方法基本上被淘汰。")]),t._v(" "),n("p",[t._v("当这种调试手法出现之后，将特殊函数，或者反调试函数放在JNI_ OnLoad中也不是那么的安全了。此时，程序猿们通过分析系统对SO文件的加载链接过程发现，JNI_ OnLoad函数并不是最开始执行的。在JNI_ OnLoad函数执行之前，还会执行init段和init_array中的一系列函数。\n因此，现在的调试方法，都是将断点下在init_array中~\n至于下断点的方法，可以类比于在JNI_ OnLoad中下断点的方法，在init_ array的函数中下断点。还有一种方法便是通过在linker模块中，通过对其中函数下断点，然后也能单步到init_array中")]),t._v(" "),n("h2",{attrs:{id:"dump-dex文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dump-dex文件"}},[t._v("#")]),t._v(" Dump dex文件")]),t._v(" "),n("p",[t._v("关键是找到加载dex文件的位置，在调用函数处下断点，比如dvmDexFileOpenPartia，然后看寄存器的值，容易得知：R0寄存器指向的地址就是dex文件在内存中的地址，R1寄存器就是dex文件的大小。IDA脚本：")]),t._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[t._v("static main"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("void"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  auto fp"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" begin"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" end"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dexbyte"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  fp "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fopen"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C:\\\\dump.dex"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"wb"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  begin "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" r0"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  end "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" r0 "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" r1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" dexbyte "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" begin"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" dexbyte "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" end"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" dexbyte "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      fputc"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Byte"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dexbyte"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fp"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br")])]),n("p",[t._v("当然这只是最简单脱壳方法，很多高级壳会动态修改dex的结构体，比如将codeoffset指向内存中的其他地址，这样的话你dump出来的dex文件其实是不完整的，因为代码段保存在了内存中的其他位置。")]),t._v(" "),n("h2",{attrs:{id:"其他"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),n("p",[t._v("我们知道在so的加载时候有个这个过程：\n.init->->.init array->->JNI_ Onload->->java_ com_XXX;\n还有我们在脱壳的过程中会在一些系统级的.so中下断点比如：fopen,fget,dvmdexfileopen,等等\n而.init以及.init_array一般会作为壳的入口地方，那我们索性叫它外壳级的.so文件\n这里归纳为三类：\n应用级别的：java_ com_XXX；\n外壳级别的：JNI_ Onload,.init,.init_array;\n系统级别的：fopen,fget,dvmdexfileopen；\n对于在应用级别的和系统级别的就不说了比较简单容易理解，这里也是在实现篇中会重点说的，看到上面的.so的加载执行过程我们知道如果说反调试放在外壳级别的.so文件的话我们就会遇程序在应用级核心函数一下断点就退出的尴尬，事实上多数的反调试会放在这，那么过反调试就必须要在这些地方下断点，那么我们就重点的说如何在.init_ array和JNI_Onload处理下断点。")])])}),[],!1,null,null,null);a.default=e.exports}}]);