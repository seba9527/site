(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{517:function(t,a,e){t.exports=e.p+"assets/img/Snipaste_2020-06-01_16-26-59.b12242b1.png"},518:function(t,a,e){t.exports=e.p+"assets/img/Snipaste_2020-06-01_21-13-35.1bd2c31e.png"},826:function(t,a,e){"use strict";e.r(a);var _=e(6),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("blockquote",[_("p",[t._v("论文名称：Speculator：A Tool to Analyze Speculative Execution Attacks and Mitigations")]),t._v(" "),_("p",[t._v("论文类型：期刊")]),t._v(" "),_("p",[t._v("发表位置：Proceedings of the 35th Annual Computer Security Applications Conference")]),t._v(" "),_("p",[t._v("发表年份：2019")])]),t._v(" "),_("h2",{attrs:{id:"摘要"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[t._v("#")]),t._v(" 摘要")]),t._v(" "),_("p",[t._v("现状：新的推测执行攻击基本上每个月都会出现新的，同时仍旧存在很多未被发现的微体系结构攻击，同时CPU厂商没有相关的文档。")]),t._v(" "),_("p",[t._v("Speculator：一个新的工具，用于审查新的微体系结构攻击和相应的缓解方法（GDB of speculative execution）")]),t._v(" "),_("p",[t._v("通过利用一些可被观察到的性能计数器，speculator可以了解代码片段或者复杂攻击常见在推测执行过程中的微体系结构行为")]),t._v(" "),_("p",[t._v("我们还介绍了在多个CPU平台上的发现，这些结果展示了Speculator及其模板提供的精度和灵活性")]),t._v(" "),_("h2",{attrs:{id:"介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),_("p",[t._v("最近的工作显示了如何通过在ISA接口级别提交经过精心设计的输入来绕过安全控制。这些攻击在微体系结构级别利用了未记录的行为，并且是通过逆向工程和反复试验发现的。由于没有公开获得有关现代商用CPU的微体系结构级别的详细信息，因此尚未完全了解此类攻击的全部范围。研究社区无法提供有关新攻击的存在和防御有效性的完整答案。")]),t._v(" "),_("p",[t._v("目前推测攻击和防御的需求：")]),t._v(" "),_("ol",[_("li",[t._v("为了开发新的攻击，通常会需要分析调试一些PoC代码的片段，此时就需要一个类似于推测执行攻击的工具，能够直接检查微体系结构状态的变化，从而判断攻击是否成功")]),t._v(" "),_("li",[t._v("当测试防御策略的有效性时，目前的选择是执行攻击的PoC代码或者选择相信一些提供的CPU flags或者内核配置。此时也需要一个更细粒度的工具能够检查微体系结构状态的变化，从而判断防御策略的有效性")])]),t._v(" "),_("p",[t._v("Speculator 通过使用性能计数器记录或推断微体系结构行为，支持增量分析（在代码段上微体系结构状态的演变），在Intel和AMDCPU上运行，并启用并发执行（SMT环境中两个线程的交互）。")]),t._v(" "),_("p",[t._v("文章工作:")]),t._v(" "),_("ol",[_("li",[t._v("提出了一种基于性能计数器的方法和工具，speculator，用于分析攻击和缓解策略")]),t._v(" "),_("li",[t._v("利用speculator验证了返回栈缓冲区的大小，嵌套的推测执行的有效性，推测执行不会跨越系统调用，clflush在推测执行过程中无效等。同时也测量了对于间接分支，间接控制流转移和store-to-load前递导致的推测窗口的大小。最后测试了页面权限，内存保护扩展和特殊指令（例如lfence）对推测执行的影响")]),t._v(" "),_("li",[t._v("给出了一些利用speculator分析的攻击和缓解示例")])]),t._v(" "),_("h2",{attrs:{id:"背景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),_("p",[t._v("较高特权模式（由受害者提供的代码）或较低特权模式（由攻击者提供的代码）")]),t._v(" "),_("p",[t._v("推测执行攻击的步骤")]),t._v(" "),_("ol",[_("li",[t._v("准备侧信道：CPU 执行一些操作用于增加攻击成功的机会，例如对于prime-and-probe的攻击，需要实现刷新cache。")]),t._v(" "),_("li",[t._v("准备侧信道攻击：CPU执行一些代码，引导受害者进行推测执行")]),t._v(" "),_("li",[t._v("开始推测执行：CPU执行一条指令，并且该指令的输出将会决定下一条指令的执行，例如条件分支，为了减少等待时间，开始进行推测执行。")]),t._v(" "),_("li",[t._v("推测执行，通过侧信道发送数据：推测执行某些指令，导致微体系结构状态变化")]),t._v(" "),_("li",[t._v("通过侧信道接收数据：CPU执行某些指令，将微体系结构状态的变化转换体系结构的变化（数据）")])]),t._v(" "),_("p",[t._v("推测执行攻击可以跨域的特权边界：")]),t._v(" "),_("ol",[_("li",[t._v("kernel vs. user-mode code")]),t._v(" "),_("li",[t._v("hardware enclave(SGX) vs. user-mode or kernel-mode code")]),t._v(" "),_("li",[t._v("sandboxed code in the same process, (JavaScript JIT code)")]),t._v(" "),_("li",[t._v("processes-to-process boundary")]),t._v(" "),_("li",[t._v("remote node to local node boundary")])]),t._v(" "),_("h2",{attrs:{id:"speculator"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#speculator"}},[t._v("#")]),t._v(" SPECULATOR")]),t._v(" "),_("p",[t._v("Speculator 通过性能计数器记录或者推断微体系结构行为，支持增量分析(在代码片段(code snippet)上的微体系结构状态的演化)，在Intel和AMD cpu上运行，支持并发执行(在SMT环境中两个线程的交互)")]),t._v(" "),_("h3",{attrs:{id:"性能监控器功能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能监控器功能"}},[t._v("#")]),t._v(" 性能监控器功能")]),t._v(" "),_("p",[t._v("现在处理器提供了一组寄存器（固定的和可编程的），用于展示执行的各个方面的信息。这些寄存器或者计数器用于记录一些和微体系结构状态变化相关的时间或者持续时间，例如提交指令数，转移预测错误次数等。")]),t._v(" "),_("p",[t._v("使用性能计数器的流程：")]),t._v(" "),_("ol",[_("li",[t._v("setup阶段，开发人员可以从受支持的事件中选择将由可编程计数器测量的事件")]),t._v(" "),_("li",[t._v("start和stop，测量过程可以通过编程控制开始和结束，从而准确的控制正在测量精确指令序列的事件。")]),t._v(" "),_("li",[t._v("access阶段，获取计数器的值")])]),t._v(" "),_("p",[t._v("setup，start，stop通常需要supervisor模式（ring 0），access在用户模式即可")]),t._v(" "),_("p",[t._v("Speculator 建立在性能计数器之上，以观察投机执行的性质和影响。这种方法面临的一个挑战是性能计数器接口的设计并未考虑到这一目标。本文的贡献之一是确定了使用接口的有效方法，以及一组有用的计数器以准确推断推测执行的行为。")]),t._v(" "),_("h3",{attrs:{id:"目的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目的"}},[t._v("#")]),t._v(" 目的")]),t._v(" "),_("p",[t._v("主要目的：准确测量代码片段中推测部分相关的微体系结构状态属性。精度是指工具能够将代码片段所引起的微体系结构状态变化和工具本身以及系统其余部分隔离开的程度（外界的影响）。")]),t._v(" "),_("p",[t._v("Speculator可观察到的部分信息：")]),t._v(" "),_("ol",[_("li",[t._v("代码中那些部分是被推测执行的")]),t._v(" "),_("li",[t._v("引发推测执行和结束推测执行的原因")]),t._v(" "),_("li",[t._v("影响推测执行指令数量/指令窗口的参数")]),t._v(" "),_("li",[t._v("特定的指令如何影响推测执行的行为")]),t._v(" "),_("li",[t._v("那些安全边界可以有效的阻止推测执行")]),t._v(" "),_("li",[t._v("CPU在同一个体系结构内以及跨体系结构和供应商的行为如何保持一致（consistency）")])]),t._v(" "),_("p",[t._v("Speculator 另一个目标：为代码片段的生成和操作（manipulation）提供一个工具。 Speculator 可以在推测执行期间检查单个代码片段或者代码片段组，从而使得用户只需要专注于特定用例相关的指令组合。")]),t._v(" "),_("h3",{attrs:{id:"speculator-的设计和实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#speculator-的设计和实现"}},[t._v("#")]),t._v(" Speculator 的设计和实现")]),t._v(" "),_("p",[_("img",{attrs:{src:e(517),alt:"架构"}})]),t._v(" "),_("p",[t._v("三个主要部件：预处理单元，运行时单元（Monitor），后期处理单元")]),t._v(" "),_("p",[t._v("预处理单元：将提供的输入编译成合适的执行格式，从而引入性能监视器接口所需要的代码/工具，以便能够观察所选的计数器的值。")]),t._v(" "),_("ol",[_("li",[t._v("输入：一段C或者汇编代码")]),t._v(" "),_("li",[t._v("处理：将预先编译的json文件中的指令添加到输入代码的特定位置（在source template中定义的位置中）")])]),t._v(" "),_("p",[t._v("Runtime 单元：主要由speculator monitor负责初始化和读取生成代码中使用到的计数器")]),t._v(" "),_("ol",[_("li",[t._v("生成的代码片段和 monitor 会放在不同的核上执行，以减少相互之间的干扰")]),t._v(" "),_("li",[t._v("当 Monitor 建立好环境后，就会加载并在另一个进程中执行snippet，直到结束")]),t._v(" "),_("li",[t._v("代码片段的开头和结尾会对计数器进行reset，start和stop的操作")])]),t._v(" "),_("p",[t._v("后期处理单元：")]),t._v(" "),_("ol",[_("li",[t._v("当代码片段执行完成后，OS通知monitor。之后Monitor将获取这些计数器的值，将结果写入文件中")]),t._v(" "),_("li",[t._v("在多次运行之后，统计收集所有结果，并且去除其中的可疑点")])]),t._v(" "),_("h3",{attrs:{id:"触发推测执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#触发推测执行"}},[t._v("#")]),t._v(" 触发推测执行")]),t._v(" "),_("p",[t._v("为了自动生成测试样例，speculator为用户提供了一系列的模板，能够用于重现各种触发推测执行的方式，包括BTI（branch target injection），spectre v1， RAS等。")]),t._v(" "),_("p",[t._v("下图为利用branch触发推测执行的样例。setup用于将BP设置为指定的状态，可以导致之后的分支发生错误预测，并且推测执行之后的snippet代码")]),t._v(" "),_("p",[_("img",{attrs:{src:e(518),alt:"触发推测执行"}})]),t._v(" "),_("h3",{attrs:{id:"推测执行标记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#推测执行标记"}},[t._v("#")]),t._v(" 推测执行标记")]),t._v(" "),_("p",[t._v("推测执行标记是指某些特殊的指令或者序列，他们在未提交之前就可以被性能计数器检测到。通常情况下，这些标记会引发一些微体系结构事件，从而可以被计数器捕获到。例如计数器可以测量某些类型的指令的发射/执行的数量，同时不需要指令一定会被提交。")]),t._v(" "),_("p",[t._v("通过在代码片段中增加这样的标记，Speculator通过检测性能计数将可以判断CPU是否执行了该代码片段。")]),t._v(" "),_("ol",[_("li",[t._v("Intel处理器中一些可用的标记：\n"),_("ol",[_("li",[t._v("UOPS_EXECUTED.CORE/THREAD：通过减去最终提交的指令数量，就可以得到被推测执行但是未提交的指令的数量。该计数器不计数不需要执行的指令，例如NOP，但是不包括FNOP")]),t._v(" "),_("li",[t._v("UOPS_ISSUED.SINGLE_MUL：当使用了XMM寄存器的单精度浮点指令发射时，进行计数。在最近的CPU中会删除了，例如Skylake")]),t._v(" "),_("li",[t._v("UOPS_ISSUED.SLOW_LEA：计数带有三个源操作数的lea指令")]),t._v(" "),_("li",[t._v("LD_BLOCKS.STORE_FORWARD：当store前递的结果失败后，计数器+1")])])]),t._v(" "),_("li",[t._v("AMD Zen可用的计数器\n"),_("ol",[_("li",[t._v("DIV_OP_COUNT：被执行的div指令的数量")]),t._v(" "),_("li",[t._v("NUMBER_ OF_ MOVE_ ELIMINATION_ AND_ SCALAR_ OP_OPTIMIZATION：类似于LD_BLOCKS.STORE_FORWARD，但是相对而言统计的是这种指令序列出现的情况，他统计了move elimination成功的次数。")])])])]),t._v(" "),_("h2",{attrs:{id:"利用-speculator-分析微体系结构状态的变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#利用-speculator-分析微体系结构状态的变化"}},[t._v("#")]),t._v(" 利用 Speculator 分析微体系结构状态的变化")]),t._v(" "),_("h3",{attrs:{id:"返回栈缓存大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#返回栈缓存大小"}},[t._v("#")]),t._v(" 返回栈缓存大小")]),t._v(" "),_("p",[t._v("RSB的大小通常已知，因此可以用于衡量speculator的准确性")]),t._v(" "),_("p",[t._v("设计：snippet代码片段包含在call和ret之间，在代码中调用filler函数，该函数会增加嵌套调用的层数。每一层call都会在RSB中增加一个表项，如果表项数使用完了，最外层的call指令将找不到对应的ret指令，导致CPU无法执行实现设置的标记")]),t._v(" "),_("p",[t._v("在Intel的Kabylake处理器中的测试结果")]),t._v(" "),_("h3",{attrs:{id:"嵌套推测执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#嵌套推测执行"}},[t._v("#")]),t._v(" 嵌套推测执行")]),t._v(" "),_("p",[t._v("实验：三个嵌套的条件分支。最外层最为复杂，包括源数据不在缓存中，同时需要进行除法操作，因此解决时间最长。中间的分支操作很简单，但是数据不在缓存中。最里层的分支数据是被缓存的，最容易解决。BP的状态会实现被训练好，三个分支都会被预测错误\n结论（Broadwell&Skylake）：内层推测执行会发生。如果内层分支在上一层分支解决之前被解决了，会在另一个方向进行推测执行。如果最外层分支被解决了，所有的指令都会被取消。")]),t._v(" "),_("h3",{attrs:{id:"跨越系统调用推测执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跨越系统调用推测执行"}},[t._v("#")]),t._v(" 跨越系统调用推测执行")]),t._v(" "),_("p",[t._v("实验：推测执行的代码片段中发射一条系统调用指令（sys_getppid，简单，只需要47条指令）。使用计数器记录执行的微操作的数量，并且将其调整为用户模式和内核模式分开的执行指令数量\n结论：在系统调用之前的推测执行的指令数量不会增加，尽管增加了系统调用指令之后的指令数量。在内核模式下的执行的指令数量和未进行推测执行的情况下一致。因此系统调用指令可以有效的停止推测执行，当系统调用从内核模式返回时。")]),t._v(" "),_("h3",{attrs:{id:"刷新缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#刷新缓存"}},[t._v("#")]),t._v(" 刷新缓存")]),t._v(" "),_("p",[t._v("实验：代码如图所示。在代码片段中，首先将值从cache中刷新出去，然后再访问该值（lfence保证clflush的操作都可以正常执行，并且停止推测执行）。在两次执行中，分别在setup阶段保证该值在cache中和不在cache中。通过测量执行时间来反映结果")]),t._v(" "),_("p",[t._v("结论：在推测执行过程中的clflush不会影响cache，直到该指令提交了，因此攻击者无法使用clflush扩展推测执行的窗口。")]),t._v(" "),_("h3",{attrs:{id:"推测执行的窗口大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#推测执行的窗口大小"}},[t._v("#")]),t._v(" 推测执行的窗口大小")]),t._v(" "),_("p",[t._v("在分支条件取决于不同类型的指令的情况下，条件分支引发推测执行的指令窗口的大小")]),t._v(" "),_("p",[t._v("间接控制流转移指令")]),t._v(" "),_("p",[t._v("store-to-load前递：在Broadwell处理器中，推测窗口大小平均为55周期")]),t._v(" "),_("h3",{attrs:{id:"可执行的页权限"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可执行的页权限"}},[t._v("#")]),t._v(" 可执行的页权限")]),t._v(" "),_("p",[t._v("问题：在推测执行过程中，是否可以推测执行不具有执行权限的页内的指令\n实现：在推测执行过程中（branch mis-prediction），增加控制流转移指令跳转到non-executable的内存区域。在实验中，首先保证该内存区域中要被使用的数据会在L2 cache中，同时地址也在TLB中\n结论：研究的所有架构中，页的可执行权限检查都会被满足，即如果该页面是不可执行的，则该页面中的指令也不会被推测执行。")]),t._v(" "),_("h3",{attrs:{id:"内存保护扩展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存保护扩展"}},[t._v("#")]),t._v(" 内存保护扩展")]),t._v(" "),_("p",[t._v("MPX的功能：efficiently keeping track of bounds information associated with pointers and corresponding spatial memory checks before dereferencing pointers 。如果边界检查失败，会触发一个#BR异常，CPU自陷入kernel")]),t._v(" "),_("p",[t._v("实验：测量在边界检查分支之后有多少代码会被推测执行")]),t._v(" "),_("p",[t._v("结果：MPX的FNOP指令在增加到22个之后，执行的指令数量不在发生变化")]),t._v(" "),_("h2",{attrs:{id:"结论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[t._v("#")]),t._v(" 结论")]),t._v(" "),_("p",[t._v("我们还展示了使用Speculator编写PoC攻击和测试缓解措施。 编写适用于投机者的测试，可以大大提高PoC和通用测试的可移植性。 我们预见到Speculator将用于共享可重复的测试，这些测试可用于以更精确，更可靠的方式验证系统保护的状态，并进一步对CPU未记录的功能进行反向工程。")]),t._v(" "),_("h2",{attrs:{id:"文章综述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文章综述"}},[t._v("#")]),t._v(" 文章综述")]),t._v(" "),_("p",[t._v("该文章提出了一种 fuzz 安卓原生系统服务的方法。能自动化的生成事务，并调用相应的接口。fans能自动化处理接口间的复杂依赖。这种依赖性体现在三方面：变量模式、类型别名和变量依赖性。最后发现了30多个漏洞，138个Java异常，这些东西要fuzz到，必须要有一个精确的接口模型。")]),t._v(" "),_("h2",{attrs:{id:"关键部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关键部分"}},[t._v("#")]),t._v(" 关键部分")]),t._v(" "),_("blockquote",[_("p",[t._v("用来记录本篇文章关键的地方，标注好内容和页码")])]),t._v(" "),_("h2",{attrs:{id:"研究方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#研究方法"}},[t._v("#")]),t._v(" 研究方法")]),t._v(" "),_("blockquote",[_("p",[t._v("可以看出此类问题，大家都是采用一个什么样的方法去解决的")])]),t._v(" "),_("h2",{attrs:{id:"存在问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[t._v("#")]),t._v(" 存在问题")]),t._v(" "),_("p",[t._v("如何解决面临的挑战")]),t._v(" "),_("ol",[_("li",[t._v("多层接口的识别")]),t._v(" "),_("li",[t._v("接口模型的解析")]),t._v(" "),_("li",[t._v("语义正确的输入生成")])]),t._v(" "),_("h2",{attrs:{id:"产生原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[t._v("#")]),t._v(" 产生原因")]),t._v(" "),_("h2",{attrs:{id:"解决方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),_("h2",{attrs:{id:"创新点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#创新点"}},[t._v("#")]),t._v(" 创新点")]),t._v(" "),_("p",[t._v("自动化进行 fuzz")]),t._v(" "),_("p",[t._v("正确处理事务之间的依赖")]),t._v(" "),_("h2",{attrs:{id:"不足之处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不足之处"}},[t._v("#")]),t._v(" 不足之处")]),t._v(" "),_("blockquote",[_("p",[t._v("别人论文里的不足可能是你idea的来源")])]),t._v(" "),_("h2",{attrs:{id:"详细部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#详细部分"}},[t._v("#")]),t._v(" 详细部分")]),t._v(" "),_("h2",{attrs:{id:"参考文献"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://github.com/ibm-research/speculator",target:"_blank",rel:"noopener noreferrer"}},[t._v("Tool to Analyze Speculative Execution Attacks and Mitigations"),_("OutboundLink")],1)]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.ibm.com/blogs/research/2019/12/speculator-a-microscope-for-spectre-like-attacks/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Speculator : A Microscope for Spectre-like Attacks"),_("OutboundLink")],1)]),t._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/shuiliusheng/article/details/103588487",target:"_blank",rel:"noopener noreferrer"}},[t._v("Speculator：A Tool to Analyze Speculative Execution Attacks and Mitigations"),_("OutboundLink")],1)]),t._v(" "),_("h2",{attrs:{id:"翻译"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#翻译"}},[t._v("#")]),t._v(" 翻译")]),t._v(" "),_("p",[t._v("事实证明，我们只需要建立一个显微镜。 为了构建它，我们开始研究CPU本身提供给开发人员的所有信息。 我们立即专注于所有现代CPU都提供的Performance Monitor Counters接口。 实际上，此接口是专为不同目的而设计的，即研究软件性能的各种特征。 我们的第一个主要贡献是，我们能够确定如何可靠地使用性能计数器来理解投机执行。 尤其是，我们能够识别出这些计数器中的哪些可以用作代码的推测执行片段中的标记。 标记指的是这些性能计数器可检测到的任何一条指令或一系列指令，即使该指令最终作为错误的“猜测”的一部分被CPU执行，从而随后被撤消。")]),t._v(" "),_("p",[t._v("为了能够使用我们设计和实现的Speculator标记进行分析。 投机者是基于性能计数器的工具-我们的显微镜。 使用Speculator，我们能够编写测试程序，其中推测性地执行了一系列指令。 然后，使用标记，我们可以在其中验证其行为。 投机者还能够通过来自受害者的投机执行秘密信息来研究攻击者进程泄漏的攻击。 该工具使我们能够验证和研究不同的微体系结构行为，例如嵌套的投机执行，各种投机窗口大小等等。")]),t._v(" "),_("p",[t._v("借助显微镜，我们发现了新的攻击类型[2,3]，包括Spectre v2攻击的两种新变种：一种使用指令缓存（Icache），另一种使用分支预测变量，即doubleBTI 。")]),t._v(" "),_("p",[t._v("让我们回到咖啡店，了解这些新型攻击的工作原理。在攻击过程中，恶意客户（攻击者）只需在柜台后方（旁通道）窥视即可看到将要发生的情况，与其他客户刚刚选择的订单相比，酒吧招待可使用哪种配料来准备投机咖啡订单起来某些成分可能仅用于此特定顺序，而没有别的，这将顺序与以前的顺序区分开。")]),t._v(" "),_("p",[t._v("但是，如果攻击者能够识别出柜台上残留的成分的痕迹，那么也可以追溯一系列特定的指令。通过推断，攻击者可以想象准备订单所需的步骤（例如煮沸水，研磨咖啡豆，加一点奶油等，或者三明治，切火腿，沙拉和西红柿，撒蛋黄酱等）。在CPU中，以推测方式执行指令的地方是将跟踪保留在高速缓存中的指令。毫不留情地追踪此类攻击者可以揭示这些特定指令计算出的秘密。从本质上讲，他们不仅揭露了秘密调味酱中的成分，而且还揭示了它的制作方法，成分来自何处以及如何被最佳使用。")])])}),[],!1,null,null,null);a.default=v.exports}}]);