<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Angrlearning 4  -  My way, though far away</title>
<meta name="description" content="  学习笔记，结合官方文档和网上资料整理，加强理解从angr第二章第四节开始 程序状态程序状态——内存，寄存器和其他到目前为止，我们只学习了angr中的模拟程序状态。(SimState 对象)。用这种最原始的方式来理解angr中的很多基本的概念和操作。这里你将学习angr中静态对象的数据结构和如何更有效的进行交互。复习：读写内存和寄存器如果你依次阅读指南，你已经知道如何对内存和寄存器进行访问了。state.regs 提供了寄存器名作为属性来获取访问。state.mem提供了以下标的方式来获取具体的内存地址，并指定一个特殊的值类型。 另外，你应该知道如何和ASTs进行交互，这样你就能理解位向量类型可以被存储在寄存器和内存中。# 获取mem[rip]的值In [33]: state.mem[state.regs.rip].int64_tOut[33]: &lt;int64_t &lt;BV64 0x8949ed31fa1e0ff3&gt; at 0x402110&gt;# 解析mem[rip]的值In [34]: state.mem[state.regs.rip].int64_t.resolvedOut[34]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# 保存该值到rbpIn [35]: state.regs.rbp = state.mem[state.regs.rip].int64_t.resolvedOut[36]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# rax += mem[rip + 8]In [37]: state.regs.rax += state.mem[state.regs.rip + 8].int64_t.resolvedOut[38]: &lt;BV64 0xe48348e289485eed&gt;# 获取mem[rbp]的值In [39]: state.mem[state.regs.rbp].int64_tOut[39]: WARNING | 2019-02-18 13:56:38,626 | angr.state_plugins.symbolic_memory | Memory address 0x8949ed31fa1e0ff3 has an unspecified value; Generating an unconstrained value of 8 bytes.&lt;int64_t &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt; at 0x8949ed31fa1e0ff3&gt;In [40]: state.mem[state.regs.rbp].int64_t.resolvedOut[40]: &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt;基本的执行之前的时候，我们展示了如何使用模拟器来展示一些基本的执行操作，我们将在下一节展示模拟管理器的全部功能，但是现在我们可以使用一些比较简单的接口来展示如何进行符号执行，通过使用state.step()，这个方法将会执行一步符号执行操作并且返沪i一个对象，叫做SimSuccessors。不同于正常的模拟，符号执行可以产生很多种不同的后继状态，这些状态将被分类成几种。现在我们关心的是.successors属性，这是一个列表，包含了所有基于给定状态的所有后续状态。为什么是列表，而不是一个单独的后继状态呢。这是因为在angr中，angr进行符号执行的流程仅仅是将一个个单独的指令编译到程序中，执行他们来改变一个模拟状态。当遇到像条件判断语句，如果变量是符号值会怎么样呢。在angr的某处深度下，该条件会被执行，这样的话，结果就包含该约束条件。这是正确的，但是下一个问题是，我们到底在判断语句处如何选择流程。答案是，我们两边都选择，我们生成了2条完整的分离的后继状态，一个模拟条件正确的路线，一个模拟相反的条件的路线，这样的话，无论我们之后使用约束求解器来求解哪一个状态，状态所拥有的条件都将确保我们得到有效的输入，这些条件将导致状态执行和给定状态相同的路径。为了展示这个，我们使用一个例子，如果你看源代码，会发现认证机制是有后门的，任何用户名可以通过sosneaky来认证成管理员。#!/usr/bin/env pythonimport angrimport sysdef basic_symbolic_execution():    p = angr.Project(&#39;fauxware&#39;)    state = p.factory.entry_state()    sm = p.factory.simulation_manager(state)    sm.run(until=lambda sm_: len(sm_.active) &gt; 1)    # posix表示可移植操作系统接口，angr中指符合posix环境的状态，数据存储和交互机制。    # dumps(fd)表示从标准输入、标准输出、标准错误中dumps信息    input_0 = sm.active[0].posix.dumps(0)    input_1 = sm.active[1].posix.dumps(0)    if b&#39;SOSNEAKY&#39; in input_0:        return input_0    else:        return input_1def test():    r = basic_symbolic_execution()    assert b&#39;SOSNEAKY&#39; in rif __name__ == &#39;__main__&#39;:    sys.stdout.buffer.write(basic_symbolic_execution())程序中标准输入流中获取数据，angr默认情况下是无符号的数据流，为了进行约束求解，并且获取到能满足这些约束的输入值，我们需要对实际的标准输入流获得一个引用。# 路径一标准输入In [90]: simgr.active[0].posix.dumps(0)Out[90]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;# 路径一标准输出In [91]: simgr.active[0].posix.dumps(1)Out[91]: b&#39;Username: \nPassword: \nWelcome to the admin console, trusted user!\n&#39;# 路径二标准输入In [92]: simgr.active[1].posix.dumps(0)Out[92]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80\x80\x80\x00\x00&#39;# 路径二标准输出In [93]: simgr.active[1].posix.dumps(1)Out[93]: b&#39;Username: \nPassword: \n&#39;通过使用angr找到它的后门，我们正在参与一个庞大的潮流，即对如何使用符号执行从二进制文件中提取意义有一个基本的了解。状态预设到目前位置，无论什么时候我们使用状态，我们都使用project.factory.entry_state()。这只是其中一个状态构造函数，其他函数如下。  .blank_state()构造状态使用一个空的状态，大部分其中的数据都是未初始化的。当访问数据时，未初始化的符号值会被返回。  .entry_state()状态构造器在主程序的入口点创建状态。  .full_init_state()状态构造器会去执行主程序入口点前，所有需要被初始化的部分，比如共享库和预初始化内容。当所有都完成后，它会跳转到入口点。  .call_state() 状态构造器准备执行一个给定函数。所有的这些构造器可以指定许多参数。TODO：  所有这些构造器可以使用地址参数来指定开始解析的地址。  If you’re executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through args and a dictionary of environment variables through env into entry_state and full_init_state. The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution. The default args is an empty list, so if the program you’re analyzing expects to find at least an argv[0], you should always provide that!  If you’d like to have argc be symbolic, you can pass a symbolic bitvector as argc to the entry_state and full_init_state constructors. Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into args.  To use the call state, you should call it with .call_state(addr, arg1, arg2, ...), where addr is the address of the function you want to call and argN is the Nth argument to that function, either as a python integer, string, or array, or a bitvector. If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. angr.PointerWrapper(&quot;point to me!&quot;). The results of this API can be a little unpredictable, but we’re working on it.  To specify the calling convention used for a function with call_state, you can pass a SimCC instance as the cc argument.内存的底层接口state.mem接口对从内存中加载特定类型的数据是很方便的，但是当我想要去进行原始加载和存储时，会非常麻烦。事实上，这种方式只是一种访问内存的逻辑方法，即在内存中填充位向量。我们可以使用.load(addr, size)和.store(addr, val)方法。# 存储In [11]: state.memory.store(0x10, state.solver.BVV(0x123456789abcdef0123456789abcdef, 128))# 加载In [21]: state.memory.load(0x10,16)Out[21]: &lt;BV128 0x123456789abcdef0123456789abcdef&gt;但是，我们可以发现，这种情况下是大端序，因为这个方式的主要目的是存储没有附加语义的数据段，所以是按照语义来进行的。如果需要使用小端序，加载的时候，需要指定加载的顺序方式。In [50]: state.memory.store(0, state.solver.BVV(0x123456789abcdef, 64))# 小端序In [51]: state.memory.load(0, 8, endness=archinfo.Endness.LE)Out[51]: &lt;BV64 0xefcdab8967452301&gt;# 寄存器存储In [58]: state.registers.store(state.regs.rip, state.solver.BVV(0x123456789ef, 64))# 寄存器加载In [59]: state.registers.load(state.regs.rip)Out[59]: &lt;BV64 0x123456789ef&gt;状态选项TODO状态插件所有存储在SimState中的内容，实际上都存储在附加到该状态的插件中。几乎所有我们讨论过的属性都是插件。memory, registers, mem, regs, solver等等，这种设计使得代码模块化，并且可以快速开发新功能。全局插件state.globals是最简单的差距，用于提供标准python字典接口。允许你存储任意数据。历史插件state.history 是一个很重要的差距，用于存储和历史有关的数据，即这个状态在执行过程中经历的路径中的数据。它实际上是一个链式的历史记录节点，每一个展示了一次执行轮次，你可以通过state.history.parent.parent遍历整个链表。为了使结构更加方便来工作，这个插件也提供了许多高效的生成器，来对特定的值进行迭代。history.recent_NAME 是程序最近访问的一个值，对应的所有值存在于history.NAME列表中。如果我们想要获取立即值，可以通过.hardcopy属性来获取列表中的所有值，默认情况下是生成器，需要手动生成。  history.descriptions 列表，描述每一轮执行的字符串信息。  history.bbl_addrs 基本块地址列表，每一轮可能不止一个，因为不是所有和二进制代码有关的基本块也会存在，比如一些被angr所hook的代码。  history.jumpkinds 状态历史中每个控制流转换的处理列表，如VEX枚举字符串  history.guards 保护状态遇到的每个分支的条件列表。（不能用？）  history.events 语义上一些有趣的事件列表，在程序执行过程中发生，比如存在符号跳转条件，程序弹出一个对话框，或者突然结束运行。  history.actions通常是空的，但是如果你添加 angr.options.refs选项到状态中，它会弹出程序执行过程中内存、寄存器或者终止代码的日志。调用栈插件angr将会跟踪模拟程序的栈调用。在每一次call指令后，一个栈帧会被添加到栈调用的最顶部，每当堆栈指针下降到调用最顶层帧，就会弹出一个帧，这允许angr健壮地存储当前模拟函数的本地数据。和history一样，调用栈插件也是节点链表，但是没有提供迭代器，可以直接访问，使用state.callstack.next 来获取每一个栈帧，如果只要最顶层的，使用 state.callstack。  callstack.func_addr 当前执行的函数地址。  callstack.call_site_addr 调用当前函数的基本块的地址。  callstack.stack_ptr 当前函数入口点栈指针的值。  callstack.ret_addr 当前函数的返回地址。更多关于IO复制和合并状态能快速进行复制，这样我们就能进行多种操作。通过state.copy()。状态也能进行快速合并# merge will return a tuple. the first element is the merged state# the second element is a symbolic variable describing a state flag# the third element is a boolean describing whether any merging was done&gt;&gt;&gt;  (s_merged, m, anything_merged)  = s1.merge(s2)# this is now an expression that can resolve to &quot;AAAA&quot; *or* &quot;BBBB&quot;&gt;&gt;&gt; aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="Angrlearning 4">
<meta property="og:url" content="https://zjgcjy.github.io/posts/2019-01/AngrLearning-4.html">


  <meta property="og:description" content="  学习笔记，结合官方文档和网上资料整理，加强理解从angr第二章第四节开始 程序状态程序状态——内存，寄存器和其他到目前为止，我们只学习了angr中的模拟程序状态。(SimState 对象)。用这种最原始的方式来理解angr中的很多基本的概念和操作。这里你将学习angr中静态对象的数据结构和如何更有效的进行交互。复习：读写内存和寄存器如果你依次阅读指南，你已经知道如何对内存和寄存器进行访问了。state.regs 提供了寄存器名作为属性来获取访问。state.mem提供了以下标的方式来获取具体的内存地址，并指定一个特殊的值类型。 另外，你应该知道如何和ASTs进行交互，这样你就能理解位向量类型可以被存储在寄存器和内存中。# 获取mem[rip]的值In [33]: state.mem[state.regs.rip].int64_tOut[33]: &lt;int64_t &lt;BV64 0x8949ed31fa1e0ff3&gt; at 0x402110&gt;# 解析mem[rip]的值In [34]: state.mem[state.regs.rip].int64_t.resolvedOut[34]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# 保存该值到rbpIn [35]: state.regs.rbp = state.mem[state.regs.rip].int64_t.resolvedOut[36]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# rax += mem[rip + 8]In [37]: state.regs.rax += state.mem[state.regs.rip + 8].int64_t.resolvedOut[38]: &lt;BV64 0xe48348e289485eed&gt;# 获取mem[rbp]的值In [39]: state.mem[state.regs.rbp].int64_tOut[39]: WARNING | 2019-02-18 13:56:38,626 | angr.state_plugins.symbolic_memory | Memory address 0x8949ed31fa1e0ff3 has an unspecified value; Generating an unconstrained value of 8 bytes.&lt;int64_t &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt; at 0x8949ed31fa1e0ff3&gt;In [40]: state.mem[state.regs.rbp].int64_t.resolvedOut[40]: &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt;基本的执行之前的时候，我们展示了如何使用模拟器来展示一些基本的执行操作，我们将在下一节展示模拟管理器的全部功能，但是现在我们可以使用一些比较简单的接口来展示如何进行符号执行，通过使用state.step()，这个方法将会执行一步符号执行操作并且返沪i一个对象，叫做SimSuccessors。不同于正常的模拟，符号执行可以产生很多种不同的后继状态，这些状态将被分类成几种。现在我们关心的是.successors属性，这是一个列表，包含了所有基于给定状态的所有后续状态。为什么是列表，而不是一个单独的后继状态呢。这是因为在angr中，angr进行符号执行的流程仅仅是将一个个单独的指令编译到程序中，执行他们来改变一个模拟状态。当遇到像条件判断语句，如果变量是符号值会怎么样呢。在angr的某处深度下，该条件会被执行，这样的话，结果就包含该约束条件。这是正确的，但是下一个问题是，我们到底在判断语句处如何选择流程。答案是，我们两边都选择，我们生成了2条完整的分离的后继状态，一个模拟条件正确的路线，一个模拟相反的条件的路线，这样的话，无论我们之后使用约束求解器来求解哪一个状态，状态所拥有的条件都将确保我们得到有效的输入，这些条件将导致状态执行和给定状态相同的路径。为了展示这个，我们使用一个例子，如果你看源代码，会发现认证机制是有后门的，任何用户名可以通过sosneaky来认证成管理员。#!/usr/bin/env pythonimport angrimport sysdef basic_symbolic_execution():    p = angr.Project(&#39;fauxware&#39;)    state = p.factory.entry_state()    sm = p.factory.simulation_manager(state)    sm.run(until=lambda sm_: len(sm_.active) &gt; 1)    # posix表示可移植操作系统接口，angr中指符合posix环境的状态，数据存储和交互机制。    # dumps(fd)表示从标准输入、标准输出、标准错误中dumps信息    input_0 = sm.active[0].posix.dumps(0)    input_1 = sm.active[1].posix.dumps(0)    if b&#39;SOSNEAKY&#39; in input_0:        return input_0    else:        return input_1def test():    r = basic_symbolic_execution()    assert b&#39;SOSNEAKY&#39; in rif __name__ == &#39;__main__&#39;:    sys.stdout.buffer.write(basic_symbolic_execution())程序中标准输入流中获取数据，angr默认情况下是无符号的数据流，为了进行约束求解，并且获取到能满足这些约束的输入值，我们需要对实际的标准输入流获得一个引用。# 路径一标准输入In [90]: simgr.active[0].posix.dumps(0)Out[90]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;# 路径一标准输出In [91]: simgr.active[0].posix.dumps(1)Out[91]: b&#39;Username: \nPassword: \nWelcome to the admin console, trusted user!\n&#39;# 路径二标准输入In [92]: simgr.active[1].posix.dumps(0)Out[92]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80\x80\x80\x00\x00&#39;# 路径二标准输出In [93]: simgr.active[1].posix.dumps(1)Out[93]: b&#39;Username: \nPassword: \n&#39;通过使用angr找到它的后门，我们正在参与一个庞大的潮流，即对如何使用符号执行从二进制文件中提取意义有一个基本的了解。状态预设到目前位置，无论什么时候我们使用状态，我们都使用project.factory.entry_state()。这只是其中一个状态构造函数，其他函数如下。  .blank_state()构造状态使用一个空的状态，大部分其中的数据都是未初始化的。当访问数据时，未初始化的符号值会被返回。  .entry_state()状态构造器在主程序的入口点创建状态。  .full_init_state()状态构造器会去执行主程序入口点前，所有需要被初始化的部分，比如共享库和预初始化内容。当所有都完成后，它会跳转到入口点。  .call_state() 状态构造器准备执行一个给定函数。所有的这些构造器可以指定许多参数。TODO：  所有这些构造器可以使用地址参数来指定开始解析的地址。  If you’re executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through args and a dictionary of environment variables through env into entry_state and full_init_state. The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution. The default args is an empty list, so if the program you’re analyzing expects to find at least an argv[0], you should always provide that!  If you’d like to have argc be symbolic, you can pass a symbolic bitvector as argc to the entry_state and full_init_state constructors. Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into args.  To use the call state, you should call it with .call_state(addr, arg1, arg2, ...), where addr is the address of the function you want to call and argN is the Nth argument to that function, either as a python integer, string, or array, or a bitvector. If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. angr.PointerWrapper(&quot;point to me!&quot;). The results of this API can be a little unpredictable, but we’re working on it.  To specify the calling convention used for a function with call_state, you can pass a SimCC instance as the cc argument.内存的底层接口state.mem接口对从内存中加载特定类型的数据是很方便的，但是当我想要去进行原始加载和存储时，会非常麻烦。事实上，这种方式只是一种访问内存的逻辑方法，即在内存中填充位向量。我们可以使用.load(addr, size)和.store(addr, val)方法。# 存储In [11]: state.memory.store(0x10, state.solver.BVV(0x123456789abcdef0123456789abcdef, 128))# 加载In [21]: state.memory.load(0x10,16)Out[21]: &lt;BV128 0x123456789abcdef0123456789abcdef&gt;但是，我们可以发现，这种情况下是大端序，因为这个方式的主要目的是存储没有附加语义的数据段，所以是按照语义来进行的。如果需要使用小端序，加载的时候，需要指定加载的顺序方式。In [50]: state.memory.store(0, state.solver.BVV(0x123456789abcdef, 64))# 小端序In [51]: state.memory.load(0, 8, endness=archinfo.Endness.LE)Out[51]: &lt;BV64 0xefcdab8967452301&gt;# 寄存器存储In [58]: state.registers.store(state.regs.rip, state.solver.BVV(0x123456789ef, 64))# 寄存器加载In [59]: state.registers.load(state.regs.rip)Out[59]: &lt;BV64 0x123456789ef&gt;状态选项TODO状态插件所有存储在SimState中的内容，实际上都存储在附加到该状态的插件中。几乎所有我们讨论过的属性都是插件。memory, registers, mem, regs, solver等等，这种设计使得代码模块化，并且可以快速开发新功能。全局插件state.globals是最简单的差距，用于提供标准python字典接口。允许你存储任意数据。历史插件state.history 是一个很重要的差距，用于存储和历史有关的数据，即这个状态在执行过程中经历的路径中的数据。它实际上是一个链式的历史记录节点，每一个展示了一次执行轮次，你可以通过state.history.parent.parent遍历整个链表。为了使结构更加方便来工作，这个插件也提供了许多高效的生成器，来对特定的值进行迭代。history.recent_NAME 是程序最近访问的一个值，对应的所有值存在于history.NAME列表中。如果我们想要获取立即值，可以通过.hardcopy属性来获取列表中的所有值，默认情况下是生成器，需要手动生成。  history.descriptions 列表，描述每一轮执行的字符串信息。  history.bbl_addrs 基本块地址列表，每一轮可能不止一个，因为不是所有和二进制代码有关的基本块也会存在，比如一些被angr所hook的代码。  history.jumpkinds 状态历史中每个控制流转换的处理列表，如VEX枚举字符串  history.guards 保护状态遇到的每个分支的条件列表。（不能用？）  history.events 语义上一些有趣的事件列表，在程序执行过程中发生，比如存在符号跳转条件，程序弹出一个对话框，或者突然结束运行。  history.actions通常是空的，但是如果你添加 angr.options.refs选项到状态中，它会弹出程序执行过程中内存、寄存器或者终止代码的日志。调用栈插件angr将会跟踪模拟程序的栈调用。在每一次call指令后，一个栈帧会被添加到栈调用的最顶部，每当堆栈指针下降到调用最顶层帧，就会弹出一个帧，这允许angr健壮地存储当前模拟函数的本地数据。和history一样，调用栈插件也是节点链表，但是没有提供迭代器，可以直接访问，使用state.callstack.next 来获取每一个栈帧，如果只要最顶层的，使用 state.callstack。  callstack.func_addr 当前执行的函数地址。  callstack.call_site_addr 调用当前函数的基本块的地址。  callstack.stack_ptr 当前函数入口点栈指针的值。  callstack.ret_addr 当前函数的返回地址。更多关于IO复制和合并状态能快速进行复制，这样我们就能进行多种操作。通过state.copy()。状态也能进行快速合并# merge will return a tuple. the first element is the merged state# the second element is a symbolic variable describing a state flag# the third element is a boolean describing whether any merging was done&gt;&gt;&gt;  (s_merged, m, anything_merged)  = s1.merge(s2)# this is now an expression that can resolve to &quot;AAAA&quot; *or* &quot;BBBB&quot;&gt;&gt;&gt; aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t">



  <meta property="og:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="Angrlearning 4">
  <meta name="twitter:description" content="  学习笔记，结合官方文档和网上资料整理，加强理解从angr第二章第四节开始 程序状态程序状态——内存，寄存器和其他到目前为止，我们只学习了angr中的模拟程序状态。(SimState 对象)。用这种最原始的方式来理解angr中的很多基本的概念和操作。这里你将学习angr中静态对象的数据结构和如何更有效的进行交互。复习：读写内存和寄存器如果你依次阅读指南，你已经知道如何对内存和寄存器进行访问了。state.regs 提供了寄存器名作为属性来获取访问。state.mem提供了以下标的方式来获取具体的内存地址，并指定一个特殊的值类型。 另外，你应该知道如何和ASTs进行交互，这样你就能理解位向量类型可以被存储在寄存器和内存中。# 获取mem[rip]的值In [33]: state.mem[state.regs.rip].int64_tOut[33]: &lt;int64_t &lt;BV64 0x8949ed31fa1e0ff3&gt; at 0x402110&gt;# 解析mem[rip]的值In [34]: state.mem[state.regs.rip].int64_t.resolvedOut[34]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# 保存该值到rbpIn [35]: state.regs.rbp = state.mem[state.regs.rip].int64_t.resolvedOut[36]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# rax += mem[rip + 8]In [37]: state.regs.rax += state.mem[state.regs.rip + 8].int64_t.resolvedOut[38]: &lt;BV64 0xe48348e289485eed&gt;# 获取mem[rbp]的值In [39]: state.mem[state.regs.rbp].int64_tOut[39]: WARNING | 2019-02-18 13:56:38,626 | angr.state_plugins.symbolic_memory | Memory address 0x8949ed31fa1e0ff3 has an unspecified value; Generating an unconstrained value of 8 bytes.&lt;int64_t &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt; at 0x8949ed31fa1e0ff3&gt;In [40]: state.mem[state.regs.rbp].int64_t.resolvedOut[40]: &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt;基本的执行之前的时候，我们展示了如何使用模拟器来展示一些基本的执行操作，我们将在下一节展示模拟管理器的全部功能，但是现在我们可以使用一些比较简单的接口来展示如何进行符号执行，通过使用state.step()，这个方法将会执行一步符号执行操作并且返沪i一个对象，叫做SimSuccessors。不同于正常的模拟，符号执行可以产生很多种不同的后继状态，这些状态将被分类成几种。现在我们关心的是.successors属性，这是一个列表，包含了所有基于给定状态的所有后续状态。为什么是列表，而不是一个单独的后继状态呢。这是因为在angr中，angr进行符号执行的流程仅仅是将一个个单独的指令编译到程序中，执行他们来改变一个模拟状态。当遇到像条件判断语句，如果变量是符号值会怎么样呢。在angr的某处深度下，该条件会被执行，这样的话，结果就包含该约束条件。这是正确的，但是下一个问题是，我们到底在判断语句处如何选择流程。答案是，我们两边都选择，我们生成了2条完整的分离的后继状态，一个模拟条件正确的路线，一个模拟相反的条件的路线，这样的话，无论我们之后使用约束求解器来求解哪一个状态，状态所拥有的条件都将确保我们得到有效的输入，这些条件将导致状态执行和给定状态相同的路径。为了展示这个，我们使用一个例子，如果你看源代码，会发现认证机制是有后门的，任何用户名可以通过sosneaky来认证成管理员。#!/usr/bin/env pythonimport angrimport sysdef basic_symbolic_execution():    p = angr.Project(&#39;fauxware&#39;)    state = p.factory.entry_state()    sm = p.factory.simulation_manager(state)    sm.run(until=lambda sm_: len(sm_.active) &gt; 1)    # posix表示可移植操作系统接口，angr中指符合posix环境的状态，数据存储和交互机制。    # dumps(fd)表示从标准输入、标准输出、标准错误中dumps信息    input_0 = sm.active[0].posix.dumps(0)    input_1 = sm.active[1].posix.dumps(0)    if b&#39;SOSNEAKY&#39; in input_0:        return input_0    else:        return input_1def test():    r = basic_symbolic_execution()    assert b&#39;SOSNEAKY&#39; in rif __name__ == &#39;__main__&#39;:    sys.stdout.buffer.write(basic_symbolic_execution())程序中标准输入流中获取数据，angr默认情况下是无符号的数据流，为了进行约束求解，并且获取到能满足这些约束的输入值，我们需要对实际的标准输入流获得一个引用。# 路径一标准输入In [90]: simgr.active[0].posix.dumps(0)Out[90]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;# 路径一标准输出In [91]: simgr.active[0].posix.dumps(1)Out[91]: b&#39;Username: \nPassword: \nWelcome to the admin console, trusted user!\n&#39;# 路径二标准输入In [92]: simgr.active[1].posix.dumps(0)Out[92]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80\x80\x80\x00\x00&#39;# 路径二标准输出In [93]: simgr.active[1].posix.dumps(1)Out[93]: b&#39;Username: \nPassword: \n&#39;通过使用angr找到它的后门，我们正在参与一个庞大的潮流，即对如何使用符号执行从二进制文件中提取意义有一个基本的了解。状态预设到目前位置，无论什么时候我们使用状态，我们都使用project.factory.entry_state()。这只是其中一个状态构造函数，其他函数如下。  .blank_state()构造状态使用一个空的状态，大部分其中的数据都是未初始化的。当访问数据时，未初始化的符号值会被返回。  .entry_state()状态构造器在主程序的入口点创建状态。  .full_init_state()状态构造器会去执行主程序入口点前，所有需要被初始化的部分，比如共享库和预初始化内容。当所有都完成后，它会跳转到入口点。  .call_state() 状态构造器准备执行一个给定函数。所有的这些构造器可以指定许多参数。TODO：  所有这些构造器可以使用地址参数来指定开始解析的地址。  If you’re executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through args and a dictionary of environment variables through env into entry_state and full_init_state. The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution. The default args is an empty list, so if the program you’re analyzing expects to find at least an argv[0], you should always provide that!  If you’d like to have argc be symbolic, you can pass a symbolic bitvector as argc to the entry_state and full_init_state constructors. Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into args.  To use the call state, you should call it with .call_state(addr, arg1, arg2, ...), where addr is the address of the function you want to call and argN is the Nth argument to that function, either as a python integer, string, or array, or a bitvector. If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. angr.PointerWrapper(&quot;point to me!&quot;). The results of this API can be a little unpredictable, but we’re working on it.  To specify the calling convention used for a function with call_state, you can pass a SimCC instance as the cc argument.内存的底层接口state.mem接口对从内存中加载特定类型的数据是很方便的，但是当我想要去进行原始加载和存储时，会非常麻烦。事实上，这种方式只是一种访问内存的逻辑方法，即在内存中填充位向量。我们可以使用.load(addr, size)和.store(addr, val)方法。# 存储In [11]: state.memory.store(0x10, state.solver.BVV(0x123456789abcdef0123456789abcdef, 128))# 加载In [21]: state.memory.load(0x10,16)Out[21]: &lt;BV128 0x123456789abcdef0123456789abcdef&gt;但是，我们可以发现，这种情况下是大端序，因为这个方式的主要目的是存储没有附加语义的数据段，所以是按照语义来进行的。如果需要使用小端序，加载的时候，需要指定加载的顺序方式。In [50]: state.memory.store(0, state.solver.BVV(0x123456789abcdef, 64))# 小端序In [51]: state.memory.load(0, 8, endness=archinfo.Endness.LE)Out[51]: &lt;BV64 0xefcdab8967452301&gt;# 寄存器存储In [58]: state.registers.store(state.regs.rip, state.solver.BVV(0x123456789ef, 64))# 寄存器加载In [59]: state.registers.load(state.regs.rip)Out[59]: &lt;BV64 0x123456789ef&gt;状态选项TODO状态插件所有存储在SimState中的内容，实际上都存储在附加到该状态的插件中。几乎所有我们讨论过的属性都是插件。memory, registers, mem, regs, solver等等，这种设计使得代码模块化，并且可以快速开发新功能。全局插件state.globals是最简单的差距，用于提供标准python字典接口。允许你存储任意数据。历史插件state.history 是一个很重要的差距，用于存储和历史有关的数据，即这个状态在执行过程中经历的路径中的数据。它实际上是一个链式的历史记录节点，每一个展示了一次执行轮次，你可以通过state.history.parent.parent遍历整个链表。为了使结构更加方便来工作，这个插件也提供了许多高效的生成器，来对特定的值进行迭代。history.recent_NAME 是程序最近访问的一个值，对应的所有值存在于history.NAME列表中。如果我们想要获取立即值，可以通过.hardcopy属性来获取列表中的所有值，默认情况下是生成器，需要手动生成。  history.descriptions 列表，描述每一轮执行的字符串信息。  history.bbl_addrs 基本块地址列表，每一轮可能不止一个，因为不是所有和二进制代码有关的基本块也会存在，比如一些被angr所hook的代码。  history.jumpkinds 状态历史中每个控制流转换的处理列表，如VEX枚举字符串  history.guards 保护状态遇到的每个分支的条件列表。（不能用？）  history.events 语义上一些有趣的事件列表，在程序执行过程中发生，比如存在符号跳转条件，程序弹出一个对话框，或者突然结束运行。  history.actions通常是空的，但是如果你添加 angr.options.refs选项到状态中，它会弹出程序执行过程中内存、寄存器或者终止代码的日志。调用栈插件angr将会跟踪模拟程序的栈调用。在每一次call指令后，一个栈帧会被添加到栈调用的最顶部，每当堆栈指针下降到调用最顶层帧，就会弹出一个帧，这允许angr健壮地存储当前模拟函数的本地数据。和history一样，调用栈插件也是节点链表，但是没有提供迭代器，可以直接访问，使用state.callstack.next 来获取每一个栈帧，如果只要最顶层的，使用 state.callstack。  callstack.func_addr 当前执行的函数地址。  callstack.call_site_addr 调用当前函数的基本块的地址。  callstack.stack_ptr 当前函数入口点栈指针的值。  callstack.ret_addr 当前函数的返回地址。更多关于IO复制和合并状态能快速进行复制，这样我们就能进行多种操作。通过state.copy()。状态也能进行快速合并# merge will return a tuple. the first element is the merged state# the second element is a symbolic variable describing a state flag# the third element is a boolean describing whether any merging was done&gt;&gt;&gt;  (s_merged, m, anything_merged)  = s1.merge(s2)# this is now an expression that can resolve to &quot;AAAA&quot; *or* &quot;BBBB&quot;&gt;&gt;&gt; aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t">
  <meta name="twitter:url" content="https://zjgcjy.github.io/posts/2019-01/AngrLearning-4.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2019-01-20T21:25:00+08:00">





  

  


<link rel="canonical" href="https://zjgcjy.github.io/posts/2019-01/AngrLearning-4.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "https://zjgcjy.github.io/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/apple-touch-icon.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about.html" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fa fa-map-marker" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fa fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fa fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Angrlearning 4">
    <meta itemprop="description" content="  学习笔记，结合官方文档和网上资料整理，加强理解从angr第二章第四节开始 程序状态程序状态——内存，寄存器和其他到目前为止，我们只学习了angr中的模拟程序状态。(SimState 对象)。用这种最原始的方式来理解angr中的很多基本的概念和操作。这里你将学习angr中静态对象的数据结构和如何更有效的进行交互。复习：读写内存和寄存器如果你依次阅读指南，你已经知道如何对内存和寄存器进行访问了。state.regs 提供了寄存器名作为属性来获取访问。state.mem提供了以下标的方式来获取具体的内存地址，并指定一个特殊的值类型。 另外，你应该知道如何和ASTs进行交互，这样你就能理解位向量类型可以被存储在寄存器和内存中。# 获取mem[rip]的值In [33]: state.mem[state.regs.rip].int64_tOut[33]: &lt;int64_t &lt;BV64 0x8949ed31fa1e0ff3&gt; at 0x402110&gt;# 解析mem[rip]的值In [34]: state.mem[state.regs.rip].int64_t.resolvedOut[34]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# 保存该值到rbpIn [35]: state.regs.rbp = state.mem[state.regs.rip].int64_t.resolvedOut[36]: &lt;BV64 0x8949ed31fa1e0ff3&gt;# rax += mem[rip + 8]In [37]: state.regs.rax += state.mem[state.regs.rip + 8].int64_t.resolvedOut[38]: &lt;BV64 0xe48348e289485eed&gt;# 获取mem[rbp]的值In [39]: state.mem[state.regs.rbp].int64_tOut[39]: WARNING | 2019-02-18 13:56:38,626 | angr.state_plugins.symbolic_memory | Memory address 0x8949ed31fa1e0ff3 has an unspecified value; Generating an unconstrained value of 8 bytes.&lt;int64_t &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt; at 0x8949ed31fa1e0ff3&gt;In [40]: state.mem[state.regs.rbp].int64_t.resolvedOut[40]: &lt;BV64 mem_8949ed31fa1e0ff3_453_64{UNINITIALIZED}&gt;基本的执行之前的时候，我们展示了如何使用模拟器来展示一些基本的执行操作，我们将在下一节展示模拟管理器的全部功能，但是现在我们可以使用一些比较简单的接口来展示如何进行符号执行，通过使用state.step()，这个方法将会执行一步符号执行操作并且返沪i一个对象，叫做SimSuccessors。不同于正常的模拟，符号执行可以产生很多种不同的后继状态，这些状态将被分类成几种。现在我们关心的是.successors属性，这是一个列表，包含了所有基于给定状态的所有后续状态。为什么是列表，而不是一个单独的后继状态呢。这是因为在angr中，angr进行符号执行的流程仅仅是将一个个单独的指令编译到程序中，执行他们来改变一个模拟状态。当遇到像条件判断语句，如果变量是符号值会怎么样呢。在angr的某处深度下，该条件会被执行，这样的话，结果就包含该约束条件。这是正确的，但是下一个问题是，我们到底在判断语句处如何选择流程。答案是，我们两边都选择，我们生成了2条完整的分离的后继状态，一个模拟条件正确的路线，一个模拟相反的条件的路线，这样的话，无论我们之后使用约束求解器来求解哪一个状态，状态所拥有的条件都将确保我们得到有效的输入，这些条件将导致状态执行和给定状态相同的路径。为了展示这个，我们使用一个例子，如果你看源代码，会发现认证机制是有后门的，任何用户名可以通过sosneaky来认证成管理员。#!/usr/bin/env pythonimport angrimport sysdef basic_symbolic_execution():    p = angr.Project(&#39;fauxware&#39;)    state = p.factory.entry_state()    sm = p.factory.simulation_manager(state)    sm.run(until=lambda sm_: len(sm_.active) &gt; 1)    # posix表示可移植操作系统接口，angr中指符合posix环境的状态，数据存储和交互机制。    # dumps(fd)表示从标准输入、标准输出、标准错误中dumps信息    input_0 = sm.active[0].posix.dumps(0)    input_1 = sm.active[1].posix.dumps(0)    if b&#39;SOSNEAKY&#39; in input_0:        return input_0    else:        return input_1def test():    r = basic_symbolic_execution()    assert b&#39;SOSNEAKY&#39; in rif __name__ == &#39;__main__&#39;:    sys.stdout.buffer.write(basic_symbolic_execution())程序中标准输入流中获取数据，angr默认情况下是无符号的数据流，为了进行约束求解，并且获取到能满足这些约束的输入值，我们需要对实际的标准输入流获得一个引用。# 路径一标准输入In [90]: simgr.active[0].posix.dumps(0)Out[90]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;# 路径一标准输出In [91]: simgr.active[0].posix.dumps(1)Out[91]: b&#39;Username: \nPassword: \nWelcome to the admin console, trusted user!\n&#39;# 路径二标准输入In [92]: simgr.active[1].posix.dumps(0)Out[92]: b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80\x80\x80\x00\x00&#39;# 路径二标准输出In [93]: simgr.active[1].posix.dumps(1)Out[93]: b&#39;Username: \nPassword: \n&#39;通过使用angr找到它的后门，我们正在参与一个庞大的潮流，即对如何使用符号执行从二进制文件中提取意义有一个基本的了解。状态预设到目前位置，无论什么时候我们使用状态，我们都使用project.factory.entry_state()。这只是其中一个状态构造函数，其他函数如下。  .blank_state()构造状态使用一个空的状态，大部分其中的数据都是未初始化的。当访问数据时，未初始化的符号值会被返回。  .entry_state()状态构造器在主程序的入口点创建状态。  .full_init_state()状态构造器会去执行主程序入口点前，所有需要被初始化的部分，比如共享库和预初始化内容。当所有都完成后，它会跳转到入口点。  .call_state() 状态构造器准备执行一个给定函数。所有的这些构造器可以指定许多参数。TODO：  所有这些构造器可以使用地址参数来指定开始解析的地址。  If you’re executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through args and a dictionary of environment variables through env into entry_state and full_init_state. The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution. The default args is an empty list, so if the program you’re analyzing expects to find at least an argv[0], you should always provide that!  If you’d like to have argc be symbolic, you can pass a symbolic bitvector as argc to the entry_state and full_init_state constructors. Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into args.  To use the call state, you should call it with .call_state(addr, arg1, arg2, ...), where addr is the address of the function you want to call and argN is the Nth argument to that function, either as a python integer, string, or array, or a bitvector. If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. angr.PointerWrapper(&quot;point to me!&quot;). The results of this API can be a little unpredictable, but we’re working on it.  To specify the calling convention used for a function with call_state, you can pass a SimCC instance as the cc argument.内存的底层接口state.mem接口对从内存中加载特定类型的数据是很方便的，但是当我想要去进行原始加载和存储时，会非常麻烦。事实上，这种方式只是一种访问内存的逻辑方法，即在内存中填充位向量。我们可以使用.load(addr, size)和.store(addr, val)方法。# 存储In [11]: state.memory.store(0x10, state.solver.BVV(0x123456789abcdef0123456789abcdef, 128))# 加载In [21]: state.memory.load(0x10,16)Out[21]: &lt;BV128 0x123456789abcdef0123456789abcdef&gt;但是，我们可以发现，这种情况下是大端序，因为这个方式的主要目的是存储没有附加语义的数据段，所以是按照语义来进行的。如果需要使用小端序，加载的时候，需要指定加载的顺序方式。In [50]: state.memory.store(0, state.solver.BVV(0x123456789abcdef, 64))# 小端序In [51]: state.memory.load(0, 8, endness=archinfo.Endness.LE)Out[51]: &lt;BV64 0xefcdab8967452301&gt;# 寄存器存储In [58]: state.registers.store(state.regs.rip, state.solver.BVV(0x123456789ef, 64))# 寄存器加载In [59]: state.registers.load(state.regs.rip)Out[59]: &lt;BV64 0x123456789ef&gt;状态选项TODO状态插件所有存储在SimState中的内容，实际上都存储在附加到该状态的插件中。几乎所有我们讨论过的属性都是插件。memory, registers, mem, regs, solver等等，这种设计使得代码模块化，并且可以快速开发新功能。全局插件state.globals是最简单的差距，用于提供标准python字典接口。允许你存储任意数据。历史插件state.history 是一个很重要的差距，用于存储和历史有关的数据，即这个状态在执行过程中经历的路径中的数据。它实际上是一个链式的历史记录节点，每一个展示了一次执行轮次，你可以通过state.history.parent.parent遍历整个链表。为了使结构更加方便来工作，这个插件也提供了许多高效的生成器，来对特定的值进行迭代。history.recent_NAME 是程序最近访问的一个值，对应的所有值存在于history.NAME列表中。如果我们想要获取立即值，可以通过.hardcopy属性来获取列表中的所有值，默认情况下是生成器，需要手动生成。  history.descriptions 列表，描述每一轮执行的字符串信息。  history.bbl_addrs 基本块地址列表，每一轮可能不止一个，因为不是所有和二进制代码有关的基本块也会存在，比如一些被angr所hook的代码。  history.jumpkinds 状态历史中每个控制流转换的处理列表，如VEX枚举字符串  history.guards 保护状态遇到的每个分支的条件列表。（不能用？）  history.events 语义上一些有趣的事件列表，在程序执行过程中发生，比如存在符号跳转条件，程序弹出一个对话框，或者突然结束运行。  history.actions通常是空的，但是如果你添加 angr.options.refs选项到状态中，它会弹出程序执行过程中内存、寄存器或者终止代码的日志。调用栈插件angr将会跟踪模拟程序的栈调用。在每一次call指令后，一个栈帧会被添加到栈调用的最顶部，每当堆栈指针下降到调用最顶层帧，就会弹出一个帧，这允许angr健壮地存储当前模拟函数的本地数据。和history一样，调用栈插件也是节点链表，但是没有提供迭代器，可以直接访问，使用state.callstack.next 来获取每一个栈帧，如果只要最顶层的，使用 state.callstack。  callstack.func_addr 当前执行的函数地址。  callstack.call_site_addr 调用当前函数的基本块的地址。  callstack.stack_ptr 当前函数入口点栈指针的值。  callstack.ret_addr 当前函数的返回地址。更多关于IO复制和合并状态能快速进行复制，这样我们就能进行多种操作。通过state.copy()。状态也能进行快速合并# merge will return a tuple. the first element is the merged state# the second element is a symbolic variable describing a state flag# the third element is a boolean describing whether any merging was done&gt;&gt;&gt;  (s_merged, m, anything_merged)  = s1.merge(s2)# this is now an expression that can resolve to &quot;AAAA&quot; *or* &quot;BBBB&quot;&gt;&gt;&gt; aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t">
    <meta itemprop="datePublished" content="January 20, 2019">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Angrlearning 4
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#程序状态内存寄存器和其他">程序状态——内存，寄存器和其他</a></li>
  <li><a href="#复习读写内存和寄存器">复习：读写内存和寄存器</a></li>
  <li><a href="#基本的执行">基本的执行</a></li>
  <li><a href="#状态预设">状态预设</a></li>
  <li><a href="#内存的底层接口">内存的底层接口</a></li>
  <li><a href="#状态选项">状态选项</a></li>
  <li><a href="#状态插件">状态插件</a>
    <ul>
      <li><a href="#全局插件">全局插件</a></li>
      <li><a href="#历史插件">历史插件</a></li>
      <li><a href="#调用栈插件">调用栈插件</a></li>
    </ul>
  </li>
  <li><a href="#更多关于io">更多关于IO</a>
    <ul>
      <li><a href="#复制和合并">复制和合并</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <blockquote>
  <p>学习笔记，结合官方文档和网上资料整理，加强理解
从angr第二章第四节开始 程序状态</p>
</blockquote>

<hr />

<h1 id="程序状态内存寄存器和其他">程序状态——内存，寄存器和其他</h1>

<p>到目前为止，我们只学习了angr中的模拟程序状态。(<code class="highlighter-rouge">SimState</code> 对象)。用这种最原始的方式来理解angr中的很多基本的概念和操作。这里你将学习angr中静态对象的数据结构和如何更有效的进行交互。</p>

<h1 id="复习读写内存和寄存器">复习：读写内存和寄存器</h1>

<p>如果你依次阅读指南，你已经知道如何对内存和寄存器进行访问了。<code class="highlighter-rouge">state.regs</code> 提供了寄存器名作为属性来获取访问。<code class="highlighter-rouge">state.mem</code>提供了以下标的方式来获取具体的内存地址，并指定一个特殊的值类型。
 另外，你应该知道如何和ASTs进行交互，这样你就能理解位向量类型可以被存储在寄存器和内存中。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 获取mem[rip]的值
</span><span class="n">In</span> <span class="p">[</span><span class="mi">33</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rip</span><span class="p">]</span><span class="o">.</span><span class="n">int64_t</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">33</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">int64_t</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0x8949ed31fa1e0ff3</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x402110</span><span class="o">&gt;</span>

<span class="c1"># 解析mem[rip]的值
</span><span class="n">In</span> <span class="p">[</span><span class="mi">34</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rip</span><span class="p">]</span><span class="o">.</span><span class="n">int64_t</span><span class="o">.</span><span class="n">resolved</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">34</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0x8949ed31fa1e0ff3</span><span class="o">&gt;</span>

<span class="c1"># 保存该值到rbp
</span><span class="n">In</span> <span class="p">[</span><span class="mi">35</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rip</span><span class="p">]</span><span class="o">.</span><span class="n">int64_t</span><span class="o">.</span><span class="n">resolved</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">36</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0x8949ed31fa1e0ff3</span><span class="o">&gt;</span>

<span class="c1"># rax += mem[rip + 8]
</span><span class="n">In</span> <span class="p">[</span><span class="mi">37</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rax</span> <span class="o">+=</span> <span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rip</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">int64_t</span><span class="o">.</span><span class="n">resolved</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">38</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0xe48348e289485eed</span><span class="o">&gt;</span>

<span class="c1"># 获取mem[rbp]的值
</span><span class="n">In</span> <span class="p">[</span><span class="mi">39</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rbp</span><span class="p">]</span><span class="o">.</span><span class="n">int64_t</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">39</span><span class="p">]:</span> <span class="n">WARNING</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">18</span> <span class="mi">13</span><span class="p">:</span><span class="mi">56</span><span class="p">:</span><span class="mi">38</span><span class="p">,</span><span class="mi">626</span> <span class="o">|</span> <span class="n">angr</span><span class="o">.</span><span class="n">state_plugins</span><span class="o">.</span><span class="n">symbolic_memory</span> <span class="o">|</span> <span class="n">Memory</span> <span class="n">address</span> <span class="mh">0x8949ed31fa1e0ff3</span> <span class="n">has</span> <span class="n">an</span> <span class="n">unspecified</span> <span class="n">value</span><span class="p">;</span> <span class="n">Generating</span> <span class="n">an</span> <span class="n">unconstrained</span> <span class="n">value</span> <span class="n">of</span> <span class="mi">8</span> <span class="nb">bytes</span><span class="o">.</span>
<span class="o">&lt;</span><span class="n">int64_t</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="n">mem_8949ed31fa1e0ff3_453_64</span><span class="p">{</span><span class="n">UNINITIALIZED</span><span class="p">}</span><span class="o">&gt;</span> <span class="n">at</span> <span class="mh">0x8949ed31fa1e0ff3</span><span class="o">&gt;</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">40</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rbp</span><span class="p">]</span><span class="o">.</span><span class="n">int64_t</span><span class="o">.</span><span class="n">resolved</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">40</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="n">mem_8949ed31fa1e0ff3_453_64</span><span class="p">{</span><span class="n">UNINITIALIZED</span><span class="p">}</span><span class="o">&gt;</span>
</code></pre></div></div>

<h1 id="基本的执行">基本的执行</h1>

<p>之前的时候，我们展示了如何使用模拟器来展示一些基本的执行操作，我们将在下一节展示模拟管理器的全部功能，但是现在我们可以使用一些比较简单的接口来展示如何进行符号执行，通过使用<code class="highlighter-rouge">state.step()</code>，这个方法将会执行一步符号执行操作并且返沪i一个对象，叫做<code class="highlighter-rouge">SimSuccessors</code>。不同于正常的模拟，符号执行可以产生很多种不同的后继状态，这些状态将被分类成几种。现在我们关心的是<code class="highlighter-rouge">.successors</code>属性，这是一个列表，包含了所有基于给定状态的所有后续状态。
为什么是列表，而不是一个单独的后继状态呢。这是因为在angr中，angr进行符号执行的流程仅仅是将一个个单独的指令编译到程序中，执行他们来改变一个模拟状态。当遇到像条件判断语句，如果变量是符号值会怎么样呢。在angr的某处深度下，该条件会被执行，这样的话，结果就包含该约束条件。
这是正确的，但是下一个问题是，我们到底在判断语句处如何选择流程。答案是，我们两边都选择，我们生成了2条完整的分离的后继状态，一个模拟条件正确的路线，一个模拟相反的条件的路线，这样的话，无论我们之后使用约束求解器来求解哪一个状态，状态所拥有的条件都将确保我们得到有效的输入，这些条件将导致状态执行和给定状态相同的路径。
为了展示这个，我们使用一个例子，如果你看源代码，会发现认证机制是有后门的，任何用户名可以通过sosneaky来认证成管理员。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">import</span> <span class="nn">angr</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">basic_symbolic_execution</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">angr</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="s">'fauxware'</span><span class="p">)</span>

    <span class="n">state</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">entry_state</span><span class="p">()</span>

    <span class="n">sm</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">simulation_manager</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="n">sm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="k">lambda</span> <span class="n">sm_</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">sm_</span><span class="o">.</span><span class="n">active</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># posix表示可移植操作系统接口，angr中指符合posix环境的状态，数据存储和交互机制。
</span>    <span class="c1"># dumps(fd)表示从标准输入、标准输出、标准错误中dumps信息
</span>    <span class="n">input_0</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">posix</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">input_1</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">posix</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">b</span><span class="s">'SOSNEAKY'</span> <span class="ow">in</span> <span class="n">input_0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_1</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">basic_symbolic_execution</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">b</span><span class="s">'SOSNEAKY'</span> <span class="ow">in</span> <span class="n">r</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="nb">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">basic_symbolic_execution</span><span class="p">())</span>
</code></pre></div></div>

<p>程序中标准输入流中获取数据，angr默认情况下是无符号的数据流，为了进行约束求解，并且获取到能满足这些约束的输入值，我们需要对实际的标准输入流获得一个引用。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 路径一标准输入
</span><span class="n">In</span> <span class="p">[</span><span class="mi">90</span><span class="p">]:</span> <span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">posix</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">90</span><span class="p">]:</span> <span class="n">b</span><span class="s">'</span><span class="se">\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span class="s">SOSNEAKY</span><span class="se">\x00</span><span class="s">'</span>

<span class="c1"># 路径一标准输出
</span><span class="n">In</span> <span class="p">[</span><span class="mi">91</span><span class="p">]:</span> <span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">posix</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">91</span><span class="p">]:</span> <span class="n">b</span><span class="s">'Username: </span><span class="se">\n</span><span class="s">Password: </span><span class="se">\n</span><span class="s">Welcome to the admin console, trusted user!</span><span class="se">\n</span><span class="s">'</span>

<span class="c1"># 路径二标准输入
</span><span class="n">In</span> <span class="p">[</span><span class="mi">92</span><span class="p">]:</span> <span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">posix</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">92</span><span class="p">]:</span> <span class="n">b</span><span class="s">'</span><span class="se">\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span class="s">S</span><span class="se">\x80\x80\x80\x80\x80\x80\x00\x00</span><span class="s">'</span>

<span class="c1"># 路径二标准输出
</span><span class="n">In</span> <span class="p">[</span><span class="mi">93</span><span class="p">]:</span> <span class="n">simgr</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">posix</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">93</span><span class="p">]:</span> <span class="n">b</span><span class="s">'Username: </span><span class="se">\n</span><span class="s">Password: </span><span class="se">\n</span><span class="s">'</span>
</code></pre></div></div>

<p>通过使用angr找到它的后门，我们正在参与一个庞大的潮流，即对如何使用符号执行从二进制文件中提取意义有一个基本的了解。</p>

<h1 id="状态预设">状态预设</h1>

<p>到目前位置，无论什么时候我们使用状态，我们都使用<code class="highlighter-rouge">project.factory.entry_state()</code>。这只是其中一个状态构造函数，其他函数如下。</p>

<ul>
  <li><code class="highlighter-rouge">.blank_state()</code>构造状态使用一个空的状态，大部分其中的数据都是未初始化的。当访问数据时，未初始化的符号值会被返回。</li>
  <li><code class="highlighter-rouge">.entry_state()</code>状态构造器在主程序的入口点创建状态。</li>
  <li><code class="highlighter-rouge">.full_init_state()</code>状态构造器会去执行主程序入口点前，所有需要被初始化的部分，比如共享库和预初始化内容。当所有都完成后，它会跳转到入口点。</li>
  <li><code class="highlighter-rouge">.call_state()</code> 状态构造器准备执行一个给定函数。</li>
</ul>

<p>所有的这些构造器可以指定许多参数。</p>

<p>TODO：</p>

<ul>
  <li>所有这些构造器可以使用地址参数来指定开始解析的地址。</li>
  <li>If you’re executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through <code class="highlighter-rouge">args</code> and a dictionary of environment variables through <code class="highlighter-rouge">env</code> into <code class="highlighter-rouge">entry_state</code> and <code class="highlighter-rouge">full_init_state</code>. The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution. The default <code class="highlighter-rouge">args</code> is an empty list, so if the program you’re analyzing expects to find at least an <code class="highlighter-rouge">argv[0]</code>, you should always provide that!</li>
  <li>If you’d like to have <code class="highlighter-rouge">argc</code> be symbolic, you can pass a symbolic bitvector as <code class="highlighter-rouge">argc</code> to the <code class="highlighter-rouge">entry_state</code> and <code class="highlighter-rouge">full_init_state</code> constructors. Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into <code class="highlighter-rouge">args</code>.</li>
  <li>To use the call state, you should call it with <code class="highlighter-rouge">.call_state(addr, arg1, arg2, ...)</code>, where <code class="highlighter-rouge">addr</code> is the address of the function you want to call and <code class="highlighter-rouge">argN</code> is the Nth argument to that function, either as a python integer, string, or array, or a bitvector. If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. <code class="highlighter-rouge">angr.PointerWrapper("point to me!")</code>. The results of this API can be a little unpredictable, but we’re working on it.</li>
  <li>To specify the calling convention used for a function with <code class="highlighter-rouge">call_state</code>, you can pass a <a href="http://angr.io/api-doc/angr.html#module-angr.calling_conventions"><code class="highlighter-rouge">SimCC</code> instance</a> as the <code class="highlighter-rouge">cc</code> argument.</li>
</ul>

<h1 id="内存的底层接口">内存的底层接口</h1>

<p><code class="highlighter-rouge">state.mem</code>接口对从内存中加载特定类型的数据是很方便的，但是当我想要去进行原始加载和存储时，会非常麻烦。事实上，这种方式只是一种访问内存的逻辑方法，即在内存中填充位向量。我们可以使用<code class="highlighter-rouge">.load(addr, size)</code>和<code class="highlighter-rouge">.store(addr, val)</code>方法。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 存储
</span><span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="mh">0x123456789abcdef0123456789abcdef</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

<span class="c1"># 加载
</span><span class="n">In</span> <span class="p">[</span><span class="mi">21</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">21</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">BV128</span> <span class="mh">0x123456789abcdef0123456789abcdef</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>但是，我们可以发现，这种情况下是大端序，因为这个方式的主要目的是存储没有附加语义的数据段，所以是按照语义来进行的。如果需要使用小端序，加载的时候，需要指定加载的顺序方式。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">In</span> <span class="p">[</span><span class="mi">50</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="mh">0x123456789abcdef</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>

<span class="c1"># 小端序
</span><span class="n">In</span> <span class="p">[</span><span class="mi">51</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">endness</span><span class="o">=</span><span class="n">archinfo</span><span class="o">.</span><span class="n">Endness</span><span class="o">.</span><span class="n">LE</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">51</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0xefcdab8967452301</span><span class="o">&gt;</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 寄存器存储
</span><span class="n">In</span> <span class="p">[</span><span class="mi">58</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">registers</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rip</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="mh">0x123456789ef</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>

<span class="c1"># 寄存器加载
</span><span class="n">In</span> <span class="p">[</span><span class="mi">59</span><span class="p">]:</span> <span class="n">state</span><span class="o">.</span><span class="n">registers</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rip</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">59</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0x123456789ef</span><span class="o">&gt;</span>
</code></pre></div></div>

<h1 id="状态选项">状态选项</h1>

<p>TODO</p>

<h1 id="状态插件">状态插件</h1>

<p>所有存储在SimState中的内容，实际上都存储在附加到该状态的插件中。几乎所有我们讨论过的属性都是插件。<code class="highlighter-rouge">memory</code>, <code class="highlighter-rouge">registers</code>, <code class="highlighter-rouge">mem</code>, <code class="highlighter-rouge">regs</code>, <code class="highlighter-rouge">solver</code>等等，这种设计使得代码模块化，并且可以快速开发新功能。</p>

<h2 id="全局插件">全局插件</h2>

<p><code class="highlighter-rouge">state.globals</code>是最简单的差距，用于提供标准python字典接口。允许你存储任意数据。</p>

<h2 id="历史插件">历史插件</h2>

<p><code class="highlighter-rouge">state.history</code> 是一个很重要的差距，用于存储和历史有关的数据，即这个状态在执行过程中经历的路径中的数据。它实际上是一个链式的历史记录节点，每一个展示了一次执行轮次，你可以通过<code class="highlighter-rouge">state.history.parent.parent</code>遍历整个链表。
为了使结构更加方便来工作，这个插件也提供了许多高效的生成器，来对特定的值进行迭代。<code class="highlighter-rouge">history.recent_NAME</code> 是程序最近访问的一个值，对应的所有值存在于<code class="highlighter-rouge">history.NAME</code>列表中。如果我们想要获取立即值，可以通过<code class="highlighter-rouge">.hardcopy</code>属性来获取列表中的所有值，默认情况下是生成器，需要手动生成。</p>

<ul>
  <li><code class="highlighter-rouge">history.descriptions</code> 列表，描述每一轮执行的字符串信息。</li>
  <li><code class="highlighter-rouge">history.bbl_addrs</code> 基本块地址列表，每一轮可能不止一个，因为不是所有和二进制代码有关的基本块也会存在，比如一些被angr所hook的代码。</li>
  <li><code class="highlighter-rouge">history.jumpkinds</code> 状态历史中每个控制流转换的处理列表，如VEX枚举字符串</li>
  <li><code class="highlighter-rouge">history.guards</code> 保护状态遇到的每个分支的条件列表。（不能用？）</li>
  <li><code class="highlighter-rouge">history.events</code> 语义上一些有趣的事件列表，在程序执行过程中发生，比如存在符号跳转条件，程序弹出一个对话框，或者突然结束运行。</li>
  <li><code class="highlighter-rouge">history.actions</code>通常是空的，但是如果你添加 <code class="highlighter-rouge">angr.options.refs</code>选项到状态中，它会弹出程序执行过程中内存、寄存器或者终止代码的日志。</li>
</ul>

<h2 id="调用栈插件">调用栈插件</h2>

<p>angr将会跟踪模拟程序的栈调用。在每一次call指令后，一个栈帧会被添加到栈调用的最顶部，每当堆栈指针下降到调用最顶层帧，就会弹出一个帧，这允许angr健壮地存储当前模拟函数的本地数据。
和history一样，调用栈插件也是节点链表，但是没有提供迭代器，可以直接访问，使用<code class="highlighter-rouge">state.callstack.next</code> 来获取每一个栈帧，如果只要最顶层的，使用 <code class="highlighter-rouge">state.callstack</code>。</p>

<ul>
  <li><code class="highlighter-rouge">callstack.func_addr</code> 当前执行的函数地址。</li>
  <li><code class="highlighter-rouge">callstack.call_site_addr</code> 调用当前函数的基本块的地址。</li>
  <li><code class="highlighter-rouge">callstack.stack_ptr</code> 当前函数入口点栈指针的值。</li>
  <li><code class="highlighter-rouge">callstack.ret_addr</code> 当前函数的返回地址。</li>
</ul>

<h1 id="更多关于io">更多关于IO</h1>

<h2 id="复制和合并">复制和合并</h2>

<p>状态能快速进行复制，这样我们就能进行多种操作。通过<code class="highlighter-rouge">state.copy()</code>。
状态也能进行快速合并</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># merge will return a tuple. the first element is the merged state
# the second element is a symbolic variable describing a state flag
# the third element is a boolean describing whether any merging was done
</span><span class="o">&gt;&gt;&gt;</span>  <span class="p">(</span><span class="n">s_merged</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">anything_merged</span><span class="p">)</span>  <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

<span class="c1"># this is now an expression that can resolve to "AAAA" *or* "BBBB"
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">aaaa_or_bbbb</span> <span class="o">=</span> <span class="n">s_merged</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">]</span><span class="o">.</span><span class="n">uint32_t</span>
</code></pre></div></div>


        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#angr" class="page__taxonomy-item" rel="tag">angr</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fa fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-01-20T21:25:00+08:00">January 20, 2019</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=Angrlearning+4%20https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-01%2FAngrLearning-4.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fa fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-01%2FAngrLearning-4.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fa fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-01%2FAngrLearning-4.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2019-01/AngrLearning-3.html" class="pagination--pager" title="Angrlearning 3
">Previous</a>
    
    
      <a href="/posts/2019-01/Insomni'hack-teaser-Reverse-WriteUp.html" class="pagination--pager" title="Insomni&#8217;hack teaser reverse writeup
">Next</a>
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">Leave a comment</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/Dirary_November/" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/diary-notes.html" rel="permalink">Diary Notes
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  最近很浮躁，日记好久没写了，书也没看，论文也没看，运动也是断断续续。


12月5日

打算重新开blog，找了很久，从stackedit到blogger，从hexo到wordpress再到jekyll。因为图片的缘故，还在vps上搭了rclone来同步onedrive当图床用，后来又用git repo来当...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/1d25d6ba93.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <div id="disqus_thread"></div>
  <script>
    /**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
    */
    /*
    var disqus_config = function () {
      this.page.url = "https://zjgcjy.github.io/posts/2019-01/AngrLearning-4.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2019-01/AngrLearning-4"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
