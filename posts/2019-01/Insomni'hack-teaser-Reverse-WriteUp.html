<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Insomni&#8217;hack teaser reverse writeup  -  My way, though far away</title>
<meta name="description" content="  周末没事的时候看了下ctftime上的比赛，正好有个 Insomni’hack teaser 2019的比赛，于是花了点时间做了下逆向的2道题，有点意思，学到了很多知识。beginner_reverse  A babyrust to become a hardcore reverser.看题目意思很明显了，是个硬核的rust逆向题，关于rust语言，自己没有了解，Google了一下，大致是一种着重于安全开发的系统编程语言。直接上手首先用file命令查看下文件特性。很庆幸，是带符号的动态编译的文件。于是暴力就完事了，直接用ida打开，如下图所示。这里和一般的C逆向不一样的是，rust运行时环境的初始化过程。由于自己不熟悉rust语言的特性，按照惯性思维，认为start最后返回之前的函数一般为主函数，而开头的函数一般为运行时初始化函数，导致一开始函数分析错误，这也同样导致了ida的反编译F5功能失败。int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  std::rt::lang_start_internal::had9505969b8e20a2();  return result;}如果我们跟进这个lang_start_internal函数的话，就会发现找不到我们实际的主函数在什么地方，而一般情况下，主函数肯定是在初始化后才执行的，所以这里会卡住，迷失了方向。写个demo为了弄清rust加载运行时环境的流程，自己装上了rust的编译环境，同时写了个简单的demo进行编译测试。源代码如下：fn main() {    println!(&quot;hello world&quot;);}编译代码如下：rustc main.rs运行结果就是输出hello world，但我们关心的是输出文件，为此，我使用ida载入文件并分析。可以看到，和题目类似的格式。为了定位主函数的位置，我直接使用搜索字符串的方法，查找交叉引用。如下图所示。然后我们可以进一步查找该处的交叉引用，就能定位到主函数的位置。void main::main::hfe98083a4c87500f(){  char v0; // [rsp+8h] [rbp-30h]  core::fmt::Arguments::new_v1::h9482ffdd5f1340ab(&amp;v0, &amp;ptrHelloworld, 1LL, off_23170, 0LL);  std::io::stdio::_print::h46f3f0db7dd4cd21();}关于这个主函数所引用的位置，我们可以看到如下所示的情况。lea    rdi, _ZN4main4main17hfe98083a4c87500fE ;mov    [rsp+8+var_8], rsimov    rsi, raxmov    rdx, [rsp+8+var_8]call   _ZN3std2rt10lang_start17hd1a40614a9e43128E也就是说在rust中，rust编译器通过使用寄存器指向主函数地址，作为函数指针，作为lang_start_internal函数的参数，供rust运行时来初始化程序状态。更多关于rust的主函数加载情况，参看Rust Runtime Services。分析主函数解决了这个问题，我们就能找到主函数了，下面我们就跟进beginer_reverse::main::h80fa15281f646bc1()这个函数（其实从名字也能看出来，上文基本解释了原因）函数首先载入了一大段密文，很容易猜测这个是密文了，或者通过交叉引用也能看出来，然后从命令行读取输入。然后会进行很多检测，首先检测长度，再检测输入的最后一位是否正常。之后会遍历每一个输入，然后进行检测，判断范围等等操作，然后再将每个值拷贝到栈中缓存。由于rust十分注重安全性检测，所以这里的工作有点复杂，自己是用动态调试配合硬件断点的方式直接跳过这段检查了。比如我输入aptx4869就会变成这样，如下图所示。在下一次断点断下的时候，我们就会看到常见的循环+相等判断，估计就是解密所在的位置了。找到伪代码对应的位置，如下图所示：对比看汇编，此时的明文和密文分别由r14和r15寄存器的首地址所指向，我们直接查看即可。这和我们最开始看到的数据是相匹配的，不同的是，在程序载入后，修改了最后的2个数据，所以我们直接dump下这段密文，然后根据上面所示的判断方法来计算，就能得到flag了。cipher = [0x0000010E, 0x00000112, 0x00000166, 0x000001C6, 0x000001CE, 0x000000EA, 0x000001FE, 0x000001E2, 0x00000156, 0x000001AE, 0x00000156, 0x000001E2, 0x000000E6, 0x000001AE, 0x000000EE, 0x00000156, 0x0000018A, 0x000000FA, 0x000001E2, 0x000001BA, 0x000001A6, 0x000000EA, 0x000001E2, 0x000000E6, 0x00000156, 0x000001E2, 0x000000E6, 0x000001F2, 0x000000E6, 0x000001E2, 0x000001E6, 0x000000E6, 0x000001e2, 0x000001de, 0x00000000, 0x00000000]cipher = &#39;&#39;.join(map(lambda x: chr((x&gt;&gt;2) ^ 0xa), cipher))print cipher总结  总体来说这题不算很难，也说不上是硬核题，主要是语言不熟悉，导致了对语言的特性不清楚，在这点上浪费了很多时间。  同时由于rust语言采用大量的安全检测来保证后续的计算正常，在静态分析上出现了些麻烦，但能通过动态调试进行很好的解决。  程序不是静态链接的，分析起来有字符串可以参考，函数名也有理有据，对逆向有很多帮助，同时最后的算法也很简单，完全不需要逆向，正向计算即可。Junkyard  Wall-E got stuck in a big pile of sh*t. To protect him from feeling too bad, its software issued an emergency lock down. Sadly, the software had a conscience and its curiosity caused him to take a glance at the pervasive filth. The filth glanced back, and then…Please free Wall-E. The software was invented by advanced beings, so maybe it is way over your head. Please skill up fast though, Wall-E cannot wait for too long. To unlock it, use the login `73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81” and the correct password.第二题难度比较大，如题所述，整个题目中充斥了很多的垃圾指令，导致程序流程异常复杂，对分析产生了很多困扰。首先进入主函数，很明显，如果输入参数不是3个，就会调用一个函数，估计是退出，我将其命名为exit，然后对第二个参数进行判断，不满足条件又会调用exit，再对第三个参数进行判断，不满足也会调用exit。最后如果情况都满足，则在最后调用一个函数来判断，同时将2个参数传入进去，这是很明显最后的check函数，也称为主逻辑。尝试运行程序，发现运行时间非常长，平均要好几秒才运行完毕，而且根据情况的不同会打印出不同的提示字符串。比如，如果我就输入一个参数会打印出Usage: ./chall user pass等等，这些情况包括：I don&#39;t like your nameIs that a password?Maybe they&#39;re hiring at mc donald&#39;s? :/Computing stuff...Usage: ./chall user pass根据这种情况，我猜测是程序对字符串进行了动态解密，于是先找到字符串解密的地方，就能对程序指向流程有个整体的把握。而很明显，字符串解密的地方就在exit这个函数中，因为这个函数被大量引用，且符合上文所述的参数个数不一致问题所打印的提示信息。解密字符串下面跟进exit这个函数，发现其只做了一件事，即将一些常量作为参数来调用另一个函数，我将其命名为calcMsg。对这些字符串并不能得到很多有用的信息，于是继续跟进calcMsg这个函数，我将其中的垃圾指令擦除后，可以看的更清晰些，如下图所示。其中能看到md5的字样，估计是调用了md5函数进行hash计算，而其中的sub296b伪代码如下：_BYTE *__fastcall sub_296B(const char *a1, __int64 a2, unsigned int a3, __int64 a4){  v7 = a3;  v6 = a4;  v10 = strlen(a1);  v9 = 0;  v8 = 0;  while ( v7 &gt; v9 )  {    v4 = sub_275F(*(v8 + a2));    *(v9 + v6) = (16 * v4 + sub_275F(*(v8 + 1LL + a2))) ^ a1[v9 % v10];    v8 += 2;    ++v9;  }  result = (v9 + v6);  *result = 0;  return result;}__int64 __fastcall sub_275F(unsigned __int8 a1){  if ( a1 &gt; &#39;/&#39; &amp;&amp; a1 &lt;= &#39;9&#39; )    return a1 - 48;  if ( a1 &lt;= &#39;9&#39; )    return a1;  return a1 - &#39;W&#39;;}简单来说，这段代码就是将输入的字符串转成十六进制值，同时每一位和一个密钥进行循环异或，综合前一个函数的调用情况，简单来说做了这些事情：  初始化一个密钥，其值是10000。  将密钥打印到一个数组中，同时将其作为参数调用另一个函数，该函数将原函数的参数作为序号，将常量字符串转换成相应的十六进制值，同时和密钥进行异或。  将异或的值进行md5计算，将结果和序号所指定的hash值对比，如果相等则退出，否则进行循环，将密钥加一，重复操作。至此，我们大致分析完了整个字符串解密的过程，这也能大致解释为什么这个程序运行的这么慢，主要是密钥的初始值太小，只有10000，或者说作者将指定的密钥设计的太大。而在这个程序中，经过自己调试，发现当密钥的值是13371337时满足条件，即可进行解密。完整idapython脚本如下所示，注意自己已经将密钥的初始化值设置为13371336，防止计算时间太慢。from idaapi import *from idc import *from idautils import *import hashlibdef getMd5(src):    m1 = hashlib.md5()    m1.update(src)    return m1.hexdigest()secret = 0x8b80md5hash = 0x8be0iv = 13371336ivs = [0,1,3,4,5,6,7,8]for i in ivs:    init = GetString(Qword(secret + 8*i)).decode(&#39;hex&#39;)    hash = GetString(Qword(md5hash + 8*i))    #print init    while True:        key = str(iv)        t = &#39;&#39;        for i in xrange(len(init)):            t += chr(ord(init[i]) ^ ord(key[i%len(key)]))        #print t        if getMd5(t) == hash:            #print key            print t            break        iv += 1运行结果如下图所示。注意整个解密过程是不包括偏移量是2的那个字符串的，因为他是真正的flag加密的字符串，可以用交叉引用来证明，同时该字符串是使用aes进行加密，和这里无关。主check逻辑在完成字符串解密后，我们只能通过字符串引用的位置大致推测每一段check的作用是什么，比如第一个check就是判断输入参数是不是3个，第二个check判断输入长度是否满足大于15并且小于等于63。在满足这个条件的情况下，程序会输出Computing stuff...然后进入真正的check逻辑，下面开始分析。如下图所示，首先滤去垃圾指令，在函数开头计算2个参数的长度，因为上文的检测，所以肯定满足小于等于63的条件，然后进入change1这个函数进行变换。change1这个函数中又调用了另一个函数，如下图所示：很明显这是用来进行素数判断的，将从零到某个数字范围内的所有素数都求出来，然后返回到这个集合。然后在change1中，求出字符串长度和64之间的差值，然后进行循环，将素数集合作为index，求出字符串对应index下的值，添加到字符串末尾，然后结束。然后取出字符串中2个特定位置上的值，对其进行操作，这里由于参数1是指定的，所以我们可以进行部分化简，我的注释也标在图上了。要注意的是，这里还定义了一个655大小的数组，也是变相进行混淆，然后程序还定义了一张表，从A到S，是为了映射用的，如下图所示，之后进行了一段很难理解的计算。这段计算代码如下所示，如果真的是这样看的话，自己很难理解其中的意思，其真正的作用是计算十进制数的位数，之前在29c3 ctf中也有类似的题目解析。while ( v23 &amp;&amp; i_1 &lt;= 15 ){  v23 = (((0x6666666666666667LL * v23) &gt;&gt; 64) &gt;&gt; 2) - (v23 &gt;&gt; 63);  ++i_1;}那么第二段何其类似的代码也能理解了，就是取整数的最低位，然后次低位这样，然后再映射到A到S的表中。while ( v24 &amp;&amp; i_1 &lt;= 15 ){  v10 = v24 - 10 * ((((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63));   // 取最低位  v24 = (((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63);  v11 = i_1++;  v42[v11] = table[v10];}最后再用a来填充，对齐到16的倍数。比如上面计算出来的结果是123，那么3对应D，2对应C，1对应B，依次添加，最后的结果就是123DCBaaaaaaaaaa。 while ( i_1 &lt;= 15 )  {    v12 = i_1++;    v42[v12] = &#39;a&#39;;  }最后一步操作就是转成十六进制，然后取其5-8位，进行md5的计算，如果和给定的常量相同就算成功？求解过程首先md5的原象只有4位，在很容易爆破，容易得到27debb435021eb68b3965290b5e24c49的原象是7303，那么我们需要的就是字符串5-8位是7303。idapython脚本如下：from idaapi import *from idc import *from idautils import *from string import maketransk = maketrans(&quot;0123456789&quot;, &quot;ABCDEFGHIJ&quot;)cipherTable = []ans = []for i in xrange(655):    cipherTable.append(Dword(0x8140 + 4*i))def getflag(x, y):    sum1 = x - 0x30 + 634 + cipherTable[y] + 892360    #print sum1        s = map(lambda x: sum1 + x, cipherTable)    t = str(s[155 - x])    p = t + t[::-1].translate(k)    if p.encode(&#39;hex&#39;)[5:9] == &#39;7303&#39;:        ans.append(chr(x) + &#39;a&#39; * 0x29 + chr(y))for i in xrange(0x20, 0x7f):    for j in xrange(0x20, 0x7f):        getflag(i, j)但是一共会得到90种不同的解，肯定不是每个解都对的，这里其实还有一个问题，因为flag是通过aes解密出来的，可能会存在数据错误，导致异常产生，我的办法就是一个一个试了，可以通过pwntools来实现自动化测试。from pwn import *#context.log_level = &quot;debug&quot;name = &quot;73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81&quot;p = process(argv=[&quot;./junkyard&quot;, name, ans])p.recv()最后得到正确的输入是2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaC，输入就能解密得到flag。总结  对于垃圾指令很多的情况，需要找出垃圾指令填充的规律，然后就能略去很大无用的代码。  对于整体的解密思路还存在宏观把握不够的情况，具体表现在求素数那部分，其实那部分之后并没有用到，因为最后只用到了输入的其中2位，然后进行爆破就行了，所以还是多分析了很多部分，浪费了很多时间。  学到了加密常量字符串的新方法，通过指定循环次数来进行哈希运算，可以对字符串进行保护，同时要进行哈希运算，加大了运行时间，减少了爆破的机会。">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="Insomni&#8217;hack teaser reverse writeup">
<meta property="og:url" content="http://localhost:4000/posts/2019-01/Insomni'hack-teaser-Reverse-WriteUp.html">


  <meta property="og:description" content="  周末没事的时候看了下ctftime上的比赛，正好有个 Insomni’hack teaser 2019的比赛，于是花了点时间做了下逆向的2道题，有点意思，学到了很多知识。beginner_reverse  A babyrust to become a hardcore reverser.看题目意思很明显了，是个硬核的rust逆向题，关于rust语言，自己没有了解，Google了一下，大致是一种着重于安全开发的系统编程语言。直接上手首先用file命令查看下文件特性。很庆幸，是带符号的动态编译的文件。于是暴力就完事了，直接用ida打开，如下图所示。这里和一般的C逆向不一样的是，rust运行时环境的初始化过程。由于自己不熟悉rust语言的特性，按照惯性思维，认为start最后返回之前的函数一般为主函数，而开头的函数一般为运行时初始化函数，导致一开始函数分析错误，这也同样导致了ida的反编译F5功能失败。int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  std::rt::lang_start_internal::had9505969b8e20a2();  return result;}如果我们跟进这个lang_start_internal函数的话，就会发现找不到我们实际的主函数在什么地方，而一般情况下，主函数肯定是在初始化后才执行的，所以这里会卡住，迷失了方向。写个demo为了弄清rust加载运行时环境的流程，自己装上了rust的编译环境，同时写了个简单的demo进行编译测试。源代码如下：fn main() {    println!(&quot;hello world&quot;);}编译代码如下：rustc main.rs运行结果就是输出hello world，但我们关心的是输出文件，为此，我使用ida载入文件并分析。可以看到，和题目类似的格式。为了定位主函数的位置，我直接使用搜索字符串的方法，查找交叉引用。如下图所示。然后我们可以进一步查找该处的交叉引用，就能定位到主函数的位置。void main::main::hfe98083a4c87500f(){  char v0; // [rsp+8h] [rbp-30h]  core::fmt::Arguments::new_v1::h9482ffdd5f1340ab(&amp;v0, &amp;ptrHelloworld, 1LL, off_23170, 0LL);  std::io::stdio::_print::h46f3f0db7dd4cd21();}关于这个主函数所引用的位置，我们可以看到如下所示的情况。lea    rdi, _ZN4main4main17hfe98083a4c87500fE ;mov    [rsp+8+var_8], rsimov    rsi, raxmov    rdx, [rsp+8+var_8]call   _ZN3std2rt10lang_start17hd1a40614a9e43128E也就是说在rust中，rust编译器通过使用寄存器指向主函数地址，作为函数指针，作为lang_start_internal函数的参数，供rust运行时来初始化程序状态。更多关于rust的主函数加载情况，参看Rust Runtime Services。分析主函数解决了这个问题，我们就能找到主函数了，下面我们就跟进beginer_reverse::main::h80fa15281f646bc1()这个函数（其实从名字也能看出来，上文基本解释了原因）函数首先载入了一大段密文，很容易猜测这个是密文了，或者通过交叉引用也能看出来，然后从命令行读取输入。然后会进行很多检测，首先检测长度，再检测输入的最后一位是否正常。之后会遍历每一个输入，然后进行检测，判断范围等等操作，然后再将每个值拷贝到栈中缓存。由于rust十分注重安全性检测，所以这里的工作有点复杂，自己是用动态调试配合硬件断点的方式直接跳过这段检查了。比如我输入aptx4869就会变成这样，如下图所示。在下一次断点断下的时候，我们就会看到常见的循环+相等判断，估计就是解密所在的位置了。找到伪代码对应的位置，如下图所示：对比看汇编，此时的明文和密文分别由r14和r15寄存器的首地址所指向，我们直接查看即可。这和我们最开始看到的数据是相匹配的，不同的是，在程序载入后，修改了最后的2个数据，所以我们直接dump下这段密文，然后根据上面所示的判断方法来计算，就能得到flag了。cipher = [0x0000010E, 0x00000112, 0x00000166, 0x000001C6, 0x000001CE, 0x000000EA, 0x000001FE, 0x000001E2, 0x00000156, 0x000001AE, 0x00000156, 0x000001E2, 0x000000E6, 0x000001AE, 0x000000EE, 0x00000156, 0x0000018A, 0x000000FA, 0x000001E2, 0x000001BA, 0x000001A6, 0x000000EA, 0x000001E2, 0x000000E6, 0x00000156, 0x000001E2, 0x000000E6, 0x000001F2, 0x000000E6, 0x000001E2, 0x000001E6, 0x000000E6, 0x000001e2, 0x000001de, 0x00000000, 0x00000000]cipher = &#39;&#39;.join(map(lambda x: chr((x&gt;&gt;2) ^ 0xa), cipher))print cipher总结  总体来说这题不算很难，也说不上是硬核题，主要是语言不熟悉，导致了对语言的特性不清楚，在这点上浪费了很多时间。  同时由于rust语言采用大量的安全检测来保证后续的计算正常，在静态分析上出现了些麻烦，但能通过动态调试进行很好的解决。  程序不是静态链接的，分析起来有字符串可以参考，函数名也有理有据，对逆向有很多帮助，同时最后的算法也很简单，完全不需要逆向，正向计算即可。Junkyard  Wall-E got stuck in a big pile of sh*t. To protect him from feeling too bad, its software issued an emergency lock down. Sadly, the software had a conscience and its curiosity caused him to take a glance at the pervasive filth. The filth glanced back, and then…Please free Wall-E. The software was invented by advanced beings, so maybe it is way over your head. Please skill up fast though, Wall-E cannot wait for too long. To unlock it, use the login `73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81” and the correct password.第二题难度比较大，如题所述，整个题目中充斥了很多的垃圾指令，导致程序流程异常复杂，对分析产生了很多困扰。首先进入主函数，很明显，如果输入参数不是3个，就会调用一个函数，估计是退出，我将其命名为exit，然后对第二个参数进行判断，不满足条件又会调用exit，再对第三个参数进行判断，不满足也会调用exit。最后如果情况都满足，则在最后调用一个函数来判断，同时将2个参数传入进去，这是很明显最后的check函数，也称为主逻辑。尝试运行程序，发现运行时间非常长，平均要好几秒才运行完毕，而且根据情况的不同会打印出不同的提示字符串。比如，如果我就输入一个参数会打印出Usage: ./chall user pass等等，这些情况包括：I don&#39;t like your nameIs that a password?Maybe they&#39;re hiring at mc donald&#39;s? :/Computing stuff...Usage: ./chall user pass根据这种情况，我猜测是程序对字符串进行了动态解密，于是先找到字符串解密的地方，就能对程序指向流程有个整体的把握。而很明显，字符串解密的地方就在exit这个函数中，因为这个函数被大量引用，且符合上文所述的参数个数不一致问题所打印的提示信息。解密字符串下面跟进exit这个函数，发现其只做了一件事，即将一些常量作为参数来调用另一个函数，我将其命名为calcMsg。对这些字符串并不能得到很多有用的信息，于是继续跟进calcMsg这个函数，我将其中的垃圾指令擦除后，可以看的更清晰些，如下图所示。其中能看到md5的字样，估计是调用了md5函数进行hash计算，而其中的sub296b伪代码如下：_BYTE *__fastcall sub_296B(const char *a1, __int64 a2, unsigned int a3, __int64 a4){  v7 = a3;  v6 = a4;  v10 = strlen(a1);  v9 = 0;  v8 = 0;  while ( v7 &gt; v9 )  {    v4 = sub_275F(*(v8 + a2));    *(v9 + v6) = (16 * v4 + sub_275F(*(v8 + 1LL + a2))) ^ a1[v9 % v10];    v8 += 2;    ++v9;  }  result = (v9 + v6);  *result = 0;  return result;}__int64 __fastcall sub_275F(unsigned __int8 a1){  if ( a1 &gt; &#39;/&#39; &amp;&amp; a1 &lt;= &#39;9&#39; )    return a1 - 48;  if ( a1 &lt;= &#39;9&#39; )    return a1;  return a1 - &#39;W&#39;;}简单来说，这段代码就是将输入的字符串转成十六进制值，同时每一位和一个密钥进行循环异或，综合前一个函数的调用情况，简单来说做了这些事情：  初始化一个密钥，其值是10000。  将密钥打印到一个数组中，同时将其作为参数调用另一个函数，该函数将原函数的参数作为序号，将常量字符串转换成相应的十六进制值，同时和密钥进行异或。  将异或的值进行md5计算，将结果和序号所指定的hash值对比，如果相等则退出，否则进行循环，将密钥加一，重复操作。至此，我们大致分析完了整个字符串解密的过程，这也能大致解释为什么这个程序运行的这么慢，主要是密钥的初始值太小，只有10000，或者说作者将指定的密钥设计的太大。而在这个程序中，经过自己调试，发现当密钥的值是13371337时满足条件，即可进行解密。完整idapython脚本如下所示，注意自己已经将密钥的初始化值设置为13371336，防止计算时间太慢。from idaapi import *from idc import *from idautils import *import hashlibdef getMd5(src):    m1 = hashlib.md5()    m1.update(src)    return m1.hexdigest()secret = 0x8b80md5hash = 0x8be0iv = 13371336ivs = [0,1,3,4,5,6,7,8]for i in ivs:    init = GetString(Qword(secret + 8*i)).decode(&#39;hex&#39;)    hash = GetString(Qword(md5hash + 8*i))    #print init    while True:        key = str(iv)        t = &#39;&#39;        for i in xrange(len(init)):            t += chr(ord(init[i]) ^ ord(key[i%len(key)]))        #print t        if getMd5(t) == hash:            #print key            print t            break        iv += 1运行结果如下图所示。注意整个解密过程是不包括偏移量是2的那个字符串的，因为他是真正的flag加密的字符串，可以用交叉引用来证明，同时该字符串是使用aes进行加密，和这里无关。主check逻辑在完成字符串解密后，我们只能通过字符串引用的位置大致推测每一段check的作用是什么，比如第一个check就是判断输入参数是不是3个，第二个check判断输入长度是否满足大于15并且小于等于63。在满足这个条件的情况下，程序会输出Computing stuff...然后进入真正的check逻辑，下面开始分析。如下图所示，首先滤去垃圾指令，在函数开头计算2个参数的长度，因为上文的检测，所以肯定满足小于等于63的条件，然后进入change1这个函数进行变换。change1这个函数中又调用了另一个函数，如下图所示：很明显这是用来进行素数判断的，将从零到某个数字范围内的所有素数都求出来，然后返回到这个集合。然后在change1中，求出字符串长度和64之间的差值，然后进行循环，将素数集合作为index，求出字符串对应index下的值，添加到字符串末尾，然后结束。然后取出字符串中2个特定位置上的值，对其进行操作，这里由于参数1是指定的，所以我们可以进行部分化简，我的注释也标在图上了。要注意的是，这里还定义了一个655大小的数组，也是变相进行混淆，然后程序还定义了一张表，从A到S，是为了映射用的，如下图所示，之后进行了一段很难理解的计算。这段计算代码如下所示，如果真的是这样看的话，自己很难理解其中的意思，其真正的作用是计算十进制数的位数，之前在29c3 ctf中也有类似的题目解析。while ( v23 &amp;&amp; i_1 &lt;= 15 ){  v23 = (((0x6666666666666667LL * v23) &gt;&gt; 64) &gt;&gt; 2) - (v23 &gt;&gt; 63);  ++i_1;}那么第二段何其类似的代码也能理解了，就是取整数的最低位，然后次低位这样，然后再映射到A到S的表中。while ( v24 &amp;&amp; i_1 &lt;= 15 ){  v10 = v24 - 10 * ((((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63));   // 取最低位  v24 = (((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63);  v11 = i_1++;  v42[v11] = table[v10];}最后再用a来填充，对齐到16的倍数。比如上面计算出来的结果是123，那么3对应D，2对应C，1对应B，依次添加，最后的结果就是123DCBaaaaaaaaaa。 while ( i_1 &lt;= 15 )  {    v12 = i_1++;    v42[v12] = &#39;a&#39;;  }最后一步操作就是转成十六进制，然后取其5-8位，进行md5的计算，如果和给定的常量相同就算成功？求解过程首先md5的原象只有4位，在很容易爆破，容易得到27debb435021eb68b3965290b5e24c49的原象是7303，那么我们需要的就是字符串5-8位是7303。idapython脚本如下：from idaapi import *from idc import *from idautils import *from string import maketransk = maketrans(&quot;0123456789&quot;, &quot;ABCDEFGHIJ&quot;)cipherTable = []ans = []for i in xrange(655):    cipherTable.append(Dword(0x8140 + 4*i))def getflag(x, y):    sum1 = x - 0x30 + 634 + cipherTable[y] + 892360    #print sum1        s = map(lambda x: sum1 + x, cipherTable)    t = str(s[155 - x])    p = t + t[::-1].translate(k)    if p.encode(&#39;hex&#39;)[5:9] == &#39;7303&#39;:        ans.append(chr(x) + &#39;a&#39; * 0x29 + chr(y))for i in xrange(0x20, 0x7f):    for j in xrange(0x20, 0x7f):        getflag(i, j)但是一共会得到90种不同的解，肯定不是每个解都对的，这里其实还有一个问题，因为flag是通过aes解密出来的，可能会存在数据错误，导致异常产生，我的办法就是一个一个试了，可以通过pwntools来实现自动化测试。from pwn import *#context.log_level = &quot;debug&quot;name = &quot;73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81&quot;p = process(argv=[&quot;./junkyard&quot;, name, ans])p.recv()最后得到正确的输入是2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaC，输入就能解密得到flag。总结  对于垃圾指令很多的情况，需要找出垃圾指令填充的规律，然后就能略去很大无用的代码。  对于整体的解密思路还存在宏观把握不够的情况，具体表现在求素数那部分，其实那部分之后并没有用到，因为最后只用到了输入的其中2位，然后进行爆破就行了，所以还是多分析了很多部分，浪费了很多时间。  学到了加密常量字符串的新方法，通过指定循环次数来进行哈希运算，可以对字符串进行保护，同时要进行哈希运算，加大了运行时间，减少了爆破的机会。">



  <meta property="og:image" content="http://localhost:4000/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="Insomni&#8217;hack teaser reverse writeup">
  <meta name="twitter:description" content="  周末没事的时候看了下ctftime上的比赛，正好有个 Insomni’hack teaser 2019的比赛，于是花了点时间做了下逆向的2道题，有点意思，学到了很多知识。beginner_reverse  A babyrust to become a hardcore reverser.看题目意思很明显了，是个硬核的rust逆向题，关于rust语言，自己没有了解，Google了一下，大致是一种着重于安全开发的系统编程语言。直接上手首先用file命令查看下文件特性。很庆幸，是带符号的动态编译的文件。于是暴力就完事了，直接用ida打开，如下图所示。这里和一般的C逆向不一样的是，rust运行时环境的初始化过程。由于自己不熟悉rust语言的特性，按照惯性思维，认为start最后返回之前的函数一般为主函数，而开头的函数一般为运行时初始化函数，导致一开始函数分析错误，这也同样导致了ida的反编译F5功能失败。int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  std::rt::lang_start_internal::had9505969b8e20a2();  return result;}如果我们跟进这个lang_start_internal函数的话，就会发现找不到我们实际的主函数在什么地方，而一般情况下，主函数肯定是在初始化后才执行的，所以这里会卡住，迷失了方向。写个demo为了弄清rust加载运行时环境的流程，自己装上了rust的编译环境，同时写了个简单的demo进行编译测试。源代码如下：fn main() {    println!(&quot;hello world&quot;);}编译代码如下：rustc main.rs运行结果就是输出hello world，但我们关心的是输出文件，为此，我使用ida载入文件并分析。可以看到，和题目类似的格式。为了定位主函数的位置，我直接使用搜索字符串的方法，查找交叉引用。如下图所示。然后我们可以进一步查找该处的交叉引用，就能定位到主函数的位置。void main::main::hfe98083a4c87500f(){  char v0; // [rsp+8h] [rbp-30h]  core::fmt::Arguments::new_v1::h9482ffdd5f1340ab(&amp;v0, &amp;ptrHelloworld, 1LL, off_23170, 0LL);  std::io::stdio::_print::h46f3f0db7dd4cd21();}关于这个主函数所引用的位置，我们可以看到如下所示的情况。lea    rdi, _ZN4main4main17hfe98083a4c87500fE ;mov    [rsp+8+var_8], rsimov    rsi, raxmov    rdx, [rsp+8+var_8]call   _ZN3std2rt10lang_start17hd1a40614a9e43128E也就是说在rust中，rust编译器通过使用寄存器指向主函数地址，作为函数指针，作为lang_start_internal函数的参数，供rust运行时来初始化程序状态。更多关于rust的主函数加载情况，参看Rust Runtime Services。分析主函数解决了这个问题，我们就能找到主函数了，下面我们就跟进beginer_reverse::main::h80fa15281f646bc1()这个函数（其实从名字也能看出来，上文基本解释了原因）函数首先载入了一大段密文，很容易猜测这个是密文了，或者通过交叉引用也能看出来，然后从命令行读取输入。然后会进行很多检测，首先检测长度，再检测输入的最后一位是否正常。之后会遍历每一个输入，然后进行检测，判断范围等等操作，然后再将每个值拷贝到栈中缓存。由于rust十分注重安全性检测，所以这里的工作有点复杂，自己是用动态调试配合硬件断点的方式直接跳过这段检查了。比如我输入aptx4869就会变成这样，如下图所示。在下一次断点断下的时候，我们就会看到常见的循环+相等判断，估计就是解密所在的位置了。找到伪代码对应的位置，如下图所示：对比看汇编，此时的明文和密文分别由r14和r15寄存器的首地址所指向，我们直接查看即可。这和我们最开始看到的数据是相匹配的，不同的是，在程序载入后，修改了最后的2个数据，所以我们直接dump下这段密文，然后根据上面所示的判断方法来计算，就能得到flag了。cipher = [0x0000010E, 0x00000112, 0x00000166, 0x000001C6, 0x000001CE, 0x000000EA, 0x000001FE, 0x000001E2, 0x00000156, 0x000001AE, 0x00000156, 0x000001E2, 0x000000E6, 0x000001AE, 0x000000EE, 0x00000156, 0x0000018A, 0x000000FA, 0x000001E2, 0x000001BA, 0x000001A6, 0x000000EA, 0x000001E2, 0x000000E6, 0x00000156, 0x000001E2, 0x000000E6, 0x000001F2, 0x000000E6, 0x000001E2, 0x000001E6, 0x000000E6, 0x000001e2, 0x000001de, 0x00000000, 0x00000000]cipher = &#39;&#39;.join(map(lambda x: chr((x&gt;&gt;2) ^ 0xa), cipher))print cipher总结  总体来说这题不算很难，也说不上是硬核题，主要是语言不熟悉，导致了对语言的特性不清楚，在这点上浪费了很多时间。  同时由于rust语言采用大量的安全检测来保证后续的计算正常，在静态分析上出现了些麻烦，但能通过动态调试进行很好的解决。  程序不是静态链接的，分析起来有字符串可以参考，函数名也有理有据，对逆向有很多帮助，同时最后的算法也很简单，完全不需要逆向，正向计算即可。Junkyard  Wall-E got stuck in a big pile of sh*t. To protect him from feeling too bad, its software issued an emergency lock down. Sadly, the software had a conscience and its curiosity caused him to take a glance at the pervasive filth. The filth glanced back, and then…Please free Wall-E. The software was invented by advanced beings, so maybe it is way over your head. Please skill up fast though, Wall-E cannot wait for too long. To unlock it, use the login `73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81” and the correct password.第二题难度比较大，如题所述，整个题目中充斥了很多的垃圾指令，导致程序流程异常复杂，对分析产生了很多困扰。首先进入主函数，很明显，如果输入参数不是3个，就会调用一个函数，估计是退出，我将其命名为exit，然后对第二个参数进行判断，不满足条件又会调用exit，再对第三个参数进行判断，不满足也会调用exit。最后如果情况都满足，则在最后调用一个函数来判断，同时将2个参数传入进去，这是很明显最后的check函数，也称为主逻辑。尝试运行程序，发现运行时间非常长，平均要好几秒才运行完毕，而且根据情况的不同会打印出不同的提示字符串。比如，如果我就输入一个参数会打印出Usage: ./chall user pass等等，这些情况包括：I don&#39;t like your nameIs that a password?Maybe they&#39;re hiring at mc donald&#39;s? :/Computing stuff...Usage: ./chall user pass根据这种情况，我猜测是程序对字符串进行了动态解密，于是先找到字符串解密的地方，就能对程序指向流程有个整体的把握。而很明显，字符串解密的地方就在exit这个函数中，因为这个函数被大量引用，且符合上文所述的参数个数不一致问题所打印的提示信息。解密字符串下面跟进exit这个函数，发现其只做了一件事，即将一些常量作为参数来调用另一个函数，我将其命名为calcMsg。对这些字符串并不能得到很多有用的信息，于是继续跟进calcMsg这个函数，我将其中的垃圾指令擦除后，可以看的更清晰些，如下图所示。其中能看到md5的字样，估计是调用了md5函数进行hash计算，而其中的sub296b伪代码如下：_BYTE *__fastcall sub_296B(const char *a1, __int64 a2, unsigned int a3, __int64 a4){  v7 = a3;  v6 = a4;  v10 = strlen(a1);  v9 = 0;  v8 = 0;  while ( v7 &gt; v9 )  {    v4 = sub_275F(*(v8 + a2));    *(v9 + v6) = (16 * v4 + sub_275F(*(v8 + 1LL + a2))) ^ a1[v9 % v10];    v8 += 2;    ++v9;  }  result = (v9 + v6);  *result = 0;  return result;}__int64 __fastcall sub_275F(unsigned __int8 a1){  if ( a1 &gt; &#39;/&#39; &amp;&amp; a1 &lt;= &#39;9&#39; )    return a1 - 48;  if ( a1 &lt;= &#39;9&#39; )    return a1;  return a1 - &#39;W&#39;;}简单来说，这段代码就是将输入的字符串转成十六进制值，同时每一位和一个密钥进行循环异或，综合前一个函数的调用情况，简单来说做了这些事情：  初始化一个密钥，其值是10000。  将密钥打印到一个数组中，同时将其作为参数调用另一个函数，该函数将原函数的参数作为序号，将常量字符串转换成相应的十六进制值，同时和密钥进行异或。  将异或的值进行md5计算，将结果和序号所指定的hash值对比，如果相等则退出，否则进行循环，将密钥加一，重复操作。至此，我们大致分析完了整个字符串解密的过程，这也能大致解释为什么这个程序运行的这么慢，主要是密钥的初始值太小，只有10000，或者说作者将指定的密钥设计的太大。而在这个程序中，经过自己调试，发现当密钥的值是13371337时满足条件，即可进行解密。完整idapython脚本如下所示，注意自己已经将密钥的初始化值设置为13371336，防止计算时间太慢。from idaapi import *from idc import *from idautils import *import hashlibdef getMd5(src):    m1 = hashlib.md5()    m1.update(src)    return m1.hexdigest()secret = 0x8b80md5hash = 0x8be0iv = 13371336ivs = [0,1,3,4,5,6,7,8]for i in ivs:    init = GetString(Qword(secret + 8*i)).decode(&#39;hex&#39;)    hash = GetString(Qword(md5hash + 8*i))    #print init    while True:        key = str(iv)        t = &#39;&#39;        for i in xrange(len(init)):            t += chr(ord(init[i]) ^ ord(key[i%len(key)]))        #print t        if getMd5(t) == hash:            #print key            print t            break        iv += 1运行结果如下图所示。注意整个解密过程是不包括偏移量是2的那个字符串的，因为他是真正的flag加密的字符串，可以用交叉引用来证明，同时该字符串是使用aes进行加密，和这里无关。主check逻辑在完成字符串解密后，我们只能通过字符串引用的位置大致推测每一段check的作用是什么，比如第一个check就是判断输入参数是不是3个，第二个check判断输入长度是否满足大于15并且小于等于63。在满足这个条件的情况下，程序会输出Computing stuff...然后进入真正的check逻辑，下面开始分析。如下图所示，首先滤去垃圾指令，在函数开头计算2个参数的长度，因为上文的检测，所以肯定满足小于等于63的条件，然后进入change1这个函数进行变换。change1这个函数中又调用了另一个函数，如下图所示：很明显这是用来进行素数判断的，将从零到某个数字范围内的所有素数都求出来，然后返回到这个集合。然后在change1中，求出字符串长度和64之间的差值，然后进行循环，将素数集合作为index，求出字符串对应index下的值，添加到字符串末尾，然后结束。然后取出字符串中2个特定位置上的值，对其进行操作，这里由于参数1是指定的，所以我们可以进行部分化简，我的注释也标在图上了。要注意的是，这里还定义了一个655大小的数组，也是变相进行混淆，然后程序还定义了一张表，从A到S，是为了映射用的，如下图所示，之后进行了一段很难理解的计算。这段计算代码如下所示，如果真的是这样看的话，自己很难理解其中的意思，其真正的作用是计算十进制数的位数，之前在29c3 ctf中也有类似的题目解析。while ( v23 &amp;&amp; i_1 &lt;= 15 ){  v23 = (((0x6666666666666667LL * v23) &gt;&gt; 64) &gt;&gt; 2) - (v23 &gt;&gt; 63);  ++i_1;}那么第二段何其类似的代码也能理解了，就是取整数的最低位，然后次低位这样，然后再映射到A到S的表中。while ( v24 &amp;&amp; i_1 &lt;= 15 ){  v10 = v24 - 10 * ((((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63));   // 取最低位  v24 = (((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63);  v11 = i_1++;  v42[v11] = table[v10];}最后再用a来填充，对齐到16的倍数。比如上面计算出来的结果是123，那么3对应D，2对应C，1对应B，依次添加，最后的结果就是123DCBaaaaaaaaaa。 while ( i_1 &lt;= 15 )  {    v12 = i_1++;    v42[v12] = &#39;a&#39;;  }最后一步操作就是转成十六进制，然后取其5-8位，进行md5的计算，如果和给定的常量相同就算成功？求解过程首先md5的原象只有4位，在很容易爆破，容易得到27debb435021eb68b3965290b5e24c49的原象是7303，那么我们需要的就是字符串5-8位是7303。idapython脚本如下：from idaapi import *from idc import *from idautils import *from string import maketransk = maketrans(&quot;0123456789&quot;, &quot;ABCDEFGHIJ&quot;)cipherTable = []ans = []for i in xrange(655):    cipherTable.append(Dword(0x8140 + 4*i))def getflag(x, y):    sum1 = x - 0x30 + 634 + cipherTable[y] + 892360    #print sum1        s = map(lambda x: sum1 + x, cipherTable)    t = str(s[155 - x])    p = t + t[::-1].translate(k)    if p.encode(&#39;hex&#39;)[5:9] == &#39;7303&#39;:        ans.append(chr(x) + &#39;a&#39; * 0x29 + chr(y))for i in xrange(0x20, 0x7f):    for j in xrange(0x20, 0x7f):        getflag(i, j)但是一共会得到90种不同的解，肯定不是每个解都对的，这里其实还有一个问题，因为flag是通过aes解密出来的，可能会存在数据错误，导致异常产生，我的办法就是一个一个试了，可以通过pwntools来实现自动化测试。from pwn import *#context.log_level = &quot;debug&quot;name = &quot;73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81&quot;p = process(argv=[&quot;./junkyard&quot;, name, ans])p.recv()最后得到正确的输入是2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaC，输入就能解密得到flag。总结  对于垃圾指令很多的情况，需要找出垃圾指令填充的规律，然后就能略去很大无用的代码。  对于整体的解密思路还存在宏观把握不够的情况，具体表现在求素数那部分，其实那部分之后并没有用到，因为最后只用到了输入的其中2位，然后进行爆破就行了，所以还是多分析了很多部分，浪费了很多时间。  学到了加密常量字符串的新方法，通过指定循环次数来进行哈希运算，可以对字符串进行保护，同时要进行哈希运算，加大了运行时间，减少了爆破的机会。">
  <meta name="twitter:url" content="http://localhost:4000/posts/2019-01/Insomni'hack-teaser-Reverse-WriteUp.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="http://localhost:4000/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2019-01-21T14:47:00+08:00">





  

  


<link rel="canonical" href="http://localhost:4000/posts/2019-01/Insomni'hack-teaser-Reverse-WriteUp.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "http://localhost:4000/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/apple-touch-icon.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about.html" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#posts" itemprop="item"><span itemprop="name">Posts</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#2019-01" itemprop="item"><span itemprop="name">2019 01</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">Insomni'hack teaser reverse writeup</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fa fa-map-marker" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fa fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fa fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Insomni&#8217;hack teaser reverse writeup">
    <meta itemprop="description" content="  周末没事的时候看了下ctftime上的比赛，正好有个 Insomni’hack teaser 2019的比赛，于是花了点时间做了下逆向的2道题，有点意思，学到了很多知识。beginner_reverse  A babyrust to become a hardcore reverser.看题目意思很明显了，是个硬核的rust逆向题，关于rust语言，自己没有了解，Google了一下，大致是一种着重于安全开发的系统编程语言。直接上手首先用file命令查看下文件特性。很庆幸，是带符号的动态编译的文件。于是暴力就完事了，直接用ida打开，如下图所示。这里和一般的C逆向不一样的是，rust运行时环境的初始化过程。由于自己不熟悉rust语言的特性，按照惯性思维，认为start最后返回之前的函数一般为主函数，而开头的函数一般为运行时初始化函数，导致一开始函数分析错误，这也同样导致了ida的反编译F5功能失败。int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  std::rt::lang_start_internal::had9505969b8e20a2();  return result;}如果我们跟进这个lang_start_internal函数的话，就会发现找不到我们实际的主函数在什么地方，而一般情况下，主函数肯定是在初始化后才执行的，所以这里会卡住，迷失了方向。写个demo为了弄清rust加载运行时环境的流程，自己装上了rust的编译环境，同时写了个简单的demo进行编译测试。源代码如下：fn main() {    println!(&quot;hello world&quot;);}编译代码如下：rustc main.rs运行结果就是输出hello world，但我们关心的是输出文件，为此，我使用ida载入文件并分析。可以看到，和题目类似的格式。为了定位主函数的位置，我直接使用搜索字符串的方法，查找交叉引用。如下图所示。然后我们可以进一步查找该处的交叉引用，就能定位到主函数的位置。void main::main::hfe98083a4c87500f(){  char v0; // [rsp+8h] [rbp-30h]  core::fmt::Arguments::new_v1::h9482ffdd5f1340ab(&amp;v0, &amp;ptrHelloworld, 1LL, off_23170, 0LL);  std::io::stdio::_print::h46f3f0db7dd4cd21();}关于这个主函数所引用的位置，我们可以看到如下所示的情况。lea    rdi, _ZN4main4main17hfe98083a4c87500fE ;mov    [rsp+8+var_8], rsimov    rsi, raxmov    rdx, [rsp+8+var_8]call   _ZN3std2rt10lang_start17hd1a40614a9e43128E也就是说在rust中，rust编译器通过使用寄存器指向主函数地址，作为函数指针，作为lang_start_internal函数的参数，供rust运行时来初始化程序状态。更多关于rust的主函数加载情况，参看Rust Runtime Services。分析主函数解决了这个问题，我们就能找到主函数了，下面我们就跟进beginer_reverse::main::h80fa15281f646bc1()这个函数（其实从名字也能看出来，上文基本解释了原因）函数首先载入了一大段密文，很容易猜测这个是密文了，或者通过交叉引用也能看出来，然后从命令行读取输入。然后会进行很多检测，首先检测长度，再检测输入的最后一位是否正常。之后会遍历每一个输入，然后进行检测，判断范围等等操作，然后再将每个值拷贝到栈中缓存。由于rust十分注重安全性检测，所以这里的工作有点复杂，自己是用动态调试配合硬件断点的方式直接跳过这段检查了。比如我输入aptx4869就会变成这样，如下图所示。在下一次断点断下的时候，我们就会看到常见的循环+相等判断，估计就是解密所在的位置了。找到伪代码对应的位置，如下图所示：对比看汇编，此时的明文和密文分别由r14和r15寄存器的首地址所指向，我们直接查看即可。这和我们最开始看到的数据是相匹配的，不同的是，在程序载入后，修改了最后的2个数据，所以我们直接dump下这段密文，然后根据上面所示的判断方法来计算，就能得到flag了。cipher = [0x0000010E, 0x00000112, 0x00000166, 0x000001C6, 0x000001CE, 0x000000EA, 0x000001FE, 0x000001E2, 0x00000156, 0x000001AE, 0x00000156, 0x000001E2, 0x000000E6, 0x000001AE, 0x000000EE, 0x00000156, 0x0000018A, 0x000000FA, 0x000001E2, 0x000001BA, 0x000001A6, 0x000000EA, 0x000001E2, 0x000000E6, 0x00000156, 0x000001E2, 0x000000E6, 0x000001F2, 0x000000E6, 0x000001E2, 0x000001E6, 0x000000E6, 0x000001e2, 0x000001de, 0x00000000, 0x00000000]cipher = &#39;&#39;.join(map(lambda x: chr((x&gt;&gt;2) ^ 0xa), cipher))print cipher总结  总体来说这题不算很难，也说不上是硬核题，主要是语言不熟悉，导致了对语言的特性不清楚，在这点上浪费了很多时间。  同时由于rust语言采用大量的安全检测来保证后续的计算正常，在静态分析上出现了些麻烦，但能通过动态调试进行很好的解决。  程序不是静态链接的，分析起来有字符串可以参考，函数名也有理有据，对逆向有很多帮助，同时最后的算法也很简单，完全不需要逆向，正向计算即可。Junkyard  Wall-E got stuck in a big pile of sh*t. To protect him from feeling too bad, its software issued an emergency lock down. Sadly, the software had a conscience and its curiosity caused him to take a glance at the pervasive filth. The filth glanced back, and then…Please free Wall-E. The software was invented by advanced beings, so maybe it is way over your head. Please skill up fast though, Wall-E cannot wait for too long. To unlock it, use the login `73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81” and the correct password.第二题难度比较大，如题所述，整个题目中充斥了很多的垃圾指令，导致程序流程异常复杂，对分析产生了很多困扰。首先进入主函数，很明显，如果输入参数不是3个，就会调用一个函数，估计是退出，我将其命名为exit，然后对第二个参数进行判断，不满足条件又会调用exit，再对第三个参数进行判断，不满足也会调用exit。最后如果情况都满足，则在最后调用一个函数来判断，同时将2个参数传入进去，这是很明显最后的check函数，也称为主逻辑。尝试运行程序，发现运行时间非常长，平均要好几秒才运行完毕，而且根据情况的不同会打印出不同的提示字符串。比如，如果我就输入一个参数会打印出Usage: ./chall user pass等等，这些情况包括：I don&#39;t like your nameIs that a password?Maybe they&#39;re hiring at mc donald&#39;s? :/Computing stuff...Usage: ./chall user pass根据这种情况，我猜测是程序对字符串进行了动态解密，于是先找到字符串解密的地方，就能对程序指向流程有个整体的把握。而很明显，字符串解密的地方就在exit这个函数中，因为这个函数被大量引用，且符合上文所述的参数个数不一致问题所打印的提示信息。解密字符串下面跟进exit这个函数，发现其只做了一件事，即将一些常量作为参数来调用另一个函数，我将其命名为calcMsg。对这些字符串并不能得到很多有用的信息，于是继续跟进calcMsg这个函数，我将其中的垃圾指令擦除后，可以看的更清晰些，如下图所示。其中能看到md5的字样，估计是调用了md5函数进行hash计算，而其中的sub296b伪代码如下：_BYTE *__fastcall sub_296B(const char *a1, __int64 a2, unsigned int a3, __int64 a4){  v7 = a3;  v6 = a4;  v10 = strlen(a1);  v9 = 0;  v8 = 0;  while ( v7 &gt; v9 )  {    v4 = sub_275F(*(v8 + a2));    *(v9 + v6) = (16 * v4 + sub_275F(*(v8 + 1LL + a2))) ^ a1[v9 % v10];    v8 += 2;    ++v9;  }  result = (v9 + v6);  *result = 0;  return result;}__int64 __fastcall sub_275F(unsigned __int8 a1){  if ( a1 &gt; &#39;/&#39; &amp;&amp; a1 &lt;= &#39;9&#39; )    return a1 - 48;  if ( a1 &lt;= &#39;9&#39; )    return a1;  return a1 - &#39;W&#39;;}简单来说，这段代码就是将输入的字符串转成十六进制值，同时每一位和一个密钥进行循环异或，综合前一个函数的调用情况，简单来说做了这些事情：  初始化一个密钥，其值是10000。  将密钥打印到一个数组中，同时将其作为参数调用另一个函数，该函数将原函数的参数作为序号，将常量字符串转换成相应的十六进制值，同时和密钥进行异或。  将异或的值进行md5计算，将结果和序号所指定的hash值对比，如果相等则退出，否则进行循环，将密钥加一，重复操作。至此，我们大致分析完了整个字符串解密的过程，这也能大致解释为什么这个程序运行的这么慢，主要是密钥的初始值太小，只有10000，或者说作者将指定的密钥设计的太大。而在这个程序中，经过自己调试，发现当密钥的值是13371337时满足条件，即可进行解密。完整idapython脚本如下所示，注意自己已经将密钥的初始化值设置为13371336，防止计算时间太慢。from idaapi import *from idc import *from idautils import *import hashlibdef getMd5(src):    m1 = hashlib.md5()    m1.update(src)    return m1.hexdigest()secret = 0x8b80md5hash = 0x8be0iv = 13371336ivs = [0,1,3,4,5,6,7,8]for i in ivs:    init = GetString(Qword(secret + 8*i)).decode(&#39;hex&#39;)    hash = GetString(Qword(md5hash + 8*i))    #print init    while True:        key = str(iv)        t = &#39;&#39;        for i in xrange(len(init)):            t += chr(ord(init[i]) ^ ord(key[i%len(key)]))        #print t        if getMd5(t) == hash:            #print key            print t            break        iv += 1运行结果如下图所示。注意整个解密过程是不包括偏移量是2的那个字符串的，因为他是真正的flag加密的字符串，可以用交叉引用来证明，同时该字符串是使用aes进行加密，和这里无关。主check逻辑在完成字符串解密后，我们只能通过字符串引用的位置大致推测每一段check的作用是什么，比如第一个check就是判断输入参数是不是3个，第二个check判断输入长度是否满足大于15并且小于等于63。在满足这个条件的情况下，程序会输出Computing stuff...然后进入真正的check逻辑，下面开始分析。如下图所示，首先滤去垃圾指令，在函数开头计算2个参数的长度，因为上文的检测，所以肯定满足小于等于63的条件，然后进入change1这个函数进行变换。change1这个函数中又调用了另一个函数，如下图所示：很明显这是用来进行素数判断的，将从零到某个数字范围内的所有素数都求出来，然后返回到这个集合。然后在change1中，求出字符串长度和64之间的差值，然后进行循环，将素数集合作为index，求出字符串对应index下的值，添加到字符串末尾，然后结束。然后取出字符串中2个特定位置上的值，对其进行操作，这里由于参数1是指定的，所以我们可以进行部分化简，我的注释也标在图上了。要注意的是，这里还定义了一个655大小的数组，也是变相进行混淆，然后程序还定义了一张表，从A到S，是为了映射用的，如下图所示，之后进行了一段很难理解的计算。这段计算代码如下所示，如果真的是这样看的话，自己很难理解其中的意思，其真正的作用是计算十进制数的位数，之前在29c3 ctf中也有类似的题目解析。while ( v23 &amp;&amp; i_1 &lt;= 15 ){  v23 = (((0x6666666666666667LL * v23) &gt;&gt; 64) &gt;&gt; 2) - (v23 &gt;&gt; 63);  ++i_1;}那么第二段何其类似的代码也能理解了，就是取整数的最低位，然后次低位这样，然后再映射到A到S的表中。while ( v24 &amp;&amp; i_1 &lt;= 15 ){  v10 = v24 - 10 * ((((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63));   // 取最低位  v24 = (((0x6666666666666667LL * v24) &gt;&gt; 64) &gt;&gt; 2) - (v24 &gt;&gt; 63);  v11 = i_1++;  v42[v11] = table[v10];}最后再用a来填充，对齐到16的倍数。比如上面计算出来的结果是123，那么3对应D，2对应C，1对应B，依次添加，最后的结果就是123DCBaaaaaaaaaa。 while ( i_1 &lt;= 15 )  {    v12 = i_1++;    v42[v12] = &#39;a&#39;;  }最后一步操作就是转成十六进制，然后取其5-8位，进行md5的计算，如果和给定的常量相同就算成功？求解过程首先md5的原象只有4位，在很容易爆破，容易得到27debb435021eb68b3965290b5e24c49的原象是7303，那么我们需要的就是字符串5-8位是7303。idapython脚本如下：from idaapi import *from idc import *from idautils import *from string import maketransk = maketrans(&quot;0123456789&quot;, &quot;ABCDEFGHIJ&quot;)cipherTable = []ans = []for i in xrange(655):    cipherTable.append(Dword(0x8140 + 4*i))def getflag(x, y):    sum1 = x - 0x30 + 634 + cipherTable[y] + 892360    #print sum1        s = map(lambda x: sum1 + x, cipherTable)    t = str(s[155 - x])    p = t + t[::-1].translate(k)    if p.encode(&#39;hex&#39;)[5:9] == &#39;7303&#39;:        ans.append(chr(x) + &#39;a&#39; * 0x29 + chr(y))for i in xrange(0x20, 0x7f):    for j in xrange(0x20, 0x7f):        getflag(i, j)但是一共会得到90种不同的解，肯定不是每个解都对的，这里其实还有一个问题，因为flag是通过aes解密出来的，可能会存在数据错误，导致异常产生，我的办法就是一个一个试了，可以通过pwntools来实现自动化测试。from pwn import *#context.log_level = &quot;debug&quot;name = &quot;73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81&quot;p = process(argv=[&quot;./junkyard&quot;, name, ans])p.recv()最后得到正确的输入是2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaC，输入就能解密得到flag。总结  对于垃圾指令很多的情况，需要找出垃圾指令填充的规律，然后就能略去很大无用的代码。  对于整体的解密思路还存在宏观把握不够的情况，具体表现在求素数那部分，其实那部分之后并没有用到，因为最后只用到了输入的其中2位，然后进行爆破就行了，所以还是多分析了很多部分，浪费了很多时间。  学到了加密常量字符串的新方法，通过指定循环次数来进行哈希运算，可以对字符串进行保护，同时要进行哈希运算，加大了运行时间，减少了爆破的机会。">
    <meta itemprop="datePublished" content="January 21, 2019">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Insomni&#8217;hack teaser reverse writeup
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  3 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#beginner_reverse">beginner_reverse</a>
    <ul>
      <li><a href="#直接上手">直接上手</a></li>
      <li><a href="#写个demo">写个demo</a></li>
      <li><a href="#分析主函数">分析主函数</a></li>
      <li><a href="#总结">总结</a></li>
    </ul>
  </li>
  <li><a href="#junkyard">Junkyard</a>
    <ul>
      <li><a href="#解密字符串">解密字符串</a></li>
      <li><a href="#主check逻辑">主check逻辑</a></li>
      <li><a href="#求解过程">求解过程</a></li>
      <li><a href="#总结-1">总结</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <blockquote>
  <p>周末没事的时候看了下ctftime上的比赛，正好有个 Insomni’hack teaser 2019的比赛，于是花了点时间做了下逆向的2道题，有点意思，学到了很多知识。</p>
</blockquote>

<hr />

<h1 id="beginner_reverse">beginner_reverse</h1>

<blockquote>
  <p>A babyrust to become a hardcore reverser.</p>
</blockquote>

<p>看题目意思很明显了，是个硬核的rust逆向题，关于rust语言，自己没有了解，Google了一下，大致是一种着重于安全开发的系统编程语言。</p>

<h2 id="直接上手">直接上手</h2>

<p>首先用<code class="highlighter-rouge">file</code>命令查看下文件特性。</p>

<p><img src="images/Snipaste_2019-01-21_17-23-18.png" alt="Snipaste_2019-01-21_17-23-18" /></p>

<p>很庆幸，是带符号的动态编译的文件。于是暴力就完事了，直接用ida打开，如下图所示。</p>

<p><img src="images/Snipaste_2019-01-21_17-26-14.png" alt="Snipaste_2019-01-21_17-26-14" /></p>

<p>这里和一般的C逆向不一样的是，rust运行时环境的初始化过程。由于自己不熟悉rust语言的特性，按照惯性思维，认为start最后返回之前的函数一般为主函数，而开头的函数一般为运行时初始化函数，导致一开始函数分析错误，这也同样导致了ida的反编译F5功能失败。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// eax</span>
  <span class="n">std</span><span class="o">::</span><span class="n">rt</span><span class="o">::</span><span class="n">lang_start_internal</span><span class="o">::</span><span class="n">had9505969b8e20a2</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果我们跟进这个<code class="highlighter-rouge">lang_start_internal</code>函数的话，就会发现找不到我们实际的主函数在什么地方，而一般情况下，主函数肯定是在初始化后才执行的，所以这里会卡住，迷失了方向。</p>

<h2 id="写个demo">写个demo</h2>

<p>为了弄清rust加载运行时环境的流程，自己装上了rust的编译环境，同时写了个简单的demo进行编译测试。源代码如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译代码如下：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rustc main.rs
</code></pre></div></div>

<p>运行结果就是输出<code class="highlighter-rouge">hello world</code>，但我们关心的是输出文件，为此，我使用ida载入文件并分析。可以看到，和题目类似的格式。</p>

<p><img src="images/Snipaste_2019-01-21_17-36-04.png" alt="Snipaste_2019-01-21_17-36-04" /></p>

<p>为了定位主函数的位置，我直接使用搜索字符串的方法，查找交叉引用。如下图所示。</p>

<p><img src="images/Snipaste_2019-01-21_17-37-51.png" alt="Snipaste_2019-01-21_17-37-51" /></p>

<p>然后我们可以进一步查找该处的交叉引用，就能定位到主函数的位置。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">main</span><span class="o">::</span><span class="n">main</span><span class="o">::</span><span class="n">hfe98083a4c87500f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">v0</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-30h]</span>
  <span class="n">core</span><span class="o">::</span><span class="n">fmt</span><span class="o">::</span><span class="n">Arguments</span><span class="o">::</span><span class="n">new_v1</span><span class="o">::</span><span class="n">h9482ffdd5f1340ab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptrHelloworld</span><span class="p">,</span> <span class="mi">1LL</span><span class="p">,</span> <span class="n">off_23170</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">stdio</span><span class="o">::</span><span class="n">_print</span><span class="o">::</span><span class="n">h46f3f0db7dd4cd21</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>关于这个主函数所引用的位置，我们可以看到如下所示的情况。</p>

<pre><code class="language-asm">lea    rdi, _ZN4main4main17hfe98083a4c87500fE ;
mov    [rsp+8+var_8], rsi
mov    rsi, rax
mov    rdx, [rsp+8+var_8]
call   _ZN3std2rt10lang_start17hd1a40614a9e43128E
</code></pre>

<p>也就是说在rust中，rust编译器通过使用寄存器指向主函数地址，作为函数指针，作为<code class="highlighter-rouge">lang_start_internal</code>函数的参数，供rust运行时来初始化程序状态。更多关于rust的主函数加载情况，参看<a href="https://github.com/rust-lang/rust/blob/3575be60ea/src/libstd/rt.rs">Rust Runtime Services</a>。</p>

<h2 id="分析主函数">分析主函数</h2>

<p>解决了这个问题，我们就能找到主函数了，下面我们就跟进<code class="highlighter-rouge">beginer_reverse::main::h80fa15281f646bc1()</code>这个函数（其实从名字也能看出来，上文基本解释了原因）函数首先载入了一大段密文，很容易猜测这个是密文了，或者通过交叉引用也能看出来，然后从命令行读取输入。</p>

<p><img src="images/Snipaste_2019-01-21_19-01-15.png" alt="Snipaste_2019-01-21_19-01-15" /></p>

<p>然后会进行很多检测，首先检测长度，再检测输入的最后一位是否正常。</p>

<p><img src="images/Snipaste_2019-01-21_19-03-39.png" alt="Snipaste_2019-01-21_19-03-39" /></p>

<p>之后会遍历每一个输入，然后进行检测，判断范围等等操作，然后再将每个值拷贝到栈中缓存。由于rust十分注重安全性检测，所以这里的工作有点复杂，自己是用动态调试配合硬件断点的方式直接跳过这段检查了。</p>

<p><img src="images/Snipaste_2019-01-21_19-10-11.png" alt="Snipaste_2019-01-21_19-10-11" /></p>

<p>比如我输入aptx4869就会变成这样，如下图所示。</p>

<p><img src="images/Snipaste_2019-01-21_19-11-59.png" alt="Snipaste_2019-01-21_19-11-59" /></p>

<p>在下一次断点断下的时候，我们就会看到常见的循环+相等判断，估计就是解密所在的位置了。找到伪代码对应的位置，如下图所示：</p>

<p><img src="images/Snipaste_2019-01-21_19-14-23.png" alt="Snipaste_2019-01-21_19-14-23" /></p>

<p>对比看汇编，此时的明文和密文分别由r14和r15寄存器的首地址所指向，我们直接查看即可。</p>

<p><img src="images/Snipaste_2019-01-21_19-16-48.png" alt="Snipaste_2019-01-21_19-16-48" /></p>

<p>这和我们最开始看到的数据是相匹配的，不同的是，在程序载入后，修改了最后的2个数据，所以我们直接dump下这段密文，然后根据上面所示的判断方法来计算，就能得到flag了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cipher</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x0000010E</span><span class="p">,</span> <span class="mh">0x00000112</span><span class="p">,</span> <span class="mh">0x00000166</span><span class="p">,</span> <span class="mh">0x000001C6</span><span class="p">,</span> <span class="mh">0x000001CE</span><span class="p">,</span> <span class="mh">0x000000EA</span><span class="p">,</span> <span class="mh">0x000001FE</span><span class="p">,</span> <span class="mh">0x000001E2</span><span class="p">,</span> <span class="mh">0x00000156</span><span class="p">,</span> <span class="mh">0x000001AE</span><span class="p">,</span> <span class="mh">0x00000156</span><span class="p">,</span> <span class="mh">0x000001E2</span><span class="p">,</span> <span class="mh">0x000000E6</span><span class="p">,</span> <span class="mh">0x000001AE</span><span class="p">,</span> <span class="mh">0x000000EE</span><span class="p">,</span> <span class="mh">0x00000156</span><span class="p">,</span> <span class="mh">0x0000018A</span><span class="p">,</span> <span class="mh">0x000000FA</span><span class="p">,</span> <span class="mh">0x000001E2</span><span class="p">,</span> <span class="mh">0x000001BA</span><span class="p">,</span> <span class="mh">0x000001A6</span><span class="p">,</span> <span class="mh">0x000000EA</span><span class="p">,</span> <span class="mh">0x000001E2</span><span class="p">,</span> <span class="mh">0x000000E6</span><span class="p">,</span> <span class="mh">0x00000156</span><span class="p">,</span> <span class="mh">0x000001E2</span><span class="p">,</span> <span class="mh">0x000000E6</span><span class="p">,</span> <span class="mh">0x000001F2</span><span class="p">,</span> <span class="mh">0x000000E6</span><span class="p">,</span> <span class="mh">0x000001E2</span><span class="p">,</span> <span class="mh">0x000001E6</span><span class="p">,</span> <span class="mh">0x000000E6</span><span class="p">,</span> <span class="mh">0x000001e2</span><span class="p">,</span> <span class="mh">0x000001de</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">]</span>

<span class="n">cipher</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">chr</span><span class="p">((</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0xa</span><span class="p">),</span> <span class="n">cipher</span><span class="p">))</span>

<span class="k">print</span> <span class="n">cipher</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<ol>
  <li>总体来说这题不算很难，也说不上是硬核题，主要是语言不熟悉，导致了对语言的特性不清楚，在这点上浪费了很多时间。</li>
  <li>同时由于rust语言采用大量的安全检测来保证后续的计算正常，在静态分析上出现了些麻烦，但能通过动态调试进行很好的解决。</li>
  <li>程序不是静态链接的，分析起来有字符串可以参考，函数名也有理有据，对逆向有很多帮助，同时最后的算法也很简单，完全不需要逆向，正向计算即可。</li>
</ol>

<h1 id="junkyard">Junkyard</h1>

<blockquote>
  <p>Wall-E got stuck in a big pile of sh*t. To protect him from feeling too bad, its software issued an emergency lock down. Sadly, the software had a conscience and its curiosity caused him to take a glance at the pervasive filth. The filth glanced back, and then…Please free Wall-E. The software was invented by advanced beings, so maybe it is way over your head. Please skill up fast though, Wall-E cannot wait for too long. To unlock it, use the login `73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81” and the correct password.</p>
</blockquote>

<p>第二题难度比较大，如题所述，整个题目中充斥了很多的垃圾指令，导致程序流程异常复杂，对分析产生了很多困扰。
首先进入主函数，很明显，如果输入参数不是3个，就会调用一个函数，估计是退出，我将其命名为exit，然后对第二个参数进行判断，不满足条件又会调用exit，再对第三个参数进行判断，不满足也会调用exit。最后如果情况都满足，则在最后调用一个函数来判断，同时将2个参数传入进去，这是很明显最后的check函数，也称为主逻辑。</p>

<p><img src="images/Snipaste_2019-01-21_19-43-20.png" alt="Snipaste_2019-01-21_19-43-20" /></p>

<p>尝试运行程序，发现运行时间非常长，平均要好几秒才运行完毕，而且根据情况的不同会打印出不同的提示字符串。比如，如果我就输入一个参数会打印出<code class="highlighter-rouge">Usage: ./chall user pass</code>等等，这些情况包括：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I don<span class="s1">'t like your name
Is that a password?
Maybe they'</span>re hiring at mc donald<span class="s1">'s? :/
Computing stuff...
Usage: ./chall user pass
</span></code></pre></div></div>

<p>根据这种情况，我猜测是程序对字符串进行了动态解密，于是先找到字符串解密的地方，就能对程序指向流程有个整体的把握。而很明显，字符串解密的地方就在exit这个函数中，因为这个函数被大量引用，且符合上文所述的参数个数不一致问题所打印的提示信息。</p>

<h2 id="解密字符串">解密字符串</h2>

<p>下面跟进exit这个函数，发现其只做了一件事，即将一些常量作为参数来调用另一个函数，我将其命名为calcMsg。</p>

<p><img src="images/Snipaste_2019-01-21_19-55-41.png" alt="Snipaste_2019-01-21_19-55-41" /></p>

<p>对这些字符串并不能得到很多有用的信息，于是继续跟进calcMsg这个函数，我将其中的垃圾指令擦除后，可以看的更清晰些，如下图所示。</p>

<p><img src="images/Snipaste_2019-01-21_19-57-55.png" alt="Snipaste_2019-01-21_19-57-55" /></p>

<p>其中能看到md5的字样，估计是调用了md5函数进行hash计算，而其中的sub296b伪代码如下：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_BYTE</span> <span class="o">*</span><span class="kr">__fastcall</span> <span class="nf">sub_296B</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a1</span><span class="p">,</span> <span class="n">__int64</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a3</span><span class="p">,</span> <span class="n">__int64</span> <span class="n">a4</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v7</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>
  <span class="n">v6</span> <span class="o">=</span> <span class="n">a4</span><span class="p">;</span>
  <span class="n">v10</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
  <span class="n">v9</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">v8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="n">v7</span> <span class="o">&gt;</span> <span class="n">v9</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v4</span> <span class="o">=</span> <span class="n">sub_275F</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">v8</span> <span class="o">+</span> <span class="n">a2</span><span class="p">));</span>
    <span class="o">*</span><span class="p">(</span><span class="n">v9</span> <span class="o">+</span> <span class="n">v6</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">v4</span> <span class="o">+</span> <span class="n">sub_275F</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">v8</span> <span class="o">+</span> <span class="mi">1LL</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)))</span> <span class="o">^</span> <span class="n">a1</span><span class="p">[</span><span class="n">v9</span> <span class="o">%</span> <span class="n">v10</span><span class="p">];</span>
    <span class="n">v8</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="o">++</span><span class="n">v9</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">v9</span> <span class="o">+</span> <span class="n">v6</span><span class="p">);</span>
  <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__int64</span> <span class="kr">__fastcall</span> <span class="nf">sub_275F</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int8</span> <span class="n">a1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">a1</span> <span class="o">&gt;</span> <span class="sc">'/'</span> <span class="o">&amp;&amp;</span> <span class="n">a1</span> <span class="o">&lt;=</span> <span class="sc">'9'</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">a1</span> <span class="o">-</span> <span class="mi">48</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">a1</span> <span class="o">&lt;=</span> <span class="sc">'9'</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">a1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">a1</span> <span class="o">-</span> <span class="sc">'W'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>简单来说，这段代码就是将输入的字符串转成十六进制值，同时每一位和一个密钥进行循环异或，综合前一个函数的调用情况，简单来说做了这些事情：</p>
<ol>
  <li>初始化一个密钥，其值是10000。</li>
  <li>将密钥打印到一个数组中，同时将其作为参数调用另一个函数，该函数将原函数的参数作为序号，将常量字符串转换成相应的十六进制值，同时和密钥进行异或。</li>
  <li>将异或的值进行md5计算，将结果和序号所指定的hash值对比，如果相等则退出，否则进行循环，将密钥加一，重复操作。</li>
</ol>

<p>至此，我们大致分析完了整个字符串解密的过程，这也能大致解释为什么这个程序运行的这么慢，主要是密钥的初始值太小，只有10000，或者说作者将指定的密钥设计的太大。而在这个程序中，经过自己调试，发现当密钥的值是13371337时满足条件，即可进行解密。完整idapython脚本如下所示，注意自己已经将密钥的初始化值设置为13371336，防止计算时间太慢。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">idaapi</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">idc</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">idautils</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">hashlib</span>

<span class="k">def</span> <span class="nf">getMd5</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
    <span class="n">m1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m1</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

<span class="n">secret</span> <span class="o">=</span> <span class="mh">0x8b80</span>
<span class="n">md5hash</span> <span class="o">=</span> <span class="mh">0x8be0</span>
<span class="n">iv</span> <span class="o">=</span> <span class="mi">13371336</span>
<span class="n">ivs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ivs</span><span class="p">:</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">(</span><span class="n">Qword</span><span class="p">(</span><span class="n">secret</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">)</span>
    <span class="nb">hash</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">(</span><span class="n">Qword</span><span class="p">(</span><span class="n">md5hash</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
    <span class="c1">#print init
</span>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="s">''</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">init</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">init</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">^</span> <span class="nb">ord</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]))</span>
        <span class="c1">#print t
</span>        <span class="k">if</span> <span class="n">getMd5</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">:</span>
            <span class="c1">#print key
</span>            <span class="k">print</span> <span class="n">t</span>
            <span class="k">break</span>
        <span class="n">iv</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>运行结果如下图所示。</p>

<p><img src="images/Snipaste_2019-01-21_20-16-37.png" alt="Snipaste_2019-01-21_20-16-37" /></p>

<p>注意整个解密过程是不包括偏移量是2的那个字符串的，因为他是真正的flag加密的字符串，可以用交叉引用来证明，同时该字符串是使用aes进行加密，和这里无关。</p>

<h2 id="主check逻辑">主check逻辑</h2>

<p>在完成字符串解密后，我们只能通过字符串引用的位置大致推测每一段check的作用是什么，比如第一个check就是判断输入参数是不是3个，第二个check判断输入长度是否满足大于15并且小于等于63。在满足这个条件的情况下，程序会输出<code class="highlighter-rouge">Computing stuff...</code>然后进入真正的check逻辑，下面开始分析。
如下图所示，首先滤去垃圾指令，在函数开头计算2个参数的长度，因为上文的检测，所以肯定满足小于等于63的条件，然后进入change1这个函数进行变换。</p>

<p><img src="images/Snipaste_2019-01-21_20-24-03.png" alt="Snipaste_2019-01-21_20-24-03" /></p>

<p>change1这个函数中又调用了另一个函数，如下图所示：</p>

<p><img src="images/Snipaste_2019-01-21_20-26-04.png" alt="Snipaste_2019-01-21_20-26-04" /></p>

<p>很明显这是用来进行素数判断的，将从零到某个数字范围内的所有素数都求出来，然后返回到这个集合。然后在change1中，求出字符串长度和64之间的差值，然后进行循环，将素数集合作为index，求出字符串对应index下的值，添加到字符串末尾，然后结束。</p>

<p><img src="images/Snipaste_2019-01-21_20-27-57.png" alt="Snipaste_2019-01-21_20-27-57" /></p>

<p>然后取出字符串中2个特定位置上的值，对其进行操作，这里由于参数1是指定的，所以我们可以进行部分化简，我的注释也标在图上了。</p>

<p><img src="images/Snipaste_2019-01-21_20-30-33.png" alt="Snipaste_2019-01-21_20-30-33" /></p>

<p>要注意的是，这里还定义了一个655大小的数组，也是变相进行混淆，然后程序还定义了一张表，从A到S，是为了映射用的，如下图所示，之后进行了一段很难理解的计算。</p>

<p><img src="images/Snipaste_2019-01-21_20-33-52.png" alt="Snipaste_2019-01-21_20-33-52" /></p>

<p>这段计算代码如下所示，如果真的是这样看的话，自己很难理解其中的意思，其真正的作用是计算十进制数的位数，之前在29c3 ctf中也有类似的<a href="https://baghaliteam.wordpress.com/2012/12/30/29c3ctf-bin300-maya/">题目解析</a>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span> <span class="n">v23</span> <span class="o">&amp;&amp;</span> <span class="n">i_1</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">v23</span> <span class="o">=</span> <span class="p">(((</span><span class="mh">0x6666666666666667LL</span> <span class="o">*</span> <span class="n">v23</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">v23</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">);</span>
  <span class="o">++</span><span class="n">i_1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>那么第二段何其类似的代码也能理解了，就是取整数的最低位，然后次低位这样，然后再映射到A到S的表中。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span> <span class="n">v24</span> <span class="o">&amp;&amp;</span> <span class="n">i_1</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">v10</span> <span class="o">=</span> <span class="n">v24</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">((((</span><span class="mh">0x6666666666666667LL</span> <span class="o">*</span> <span class="n">v24</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">v24</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">));</span>   <span class="c1">// 取最低位</span>
  <span class="n">v24</span> <span class="o">=</span> <span class="p">(((</span><span class="mh">0x6666666666666667LL</span> <span class="o">*</span> <span class="n">v24</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">v24</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">);</span>
  <span class="n">v11</span> <span class="o">=</span> <span class="n">i_1</span><span class="o">++</span><span class="p">;</span>
  <span class="n">v42</span><span class="p">[</span><span class="n">v11</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">v10</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后再用a来填充，对齐到16的倍数。比如上面计算出来的结果是123，那么3对应D，2对应C，1对应B，依次添加，最后的结果就是123DCBaaaaaaaaaa。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span> <span class="n">i_1</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v12</span> <span class="o">=</span> <span class="n">i_1</span><span class="o">++</span><span class="p">;</span>
    <span class="n">v42</span><span class="p">[</span><span class="n">v12</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>最后一步操作就是转成十六进制，然后取其5-8位，进行md5的计算，如果和给定的常量相同就算成功？</p>

<p><img src="images/Snipaste_2019-01-21_20-34-48.png" alt="Snipaste_2019-01-21_20-34-48" /></p>

<h2 id="求解过程">求解过程</h2>

<p>首先md5的原象只有4位，在很容易爆破，容易得到27debb435021eb68b3965290b5e24c49的原象是7303，那么我们需要的就是字符串5-8位是7303。idapython脚本如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">idaapi</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">idc</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">idautils</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">maketrans</span>

<span class="n">k</span> <span class="o">=</span> <span class="n">maketrans</span><span class="p">(</span><span class="s">"0123456789"</span><span class="p">,</span> <span class="s">"ABCDEFGHIJ"</span><span class="p">)</span>

<span class="n">cipherTable</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">655</span><span class="p">):</span>
    <span class="n">cipherTable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Dword</span><span class="p">(</span><span class="mh">0x8140</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">getflag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">sum1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="mi">634</span> <span class="o">+</span> <span class="n">cipherTable</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">892360</span>
    <span class="c1">#print sum1
</span>    
    <span class="n">s</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sum1</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">cipherTable</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">155</span> <span class="o">-</span> <span class="n">x</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">)[</span><span class="mi">5</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="s">'7303'</span><span class="p">:</span>
        <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s">'a'</span> <span class="o">*</span> <span class="mh">0x29</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">):</span>
        <span class="n">getflag</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
</code></pre></div></div>

<p>但是一共会得到90种不同的解，肯定不是每个解都对的，这里其实还有一个问题，因为flag是通过aes解密出来的，可能会存在数据错误，导致异常产生，我的办法就是一个一个试了，可以通过pwntools来实现自动化测试。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c1">#context.log_level = "debug"
</span><span class="n">name</span> <span class="o">=</span> <span class="s">"73FF9B24EF8DE48C346D93FADCEE01151B0A1644BC81"</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="p">[</span><span class="s">"./junkyard"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ans</span><span class="p">])</span>
<span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
</code></pre></div></div>

<p>最后得到正确的输入是2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaC，输入就能解密得到flag。</p>

<p><img src="images/Snipaste_2019-01-21_21-12-40.png" alt="Snipaste_2019-01-21_21-12-40" /></p>

<h2 id="总结-1">总结</h2>

<ol>
  <li>对于垃圾指令很多的情况，需要找出垃圾指令填充的规律，然后就能略去很大无用的代码。</li>
  <li>对于整体的解密思路还存在宏观把握不够的情况，具体表现在求素数那部分，其实那部分之后并没有用到，因为最后只用到了输入的其中2位，然后进行爆破就行了，所以还是多分析了很多部分，浪费了很多时间。</li>
  <li>学到了加密常量字符串的新方法，通过指定循环次数来进行哈希运算，可以对字符串进行保护，同时要进行哈希运算，加大了运行时间，减少了爆破的机会。</li>
</ol>


        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#wp" class="page__taxonomy-item" rel="tag">wp</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fa fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-01-21T14:47:00+08:00">January 21, 2019</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=Insomni%27hack+teaser+reverse+writeup%20http%3A%2F%2Flocalhost%3A4000%2Fposts%2F2019-01%2FInsomni%27hack-teaser-Reverse-WriteUp.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fa fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fposts%2F2019-01%2FInsomni%27hack-teaser-Reverse-WriteUp.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fa fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2F2019-01%2FInsomni%27hack-teaser-Reverse-WriteUp.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2019-01/AngrLearning-4.html" class="pagination--pager" title="Angrlearning 4
">Previous</a>
    
    
      <a href="/posts/2019-01/AngrLearning-5.html" class="pagination--pager" title="Angrlearning 5
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-11/Dirary_November.html" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/%E5%8D%81%E6%9C%88%E6%97%A5%E8%AE%B0.html" rel="permalink">十月日记
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




10月1日

周日，上课前最后一天，算是给自己放了最后一天假期

10月2日

上了第一天的课，主要是os，一脸蒙蔽。
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/1d25d6ba93.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <script>
    var disqus_config = function () {
      this.page.url = "http://localhost:4000/posts/2019-01/Insomni'hack-teaser-Reverse-WriteUp.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2019-01/Insomni'hack teaser Reverse WriteUp"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
