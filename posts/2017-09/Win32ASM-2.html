<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Win32asm 2  -  My way, though far away</title>
<meta name="description" content="  Windows 环境32位汇编语言程序设计PE文件格式概述首先PE文件分为DOS部分，PE文件头，节表和节数据一共4部分。DOS_HeaderMZ格式的文件头由IMAGE_DOS_HEADER结构体定义。最开始的DOS可执行文件的标记，为MZ。DOS_Header的大小为0x40。其中最后为PE文件头的偏移量：LONG AddressOfNewExeHeader，位置为文件头偏移0x003ch，大小为4字节。DOS_Stub可执行代码部分称为DOS stub。简单的显示一个“This program cannot be run in DOS mode.”。由于现在是NT结构，就不说了。NT_Header (PE文件头)NT_Header格式由IMAGE_NT_HEADER结构体定义。最开始是signature签名，被定义为00004550h，就是PE和两个0。IMAGE_FILE_HEADER结构体如下。struct IMAGE_FILE_HEADER{    Machine                 运行平台    NumberOfSections        节数目    TimeDateStamp           创建时间，从 1970-01-01 00:00 开始    PointerToSymbolTable    符号表指针，用于调试    NumberOfSymbols         符号表中符号数量，用于调试    SizeOfOptionalHeader    Optional结构大小，紧挨FILE_HEADER，为0xe0    Characteristics         文件属性。exe一般是0x010f，dll一般是0x210e。};IMAGE_OPTINONAL_HEADERoptional结构体本意是让开发者在pe文件头中使用自定义的数据，但实际上IMAGE_FILE_HEADER不足以定义PE的属性，所以optional并不是可选的。struct IMAGE_OPTIONAL_HEADER32{    Magic                           0x107 ROM Image; 0x108 EXE Image    MajorLinkerVersion    MinorLinkerVersion    SizeOfCode                      代码节大小    SizeOfInitializedData           已初始化代码节大小    SizeOfUninitializedData         未初始化代码节大小    AddressOfEntryPoint             程序执行入口RVA    BaseOfCode                      代码节起始RVA    BaseOfData                      数据节其实RVA    ImageBase                       装载地址    SectionAlignment    FileAlignment    MajorOperatingSystemVersion    MinorOperatingSystemVersion    MajorImageVersion    MinorImageVersion    MajorSubsystemVersion    MinorSubsystemVersion    Win32VersionValue    SizeOfImage                     载入内存PE镜像大小    SizeOfHeaders                   载入内存所有头+节表大小    CheckSum    Subsystem                       文件子系统    DllCharacteristics    SizeOfStackReserve              初始化堆栈大小    SizeOfStackCommit               初始化实际提交堆栈大小    SizeOfHeapReserve               初始化保留的堆大小    SizeOfHeapCommit                初始化实际提交的堆大小    LoaderFlags    NumberOfRvaAndSizes             下面的数据目录结构数量    DataDirArray};AddressOfEntryPoint指出文件执行的入口地址，是RVA地址。如果在exe中附加了一段代码并希望先执行，只需要修改这个入口地址就行了。ImageBase文件优先装入的地址，当文件不需要重定位的时候最快。对于exe文件来说，每个文件总是独立使用虚拟地址空间，其地址不可能被其他模块占据，exe一般不需要重定位。对于dll来说，由于多个dll文件全部使用宿主exe文件的地址空间，不能确保地址没有被其他dll占用，所以dll必须包含重定位信息。一般exe默认是0x00400000，dll是0x10000000。SubsystemWindows_CUI     win32控制台Windows_GUI     win32图形界面DataDirArray这个字段是比较重要的字段之一，各个节中的数据按照用途可以分为导出表，导入表，资源，重定位表数据块。要查看某个结构，就到这里查看某结构的位置和大小。节表和节PE文件到内存的映射Windows在装载可执行程序时候，对DOS头，PE文件头和节表部分不做任何处理，装载节的时候，根据节的属性做不同的处理。所以在同属一个模块的内存页中，从不同映射过来的内存页的属性的不同的。节是相同属性的数据的集合，所以节在内存中的对齐单位必须是一个页的大小。节的规模有大有小，首先由于磁盘映像和内存映像中节的对齐单位不同，其次是对包含未初始化的节的处理，如.data节。也有不进行映射的节，比如.reloc节，重定位数据对于文件的执行代码来说是透明的，它只对Windows装载器使用。节表PE文件中所有的节的属性都被定义在节表中，有一系列IMAGE_SECTION_HEADER的结构体排列组成，紧跟着PE文件头，从PE文件头开始偏移0x00f8的地方。struct IMAGE_SECTION_HEADER{    Name1                       8字节的节区名称    union Misc            PhysicalAddress                 VirtualSize         节区的实际大小    VirtualAddress              节区的RVA地址    SizeOfRawData               在文件中对齐的大小    PointerToRawData            文件中的偏移    PointerToRelocations            PointerToLinenumbers    NumberOfRelocations    NumberOfLinenumbers    Characteristics             节的属性};MASM32产生的exe文件中，代码节被命名为.text，可读写的数据节为.data，只读数据，导入表和导出表的节为.rdata，资源节为.rsrc。也有其他编译器将导入表放在.idata，中，代码节被命名为.code。PointerToRawDataPointerToRawData 是指出了节在磁盘文件中的偏移地址，从文件头开始计算。SizeOfRawDataSizeOfRawData 指出了某个节在磁盘文件中的大小。映射方式装载器从PE文件中找到某个节，即从PointerToRawData开始的大小为SizeOfRawData 的字节数据，把他们映射到内存中去，位置是从模块基址开始的偏移的VirtualAddress地方，并占用VirtualSize的值按照页大小的对齐。RVA和文件偏移的转换RVA是 relative virtual address的缩写，表示相对虚拟地址，是某个数据位置相对与文件头的位置。对于DOS头，DOS stub，PE头，节表来说，无所谓RVA和文件偏移。因为他们在文件中和内存映射中的大小和偏移都不变。RVA只是对节来说的。想要获得RVA对应的文件偏移，唯一的办法就是：如果目标RVA在某个节中，用目标RVA减去节的起始RVA’，获得数据在节中的偏移量。再通过PointerToRawData获得节在文件中的偏移，加上刚刚获得的偏移就是文件偏移量。导入表导入函数组成导入表，导入函数就是被程序调用的函数，但其代码不在程序中，这些代码位于一个或多个DLL中，调用程序中只保留一些函数信息。只有当PE文件装载入内存的时候，Windows装载器才将DLL装入，并调用导入函数指令和函数实际地址，这就是动态链接，这是依靠PE文件中的导入表来完成的。导入表结构导入表由一系列IMAGE_IMPORT_DESCRIPTOR结构组成，每个结构对应一个DLL文件，struct IMAGE_IMPORT_DESCRIPTOR{    union        Characteristics        OriginalFirstThunk      指向包含一系列IMAGE_THUNK_DATA的数组（不会变）    TimeDateStamp    ForwarderChain    Name1                       对应的DLL名称    FirstThunk                  指向包含一系列IMAGE_THUNK_DATA的数组（会改变）}IMAGE_THUNK_DATA的数组中每个元素定义了一个导入函数的信息，并且以0结尾。当最高位为1时，表示函数以序号方式导入，这时结构体的值是函数的序号。当最高位为0时，表示函数以字符串类型的函数名方式导入，这时结构体的值是个RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构。struct IMAGE_IMPORT_BY_NAME{    Hint    函数的序号，可选字段    Name1   导入函数的名称字符串，以0结尾。}当PE文件装载入内存时，FirstThunk所指向的数组的值都被替换成了真正的函数入口地址，这样做的目的是可以反过来查询地址的对应导入函数名。导入地址表 IAT把FirstThunk所指向的数组称为导入地址数组。在PE文件中，所有DLL对应的导入地址数组在位置上排列在一起，数组的组合称为导入地址表IAT。导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk指向的就是IAT的起始地址。或者可以通过数据目录表，查找数据目录表中第13项（索引值为12/IMAGE_DIRECTORY_ENTRY_IAT），直接用来定义IAT数据块的位置和大小。导出表和重定位表导出表在包含导出函数的DLL中，导出信息位于导出表，通过导出表，DLL文件向系统提供导出函数的名称，序号和入口地址。以便完成动态链接。重定位表首先要明白，在X86下，涉及到直接寻址的指令都是要重定位的。重定位算法将直接寻址的指令中的双字地址减去建议装载地址，获得RVA，再加上模块的实际装入地址，获得VA。由于建议装载地址在PE文件头中，而实际装入地址由装载器决定，所以重定位所需要的只是需要修正的代码的地址。重定位表的位置一般单独存放在一个可以丢弃的.reloc节中，和资源差不多，不是必须的。重定位表的位置可以由数据目录表IMAGE_DATA_DIRECTORY结构获取。获得重定位表位置后，地址指向的就是很多重定位块，每一块描述一个内存页的所有重定位项。每个重定位块分起始RVA和块长度，之后的重定位项低12位表示数据在当前页面中的RVA，高4为表示重定位项种类。假设模块装入地址为00400000h处。            重定位表偏移      数据      说明                  0000h      00001000h      第一个块，页面地址是00401000h              0004h      00000010h      该重定位块长度10h              0008h      3012h      重定位位置00401012h              000ah      3040h      重定位位置00401040h              000ch      306fh      重定位位置0040106fh              000eh      0000h      用于对齐的空白数据              0010h      00002000h      第一个块，页面地址是00402000h              0014h      0000000ch      该重定位块长度0ch              0018h      3080h      重定位位置00402080h              001ah      30f0h      重定位位置004020f0h              001ch      00000000h      重定位数据块结束标志      PE解析到这里就不详细讲了，以后若对这方面深入研究再说，具体资料可以查阅 WindowsPE权威指南。">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="Win32asm 2">
<meta property="og:url" content="https://zjgcjy.github.io/posts/2017-09/Win32ASM-2.html">


  <meta property="og:description" content="  Windows 环境32位汇编语言程序设计PE文件格式概述首先PE文件分为DOS部分，PE文件头，节表和节数据一共4部分。DOS_HeaderMZ格式的文件头由IMAGE_DOS_HEADER结构体定义。最开始的DOS可执行文件的标记，为MZ。DOS_Header的大小为0x40。其中最后为PE文件头的偏移量：LONG AddressOfNewExeHeader，位置为文件头偏移0x003ch，大小为4字节。DOS_Stub可执行代码部分称为DOS stub。简单的显示一个“This program cannot be run in DOS mode.”。由于现在是NT结构，就不说了。NT_Header (PE文件头)NT_Header格式由IMAGE_NT_HEADER结构体定义。最开始是signature签名，被定义为00004550h，就是PE和两个0。IMAGE_FILE_HEADER结构体如下。struct IMAGE_FILE_HEADER{    Machine                 运行平台    NumberOfSections        节数目    TimeDateStamp           创建时间，从 1970-01-01 00:00 开始    PointerToSymbolTable    符号表指针，用于调试    NumberOfSymbols         符号表中符号数量，用于调试    SizeOfOptionalHeader    Optional结构大小，紧挨FILE_HEADER，为0xe0    Characteristics         文件属性。exe一般是0x010f，dll一般是0x210e。};IMAGE_OPTINONAL_HEADERoptional结构体本意是让开发者在pe文件头中使用自定义的数据，但实际上IMAGE_FILE_HEADER不足以定义PE的属性，所以optional并不是可选的。struct IMAGE_OPTIONAL_HEADER32{    Magic                           0x107 ROM Image; 0x108 EXE Image    MajorLinkerVersion    MinorLinkerVersion    SizeOfCode                      代码节大小    SizeOfInitializedData           已初始化代码节大小    SizeOfUninitializedData         未初始化代码节大小    AddressOfEntryPoint             程序执行入口RVA    BaseOfCode                      代码节起始RVA    BaseOfData                      数据节其实RVA    ImageBase                       装载地址    SectionAlignment    FileAlignment    MajorOperatingSystemVersion    MinorOperatingSystemVersion    MajorImageVersion    MinorImageVersion    MajorSubsystemVersion    MinorSubsystemVersion    Win32VersionValue    SizeOfImage                     载入内存PE镜像大小    SizeOfHeaders                   载入内存所有头+节表大小    CheckSum    Subsystem                       文件子系统    DllCharacteristics    SizeOfStackReserve              初始化堆栈大小    SizeOfStackCommit               初始化实际提交堆栈大小    SizeOfHeapReserve               初始化保留的堆大小    SizeOfHeapCommit                初始化实际提交的堆大小    LoaderFlags    NumberOfRvaAndSizes             下面的数据目录结构数量    DataDirArray};AddressOfEntryPoint指出文件执行的入口地址，是RVA地址。如果在exe中附加了一段代码并希望先执行，只需要修改这个入口地址就行了。ImageBase文件优先装入的地址，当文件不需要重定位的时候最快。对于exe文件来说，每个文件总是独立使用虚拟地址空间，其地址不可能被其他模块占据，exe一般不需要重定位。对于dll来说，由于多个dll文件全部使用宿主exe文件的地址空间，不能确保地址没有被其他dll占用，所以dll必须包含重定位信息。一般exe默认是0x00400000，dll是0x10000000。SubsystemWindows_CUI     win32控制台Windows_GUI     win32图形界面DataDirArray这个字段是比较重要的字段之一，各个节中的数据按照用途可以分为导出表，导入表，资源，重定位表数据块。要查看某个结构，就到这里查看某结构的位置和大小。节表和节PE文件到内存的映射Windows在装载可执行程序时候，对DOS头，PE文件头和节表部分不做任何处理，装载节的时候，根据节的属性做不同的处理。所以在同属一个模块的内存页中，从不同映射过来的内存页的属性的不同的。节是相同属性的数据的集合，所以节在内存中的对齐单位必须是一个页的大小。节的规模有大有小，首先由于磁盘映像和内存映像中节的对齐单位不同，其次是对包含未初始化的节的处理，如.data节。也有不进行映射的节，比如.reloc节，重定位数据对于文件的执行代码来说是透明的，它只对Windows装载器使用。节表PE文件中所有的节的属性都被定义在节表中，有一系列IMAGE_SECTION_HEADER的结构体排列组成，紧跟着PE文件头，从PE文件头开始偏移0x00f8的地方。struct IMAGE_SECTION_HEADER{    Name1                       8字节的节区名称    union Misc            PhysicalAddress                 VirtualSize         节区的实际大小    VirtualAddress              节区的RVA地址    SizeOfRawData               在文件中对齐的大小    PointerToRawData            文件中的偏移    PointerToRelocations            PointerToLinenumbers    NumberOfRelocations    NumberOfLinenumbers    Characteristics             节的属性};MASM32产生的exe文件中，代码节被命名为.text，可读写的数据节为.data，只读数据，导入表和导出表的节为.rdata，资源节为.rsrc。也有其他编译器将导入表放在.idata，中，代码节被命名为.code。PointerToRawDataPointerToRawData 是指出了节在磁盘文件中的偏移地址，从文件头开始计算。SizeOfRawDataSizeOfRawData 指出了某个节在磁盘文件中的大小。映射方式装载器从PE文件中找到某个节，即从PointerToRawData开始的大小为SizeOfRawData 的字节数据，把他们映射到内存中去，位置是从模块基址开始的偏移的VirtualAddress地方，并占用VirtualSize的值按照页大小的对齐。RVA和文件偏移的转换RVA是 relative virtual address的缩写，表示相对虚拟地址，是某个数据位置相对与文件头的位置。对于DOS头，DOS stub，PE头，节表来说，无所谓RVA和文件偏移。因为他们在文件中和内存映射中的大小和偏移都不变。RVA只是对节来说的。想要获得RVA对应的文件偏移，唯一的办法就是：如果目标RVA在某个节中，用目标RVA减去节的起始RVA’，获得数据在节中的偏移量。再通过PointerToRawData获得节在文件中的偏移，加上刚刚获得的偏移就是文件偏移量。导入表导入函数组成导入表，导入函数就是被程序调用的函数，但其代码不在程序中，这些代码位于一个或多个DLL中，调用程序中只保留一些函数信息。只有当PE文件装载入内存的时候，Windows装载器才将DLL装入，并调用导入函数指令和函数实际地址，这就是动态链接，这是依靠PE文件中的导入表来完成的。导入表结构导入表由一系列IMAGE_IMPORT_DESCRIPTOR结构组成，每个结构对应一个DLL文件，struct IMAGE_IMPORT_DESCRIPTOR{    union        Characteristics        OriginalFirstThunk      指向包含一系列IMAGE_THUNK_DATA的数组（不会变）    TimeDateStamp    ForwarderChain    Name1                       对应的DLL名称    FirstThunk                  指向包含一系列IMAGE_THUNK_DATA的数组（会改变）}IMAGE_THUNK_DATA的数组中每个元素定义了一个导入函数的信息，并且以0结尾。当最高位为1时，表示函数以序号方式导入，这时结构体的值是函数的序号。当最高位为0时，表示函数以字符串类型的函数名方式导入，这时结构体的值是个RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构。struct IMAGE_IMPORT_BY_NAME{    Hint    函数的序号，可选字段    Name1   导入函数的名称字符串，以0结尾。}当PE文件装载入内存时，FirstThunk所指向的数组的值都被替换成了真正的函数入口地址，这样做的目的是可以反过来查询地址的对应导入函数名。导入地址表 IAT把FirstThunk所指向的数组称为导入地址数组。在PE文件中，所有DLL对应的导入地址数组在位置上排列在一起，数组的组合称为导入地址表IAT。导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk指向的就是IAT的起始地址。或者可以通过数据目录表，查找数据目录表中第13项（索引值为12/IMAGE_DIRECTORY_ENTRY_IAT），直接用来定义IAT数据块的位置和大小。导出表和重定位表导出表在包含导出函数的DLL中，导出信息位于导出表，通过导出表，DLL文件向系统提供导出函数的名称，序号和入口地址。以便完成动态链接。重定位表首先要明白，在X86下，涉及到直接寻址的指令都是要重定位的。重定位算法将直接寻址的指令中的双字地址减去建议装载地址，获得RVA，再加上模块的实际装入地址，获得VA。由于建议装载地址在PE文件头中，而实际装入地址由装载器决定，所以重定位所需要的只是需要修正的代码的地址。重定位表的位置一般单独存放在一个可以丢弃的.reloc节中，和资源差不多，不是必须的。重定位表的位置可以由数据目录表IMAGE_DATA_DIRECTORY结构获取。获得重定位表位置后，地址指向的就是很多重定位块，每一块描述一个内存页的所有重定位项。每个重定位块分起始RVA和块长度，之后的重定位项低12位表示数据在当前页面中的RVA，高4为表示重定位项种类。假设模块装入地址为00400000h处。            重定位表偏移      数据      说明                  0000h      00001000h      第一个块，页面地址是00401000h              0004h      00000010h      该重定位块长度10h              0008h      3012h      重定位位置00401012h              000ah      3040h      重定位位置00401040h              000ch      306fh      重定位位置0040106fh              000eh      0000h      用于对齐的空白数据              0010h      00002000h      第一个块，页面地址是00402000h              0014h      0000000ch      该重定位块长度0ch              0018h      3080h      重定位位置00402080h              001ah      30f0h      重定位位置004020f0h              001ch      00000000h      重定位数据块结束标志      PE解析到这里就不详细讲了，以后若对这方面深入研究再说，具体资料可以查阅 WindowsPE权威指南。">



  <meta property="og:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="Win32asm 2">
  <meta name="twitter:description" content="  Windows 环境32位汇编语言程序设计PE文件格式概述首先PE文件分为DOS部分，PE文件头，节表和节数据一共4部分。DOS_HeaderMZ格式的文件头由IMAGE_DOS_HEADER结构体定义。最开始的DOS可执行文件的标记，为MZ。DOS_Header的大小为0x40。其中最后为PE文件头的偏移量：LONG AddressOfNewExeHeader，位置为文件头偏移0x003ch，大小为4字节。DOS_Stub可执行代码部分称为DOS stub。简单的显示一个“This program cannot be run in DOS mode.”。由于现在是NT结构，就不说了。NT_Header (PE文件头)NT_Header格式由IMAGE_NT_HEADER结构体定义。最开始是signature签名，被定义为00004550h，就是PE和两个0。IMAGE_FILE_HEADER结构体如下。struct IMAGE_FILE_HEADER{    Machine                 运行平台    NumberOfSections        节数目    TimeDateStamp           创建时间，从 1970-01-01 00:00 开始    PointerToSymbolTable    符号表指针，用于调试    NumberOfSymbols         符号表中符号数量，用于调试    SizeOfOptionalHeader    Optional结构大小，紧挨FILE_HEADER，为0xe0    Characteristics         文件属性。exe一般是0x010f，dll一般是0x210e。};IMAGE_OPTINONAL_HEADERoptional结构体本意是让开发者在pe文件头中使用自定义的数据，但实际上IMAGE_FILE_HEADER不足以定义PE的属性，所以optional并不是可选的。struct IMAGE_OPTIONAL_HEADER32{    Magic                           0x107 ROM Image; 0x108 EXE Image    MajorLinkerVersion    MinorLinkerVersion    SizeOfCode                      代码节大小    SizeOfInitializedData           已初始化代码节大小    SizeOfUninitializedData         未初始化代码节大小    AddressOfEntryPoint             程序执行入口RVA    BaseOfCode                      代码节起始RVA    BaseOfData                      数据节其实RVA    ImageBase                       装载地址    SectionAlignment    FileAlignment    MajorOperatingSystemVersion    MinorOperatingSystemVersion    MajorImageVersion    MinorImageVersion    MajorSubsystemVersion    MinorSubsystemVersion    Win32VersionValue    SizeOfImage                     载入内存PE镜像大小    SizeOfHeaders                   载入内存所有头+节表大小    CheckSum    Subsystem                       文件子系统    DllCharacteristics    SizeOfStackReserve              初始化堆栈大小    SizeOfStackCommit               初始化实际提交堆栈大小    SizeOfHeapReserve               初始化保留的堆大小    SizeOfHeapCommit                初始化实际提交的堆大小    LoaderFlags    NumberOfRvaAndSizes             下面的数据目录结构数量    DataDirArray};AddressOfEntryPoint指出文件执行的入口地址，是RVA地址。如果在exe中附加了一段代码并希望先执行，只需要修改这个入口地址就行了。ImageBase文件优先装入的地址，当文件不需要重定位的时候最快。对于exe文件来说，每个文件总是独立使用虚拟地址空间，其地址不可能被其他模块占据，exe一般不需要重定位。对于dll来说，由于多个dll文件全部使用宿主exe文件的地址空间，不能确保地址没有被其他dll占用，所以dll必须包含重定位信息。一般exe默认是0x00400000，dll是0x10000000。SubsystemWindows_CUI     win32控制台Windows_GUI     win32图形界面DataDirArray这个字段是比较重要的字段之一，各个节中的数据按照用途可以分为导出表，导入表，资源，重定位表数据块。要查看某个结构，就到这里查看某结构的位置和大小。节表和节PE文件到内存的映射Windows在装载可执行程序时候，对DOS头，PE文件头和节表部分不做任何处理，装载节的时候，根据节的属性做不同的处理。所以在同属一个模块的内存页中，从不同映射过来的内存页的属性的不同的。节是相同属性的数据的集合，所以节在内存中的对齐单位必须是一个页的大小。节的规模有大有小，首先由于磁盘映像和内存映像中节的对齐单位不同，其次是对包含未初始化的节的处理，如.data节。也有不进行映射的节，比如.reloc节，重定位数据对于文件的执行代码来说是透明的，它只对Windows装载器使用。节表PE文件中所有的节的属性都被定义在节表中，有一系列IMAGE_SECTION_HEADER的结构体排列组成，紧跟着PE文件头，从PE文件头开始偏移0x00f8的地方。struct IMAGE_SECTION_HEADER{    Name1                       8字节的节区名称    union Misc            PhysicalAddress                 VirtualSize         节区的实际大小    VirtualAddress              节区的RVA地址    SizeOfRawData               在文件中对齐的大小    PointerToRawData            文件中的偏移    PointerToRelocations            PointerToLinenumbers    NumberOfRelocations    NumberOfLinenumbers    Characteristics             节的属性};MASM32产生的exe文件中，代码节被命名为.text，可读写的数据节为.data，只读数据，导入表和导出表的节为.rdata，资源节为.rsrc。也有其他编译器将导入表放在.idata，中，代码节被命名为.code。PointerToRawDataPointerToRawData 是指出了节在磁盘文件中的偏移地址，从文件头开始计算。SizeOfRawDataSizeOfRawData 指出了某个节在磁盘文件中的大小。映射方式装载器从PE文件中找到某个节，即从PointerToRawData开始的大小为SizeOfRawData 的字节数据，把他们映射到内存中去，位置是从模块基址开始的偏移的VirtualAddress地方，并占用VirtualSize的值按照页大小的对齐。RVA和文件偏移的转换RVA是 relative virtual address的缩写，表示相对虚拟地址，是某个数据位置相对与文件头的位置。对于DOS头，DOS stub，PE头，节表来说，无所谓RVA和文件偏移。因为他们在文件中和内存映射中的大小和偏移都不变。RVA只是对节来说的。想要获得RVA对应的文件偏移，唯一的办法就是：如果目标RVA在某个节中，用目标RVA减去节的起始RVA’，获得数据在节中的偏移量。再通过PointerToRawData获得节在文件中的偏移，加上刚刚获得的偏移就是文件偏移量。导入表导入函数组成导入表，导入函数就是被程序调用的函数，但其代码不在程序中，这些代码位于一个或多个DLL中，调用程序中只保留一些函数信息。只有当PE文件装载入内存的时候，Windows装载器才将DLL装入，并调用导入函数指令和函数实际地址，这就是动态链接，这是依靠PE文件中的导入表来完成的。导入表结构导入表由一系列IMAGE_IMPORT_DESCRIPTOR结构组成，每个结构对应一个DLL文件，struct IMAGE_IMPORT_DESCRIPTOR{    union        Characteristics        OriginalFirstThunk      指向包含一系列IMAGE_THUNK_DATA的数组（不会变）    TimeDateStamp    ForwarderChain    Name1                       对应的DLL名称    FirstThunk                  指向包含一系列IMAGE_THUNK_DATA的数组（会改变）}IMAGE_THUNK_DATA的数组中每个元素定义了一个导入函数的信息，并且以0结尾。当最高位为1时，表示函数以序号方式导入，这时结构体的值是函数的序号。当最高位为0时，表示函数以字符串类型的函数名方式导入，这时结构体的值是个RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构。struct IMAGE_IMPORT_BY_NAME{    Hint    函数的序号，可选字段    Name1   导入函数的名称字符串，以0结尾。}当PE文件装载入内存时，FirstThunk所指向的数组的值都被替换成了真正的函数入口地址，这样做的目的是可以反过来查询地址的对应导入函数名。导入地址表 IAT把FirstThunk所指向的数组称为导入地址数组。在PE文件中，所有DLL对应的导入地址数组在位置上排列在一起，数组的组合称为导入地址表IAT。导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk指向的就是IAT的起始地址。或者可以通过数据目录表，查找数据目录表中第13项（索引值为12/IMAGE_DIRECTORY_ENTRY_IAT），直接用来定义IAT数据块的位置和大小。导出表和重定位表导出表在包含导出函数的DLL中，导出信息位于导出表，通过导出表，DLL文件向系统提供导出函数的名称，序号和入口地址。以便完成动态链接。重定位表首先要明白，在X86下，涉及到直接寻址的指令都是要重定位的。重定位算法将直接寻址的指令中的双字地址减去建议装载地址，获得RVA，再加上模块的实际装入地址，获得VA。由于建议装载地址在PE文件头中，而实际装入地址由装载器决定，所以重定位所需要的只是需要修正的代码的地址。重定位表的位置一般单独存放在一个可以丢弃的.reloc节中，和资源差不多，不是必须的。重定位表的位置可以由数据目录表IMAGE_DATA_DIRECTORY结构获取。获得重定位表位置后，地址指向的就是很多重定位块，每一块描述一个内存页的所有重定位项。每个重定位块分起始RVA和块长度，之后的重定位项低12位表示数据在当前页面中的RVA，高4为表示重定位项种类。假设模块装入地址为00400000h处。            重定位表偏移      数据      说明                  0000h      00001000h      第一个块，页面地址是00401000h              0004h      00000010h      该重定位块长度10h              0008h      3012h      重定位位置00401012h              000ah      3040h      重定位位置00401040h              000ch      306fh      重定位位置0040106fh              000eh      0000h      用于对齐的空白数据              0010h      00002000h      第一个块，页面地址是00402000h              0014h      0000000ch      该重定位块长度0ch              0018h      3080h      重定位位置00402080h              001ah      30f0h      重定位位置004020f0h              001ch      00000000h      重定位数据块结束标志      PE解析到这里就不详细讲了，以后若对这方面深入研究再说，具体资料可以查阅 WindowsPE权威指南。">
  <meta name="twitter:url" content="https://zjgcjy.github.io/posts/2017-09/Win32ASM-2.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2017-09-08T06:44:00+08:00">





  

  


<link rel="canonical" href="https://zjgcjy.github.io/posts/2017-09/Win32ASM-2.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "https://zjgcjy.github.io/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/apple-touch-icon.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about.html" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fa fa-map-marker" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fa fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fa fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Win32asm 2">
    <meta itemprop="description" content="  Windows 环境32位汇编语言程序设计PE文件格式概述首先PE文件分为DOS部分，PE文件头，节表和节数据一共4部分。DOS_HeaderMZ格式的文件头由IMAGE_DOS_HEADER结构体定义。最开始的DOS可执行文件的标记，为MZ。DOS_Header的大小为0x40。其中最后为PE文件头的偏移量：LONG AddressOfNewExeHeader，位置为文件头偏移0x003ch，大小为4字节。DOS_Stub可执行代码部分称为DOS stub。简单的显示一个“This program cannot be run in DOS mode.”。由于现在是NT结构，就不说了。NT_Header (PE文件头)NT_Header格式由IMAGE_NT_HEADER结构体定义。最开始是signature签名，被定义为00004550h，就是PE和两个0。IMAGE_FILE_HEADER结构体如下。struct IMAGE_FILE_HEADER{    Machine                 运行平台    NumberOfSections        节数目    TimeDateStamp           创建时间，从 1970-01-01 00:00 开始    PointerToSymbolTable    符号表指针，用于调试    NumberOfSymbols         符号表中符号数量，用于调试    SizeOfOptionalHeader    Optional结构大小，紧挨FILE_HEADER，为0xe0    Characteristics         文件属性。exe一般是0x010f，dll一般是0x210e。};IMAGE_OPTINONAL_HEADERoptional结构体本意是让开发者在pe文件头中使用自定义的数据，但实际上IMAGE_FILE_HEADER不足以定义PE的属性，所以optional并不是可选的。struct IMAGE_OPTIONAL_HEADER32{    Magic                           0x107 ROM Image; 0x108 EXE Image    MajorLinkerVersion    MinorLinkerVersion    SizeOfCode                      代码节大小    SizeOfInitializedData           已初始化代码节大小    SizeOfUninitializedData         未初始化代码节大小    AddressOfEntryPoint             程序执行入口RVA    BaseOfCode                      代码节起始RVA    BaseOfData                      数据节其实RVA    ImageBase                       装载地址    SectionAlignment    FileAlignment    MajorOperatingSystemVersion    MinorOperatingSystemVersion    MajorImageVersion    MinorImageVersion    MajorSubsystemVersion    MinorSubsystemVersion    Win32VersionValue    SizeOfImage                     载入内存PE镜像大小    SizeOfHeaders                   载入内存所有头+节表大小    CheckSum    Subsystem                       文件子系统    DllCharacteristics    SizeOfStackReserve              初始化堆栈大小    SizeOfStackCommit               初始化实际提交堆栈大小    SizeOfHeapReserve               初始化保留的堆大小    SizeOfHeapCommit                初始化实际提交的堆大小    LoaderFlags    NumberOfRvaAndSizes             下面的数据目录结构数量    DataDirArray};AddressOfEntryPoint指出文件执行的入口地址，是RVA地址。如果在exe中附加了一段代码并希望先执行，只需要修改这个入口地址就行了。ImageBase文件优先装入的地址，当文件不需要重定位的时候最快。对于exe文件来说，每个文件总是独立使用虚拟地址空间，其地址不可能被其他模块占据，exe一般不需要重定位。对于dll来说，由于多个dll文件全部使用宿主exe文件的地址空间，不能确保地址没有被其他dll占用，所以dll必须包含重定位信息。一般exe默认是0x00400000，dll是0x10000000。SubsystemWindows_CUI     win32控制台Windows_GUI     win32图形界面DataDirArray这个字段是比较重要的字段之一，各个节中的数据按照用途可以分为导出表，导入表，资源，重定位表数据块。要查看某个结构，就到这里查看某结构的位置和大小。节表和节PE文件到内存的映射Windows在装载可执行程序时候，对DOS头，PE文件头和节表部分不做任何处理，装载节的时候，根据节的属性做不同的处理。所以在同属一个模块的内存页中，从不同映射过来的内存页的属性的不同的。节是相同属性的数据的集合，所以节在内存中的对齐单位必须是一个页的大小。节的规模有大有小，首先由于磁盘映像和内存映像中节的对齐单位不同，其次是对包含未初始化的节的处理，如.data节。也有不进行映射的节，比如.reloc节，重定位数据对于文件的执行代码来说是透明的，它只对Windows装载器使用。节表PE文件中所有的节的属性都被定义在节表中，有一系列IMAGE_SECTION_HEADER的结构体排列组成，紧跟着PE文件头，从PE文件头开始偏移0x00f8的地方。struct IMAGE_SECTION_HEADER{    Name1                       8字节的节区名称    union Misc            PhysicalAddress                 VirtualSize         节区的实际大小    VirtualAddress              节区的RVA地址    SizeOfRawData               在文件中对齐的大小    PointerToRawData            文件中的偏移    PointerToRelocations            PointerToLinenumbers    NumberOfRelocations    NumberOfLinenumbers    Characteristics             节的属性};MASM32产生的exe文件中，代码节被命名为.text，可读写的数据节为.data，只读数据，导入表和导出表的节为.rdata，资源节为.rsrc。也有其他编译器将导入表放在.idata，中，代码节被命名为.code。PointerToRawDataPointerToRawData 是指出了节在磁盘文件中的偏移地址，从文件头开始计算。SizeOfRawDataSizeOfRawData 指出了某个节在磁盘文件中的大小。映射方式装载器从PE文件中找到某个节，即从PointerToRawData开始的大小为SizeOfRawData 的字节数据，把他们映射到内存中去，位置是从模块基址开始的偏移的VirtualAddress地方，并占用VirtualSize的值按照页大小的对齐。RVA和文件偏移的转换RVA是 relative virtual address的缩写，表示相对虚拟地址，是某个数据位置相对与文件头的位置。对于DOS头，DOS stub，PE头，节表来说，无所谓RVA和文件偏移。因为他们在文件中和内存映射中的大小和偏移都不变。RVA只是对节来说的。想要获得RVA对应的文件偏移，唯一的办法就是：如果目标RVA在某个节中，用目标RVA减去节的起始RVA’，获得数据在节中的偏移量。再通过PointerToRawData获得节在文件中的偏移，加上刚刚获得的偏移就是文件偏移量。导入表导入函数组成导入表，导入函数就是被程序调用的函数，但其代码不在程序中，这些代码位于一个或多个DLL中，调用程序中只保留一些函数信息。只有当PE文件装载入内存的时候，Windows装载器才将DLL装入，并调用导入函数指令和函数实际地址，这就是动态链接，这是依靠PE文件中的导入表来完成的。导入表结构导入表由一系列IMAGE_IMPORT_DESCRIPTOR结构组成，每个结构对应一个DLL文件，struct IMAGE_IMPORT_DESCRIPTOR{    union        Characteristics        OriginalFirstThunk      指向包含一系列IMAGE_THUNK_DATA的数组（不会变）    TimeDateStamp    ForwarderChain    Name1                       对应的DLL名称    FirstThunk                  指向包含一系列IMAGE_THUNK_DATA的数组（会改变）}IMAGE_THUNK_DATA的数组中每个元素定义了一个导入函数的信息，并且以0结尾。当最高位为1时，表示函数以序号方式导入，这时结构体的值是函数的序号。当最高位为0时，表示函数以字符串类型的函数名方式导入，这时结构体的值是个RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构。struct IMAGE_IMPORT_BY_NAME{    Hint    函数的序号，可选字段    Name1   导入函数的名称字符串，以0结尾。}当PE文件装载入内存时，FirstThunk所指向的数组的值都被替换成了真正的函数入口地址，这样做的目的是可以反过来查询地址的对应导入函数名。导入地址表 IAT把FirstThunk所指向的数组称为导入地址数组。在PE文件中，所有DLL对应的导入地址数组在位置上排列在一起，数组的组合称为导入地址表IAT。导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk指向的就是IAT的起始地址。或者可以通过数据目录表，查找数据目录表中第13项（索引值为12/IMAGE_DIRECTORY_ENTRY_IAT），直接用来定义IAT数据块的位置和大小。导出表和重定位表导出表在包含导出函数的DLL中，导出信息位于导出表，通过导出表，DLL文件向系统提供导出函数的名称，序号和入口地址。以便完成动态链接。重定位表首先要明白，在X86下，涉及到直接寻址的指令都是要重定位的。重定位算法将直接寻址的指令中的双字地址减去建议装载地址，获得RVA，再加上模块的实际装入地址，获得VA。由于建议装载地址在PE文件头中，而实际装入地址由装载器决定，所以重定位所需要的只是需要修正的代码的地址。重定位表的位置一般单独存放在一个可以丢弃的.reloc节中，和资源差不多，不是必须的。重定位表的位置可以由数据目录表IMAGE_DATA_DIRECTORY结构获取。获得重定位表位置后，地址指向的就是很多重定位块，每一块描述一个内存页的所有重定位项。每个重定位块分起始RVA和块长度，之后的重定位项低12位表示数据在当前页面中的RVA，高4为表示重定位项种类。假设模块装入地址为00400000h处。            重定位表偏移      数据      说明                  0000h      00001000h      第一个块，页面地址是00401000h              0004h      00000010h      该重定位块长度10h              0008h      3012h      重定位位置00401012h              000ah      3040h      重定位位置00401040h              000ch      306fh      重定位位置0040106fh              000eh      0000h      用于对齐的空白数据              0010h      00002000h      第一个块，页面地址是00402000h              0014h      0000000ch      该重定位块长度0ch              0018h      3080h      重定位位置00402080h              001ah      30f0h      重定位位置004020f0h              001ch      00000000h      重定位数据块结束标志      PE解析到这里就不详细讲了，以后若对这方面深入研究再说，具体资料可以查阅 WindowsPE权威指南。">
    <meta itemprop="datePublished" content="September 08, 2017">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Win32asm 2
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#概述">概述</a></li>
  <li><a href="#dos_header">DOS_Header</a>
    <ul>
      <li><a href="#dos_stub">DOS_Stub</a></li>
    </ul>
  </li>
  <li><a href="#nt_header-pe文件头">NT_Header (PE文件头)</a>
    <ul>
      <li><a href="#image_file_header">IMAGE_FILE_HEADER</a></li>
      <li><a href="#image_optinonal_header">IMAGE_OPTINONAL_HEADER</a>
        <ul>
          <li><a href="#addressofentrypoint">AddressOfEntryPoint</a></li>
          <li><a href="#imagebase">ImageBase</a></li>
          <li><a href="#subsystem">Subsystem</a></li>
          <li><a href="#datadirarray">DataDirArray</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#节表和节">节表和节</a>
    <ul>
      <li><a href="#pe文件到内存的映射">PE文件到内存的映射</a></li>
      <li><a href="#节表">节表</a>
        <ul>
          <li><a href="#pointertorawdata">PointerToRawData</a></li>
          <li><a href="#sizeofrawdata">SizeOfRawData</a></li>
        </ul>
      </li>
      <li><a href="#映射方式">映射方式</a></li>
      <li><a href="#rva和文件偏移的转换">RVA和文件偏移的转换</a></li>
    </ul>
  </li>
  <li><a href="#导入表">导入表</a>
    <ul>
      <li><a href="#导入表结构">导入表结构</a></li>
      <li><a href="#导入地址表-iat">导入地址表 IAT</a></li>
    </ul>
  </li>
  <li><a href="#导出表和重定位表">导出表和重定位表</a>
    <ul>
      <li><a href="#导出表">导出表</a></li>
      <li><a href="#重定位表">重定位表</a>
        <ul>
          <li><a href="#重定位算法">重定位算法</a></li>
          <li><a href="#重定位表的位置">重定位表的位置</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <hr />

<blockquote>
  <p>Windows 环境32位汇编语言程序设计</p>
</blockquote>

<p>PE文件格式</p>

<h1 id="概述">概述</h1>

<p>首先PE文件分为DOS部分，PE文件头，节表和节数据一共4部分。</p>

<h1 id="dos_header">DOS_Header</h1>

<p>MZ格式的文件头由IMAGE_DOS_HEADER结构体定义。最开始的DOS可执行文件的标记，为MZ。
DOS_Header的大小为0x40。其中最后为PE文件头的偏移量：LONG AddressOfNewExeHeader，位置为文件头偏移0x003ch，大小为4字节。</p>

<h2 id="dos_stub">DOS_Stub</h2>

<p>可执行代码部分称为DOS stub。简单的显示一个“This program cannot be run in DOS mode.”。由于现在是NT结构，就不说了。</p>

<h1 id="nt_header-pe文件头">NT_Header (PE文件头)</h1>

<p>NT_Header格式由IMAGE_NT_HEADER结构体定义。最开始是signature签名，被定义为00004550h，就是PE和两个0。</p>

<h2 id="image_file_header">IMAGE_FILE_HEADER</h2>

<p>结构体如下。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">IMAGE_FILE_HEADER</span>
<span class="p">{</span>
    <span class="n">Machine</span>                 <span class="err">运行平台</span>
    <span class="n">NumberOfSections</span>        <span class="err">节数目</span>
    <span class="n">TimeDateStamp</span>           <span class="err">创建时间，从</span> <span class="mi">1970</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span> <span class="err">开始</span>
    <span class="n">PointerToSymbolTable</span>    <span class="err">符号表指针，用于调试</span>
    <span class="n">NumberOfSymbols</span>         <span class="err">符号表中符号数量，用于调试</span>
    <span class="n">SizeOfOptionalHeader</span>    <span class="n">Optional</span><span class="err">结构大小，紧挨</span><span class="n">FILE_HEADER</span><span class="err">，为</span><span class="mh">0xe0</span>
    <span class="n">Characteristics</span>         <span class="err">文件属性。</span><span class="n">exe</span><span class="err">一般是</span><span class="mh">0x010f</span><span class="err">，</span><span class="n">dll</span><span class="err">一般是</span><span class="mh">0x210e</span><span class="err">。</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="image_optinonal_header">IMAGE_OPTINONAL_HEADER</h2>

<p>optional结构体本意是让开发者在pe文件头中使用自定义的数据，但实际上IMAGE_FILE_HEADER不足以定义PE的属性，所以optional并不是可选的。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">IMAGE_OPTIONAL_HEADER32</span>
<span class="p">{</span>
    <span class="n">Magic</span>                           <span class="mh">0x107</span> <span class="n">ROM</span> <span class="n">Image</span><span class="p">;</span> <span class="mh">0x108</span> <span class="n">EXE</span> <span class="n">Image</span>
    <span class="n">MajorLinkerVersion</span>
    <span class="n">MinorLinkerVersion</span>
    <span class="n">SizeOfCode</span>                      <span class="err">代码节大小</span>
    <span class="n">SizeOfInitializedData</span>           <span class="err">已初始化代码节大小</span>
    <span class="n">SizeOfUninitializedData</span>         <span class="err">未初始化代码节大小</span>
    <span class="n">AddressOfEntryPoint</span>             <span class="err">程序执行入口</span><span class="n">RVA</span>
    <span class="n">BaseOfCode</span>                      <span class="err">代码节起始</span><span class="n">RVA</span>
    <span class="n">BaseOfData</span>                      <span class="err">数据节其实</span><span class="n">RVA</span>
    <span class="n">ImageBase</span>                       <span class="err">装载地址</span>
    <span class="n">SectionAlignment</span>
    <span class="n">FileAlignment</span>
    <span class="n">MajorOperatingSystemVersion</span>
    <span class="n">MinorOperatingSystemVersion</span>
    <span class="n">MajorImageVersion</span>
    <span class="n">MinorImageVersion</span>
    <span class="n">MajorSubsystemVersion</span>
    <span class="n">MinorSubsystemVersion</span>
    <span class="n">Win32VersionValue</span>
    <span class="n">SizeOfImage</span>                     <span class="err">载入内存</span><span class="n">PE</span><span class="err">镜像大小</span>
    <span class="n">SizeOfHeaders</span>                   <span class="err">载入内存所有头</span><span class="o">+</span><span class="err">节表大小</span>
    <span class="n">CheckSum</span>
    <span class="n">Subsystem</span>                       <span class="err">文件子系统</span>
    <span class="n">DllCharacteristics</span>
    <span class="n">SizeOfStackReserve</span>              <span class="err">初始化堆栈大小</span>
    <span class="n">SizeOfStackCommit</span>               <span class="err">初始化实际提交堆栈大小</span>
    <span class="n">SizeOfHeapReserve</span>               <span class="err">初始化保留的堆大小</span>
    <span class="n">SizeOfHeapCommit</span>                <span class="err">初始化实际提交的堆大小</span>
    <span class="n">LoaderFlags</span>
    <span class="n">NumberOfRvaAndSizes</span>             <span class="err">下面的数据目录结构数量</span>
    <span class="n">DataDirArray</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="addressofentrypoint">AddressOfEntryPoint</h3>

<p>指出文件执行的入口地址，是RVA地址。如果在exe中附加了一段代码并希望先执行，只需要修改这个入口地址就行了。</p>

<h3 id="imagebase">ImageBase</h3>

<p>文件优先装入的地址，当文件不需要重定位的时候最快。对于exe文件来说，每个文件总是独立使用虚拟地址空间，其地址不可能被其他模块占据，exe一般不需要重定位。对于dll来说，由于多个dll文件全部使用宿主exe文件的地址空间，不能确保地址没有被其他dll占用，所以dll必须包含重定位信息。一般exe默认是0x00400000，dll是0x10000000。</p>

<h3 id="subsystem">Subsystem</h3>

<p>Windows_CUI     win32控制台
Windows_GUI     win32图形界面</p>

<h3 id="datadirarray">DataDirArray</h3>

<p>这个字段是比较重要的字段之一，各个节中的数据按照用途可以分为导出表，导入表，资源，重定位表数据块。要查看某个结构，就到这里查看某结构的位置和大小。</p>

<h1 id="节表和节">节表和节</h1>

<h2 id="pe文件到内存的映射">PE文件到内存的映射</h2>

<p>Windows在装载可执行程序时候，对DOS头，PE文件头和节表部分不做任何处理，装载节的时候，根据节的属性做不同的处理。所以在同属一个模块的内存页中，从不同映射过来的内存页的属性的不同的。节是相同属性的数据的集合，所以节在内存中的对齐单位必须是一个页的大小。节的规模有大有小，首先由于磁盘映像和内存映像中节的对齐单位不同，其次是对包含未初始化的节的处理，如.data节。也有不进行映射的节，比如.reloc节，重定位数据对于文件的执行代码来说是透明的，它只对Windows装载器使用。</p>

<h2 id="节表">节表</h2>

<p>PE文件中所有的节的属性都被定义在节表中，有一系列IMAGE_SECTION_HEADER的结构体排列组成，紧跟着PE文件头，从PE文件头开始偏移0x00f8的地方。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">IMAGE_SECTION_HEADER</span>
<span class="p">{</span>
    <span class="n">Name1</span>                       <span class="mi">8</span><span class="err">字节的节区名称</span>
    <span class="k">union</span> <span class="n">Misc</span>
            <span class="n">PhysicalAddress</span>     
            <span class="n">VirtualSize</span>         <span class="err">节区的实际大小</span>
    <span class="n">VirtualAddress</span>              <span class="err">节区的</span><span class="n">RVA</span><span class="err">地址</span>
    <span class="n">SizeOfRawData</span>               <span class="err">在文件中对齐的大小</span>
    <span class="n">PointerToRawData</span>            <span class="err">文件中的偏移</span>
    <span class="n">PointerToRelocations</span>        
    <span class="n">PointerToLinenumbers</span>
    <span class="n">NumberOfRelocations</span>
    <span class="n">NumberOfLinenumbers</span>
    <span class="n">Characteristics</span>             <span class="err">节的属性</span>
<span class="p">};</span>
</code></pre></div></div>

<p>MASM32产生的exe文件中，代码节被命名为.text，可读写的数据节为.data，只读数据，导入表和导出表的节为.rdata，资源节为.rsrc。也有其他编译器将导入表放在.idata，中，代码节被命名为.code。</p>

<h3 id="pointertorawdata">PointerToRawData</h3>

<p>PointerToRawData 是指出了节在磁盘文件中的偏移地址，从文件头开始计算。</p>

<h3 id="sizeofrawdata">SizeOfRawData</h3>

<p>SizeOfRawData 指出了某个节在磁盘文件中的大小。</p>

<h2 id="映射方式">映射方式</h2>

<p>装载器从PE文件中找到某个节，即从PointerToRawData开始的大小为SizeOfRawData 的字节数据，把他们映射到内存中去，位置是从模块基址开始的偏移的VirtualAddress地方，并占用VirtualSize的值按照页大小的对齐。</p>

<h2 id="rva和文件偏移的转换">RVA和文件偏移的转换</h2>

<p>RVA是 relative virtual address的缩写，表示相对虚拟地址，是某个数据位置相对与文件头的位置。
对于DOS头，DOS stub，PE头，节表来说，无所谓RVA和文件偏移。因为他们在文件中和内存映射中的大小和偏移都不变。RVA只是对节来说的。
想要获得RVA对应的文件偏移，唯一的办法就是：如果目标RVA在某个节中，用目标RVA减去节的起始RVA’，获得数据在节中的偏移量。再通过PointerToRawData获得节在文件中的偏移，加上刚刚获得的偏移就是文件偏移量。</p>

<h1 id="导入表">导入表</h1>

<p>导入函数组成导入表，导入函数就是被程序调用的函数，但其代码不在程序中，这些代码位于一个或多个DLL中，调用程序中只保留一些函数信息。
只有当PE文件装载入内存的时候，Windows装载器才将DLL装入，并调用导入函数指令和函数实际地址，这就是动态链接，这是依靠PE文件中的导入表来完成的。</p>

<h2 id="导入表结构">导入表结构</h2>

<p>导入表由一系列IMAGE_IMPORT_DESCRIPTOR结构组成，每个结构对应一个DLL文件，</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">IMAGE_IMPORT_DESCRIPTOR</span>
<span class="p">{</span>
    <span class="k">union</span>
        <span class="n">Characteristics</span>
        <span class="n">OriginalFirstThunk</span>      <span class="err">指向包含一系列</span><span class="n">IMAGE_THUNK_DATA</span><span class="err">的数组（不会变）</span>
    <span class="n">TimeDateStamp</span>
    <span class="n">ForwarderChain</span>
    <span class="n">Name1</span>                       <span class="err">对应的</span><span class="n">DLL</span><span class="err">名称</span>
    <span class="n">FirstThunk</span>                  <span class="err">指向包含一系列</span><span class="n">IMAGE_THUNK_DATA</span><span class="err">的数组（会改变）</span>
<span class="p">}</span>
</code></pre></div></div>

<p>IMAGE_THUNK_DATA的数组中每个元素定义了一个导入函数的信息，并且以0结尾。
当最高位为1时，表示函数以序号方式导入，这时结构体的值是函数的序号。
当最高位为0时，表示函数以字符串类型的函数名方式导入，这时结构体的值是个RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">IMAGE_IMPORT_BY_NAME</span>
<span class="p">{</span>
    <span class="n">Hint</span>    <span class="err">函数的序号，可选字段</span>
    <span class="n">Name1</span>   <span class="err">导入函数的名称字符串，以</span><span class="mi">0</span><span class="err">结尾。</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当PE文件装载入内存时，FirstThunk所指向的数组的值都被替换成了真正的函数入口地址，这样做的目的是可以反过来查询地址的对应导入函数名。</p>

<h2 id="导入地址表-iat">导入地址表 IAT</h2>

<p>把FirstThunk所指向的数组称为导入地址数组。在PE文件中，所有DLL对应的导入地址数组在位置上排列在一起，数组的组合称为导入地址表IAT。
导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk指向的就是IAT的起始地址。
或者可以通过数据目录表，查找数据目录表中第13项（索引值为12/IMAGE_DIRECTORY_ENTRY_IAT），直接用来定义IAT数据块的位置和大小。</p>

<h1 id="导出表和重定位表">导出表和重定位表</h1>

<h2 id="导出表">导出表</h2>

<p>在包含导出函数的DLL中，导出信息位于导出表，通过导出表，DLL文件向系统提供导出函数的名称，序号和入口地址。以便完成动态链接。</p>

<h2 id="重定位表">重定位表</h2>

<p>首先要明白，在X86下，涉及到直接寻址的指令都是要重定位的。</p>

<h3 id="重定位算法">重定位算法</h3>

<p>将直接寻址的指令中的双字地址减去建议装载地址，获得RVA，再加上模块的实际装入地址，获得VA。由于建议装载地址在PE文件头中，而实际装入地址由装载器决定，所以重定位所需要的只是需要修正的代码的地址。</p>

<h3 id="重定位表的位置">重定位表的位置</h3>

<p>一般单独存放在一个可以丢弃的.reloc节中，和资源差不多，不是必须的。重定位表的位置可以由数据目录表IMAGE_DATA_DIRECTORY结构获取。
获得重定位表位置后，地址指向的就是很多重定位块，每一块描述一个内存页的所有重定位项。每个重定位块分起始RVA和块长度，之后的重定位项低12位表示数据在当前页面中的RVA，高4为表示重定位项种类。
假设模块装入地址为00400000h处。</p>

<table>
  <thead>
    <tr>
      <th>重定位表偏移</th>
      <th style="text-align: right">数据</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0000h</td>
      <td style="text-align: right">00001000h</td>
      <td style="text-align: center">第一个块，页面地址是00401000h</td>
    </tr>
    <tr>
      <td>0004h</td>
      <td style="text-align: right">00000010h</td>
      <td style="text-align: center">该重定位块长度10h</td>
    </tr>
    <tr>
      <td>0008h</td>
      <td style="text-align: right">3012h</td>
      <td style="text-align: center">重定位位置00401012h</td>
    </tr>
    <tr>
      <td>000ah</td>
      <td style="text-align: right">3040h</td>
      <td style="text-align: center">重定位位置00401040h</td>
    </tr>
    <tr>
      <td>000ch</td>
      <td style="text-align: right">306fh</td>
      <td style="text-align: center">重定位位置0040106fh</td>
    </tr>
    <tr>
      <td>000eh</td>
      <td style="text-align: right">0000h</td>
      <td style="text-align: center">用于对齐的空白数据</td>
    </tr>
    <tr>
      <td>0010h</td>
      <td style="text-align: right">00002000h</td>
      <td style="text-align: center">第一个块，页面地址是00402000h</td>
    </tr>
    <tr>
      <td>0014h</td>
      <td style="text-align: right">0000000ch</td>
      <td style="text-align: center">该重定位块长度0ch</td>
    </tr>
    <tr>
      <td>0018h</td>
      <td style="text-align: right">3080h</td>
      <td style="text-align: center">重定位位置00402080h</td>
    </tr>
    <tr>
      <td>001ah</td>
      <td style="text-align: right">30f0h</td>
      <td style="text-align: center">重定位位置004020f0h</td>
    </tr>
    <tr>
      <td>001ch</td>
      <td style="text-align: right">00000000h</td>
      <td style="text-align: center">重定位数据块结束标志</td>
    </tr>
  </tbody>
</table>

<p>PE解析到这里就不详细讲了，以后若对这方面深入研究再说，具体资料可以查阅 WindowsPE权威指南。</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#windows" class="page__taxonomy-item" rel="tag">windows</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fa fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2017-09-08T06:44:00+08:00">September 08, 2017</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=Win32asm+2%20https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2017-09%2FWin32ASM-2.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fa fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2017-09%2FWin32ASM-2.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fa fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2017-09%2FWin32ASM-2.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2017-09/Win32ASM-1.html" class="pagination--pager" title="Win32asm 1
">Previous</a>
    
    
      <a href="/posts/2017-09/Win32-coding-1.html" class="pagination--pager" title="Win32 Coding 1
">Next</a>
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">Leave a comment</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/Dirary_November/" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/%E5%8D%81%E6%9C%88%E6%97%A5%E8%AE%B0.html" rel="permalink">十月日记
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




10月1日

周日，上课前最后一天，算是给自己放了最后一天假期

10月2日

上了第一天的课，主要是os，一脸蒙蔽。
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/1d25d6ba93.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <div id="disqus_thread"></div>
  <script>
    /**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
    */
    /*
    var disqus_config = function () {
      this.page.url = "https://zjgcjy.github.io/posts/2017-09/Win32ASM-2.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2017-09/Win32ASM-2"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
