<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>2017cumtctf决赛 Writeup  -  My way, though far away</title>
<meta name="description" content="  本次比赛历时10个小时，我们队最终取得了第二名的成绩，还算不错吧。感谢3位队友的努力付出，也感谢各位学长的认真出题与提示（笑）。以下是我们队的writeup。本人才疏学浅,不周不对之处,望乞见谅。      MISC    CRYPTO    WEB    MOBILE    REVERSE    PWN  MISC签到题School song使用16进制文本分析器直接打开wav文件，发现文件最后部分存在异常。.../-/./--./..../../-.././-....-/.--./.-/.../.../-....-/../.../-....-/..-./.-../...-..-/--.这是是一段摩斯电码，使用翻译器得到：STEGHIDE-PASS-IS-FL$G。说明wav文件采用steghide加密，密码为FL$G。steghide extract -sf cumt.wavcumtctf{Lu0Ti@NY1_s0_Cut3}Digital Image Processing 1打开后，由题目意思和文件信息格式知道，这是一张图片，根据每个点的值，画出这张图片即可得到flag。在比赛中，我们认为图片格式是RGB，但是RGB只有3位，显然不对，但是使用RGB的Python脚本画图却成功了。但是图片颜色不对，只能说运气还不错吧。#-*- coding:utf-8 -*-from PIL import Imageimport rex = 250y = 250image = Image.new(&quot;RGB&quot;,(x,y))f = open(&#39;cumt.txt&#39;)for i in range(0,x):    for j in range(0,y):        l = f.readline()        r = l.split(&quot;,&quot;)        image.putpixel((i,j),(int(r[0]),int(r[1]),int(r[2])))image.save(&#39;image1.jpg&#39;)得到flag。cumtctf{CMYK_ExC1t3d}Digital Image Processing 2这道题，题目提示是傅里叶变换，由此想到数字水印，网上苦苦寻觅，只有matlab能处理，但是队友三人都没用matlab，无奈。最后使用photoshop进行简单的处理，依稀能看到flag，剩下的一位看不清，于是开始猜，虽然最后猜对了，但是提交时比赛已经结束。。。cumtctf{666_to_you}Hacker本题给了个抓包文件，还有一个加密的zip。打开wireshark，追踪TCP，查看各文件头，存在一个linux下可执行文件，提取出来后找到zip密码为：int_main_bxs。解密zip后得到mini.pcap，打开继续分析，发现flag.tar.gz文件，仔细追踪TCP，在其中一个发现了该文件的文件头，恢复文件，得到flag.txt。cumtctf{CaiDao_@nd_B4ckDoor_so_c00l!}LSB Picture这个题目首先给了个mp3，但是分析知道里面有个PNG文件，提取出来之后，首先根据题目意思LSB，分析了半天，没什么用，然后放了HINT，在mp3里面，也就是PNG文件最后，发现一段代码。。。aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyaW5jL2Nsb2Fja2VkLXBpeGVsKHBhc3N3b3JkOmZsYWcp最后发现是Base64加密，解密后得到：https://github.com/cyberinc/cloacked-pixel(password:flag)然后去这个地址找工具。。。下载下来后。python lsb.py extract 0.png-1.png flag得到一个文件。名曰：LDR.asm。。。00010554~00010674E52DB004 E28DB000E24DD01C E50B0018E3A03000 E50B3010EA000022 E3A03000E50B3008 E3A03000E50B300C EA000013E51B300C E51B2018E0823003 E5D33000E1A00003 E59F10C8E51B2010 E1A03002E1A03203 E0433002E51B200C E0833002E7913103 E0030390E51B2008 E0823003E50B3008 E51B300CE2833001 E50B300CE51B300C E353000EDAFFFFE8 E59F1084E51B3010 E51B2008E7812103 E51B3010E2833001 E50B3010E51B3010 E353000EDAFFFFD9 E3A03000E50B3010 EA00000CE59F2050 E51B3010E7922103 E59F1048E51B3010 E7913103E1520003 0A000001E3E03000 EA000006E51B3010 E2833001E50B3010 E51B3010E353000E DAFFFFEFE3A03000 E1A00003E24BD000 E49DB004E12FFF1E 0002103400021400 000213B8=================0002102C~0002146C00000000 0000000000000024 0000000E00000011 0000002000000008 0000000600000001 0000000C0000004C 0000005500000031 0000001200000039 0000000200000002 0000002100000010 000000100000001E 0000000600000004 000000020000000A 0000004800000054 0000002F00000013 0000003900000001 000000010000001C 0000000F0000000F 0000001B00000006 0000000400000001 0000000900000040 0000004D0000002B 0000001200000035 0000000100000002 000000130000000C 0000000B00000013 0000000500000001 0000000100000005 0000002B00000037 0000001C0000000E 0000002700000001 0000000100000019 0000000A0000000B 0000001400000006 0000000400000001 0000000800000031 000000370000001E 0000000D00000026 0000000100000001 0000001A0000000E 0000000F0000001B 0000000400000005 000000000000000B 0000003F0000004D 0000002C0000000F 0000003300000003 000000030000001F 0000001000000010 0000001C00000007 0000000200000002 0000000800000042 0000004F0000002A 0000001300000037 0000000100000001 0000000F00000006 0000000800000010 0000000200000002 0000000000000005 0000002500000029 0000001A00000007 0000001A00000001 0000000100000028 0000000C00000011 0000002100000007 0000000700000002 0000000D00000051 0000005300000033 0000001000000036 0000000100000001 000000230000000C 0000001100000020 0000000600000006 000000010000000C 0000004C00000052 000000320000000F 0000003500000002 0000000200000018 000000080000000B 0000001500000004 0000000400000001 0000000800000033 0000003600000021 0000000A00000023 0000000100000001 0000001E0000000E 0000000D00000019 0000000700000002 0000000200000007 0000003D00000046 0000002600000012 0000003100000000 0000000000000020 0000000E00000010 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000002 0000001D0000000F 0000000F0000001B 0000000700000005 000000010000000A 000000400000004E 0000002A00000012 0000003600000002 0000000300000020 0000000E00000011 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000003 00008ED100008921 00007CD80000570C 00005D8700007B78 0000800E0000428D 0000906500008A65 00005BCF00007343 00007FB000007F03 0000805500000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 00000000显然是一个ARM汇编，但是鄙人不懂ARM平台汇编。更不用说直接给机器码和数据了。（学长够狠的，一个LSB出成这样。。。）CRYPTOBase都说是base了，先将hex转成text，再base64解密54553479567A493152455250556C524956314655516B394E576C593257564E4254303554566A5A4F56454A48566C4E594D6A303950513D3D-&gt; TU4yVzI1RERPUlRIV1FUQk9NWlY2WVNBT05TVjZOVEJHVlNYMj09PQ==-&gt; MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===最后出现3个=，应该不是base64了，推测是base32MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===-&gt; cumtctf{Bas3_b@se_6a5e}我都不好意思说这是加密密文最后有6个等号，肯定不是base64了，是base32OFQXC5DTM5PWG6LSMJPWQ2LINB5W63LLMZPWG43XPU======-&gt; qaqtsg_cyrb_hihh{omkf_csw}这又是常见的套路。一般就是栅栏，凯撒，最多还有ROT13这几个混着用。。。qaqtsg_cyrb_hihh{omkf_csw}-&gt; qiahqht{sogm_kcfy_rcbs_wh}-&gt; cumtctf{easy_work_done_it}超超超简单的RSA题目很明显给出了rsa的攻击，打开文件发现两个txt文档，打开任意一个文档发现里面均存在有n 与 e，所以知道本题目是两个rsa文件（即两个被加密的文件），所以想办法得到每个文件的私钥才可以解题。对第一个A文本中的n用质数分解发现分解不出来（对了，我不懂16进制怎么去处理，所以用py全部转成10进制了，花了一些时间。。。。）所以很复杂。想了好久猜想两个文本A与B中的N也许有联系，所以用py处理了一下两个质数得出了他们的最大公约数，所以以这个公约数C作为P，即得出Q=N/P。有P有Q然后用小工具（下图）得出私钥D。之后有私钥利用A文本里给的公钥与小工具,将密文等数据填写进去得到即明文得出来了。不过B文件的内容我没有去尝试解，大家可以去解下试试。模数N=29418132766062200053827508724246843105374637443595563658353636901180985530454564748758954022059769968982002140853896779902444989762754829021500174009685317744797202131791952882245156752602275951380571602331788950944361654561540811865247443070852205987517914882270234145588910167329180689201693364463939325045996426086956404110646487321752453515607959864012257125599952218384912758492278760212475418527633763779623723297398616758881690569134708160861225121310386258262233845349929832236096958219199090596331413929196303615488618826471077896979729621018914864133480510063685383380281751344618122905355446455152052146107私钥D=5276569622169127583335396030174609377842679457826382876886732018555136943898524693377979534161711823815512184943455864784707258401816484897185891483275856469930223821580727295178409526710404020255132334411694676322006535535546302259515681376235707488042647120486202926845339494431016269464963898657451334903848837250871373477682894250164643619602539540167941126569254100541247071088029518267294673136150590137761627750871598184521964595130415894447450203665799780203794291800387632230796502586420060307704968798926230993933417456137261862838342423360539764609700124237130276870839075369086314306378124788811184527308864016188670758147951657948794726339811014447072181868238689002340820729878182691215125098872623119560093174867103561051579057密文=16100055693360522322921904559463506095804777561229411389210562116776123887118032506500785234735650863266120870039583905903640748310769171758726776231272365756600955133373377424528798613667972612939112952739492634777392213118214538310023716791113397548161112585724810411650439986941834109983323315567262092245187889800878232402966804760965881216269022049586892968822789422135384021734622276346902887808132752808716548024992278042957487218505559297871159990210141047554025964806293617142183951888549982800751775892257499574146183538611011708642419473426914866890982026974237403676735705451473230887885053941067076232393公钥e=0x10001此外，根据A和B文本得到的最大公约数Q=176619317803996218465829943540526296076867590914430196106340551568870328156449028441778892112662362916940116161090362718242443676528799588976770654437504474997568793583909264900680213577430229171890593572386841798207200784823655954364900051437142324539709060542879468781584230692448457677803389650254712030259P=166562373424571003644969210886957594935507861087984296297058666148455412078457690109851370986660882279126361524191566223822671452404569269819830903808012097953053534590353386995492143954050309296677311577678675327620326594657482392410288368865181591208513290907483245868756146614333721689500461074105692470873cumtctf{GCD_is_Useful_in_Rsa}WEB暴打出题人上来给了一个留言板,然后提示用XSS平台.网上找了一个XSS平台,通过最简单的使用得到了cookie。在最开始的留言板的页面加入XSS平台得到的cookie即得flag。just trick这个题涉及到几个小技巧  首先进入页面查看源代码得到的提示,然后打开这个文本得到代码。&lt;?phpecho &quot;&lt;!--index.txt--&gt;&quot;;if(!$_GET[&#39;id&#39;]){    header(&#39;Location: index.php?id=1&#39;);    exit();}$id=$_GET[&#39;id&#39;];if($id==0)  {      if(isset($_COOKIE[&#39;token&#39;]))      {        $key=$_GET[&#39;key&#39;];        $token =$_COOKIE[&#39;token&#39;];        if(isset($key)&amp;&amp;(file_get_contents($key,&#39;r&#39;)===&quot;I want flag!!!&quot;))        {          echo &quot;hello Hacker!&lt;br&gt;&quot;;          include(&quot;include.php&quot;);          echo cumtctf_unserialize($token);        }        else        {            echo &quot;You are not Hacker ! &quot;;          }        }  }?&gt;  PHP中可以看到首先get方式提交一个id的值,在if(!$_GET[‘id’])的地方需要值不为空跳过if,后面if($id==0)的地方需要id的值为0进入if,如果id=0第一个if语句无法跳过,所以让id=’0’这两个地方就都能过去.  看到需要get方式提交一个key.想让file_get_contents($key,’r’)===”I want flag!!!”可以用PHP的封装协议php://input,它可以得到原始的POST数据.  这里我想了好久怎么才能看到include.php的内容= =,也没有文件包含什么的,最后发现和看index.php一下,看一下include.txt就得到了内容。&lt;?phpecho &quot;&lt;!--include.txt--&gt;&quot;;class Read{//flag.php    public $file;    public function __toString(){        if(isset($this-&gt;file)){            if(&quot;flag.php&quot;===$this-&gt;file||stripos($this-&gt;file,&quot;://&quot;)&gt;-1)            {                exit();              }            else            {                echo file_get_contents($this-&gt;file);            }                      }        return &quot;you are big Hacker&quot;;    }}function cumtctf_unserialize($value)    {        preg_match(&#39;/[oc]:\d+:/i&#39;, $value,$matches);        if(count($matches)){            return false;        }        return unserialize($value);    }?&gt;  最后就是读flag.php的内容了,这里可以通过反序列化去读,但是有两个过滤,一个是过滤了协议的使用,php://filter/convert.base64-encode/resource=flag.php就不能用了,因为不是严格的查找字符串所以./flag.php,后面还有一个对于你传入的序列化字符串有一个正则的过滤,PHP序列化字符串中对象长度前加一个+号仍可正常反序列化,可用此来绕过正则.将这个的序列化字符串作为cookie里面token的值提交得flag.TextWall进去随便提交了一个东西然后看到有一个lists的cookie,其中值为24c5889e00902d6bcc65073f0e91ea30bbe203c2 a:1:{i:0;s:9:”hiehiehie”;},字符串前一段为后一段序列化字符串的SHA1.一般构造反序列化一般都需要源码，所以找到了源码泄露点：http://textwall.bxsteam.xyz/.index.php.swo。&lt;?php$lists = [];Class filelist{    public function __toString()    {        return highlight_file(&#39;hiehiehie.txt&#39;, true).highlight_file($this-&gt;source, true);    }}........?&gt;构造序列化的串（反序列化后是一个filelist类，$sorce值是我们想查找的路径，这样在反序列化后）这里我们构造如下:$a = new filelist();$b= new filelist();$b-&gt;source = &#39;index.php&#39;;$a-&gt;source=$b;$d=serialize($a);$e=sha1($d).$d;echo urlencode($e).&quot;&lt;br&gt;&quot;;得到16d8c3c46653e89932859dd7a2eb12fa59df777aO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3B%7D%7D作为cookie提交得到源码(贴部分):233333333333333333333333333333333333333333333333333333333333333333 &lt;?php//flag in Fl4444444444g.phpsession_start();$lists = [];Class filelist{    public $source;    public function __toString()在上面的过程中将路径改为Fl4444444444g.php,读取即得到flag.简单的盲注这个题第一个hint是请关注图片,抓包发现是get请求发送图片对应的id来获取图片,这里id就是注入点,当id=1”的时候会报错,说明sql语句中使用的是”,接下来就是盲注密码,构造的为id=1”and ord(mid((password),1,1))&lt;48#,跑出来密码为8211d7b4ba2828919651,是DEDECMS的20位MD5加密,账号admin然后登陆进去一个上传文件的地方.文件后缀是白名单过滤,我查了好久都没有结果,后来得知是phps后缀(不知道在哪里找的这种后缀…),然后还是传不上去是因为有关于PHP标识的过滤,改为比较不常见的脚本类型可以绕过。(开始时候我把language拼错了导致半天没过…)。MOBILE多谢款待这题很坑，因为我android版本的原因，这个APK运行不了。而且很奇怪，是因为加保护了，还是其他原因，用Android_Killer无法反编译。无奈之下，用APKtools，对Main先转dex，再转java。直接看源码。。但是也很奇怪，这样转出来的string，都是十六进制的数字，不是ascii表示，也不是其他的。什么编码，卡在这里半天。。。后来学长指点说用Jeb可以看。于是我就去下载了。之后进行反编译。以下是伪Java代码。private boolean check(String arg10, int arg11){    int v0[] = new int[]{125, 108, 97, 103, 123, 51, 108, 51, 99, 116, 101, 57, 114, 65, 104, 99, 95, 99, 49, 114, 102};    //  数组的值是：}lag{3l3cte9rAhc_c1rf    int v2 = 0;    int v3 = 0;    char v5[]  = arg10.toCharArray();    if(arg10 != null &amp;&amp; arg11 != 0)    {        if(v5[0] == v0[arg10.length() - 1] &amp;&amp; v5[arg10.length() - 1] == v0[0])        {            v2 = 1;        }        int v1;        for(v1 = 1; v1 &lt; arg10.length() / 2; ++v1)        {            if(v5[v1] != v0[v1])            {                break;            }            if(v1 == arg10.length() / 2 - 1)            {                v3 = 1;            }        }        while(v1 &lt; arg10.length() - 1)        {            if(v5[v1] != v0[arg10.length() - v1])            {                break;            }            ++v1;        }    }return v2 &amp; v3;}public void onClick(View arg5){    String v0 = this.editText.getText().toString().trim();    if(!this.check(v0, v0.length()))    {        Toast.makeText(((Context)this), &quot;It\&#39;s not smell good!&quot;, 0).show();    }    else    {        Toast.makeText(((Context)this), &quot;Good, you got it!&quot;, 0).show();    }}为得到flag，只要check返回1就行，即在check中v2和v3都是1，发现check只是进行简单的替换，将最后一位和第一位替换。还原只要将}lag{3l3cte9rAhc_c1rf中第一位和最后一位对调即可，当然，长度相同也行，只要第一位是f，最后一位是}。这时候v2=1，而此时v3根据程序的推进必等于1，所以得到flag。flag{3l3cte9rAhc_c1r}助人为乐这题，和第一题一样，我直接用Jeb分析了，Android_Killer同样失效了。程序的关键部分如下： public static String encode(String password) {        int v11 = 6;        int v10 = 2;        if(password != null &amp;&amp; password.length() != 0)			{            char[] pass = password.toCharArray();            StringBuilder v2 = new StringBuilder();            int i;            for(i = 0; i &lt; pass.length; ++i) {                String v0;                for(v0 = Integer.toBinaryString(pass[i]); v0.length() &lt; 8; v0 = &quot;0&quot; + v0) {                }                v2.append(v0);            }            while(v2.length() % 6 != 0) {                v2.append(&quot;0&quot;);            }            String v1 = String.valueOf(v2);            char[] v4 = new char[v1.length() / 6];            for(i = 0; i &lt; v4.length; ++i) {                int v6 = Integer.parseInt(v1.substring(0, v11), v10);                v1 = v1.substring(v11);                v4[i] = Code.CodeText.charAt(v6);            }            StringBuilder v3 = new StringBuilder(String.valueOf(v4));            if(password.length() % 3 == 1) {                v3.append(&quot;1&quot;);            }            else if(password.length() % 3 == v10) {                v3.append(&quot;23&quot;);            }            for(i = 76; i &lt; v3.length(); i += 76) {                v3.insert(i, &quot;\r\n&quot;);            }            v3.append(&quot;\r\n&quot;);            password = String.valueOf(v3);        }        return password;    }这其中有两个列表，一个是加密列表：（长度为64=2^6）abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#\$%^&amp;*()+/另一个是密文：zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1本题就是要求我们解密出明文。加密过程大致如下：首先将输入的字符串对应的ascii码转换成二进制，每一字符是8bit，得到一串比特流。之后检测总长度是否为6的倍数，不是的话在后面补0，之后将比特流每6个一组，得到一串数字，数字均小于63(2^6-1)，将这串数字作为加密列表的下标查找对应字符，实现加密。所以解法如下： 首先查找密文每一位在加密列表中的下标。int main(){    char pass[] = &quot;zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1&quot;;	char name[] = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()+/&quot;;	for (int i = 0; i &lt; 47; i++)	{		for (int j = 0; j &lt; 65; j++)		{			if (pass[i] == name[j])			{				cout &lt;&lt; j &lt;&lt; &quot; &quot;;				break;			}			else				continue;		}	 }	return 0;}得到的即为下标：25 38 49 33 25 55 44 49 29 5 61 44 28 53 61 46 27 55 17 31 24 21 61 35 12 6 53 55 25 22 57 31 24 38 5 51 25 22 13 47 25 4 20 33 31 16再转成二进制，注意补0对齐，6个一组。再去掉空格连起来。011001 100110 110001 100001 011001 110111 101100 110001 011101 000101 111101 101100 011100 110101 111101 101110 011011 110111 010001 011111 011000 010101 111101 100011 001100 000110 110101 110111 011001 010110 111001 011111 011000 100110 000101 110011 011001 010110 001101 101111 011001 000100 010100 100001 011111 010000-&gt;011001100110110001100001011001110111101100110001011101000101111101101100011100110101111101101110011011110111010001011111011000010101111101100011001100000110110101110111011001010110111001011111011000100110000101110011011001010110001101101111011001000100010100100001011111010000之后再8个一组，作为字符，查ascii表。得到flag。01100110 01101100 01100001 01100111 01111011 00110001 01110100 01011111 01101100 01110011 01011111 01101110 01101111 01110100 01011111 01100001 01011111 01100011 00110000 01101101 01110111 01100101 01101110 01011111 01100010 01100001 01110011 01100101 01100011 01101111 01100100 01000101 00100001 01111101 000-&gt;flag{1t_ls_not_a_c0mwen_basecodE!}REVERSEreverse1别想多了，这题就是看汇编。（哭）第一步：首先判断输入字符串长度是否为0x1C。用ecx作为累加器，一次处理一个字节，累加和与1Ch作比较，相等则跳转。之后判断最后一位是否是}，是则call eax 进行下一步加密。mov     al, [ecx]inc     ecxtest    al, aljnz     short loc_401030sub     ecx, edxcmp     ecx, 1Chjz      short loc_40104B…………cmp     [ebp+var_49], &#39;}&#39;jnz     short loc_401070…………lea     eax, [ebp+var_64]push    offset byte_403068push    eaxmov     eax, offset loc_403020call    eax ; loc_403020第二步：执行 call eax，之后，来到一段数据区，显然实际为代码，手动转成代码后，进行以下逻辑判断。即判断输入的前5个字符是否为flag{，是就进行call edx 下一轮加密。cmp     byte ptr [eax], &#39;f&#39;jnz     short loc_40305Fcmp     byte ptr [eax+1], &#39;l&#39;jnz     short loc_40305Fcmp     byte ptr [eax+2], &#39;a&#39;jnz     short loc_40305Fcmp     byte ptr [eax+3], &#39;g&#39;jnz     short loc_40305Fcmp     byte ptr [eax+4], &#39;{&#39;jnz     short loc_40305F…………push    offset unk_403110push    eaxcall    edx第三步：异或加密，注意到此时的基址指针ebp+8为输入的第6位的地址，而ebp-8是一个加密列表所在地址。通过赋值语句，和Intel小段结构，知道加密列表为 98 A4 A9 93。之后的运算表明，从输入的第6位开始和0xCC进行异或，再与加密的每一位依次对比，相等则继续，不等则退出，循环比较次数为4次。由于异或的可逆性，解除这段明文是：The_。最后取ebx+4则是取输入的第10位的地址进行下一轮加密。mov     ebx, [ebp+8]lea     eax, [ebp-8]push    esipush    edixor     edx, edxmov     dword ptr [ebp-8], 93A9A498h…………lea     ecx, [ebp-8]add     ecx, esimov     al, [edi+ecx]xor     al, 0CChcmp     al, [ecx]jnz     short loc_4030B9inc     esicmp     esi, 4jl      short loc_403088…………lea     eax, [ebx+4]push    offset unk_4032A0push    eaxcall    ecx第四步：Base64加密，首先进行初始化，初始加密列表为4部分：ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 +/mov     dl, &#39;A&#39;xor     ecx, ecxmov     eax, ecx…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;Z&#39;jle     short loc_40311Cmov     dl, &#39;a&#39;…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;z&#39;jle     short loc_40312Amov     dl, &#39;0&#39;…………mov     [ebp+eax-100], dlinc     dlinc     eaxcmp     dl, &#39;9&#39;jle     short loc_403138push    ebxpush    esipush    edimov     word ptr [ebp+eax-64h], &#39;/+&#39;因为为避免明文泄露，肯定会有Base64加密后的密文出现，即cmVhbEN0Rl8=。之后会将输入的第10位开始的8位进行Base64加密，与该密文进行对比。由于开启了优化，这段代码是纯数学运算，因此跳过，直接解密密文后得到realCtF_。至此前17位已经得到：flag{The_realCtF_xxxxxxxxxx}。ebx+8为输入的第18位，eax取该地址后，再进行下一步加密。mov     dword ptr [ebp-10h], &#39;hVmc&#39;mov     dword ptr [ebp-0Ch], &#39;0NEb&#39;mov     dword ptr [ebp-8], &#39;=8lR&#39;…………lea     eax, [ebx+8]push    eaxcall    ecx第五步：首先进行加密列表的初始化，得到：kvtu`C4h”o。mov     dword ptr [ebp-0Ch], &#39;utvk&#39;push    esipush    edimov     dword ptr [ebp-8], &#39;h4C`&#39;or      edx, 0FFFFFFFFhmov     word ptr [ebp-4], &#39;o&quot;&#39;之后将输入值的第18位的地址传入esi中，esi+edi为加密列表的地址，即比较ecx与eax。并且ecx=加密列表每一个字符减一的值，eax=为输入第18位开始的值。循环比较10次，相等则继续，不等则退出。为得到明文，只要将密文6B 76 74 75 60 43 34 68 22 每一位都减一即可，得到6A 75 73 74 5F 42 33 67 21 ，即为：just_B3g!movsx   ecx, byte ptr [edi+esi]movsx   eax, byte ptr [esi]dec     ecxcmp     eax, ecxjnz     short loc_4032EAinc     ebxinc     esicmp     ebx, edxjl      short loc_4032D8综上，得到flag{The_realCtF_just_B3g!n}。PWN我太菜了，完全不会啊。">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="2017cumtctf决赛 Writeup">
<meta property="og:url" content="https://zjgcjy.github.io/posts/2018-08/2017cumtctf%E5%86%B3%E8%B5%9B-writeup.html">


  <meta property="og:description" content="  本次比赛历时10个小时，我们队最终取得了第二名的成绩，还算不错吧。感谢3位队友的努力付出，也感谢各位学长的认真出题与提示（笑）。以下是我们队的writeup。本人才疏学浅,不周不对之处,望乞见谅。      MISC    CRYPTO    WEB    MOBILE    REVERSE    PWN  MISC签到题School song使用16进制文本分析器直接打开wav文件，发现文件最后部分存在异常。.../-/./--./..../../-.././-....-/.--./.-/.../.../-....-/../.../-....-/..-./.-../...-..-/--.这是是一段摩斯电码，使用翻译器得到：STEGHIDE-PASS-IS-FL$G。说明wav文件采用steghide加密，密码为FL$G。steghide extract -sf cumt.wavcumtctf{Lu0Ti@NY1_s0_Cut3}Digital Image Processing 1打开后，由题目意思和文件信息格式知道，这是一张图片，根据每个点的值，画出这张图片即可得到flag。在比赛中，我们认为图片格式是RGB，但是RGB只有3位，显然不对，但是使用RGB的Python脚本画图却成功了。但是图片颜色不对，只能说运气还不错吧。#-*- coding:utf-8 -*-from PIL import Imageimport rex = 250y = 250image = Image.new(&quot;RGB&quot;,(x,y))f = open(&#39;cumt.txt&#39;)for i in range(0,x):    for j in range(0,y):        l = f.readline()        r = l.split(&quot;,&quot;)        image.putpixel((i,j),(int(r[0]),int(r[1]),int(r[2])))image.save(&#39;image1.jpg&#39;)得到flag。cumtctf{CMYK_ExC1t3d}Digital Image Processing 2这道题，题目提示是傅里叶变换，由此想到数字水印，网上苦苦寻觅，只有matlab能处理，但是队友三人都没用matlab，无奈。最后使用photoshop进行简单的处理，依稀能看到flag，剩下的一位看不清，于是开始猜，虽然最后猜对了，但是提交时比赛已经结束。。。cumtctf{666_to_you}Hacker本题给了个抓包文件，还有一个加密的zip。打开wireshark，追踪TCP，查看各文件头，存在一个linux下可执行文件，提取出来后找到zip密码为：int_main_bxs。解密zip后得到mini.pcap，打开继续分析，发现flag.tar.gz文件，仔细追踪TCP，在其中一个发现了该文件的文件头，恢复文件，得到flag.txt。cumtctf{CaiDao_@nd_B4ckDoor_so_c00l!}LSB Picture这个题目首先给了个mp3，但是分析知道里面有个PNG文件，提取出来之后，首先根据题目意思LSB，分析了半天，没什么用，然后放了HINT，在mp3里面，也就是PNG文件最后，发现一段代码。。。aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyaW5jL2Nsb2Fja2VkLXBpeGVsKHBhc3N3b3JkOmZsYWcp最后发现是Base64加密，解密后得到：https://github.com/cyberinc/cloacked-pixel(password:flag)然后去这个地址找工具。。。下载下来后。python lsb.py extract 0.png-1.png flag得到一个文件。名曰：LDR.asm。。。00010554~00010674E52DB004 E28DB000E24DD01C E50B0018E3A03000 E50B3010EA000022 E3A03000E50B3008 E3A03000E50B300C EA000013E51B300C E51B2018E0823003 E5D33000E1A00003 E59F10C8E51B2010 E1A03002E1A03203 E0433002E51B200C E0833002E7913103 E0030390E51B2008 E0823003E50B3008 E51B300CE2833001 E50B300CE51B300C E353000EDAFFFFE8 E59F1084E51B3010 E51B2008E7812103 E51B3010E2833001 E50B3010E51B3010 E353000EDAFFFFD9 E3A03000E50B3010 EA00000CE59F2050 E51B3010E7922103 E59F1048E51B3010 E7913103E1520003 0A000001E3E03000 EA000006E51B3010 E2833001E50B3010 E51B3010E353000E DAFFFFEFE3A03000 E1A00003E24BD000 E49DB004E12FFF1E 0002103400021400 000213B8=================0002102C~0002146C00000000 0000000000000024 0000000E00000011 0000002000000008 0000000600000001 0000000C0000004C 0000005500000031 0000001200000039 0000000200000002 0000002100000010 000000100000001E 0000000600000004 000000020000000A 0000004800000054 0000002F00000013 0000003900000001 000000010000001C 0000000F0000000F 0000001B00000006 0000000400000001 0000000900000040 0000004D0000002B 0000001200000035 0000000100000002 000000130000000C 0000000B00000013 0000000500000001 0000000100000005 0000002B00000037 0000001C0000000E 0000002700000001 0000000100000019 0000000A0000000B 0000001400000006 0000000400000001 0000000800000031 000000370000001E 0000000D00000026 0000000100000001 0000001A0000000E 0000000F0000001B 0000000400000005 000000000000000B 0000003F0000004D 0000002C0000000F 0000003300000003 000000030000001F 0000001000000010 0000001C00000007 0000000200000002 0000000800000042 0000004F0000002A 0000001300000037 0000000100000001 0000000F00000006 0000000800000010 0000000200000002 0000000000000005 0000002500000029 0000001A00000007 0000001A00000001 0000000100000028 0000000C00000011 0000002100000007 0000000700000002 0000000D00000051 0000005300000033 0000001000000036 0000000100000001 000000230000000C 0000001100000020 0000000600000006 000000010000000C 0000004C00000052 000000320000000F 0000003500000002 0000000200000018 000000080000000B 0000001500000004 0000000400000001 0000000800000033 0000003600000021 0000000A00000023 0000000100000001 0000001E0000000E 0000000D00000019 0000000700000002 0000000200000007 0000003D00000046 0000002600000012 0000003100000000 0000000000000020 0000000E00000010 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000002 0000001D0000000F 0000000F0000001B 0000000700000005 000000010000000A 000000400000004E 0000002A00000012 0000003600000002 0000000300000020 0000000E00000011 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000003 00008ED100008921 00007CD80000570C 00005D8700007B78 0000800E0000428D 0000906500008A65 00005BCF00007343 00007FB000007F03 0000805500000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 00000000显然是一个ARM汇编，但是鄙人不懂ARM平台汇编。更不用说直接给机器码和数据了。（学长够狠的，一个LSB出成这样。。。）CRYPTOBase都说是base了，先将hex转成text，再base64解密54553479567A493152455250556C524956314655516B394E576C593257564E4254303554566A5A4F56454A48566C4E594D6A303950513D3D-&gt; TU4yVzI1RERPUlRIV1FUQk9NWlY2WVNBT05TVjZOVEJHVlNYMj09PQ==-&gt; MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===最后出现3个=，应该不是base64了，推测是base32MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===-&gt; cumtctf{Bas3_b@se_6a5e}我都不好意思说这是加密密文最后有6个等号，肯定不是base64了，是base32OFQXC5DTM5PWG6LSMJPWQ2LINB5W63LLMZPWG43XPU======-&gt; qaqtsg_cyrb_hihh{omkf_csw}这又是常见的套路。一般就是栅栏，凯撒，最多还有ROT13这几个混着用。。。qaqtsg_cyrb_hihh{omkf_csw}-&gt; qiahqht{sogm_kcfy_rcbs_wh}-&gt; cumtctf{easy_work_done_it}超超超简单的RSA题目很明显给出了rsa的攻击，打开文件发现两个txt文档，打开任意一个文档发现里面均存在有n 与 e，所以知道本题目是两个rsa文件（即两个被加密的文件），所以想办法得到每个文件的私钥才可以解题。对第一个A文本中的n用质数分解发现分解不出来（对了，我不懂16进制怎么去处理，所以用py全部转成10进制了，花了一些时间。。。。）所以很复杂。想了好久猜想两个文本A与B中的N也许有联系，所以用py处理了一下两个质数得出了他们的最大公约数，所以以这个公约数C作为P，即得出Q=N/P。有P有Q然后用小工具（下图）得出私钥D。之后有私钥利用A文本里给的公钥与小工具,将密文等数据填写进去得到即明文得出来了。不过B文件的内容我没有去尝试解，大家可以去解下试试。模数N=29418132766062200053827508724246843105374637443595563658353636901180985530454564748758954022059769968982002140853896779902444989762754829021500174009685317744797202131791952882245156752602275951380571602331788950944361654561540811865247443070852205987517914882270234145588910167329180689201693364463939325045996426086956404110646487321752453515607959864012257125599952218384912758492278760212475418527633763779623723297398616758881690569134708160861225121310386258262233845349929832236096958219199090596331413929196303615488618826471077896979729621018914864133480510063685383380281751344618122905355446455152052146107私钥D=5276569622169127583335396030174609377842679457826382876886732018555136943898524693377979534161711823815512184943455864784707258401816484897185891483275856469930223821580727295178409526710404020255132334411694676322006535535546302259515681376235707488042647120486202926845339494431016269464963898657451334903848837250871373477682894250164643619602539540167941126569254100541247071088029518267294673136150590137761627750871598184521964595130415894447450203665799780203794291800387632230796502586420060307704968798926230993933417456137261862838342423360539764609700124237130276870839075369086314306378124788811184527308864016188670758147951657948794726339811014447072181868238689002340820729878182691215125098872623119560093174867103561051579057密文=16100055693360522322921904559463506095804777561229411389210562116776123887118032506500785234735650863266120870039583905903640748310769171758726776231272365756600955133373377424528798613667972612939112952739492634777392213118214538310023716791113397548161112585724810411650439986941834109983323315567262092245187889800878232402966804760965881216269022049586892968822789422135384021734622276346902887808132752808716548024992278042957487218505559297871159990210141047554025964806293617142183951888549982800751775892257499574146183538611011708642419473426914866890982026974237403676735705451473230887885053941067076232393公钥e=0x10001此外，根据A和B文本得到的最大公约数Q=176619317803996218465829943540526296076867590914430196106340551568870328156449028441778892112662362916940116161090362718242443676528799588976770654437504474997568793583909264900680213577430229171890593572386841798207200784823655954364900051437142324539709060542879468781584230692448457677803389650254712030259P=166562373424571003644969210886957594935507861087984296297058666148455412078457690109851370986660882279126361524191566223822671452404569269819830903808012097953053534590353386995492143954050309296677311577678675327620326594657482392410288368865181591208513290907483245868756146614333721689500461074105692470873cumtctf{GCD_is_Useful_in_Rsa}WEB暴打出题人上来给了一个留言板,然后提示用XSS平台.网上找了一个XSS平台,通过最简单的使用得到了cookie。在最开始的留言板的页面加入XSS平台得到的cookie即得flag。just trick这个题涉及到几个小技巧  首先进入页面查看源代码得到的提示,然后打开这个文本得到代码。&lt;?phpecho &quot;&lt;!--index.txt--&gt;&quot;;if(!$_GET[&#39;id&#39;]){    header(&#39;Location: index.php?id=1&#39;);    exit();}$id=$_GET[&#39;id&#39;];if($id==0)  {      if(isset($_COOKIE[&#39;token&#39;]))      {        $key=$_GET[&#39;key&#39;];        $token =$_COOKIE[&#39;token&#39;];        if(isset($key)&amp;&amp;(file_get_contents($key,&#39;r&#39;)===&quot;I want flag!!!&quot;))        {          echo &quot;hello Hacker!&lt;br&gt;&quot;;          include(&quot;include.php&quot;);          echo cumtctf_unserialize($token);        }        else        {            echo &quot;You are not Hacker ! &quot;;          }        }  }?&gt;  PHP中可以看到首先get方式提交一个id的值,在if(!$_GET[‘id’])的地方需要值不为空跳过if,后面if($id==0)的地方需要id的值为0进入if,如果id=0第一个if语句无法跳过,所以让id=’0’这两个地方就都能过去.  看到需要get方式提交一个key.想让file_get_contents($key,’r’)===”I want flag!!!”可以用PHP的封装协议php://input,它可以得到原始的POST数据.  这里我想了好久怎么才能看到include.php的内容= =,也没有文件包含什么的,最后发现和看index.php一下,看一下include.txt就得到了内容。&lt;?phpecho &quot;&lt;!--include.txt--&gt;&quot;;class Read{//flag.php    public $file;    public function __toString(){        if(isset($this-&gt;file)){            if(&quot;flag.php&quot;===$this-&gt;file||stripos($this-&gt;file,&quot;://&quot;)&gt;-1)            {                exit();              }            else            {                echo file_get_contents($this-&gt;file);            }                      }        return &quot;you are big Hacker&quot;;    }}function cumtctf_unserialize($value)    {        preg_match(&#39;/[oc]:\d+:/i&#39;, $value,$matches);        if(count($matches)){            return false;        }        return unserialize($value);    }?&gt;  最后就是读flag.php的内容了,这里可以通过反序列化去读,但是有两个过滤,一个是过滤了协议的使用,php://filter/convert.base64-encode/resource=flag.php就不能用了,因为不是严格的查找字符串所以./flag.php,后面还有一个对于你传入的序列化字符串有一个正则的过滤,PHP序列化字符串中对象长度前加一个+号仍可正常反序列化,可用此来绕过正则.将这个的序列化字符串作为cookie里面token的值提交得flag.TextWall进去随便提交了一个东西然后看到有一个lists的cookie,其中值为24c5889e00902d6bcc65073f0e91ea30bbe203c2 a:1:{i:0;s:9:”hiehiehie”;},字符串前一段为后一段序列化字符串的SHA1.一般构造反序列化一般都需要源码，所以找到了源码泄露点：http://textwall.bxsteam.xyz/.index.php.swo。&lt;?php$lists = [];Class filelist{    public function __toString()    {        return highlight_file(&#39;hiehiehie.txt&#39;, true).highlight_file($this-&gt;source, true);    }}........?&gt;构造序列化的串（反序列化后是一个filelist类，$sorce值是我们想查找的路径，这样在反序列化后）这里我们构造如下:$a = new filelist();$b= new filelist();$b-&gt;source = &#39;index.php&#39;;$a-&gt;source=$b;$d=serialize($a);$e=sha1($d).$d;echo urlencode($e).&quot;&lt;br&gt;&quot;;得到16d8c3c46653e89932859dd7a2eb12fa59df777aO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3B%7D%7D作为cookie提交得到源码(贴部分):233333333333333333333333333333333333333333333333333333333333333333 &lt;?php//flag in Fl4444444444g.phpsession_start();$lists = [];Class filelist{    public $source;    public function __toString()在上面的过程中将路径改为Fl4444444444g.php,读取即得到flag.简单的盲注这个题第一个hint是请关注图片,抓包发现是get请求发送图片对应的id来获取图片,这里id就是注入点,当id=1”的时候会报错,说明sql语句中使用的是”,接下来就是盲注密码,构造的为id=1”and ord(mid((password),1,1))&lt;48#,跑出来密码为8211d7b4ba2828919651,是DEDECMS的20位MD5加密,账号admin然后登陆进去一个上传文件的地方.文件后缀是白名单过滤,我查了好久都没有结果,后来得知是phps后缀(不知道在哪里找的这种后缀…),然后还是传不上去是因为有关于PHP标识的过滤,改为比较不常见的脚本类型可以绕过。(开始时候我把language拼错了导致半天没过…)。MOBILE多谢款待这题很坑，因为我android版本的原因，这个APK运行不了。而且很奇怪，是因为加保护了，还是其他原因，用Android_Killer无法反编译。无奈之下，用APKtools，对Main先转dex，再转java。直接看源码。。但是也很奇怪，这样转出来的string，都是十六进制的数字，不是ascii表示，也不是其他的。什么编码，卡在这里半天。。。后来学长指点说用Jeb可以看。于是我就去下载了。之后进行反编译。以下是伪Java代码。private boolean check(String arg10, int arg11){    int v0[] = new int[]{125, 108, 97, 103, 123, 51, 108, 51, 99, 116, 101, 57, 114, 65, 104, 99, 95, 99, 49, 114, 102};    //  数组的值是：}lag{3l3cte9rAhc_c1rf    int v2 = 0;    int v3 = 0;    char v5[]  = arg10.toCharArray();    if(arg10 != null &amp;&amp; arg11 != 0)    {        if(v5[0] == v0[arg10.length() - 1] &amp;&amp; v5[arg10.length() - 1] == v0[0])        {            v2 = 1;        }        int v1;        for(v1 = 1; v1 &lt; arg10.length() / 2; ++v1)        {            if(v5[v1] != v0[v1])            {                break;            }            if(v1 == arg10.length() / 2 - 1)            {                v3 = 1;            }        }        while(v1 &lt; arg10.length() - 1)        {            if(v5[v1] != v0[arg10.length() - v1])            {                break;            }            ++v1;        }    }return v2 &amp; v3;}public void onClick(View arg5){    String v0 = this.editText.getText().toString().trim();    if(!this.check(v0, v0.length()))    {        Toast.makeText(((Context)this), &quot;It\&#39;s not smell good!&quot;, 0).show();    }    else    {        Toast.makeText(((Context)this), &quot;Good, you got it!&quot;, 0).show();    }}为得到flag，只要check返回1就行，即在check中v2和v3都是1，发现check只是进行简单的替换，将最后一位和第一位替换。还原只要将}lag{3l3cte9rAhc_c1rf中第一位和最后一位对调即可，当然，长度相同也行，只要第一位是f，最后一位是}。这时候v2=1，而此时v3根据程序的推进必等于1，所以得到flag。flag{3l3cte9rAhc_c1r}助人为乐这题，和第一题一样，我直接用Jeb分析了，Android_Killer同样失效了。程序的关键部分如下： public static String encode(String password) {        int v11 = 6;        int v10 = 2;        if(password != null &amp;&amp; password.length() != 0)			{            char[] pass = password.toCharArray();            StringBuilder v2 = new StringBuilder();            int i;            for(i = 0; i &lt; pass.length; ++i) {                String v0;                for(v0 = Integer.toBinaryString(pass[i]); v0.length() &lt; 8; v0 = &quot;0&quot; + v0) {                }                v2.append(v0);            }            while(v2.length() % 6 != 0) {                v2.append(&quot;0&quot;);            }            String v1 = String.valueOf(v2);            char[] v4 = new char[v1.length() / 6];            for(i = 0; i &lt; v4.length; ++i) {                int v6 = Integer.parseInt(v1.substring(0, v11), v10);                v1 = v1.substring(v11);                v4[i] = Code.CodeText.charAt(v6);            }            StringBuilder v3 = new StringBuilder(String.valueOf(v4));            if(password.length() % 3 == 1) {                v3.append(&quot;1&quot;);            }            else if(password.length() % 3 == v10) {                v3.append(&quot;23&quot;);            }            for(i = 76; i &lt; v3.length(); i += 76) {                v3.insert(i, &quot;\r\n&quot;);            }            v3.append(&quot;\r\n&quot;);            password = String.valueOf(v3);        }        return password;    }这其中有两个列表，一个是加密列表：（长度为64=2^6）abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#\$%^&amp;*()+/另一个是密文：zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1本题就是要求我们解密出明文。加密过程大致如下：首先将输入的字符串对应的ascii码转换成二进制，每一字符是8bit，得到一串比特流。之后检测总长度是否为6的倍数，不是的话在后面补0，之后将比特流每6个一组，得到一串数字，数字均小于63(2^6-1)，将这串数字作为加密列表的下标查找对应字符，实现加密。所以解法如下： 首先查找密文每一位在加密列表中的下标。int main(){    char pass[] = &quot;zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1&quot;;	char name[] = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()+/&quot;;	for (int i = 0; i &lt; 47; i++)	{		for (int j = 0; j &lt; 65; j++)		{			if (pass[i] == name[j])			{				cout &lt;&lt; j &lt;&lt; &quot; &quot;;				break;			}			else				continue;		}	 }	return 0;}得到的即为下标：25 38 49 33 25 55 44 49 29 5 61 44 28 53 61 46 27 55 17 31 24 21 61 35 12 6 53 55 25 22 57 31 24 38 5 51 25 22 13 47 25 4 20 33 31 16再转成二进制，注意补0对齐，6个一组。再去掉空格连起来。011001 100110 110001 100001 011001 110111 101100 110001 011101 000101 111101 101100 011100 110101 111101 101110 011011 110111 010001 011111 011000 010101 111101 100011 001100 000110 110101 110111 011001 010110 111001 011111 011000 100110 000101 110011 011001 010110 001101 101111 011001 000100 010100 100001 011111 010000-&gt;011001100110110001100001011001110111101100110001011101000101111101101100011100110101111101101110011011110111010001011111011000010101111101100011001100000110110101110111011001010110111001011111011000100110000101110011011001010110001101101111011001000100010100100001011111010000之后再8个一组，作为字符，查ascii表。得到flag。01100110 01101100 01100001 01100111 01111011 00110001 01110100 01011111 01101100 01110011 01011111 01101110 01101111 01110100 01011111 01100001 01011111 01100011 00110000 01101101 01110111 01100101 01101110 01011111 01100010 01100001 01110011 01100101 01100011 01101111 01100100 01000101 00100001 01111101 000-&gt;flag{1t_ls_not_a_c0mwen_basecodE!}REVERSEreverse1别想多了，这题就是看汇编。（哭）第一步：首先判断输入字符串长度是否为0x1C。用ecx作为累加器，一次处理一个字节，累加和与1Ch作比较，相等则跳转。之后判断最后一位是否是}，是则call eax 进行下一步加密。mov     al, [ecx]inc     ecxtest    al, aljnz     short loc_401030sub     ecx, edxcmp     ecx, 1Chjz      short loc_40104B…………cmp     [ebp+var_49], &#39;}&#39;jnz     short loc_401070…………lea     eax, [ebp+var_64]push    offset byte_403068push    eaxmov     eax, offset loc_403020call    eax ; loc_403020第二步：执行 call eax，之后，来到一段数据区，显然实际为代码，手动转成代码后，进行以下逻辑判断。即判断输入的前5个字符是否为flag{，是就进行call edx 下一轮加密。cmp     byte ptr [eax], &#39;f&#39;jnz     short loc_40305Fcmp     byte ptr [eax+1], &#39;l&#39;jnz     short loc_40305Fcmp     byte ptr [eax+2], &#39;a&#39;jnz     short loc_40305Fcmp     byte ptr [eax+3], &#39;g&#39;jnz     short loc_40305Fcmp     byte ptr [eax+4], &#39;{&#39;jnz     short loc_40305F…………push    offset unk_403110push    eaxcall    edx第三步：异或加密，注意到此时的基址指针ebp+8为输入的第6位的地址，而ebp-8是一个加密列表所在地址。通过赋值语句，和Intel小段结构，知道加密列表为 98 A4 A9 93。之后的运算表明，从输入的第6位开始和0xCC进行异或，再与加密的每一位依次对比，相等则继续，不等则退出，循环比较次数为4次。由于异或的可逆性，解除这段明文是：The_。最后取ebx+4则是取输入的第10位的地址进行下一轮加密。mov     ebx, [ebp+8]lea     eax, [ebp-8]push    esipush    edixor     edx, edxmov     dword ptr [ebp-8], 93A9A498h…………lea     ecx, [ebp-8]add     ecx, esimov     al, [edi+ecx]xor     al, 0CChcmp     al, [ecx]jnz     short loc_4030B9inc     esicmp     esi, 4jl      short loc_403088…………lea     eax, [ebx+4]push    offset unk_4032A0push    eaxcall    ecx第四步：Base64加密，首先进行初始化，初始加密列表为4部分：ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 +/mov     dl, &#39;A&#39;xor     ecx, ecxmov     eax, ecx…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;Z&#39;jle     short loc_40311Cmov     dl, &#39;a&#39;…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;z&#39;jle     short loc_40312Amov     dl, &#39;0&#39;…………mov     [ebp+eax-100], dlinc     dlinc     eaxcmp     dl, &#39;9&#39;jle     short loc_403138push    ebxpush    esipush    edimov     word ptr [ebp+eax-64h], &#39;/+&#39;因为为避免明文泄露，肯定会有Base64加密后的密文出现，即cmVhbEN0Rl8=。之后会将输入的第10位开始的8位进行Base64加密，与该密文进行对比。由于开启了优化，这段代码是纯数学运算，因此跳过，直接解密密文后得到realCtF_。至此前17位已经得到：flag{The_realCtF_xxxxxxxxxx}。ebx+8为输入的第18位，eax取该地址后，再进行下一步加密。mov     dword ptr [ebp-10h], &#39;hVmc&#39;mov     dword ptr [ebp-0Ch], &#39;0NEb&#39;mov     dword ptr [ebp-8], &#39;=8lR&#39;…………lea     eax, [ebx+8]push    eaxcall    ecx第五步：首先进行加密列表的初始化，得到：kvtu`C4h”o。mov     dword ptr [ebp-0Ch], &#39;utvk&#39;push    esipush    edimov     dword ptr [ebp-8], &#39;h4C`&#39;or      edx, 0FFFFFFFFhmov     word ptr [ebp-4], &#39;o&quot;&#39;之后将输入值的第18位的地址传入esi中，esi+edi为加密列表的地址，即比较ecx与eax。并且ecx=加密列表每一个字符减一的值，eax=为输入第18位开始的值。循环比较10次，相等则继续，不等则退出。为得到明文，只要将密文6B 76 74 75 60 43 34 68 22 每一位都减一即可，得到6A 75 73 74 5F 42 33 67 21 ，即为：just_B3g!movsx   ecx, byte ptr [edi+esi]movsx   eax, byte ptr [esi]dec     ecxcmp     eax, ecxjnz     short loc_4032EAinc     ebxinc     esicmp     ebx, edxjl      short loc_4032D8综上，得到flag{The_realCtF_just_B3g!n}。PWN我太菜了，完全不会啊。">



  <meta property="og:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="2017cumtctf决赛 Writeup">
  <meta name="twitter:description" content="  本次比赛历时10个小时，我们队最终取得了第二名的成绩，还算不错吧。感谢3位队友的努力付出，也感谢各位学长的认真出题与提示（笑）。以下是我们队的writeup。本人才疏学浅,不周不对之处,望乞见谅。      MISC    CRYPTO    WEB    MOBILE    REVERSE    PWN  MISC签到题School song使用16进制文本分析器直接打开wav文件，发现文件最后部分存在异常。.../-/./--./..../../-.././-....-/.--./.-/.../.../-....-/../.../-....-/..-./.-../...-..-/--.这是是一段摩斯电码，使用翻译器得到：STEGHIDE-PASS-IS-FL$G。说明wav文件采用steghide加密，密码为FL$G。steghide extract -sf cumt.wavcumtctf{Lu0Ti@NY1_s0_Cut3}Digital Image Processing 1打开后，由题目意思和文件信息格式知道，这是一张图片，根据每个点的值，画出这张图片即可得到flag。在比赛中，我们认为图片格式是RGB，但是RGB只有3位，显然不对，但是使用RGB的Python脚本画图却成功了。但是图片颜色不对，只能说运气还不错吧。#-*- coding:utf-8 -*-from PIL import Imageimport rex = 250y = 250image = Image.new(&quot;RGB&quot;,(x,y))f = open(&#39;cumt.txt&#39;)for i in range(0,x):    for j in range(0,y):        l = f.readline()        r = l.split(&quot;,&quot;)        image.putpixel((i,j),(int(r[0]),int(r[1]),int(r[2])))image.save(&#39;image1.jpg&#39;)得到flag。cumtctf{CMYK_ExC1t3d}Digital Image Processing 2这道题，题目提示是傅里叶变换，由此想到数字水印，网上苦苦寻觅，只有matlab能处理，但是队友三人都没用matlab，无奈。最后使用photoshop进行简单的处理，依稀能看到flag，剩下的一位看不清，于是开始猜，虽然最后猜对了，但是提交时比赛已经结束。。。cumtctf{666_to_you}Hacker本题给了个抓包文件，还有一个加密的zip。打开wireshark，追踪TCP，查看各文件头，存在一个linux下可执行文件，提取出来后找到zip密码为：int_main_bxs。解密zip后得到mini.pcap，打开继续分析，发现flag.tar.gz文件，仔细追踪TCP，在其中一个发现了该文件的文件头，恢复文件，得到flag.txt。cumtctf{CaiDao_@nd_B4ckDoor_so_c00l!}LSB Picture这个题目首先给了个mp3，但是分析知道里面有个PNG文件，提取出来之后，首先根据题目意思LSB，分析了半天，没什么用，然后放了HINT，在mp3里面，也就是PNG文件最后，发现一段代码。。。aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyaW5jL2Nsb2Fja2VkLXBpeGVsKHBhc3N3b3JkOmZsYWcp最后发现是Base64加密，解密后得到：https://github.com/cyberinc/cloacked-pixel(password:flag)然后去这个地址找工具。。。下载下来后。python lsb.py extract 0.png-1.png flag得到一个文件。名曰：LDR.asm。。。00010554~00010674E52DB004 E28DB000E24DD01C E50B0018E3A03000 E50B3010EA000022 E3A03000E50B3008 E3A03000E50B300C EA000013E51B300C E51B2018E0823003 E5D33000E1A00003 E59F10C8E51B2010 E1A03002E1A03203 E0433002E51B200C E0833002E7913103 E0030390E51B2008 E0823003E50B3008 E51B300CE2833001 E50B300CE51B300C E353000EDAFFFFE8 E59F1084E51B3010 E51B2008E7812103 E51B3010E2833001 E50B3010E51B3010 E353000EDAFFFFD9 E3A03000E50B3010 EA00000CE59F2050 E51B3010E7922103 E59F1048E51B3010 E7913103E1520003 0A000001E3E03000 EA000006E51B3010 E2833001E50B3010 E51B3010E353000E DAFFFFEFE3A03000 E1A00003E24BD000 E49DB004E12FFF1E 0002103400021400 000213B8=================0002102C~0002146C00000000 0000000000000024 0000000E00000011 0000002000000008 0000000600000001 0000000C0000004C 0000005500000031 0000001200000039 0000000200000002 0000002100000010 000000100000001E 0000000600000004 000000020000000A 0000004800000054 0000002F00000013 0000003900000001 000000010000001C 0000000F0000000F 0000001B00000006 0000000400000001 0000000900000040 0000004D0000002B 0000001200000035 0000000100000002 000000130000000C 0000000B00000013 0000000500000001 0000000100000005 0000002B00000037 0000001C0000000E 0000002700000001 0000000100000019 0000000A0000000B 0000001400000006 0000000400000001 0000000800000031 000000370000001E 0000000D00000026 0000000100000001 0000001A0000000E 0000000F0000001B 0000000400000005 000000000000000B 0000003F0000004D 0000002C0000000F 0000003300000003 000000030000001F 0000001000000010 0000001C00000007 0000000200000002 0000000800000042 0000004F0000002A 0000001300000037 0000000100000001 0000000F00000006 0000000800000010 0000000200000002 0000000000000005 0000002500000029 0000001A00000007 0000001A00000001 0000000100000028 0000000C00000011 0000002100000007 0000000700000002 0000000D00000051 0000005300000033 0000001000000036 0000000100000001 000000230000000C 0000001100000020 0000000600000006 000000010000000C 0000004C00000052 000000320000000F 0000003500000002 0000000200000018 000000080000000B 0000001500000004 0000000400000001 0000000800000033 0000003600000021 0000000A00000023 0000000100000001 0000001E0000000E 0000000D00000019 0000000700000002 0000000200000007 0000003D00000046 0000002600000012 0000003100000000 0000000000000020 0000000E00000010 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000002 0000001D0000000F 0000000F0000001B 0000000700000005 000000010000000A 000000400000004E 0000002A00000012 0000003600000002 0000000300000020 0000000E00000011 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000003 00008ED100008921 00007CD80000570C 00005D8700007B78 0000800E0000428D 0000906500008A65 00005BCF00007343 00007FB000007F03 0000805500000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 00000000显然是一个ARM汇编，但是鄙人不懂ARM平台汇编。更不用说直接给机器码和数据了。（学长够狠的，一个LSB出成这样。。。）CRYPTOBase都说是base了，先将hex转成text，再base64解密54553479567A493152455250556C524956314655516B394E576C593257564E4254303554566A5A4F56454A48566C4E594D6A303950513D3D-&gt; TU4yVzI1RERPUlRIV1FUQk9NWlY2WVNBT05TVjZOVEJHVlNYMj09PQ==-&gt; MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===最后出现3个=，应该不是base64了，推测是base32MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===-&gt; cumtctf{Bas3_b@se_6a5e}我都不好意思说这是加密密文最后有6个等号，肯定不是base64了，是base32OFQXC5DTM5PWG6LSMJPWQ2LINB5W63LLMZPWG43XPU======-&gt; qaqtsg_cyrb_hihh{omkf_csw}这又是常见的套路。一般就是栅栏，凯撒，最多还有ROT13这几个混着用。。。qaqtsg_cyrb_hihh{omkf_csw}-&gt; qiahqht{sogm_kcfy_rcbs_wh}-&gt; cumtctf{easy_work_done_it}超超超简单的RSA题目很明显给出了rsa的攻击，打开文件发现两个txt文档，打开任意一个文档发现里面均存在有n 与 e，所以知道本题目是两个rsa文件（即两个被加密的文件），所以想办法得到每个文件的私钥才可以解题。对第一个A文本中的n用质数分解发现分解不出来（对了，我不懂16进制怎么去处理，所以用py全部转成10进制了，花了一些时间。。。。）所以很复杂。想了好久猜想两个文本A与B中的N也许有联系，所以用py处理了一下两个质数得出了他们的最大公约数，所以以这个公约数C作为P，即得出Q=N/P。有P有Q然后用小工具（下图）得出私钥D。之后有私钥利用A文本里给的公钥与小工具,将密文等数据填写进去得到即明文得出来了。不过B文件的内容我没有去尝试解，大家可以去解下试试。模数N=29418132766062200053827508724246843105374637443595563658353636901180985530454564748758954022059769968982002140853896779902444989762754829021500174009685317744797202131791952882245156752602275951380571602331788950944361654561540811865247443070852205987517914882270234145588910167329180689201693364463939325045996426086956404110646487321752453515607959864012257125599952218384912758492278760212475418527633763779623723297398616758881690569134708160861225121310386258262233845349929832236096958219199090596331413929196303615488618826471077896979729621018914864133480510063685383380281751344618122905355446455152052146107私钥D=5276569622169127583335396030174609377842679457826382876886732018555136943898524693377979534161711823815512184943455864784707258401816484897185891483275856469930223821580727295178409526710404020255132334411694676322006535535546302259515681376235707488042647120486202926845339494431016269464963898657451334903848837250871373477682894250164643619602539540167941126569254100541247071088029518267294673136150590137761627750871598184521964595130415894447450203665799780203794291800387632230796502586420060307704968798926230993933417456137261862838342423360539764609700124237130276870839075369086314306378124788811184527308864016188670758147951657948794726339811014447072181868238689002340820729878182691215125098872623119560093174867103561051579057密文=16100055693360522322921904559463506095804777561229411389210562116776123887118032506500785234735650863266120870039583905903640748310769171758726776231272365756600955133373377424528798613667972612939112952739492634777392213118214538310023716791113397548161112585724810411650439986941834109983323315567262092245187889800878232402966804760965881216269022049586892968822789422135384021734622276346902887808132752808716548024992278042957487218505559297871159990210141047554025964806293617142183951888549982800751775892257499574146183538611011708642419473426914866890982026974237403676735705451473230887885053941067076232393公钥e=0x10001此外，根据A和B文本得到的最大公约数Q=176619317803996218465829943540526296076867590914430196106340551568870328156449028441778892112662362916940116161090362718242443676528799588976770654437504474997568793583909264900680213577430229171890593572386841798207200784823655954364900051437142324539709060542879468781584230692448457677803389650254712030259P=166562373424571003644969210886957594935507861087984296297058666148455412078457690109851370986660882279126361524191566223822671452404569269819830903808012097953053534590353386995492143954050309296677311577678675327620326594657482392410288368865181591208513290907483245868756146614333721689500461074105692470873cumtctf{GCD_is_Useful_in_Rsa}WEB暴打出题人上来给了一个留言板,然后提示用XSS平台.网上找了一个XSS平台,通过最简单的使用得到了cookie。在最开始的留言板的页面加入XSS平台得到的cookie即得flag。just trick这个题涉及到几个小技巧  首先进入页面查看源代码得到的提示,然后打开这个文本得到代码。&lt;?phpecho &quot;&lt;!--index.txt--&gt;&quot;;if(!$_GET[&#39;id&#39;]){    header(&#39;Location: index.php?id=1&#39;);    exit();}$id=$_GET[&#39;id&#39;];if($id==0)  {      if(isset($_COOKIE[&#39;token&#39;]))      {        $key=$_GET[&#39;key&#39;];        $token =$_COOKIE[&#39;token&#39;];        if(isset($key)&amp;&amp;(file_get_contents($key,&#39;r&#39;)===&quot;I want flag!!!&quot;))        {          echo &quot;hello Hacker!&lt;br&gt;&quot;;          include(&quot;include.php&quot;);          echo cumtctf_unserialize($token);        }        else        {            echo &quot;You are not Hacker ! &quot;;          }        }  }?&gt;  PHP中可以看到首先get方式提交一个id的值,在if(!$_GET[‘id’])的地方需要值不为空跳过if,后面if($id==0)的地方需要id的值为0进入if,如果id=0第一个if语句无法跳过,所以让id=’0’这两个地方就都能过去.  看到需要get方式提交一个key.想让file_get_contents($key,’r’)===”I want flag!!!”可以用PHP的封装协议php://input,它可以得到原始的POST数据.  这里我想了好久怎么才能看到include.php的内容= =,也没有文件包含什么的,最后发现和看index.php一下,看一下include.txt就得到了内容。&lt;?phpecho &quot;&lt;!--include.txt--&gt;&quot;;class Read{//flag.php    public $file;    public function __toString(){        if(isset($this-&gt;file)){            if(&quot;flag.php&quot;===$this-&gt;file||stripos($this-&gt;file,&quot;://&quot;)&gt;-1)            {                exit();              }            else            {                echo file_get_contents($this-&gt;file);            }                      }        return &quot;you are big Hacker&quot;;    }}function cumtctf_unserialize($value)    {        preg_match(&#39;/[oc]:\d+:/i&#39;, $value,$matches);        if(count($matches)){            return false;        }        return unserialize($value);    }?&gt;  最后就是读flag.php的内容了,这里可以通过反序列化去读,但是有两个过滤,一个是过滤了协议的使用,php://filter/convert.base64-encode/resource=flag.php就不能用了,因为不是严格的查找字符串所以./flag.php,后面还有一个对于你传入的序列化字符串有一个正则的过滤,PHP序列化字符串中对象长度前加一个+号仍可正常反序列化,可用此来绕过正则.将这个的序列化字符串作为cookie里面token的值提交得flag.TextWall进去随便提交了一个东西然后看到有一个lists的cookie,其中值为24c5889e00902d6bcc65073f0e91ea30bbe203c2 a:1:{i:0;s:9:”hiehiehie”;},字符串前一段为后一段序列化字符串的SHA1.一般构造反序列化一般都需要源码，所以找到了源码泄露点：http://textwall.bxsteam.xyz/.index.php.swo。&lt;?php$lists = [];Class filelist{    public function __toString()    {        return highlight_file(&#39;hiehiehie.txt&#39;, true).highlight_file($this-&gt;source, true);    }}........?&gt;构造序列化的串（反序列化后是一个filelist类，$sorce值是我们想查找的路径，这样在反序列化后）这里我们构造如下:$a = new filelist();$b= new filelist();$b-&gt;source = &#39;index.php&#39;;$a-&gt;source=$b;$d=serialize($a);$e=sha1($d).$d;echo urlencode($e).&quot;&lt;br&gt;&quot;;得到16d8c3c46653e89932859dd7a2eb12fa59df777aO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3B%7D%7D作为cookie提交得到源码(贴部分):233333333333333333333333333333333333333333333333333333333333333333 &lt;?php//flag in Fl4444444444g.phpsession_start();$lists = [];Class filelist{    public $source;    public function __toString()在上面的过程中将路径改为Fl4444444444g.php,读取即得到flag.简单的盲注这个题第一个hint是请关注图片,抓包发现是get请求发送图片对应的id来获取图片,这里id就是注入点,当id=1”的时候会报错,说明sql语句中使用的是”,接下来就是盲注密码,构造的为id=1”and ord(mid((password),1,1))&lt;48#,跑出来密码为8211d7b4ba2828919651,是DEDECMS的20位MD5加密,账号admin然后登陆进去一个上传文件的地方.文件后缀是白名单过滤,我查了好久都没有结果,后来得知是phps后缀(不知道在哪里找的这种后缀…),然后还是传不上去是因为有关于PHP标识的过滤,改为比较不常见的脚本类型可以绕过。(开始时候我把language拼错了导致半天没过…)。MOBILE多谢款待这题很坑，因为我android版本的原因，这个APK运行不了。而且很奇怪，是因为加保护了，还是其他原因，用Android_Killer无法反编译。无奈之下，用APKtools，对Main先转dex，再转java。直接看源码。。但是也很奇怪，这样转出来的string，都是十六进制的数字，不是ascii表示，也不是其他的。什么编码，卡在这里半天。。。后来学长指点说用Jeb可以看。于是我就去下载了。之后进行反编译。以下是伪Java代码。private boolean check(String arg10, int arg11){    int v0[] = new int[]{125, 108, 97, 103, 123, 51, 108, 51, 99, 116, 101, 57, 114, 65, 104, 99, 95, 99, 49, 114, 102};    //  数组的值是：}lag{3l3cte9rAhc_c1rf    int v2 = 0;    int v3 = 0;    char v5[]  = arg10.toCharArray();    if(arg10 != null &amp;&amp; arg11 != 0)    {        if(v5[0] == v0[arg10.length() - 1] &amp;&amp; v5[arg10.length() - 1] == v0[0])        {            v2 = 1;        }        int v1;        for(v1 = 1; v1 &lt; arg10.length() / 2; ++v1)        {            if(v5[v1] != v0[v1])            {                break;            }            if(v1 == arg10.length() / 2 - 1)            {                v3 = 1;            }        }        while(v1 &lt; arg10.length() - 1)        {            if(v5[v1] != v0[arg10.length() - v1])            {                break;            }            ++v1;        }    }return v2 &amp; v3;}public void onClick(View arg5){    String v0 = this.editText.getText().toString().trim();    if(!this.check(v0, v0.length()))    {        Toast.makeText(((Context)this), &quot;It\&#39;s not smell good!&quot;, 0).show();    }    else    {        Toast.makeText(((Context)this), &quot;Good, you got it!&quot;, 0).show();    }}为得到flag，只要check返回1就行，即在check中v2和v3都是1，发现check只是进行简单的替换，将最后一位和第一位替换。还原只要将}lag{3l3cte9rAhc_c1rf中第一位和最后一位对调即可，当然，长度相同也行，只要第一位是f，最后一位是}。这时候v2=1，而此时v3根据程序的推进必等于1，所以得到flag。flag{3l3cte9rAhc_c1r}助人为乐这题，和第一题一样，我直接用Jeb分析了，Android_Killer同样失效了。程序的关键部分如下： public static String encode(String password) {        int v11 = 6;        int v10 = 2;        if(password != null &amp;&amp; password.length() != 0)			{            char[] pass = password.toCharArray();            StringBuilder v2 = new StringBuilder();            int i;            for(i = 0; i &lt; pass.length; ++i) {                String v0;                for(v0 = Integer.toBinaryString(pass[i]); v0.length() &lt; 8; v0 = &quot;0&quot; + v0) {                }                v2.append(v0);            }            while(v2.length() % 6 != 0) {                v2.append(&quot;0&quot;);            }            String v1 = String.valueOf(v2);            char[] v4 = new char[v1.length() / 6];            for(i = 0; i &lt; v4.length; ++i) {                int v6 = Integer.parseInt(v1.substring(0, v11), v10);                v1 = v1.substring(v11);                v4[i] = Code.CodeText.charAt(v6);            }            StringBuilder v3 = new StringBuilder(String.valueOf(v4));            if(password.length() % 3 == 1) {                v3.append(&quot;1&quot;);            }            else if(password.length() % 3 == v10) {                v3.append(&quot;23&quot;);            }            for(i = 76; i &lt; v3.length(); i += 76) {                v3.insert(i, &quot;\r\n&quot;);            }            v3.append(&quot;\r\n&quot;);            password = String.valueOf(v3);        }        return password;    }这其中有两个列表，一个是加密列表：（长度为64=2^6）abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#\$%^&amp;*()+/另一个是密文：zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1本题就是要求我们解密出明文。加密过程大致如下：首先将输入的字符串对应的ascii码转换成二进制，每一字符是8bit，得到一串比特流。之后检测总长度是否为6的倍数，不是的话在后面补0，之后将比特流每6个一组，得到一串数字，数字均小于63(2^6-1)，将这串数字作为加密列表的下标查找对应字符，实现加密。所以解法如下： 首先查找密文每一位在加密列表中的下标。int main(){    char pass[] = &quot;zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1&quot;;	char name[] = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()+/&quot;;	for (int i = 0; i &lt; 47; i++)	{		for (int j = 0; j &lt; 65; j++)		{			if (pass[i] == name[j])			{				cout &lt;&lt; j &lt;&lt; &quot; &quot;;				break;			}			else				continue;		}	 }	return 0;}得到的即为下标：25 38 49 33 25 55 44 49 29 5 61 44 28 53 61 46 27 55 17 31 24 21 61 35 12 6 53 55 25 22 57 31 24 38 5 51 25 22 13 47 25 4 20 33 31 16再转成二进制，注意补0对齐，6个一组。再去掉空格连起来。011001 100110 110001 100001 011001 110111 101100 110001 011101 000101 111101 101100 011100 110101 111101 101110 011011 110111 010001 011111 011000 010101 111101 100011 001100 000110 110101 110111 011001 010110 111001 011111 011000 100110 000101 110011 011001 010110 001101 101111 011001 000100 010100 100001 011111 010000-&gt;011001100110110001100001011001110111101100110001011101000101111101101100011100110101111101101110011011110111010001011111011000010101111101100011001100000110110101110111011001010110111001011111011000100110000101110011011001010110001101101111011001000100010100100001011111010000之后再8个一组，作为字符，查ascii表。得到flag。01100110 01101100 01100001 01100111 01111011 00110001 01110100 01011111 01101100 01110011 01011111 01101110 01101111 01110100 01011111 01100001 01011111 01100011 00110000 01101101 01110111 01100101 01101110 01011111 01100010 01100001 01110011 01100101 01100011 01101111 01100100 01000101 00100001 01111101 000-&gt;flag{1t_ls_not_a_c0mwen_basecodE!}REVERSEreverse1别想多了，这题就是看汇编。（哭）第一步：首先判断输入字符串长度是否为0x1C。用ecx作为累加器，一次处理一个字节，累加和与1Ch作比较，相等则跳转。之后判断最后一位是否是}，是则call eax 进行下一步加密。mov     al, [ecx]inc     ecxtest    al, aljnz     short loc_401030sub     ecx, edxcmp     ecx, 1Chjz      short loc_40104B…………cmp     [ebp+var_49], &#39;}&#39;jnz     short loc_401070…………lea     eax, [ebp+var_64]push    offset byte_403068push    eaxmov     eax, offset loc_403020call    eax ; loc_403020第二步：执行 call eax，之后，来到一段数据区，显然实际为代码，手动转成代码后，进行以下逻辑判断。即判断输入的前5个字符是否为flag{，是就进行call edx 下一轮加密。cmp     byte ptr [eax], &#39;f&#39;jnz     short loc_40305Fcmp     byte ptr [eax+1], &#39;l&#39;jnz     short loc_40305Fcmp     byte ptr [eax+2], &#39;a&#39;jnz     short loc_40305Fcmp     byte ptr [eax+3], &#39;g&#39;jnz     short loc_40305Fcmp     byte ptr [eax+4], &#39;{&#39;jnz     short loc_40305F…………push    offset unk_403110push    eaxcall    edx第三步：异或加密，注意到此时的基址指针ebp+8为输入的第6位的地址，而ebp-8是一个加密列表所在地址。通过赋值语句，和Intel小段结构，知道加密列表为 98 A4 A9 93。之后的运算表明，从输入的第6位开始和0xCC进行异或，再与加密的每一位依次对比，相等则继续，不等则退出，循环比较次数为4次。由于异或的可逆性，解除这段明文是：The_。最后取ebx+4则是取输入的第10位的地址进行下一轮加密。mov     ebx, [ebp+8]lea     eax, [ebp-8]push    esipush    edixor     edx, edxmov     dword ptr [ebp-8], 93A9A498h…………lea     ecx, [ebp-8]add     ecx, esimov     al, [edi+ecx]xor     al, 0CChcmp     al, [ecx]jnz     short loc_4030B9inc     esicmp     esi, 4jl      short loc_403088…………lea     eax, [ebx+4]push    offset unk_4032A0push    eaxcall    ecx第四步：Base64加密，首先进行初始化，初始加密列表为4部分：ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 +/mov     dl, &#39;A&#39;xor     ecx, ecxmov     eax, ecx…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;Z&#39;jle     short loc_40311Cmov     dl, &#39;a&#39;…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;z&#39;jle     short loc_40312Amov     dl, &#39;0&#39;…………mov     [ebp+eax-100], dlinc     dlinc     eaxcmp     dl, &#39;9&#39;jle     short loc_403138push    ebxpush    esipush    edimov     word ptr [ebp+eax-64h], &#39;/+&#39;因为为避免明文泄露，肯定会有Base64加密后的密文出现，即cmVhbEN0Rl8=。之后会将输入的第10位开始的8位进行Base64加密，与该密文进行对比。由于开启了优化，这段代码是纯数学运算，因此跳过，直接解密密文后得到realCtF_。至此前17位已经得到：flag{The_realCtF_xxxxxxxxxx}。ebx+8为输入的第18位，eax取该地址后，再进行下一步加密。mov     dword ptr [ebp-10h], &#39;hVmc&#39;mov     dword ptr [ebp-0Ch], &#39;0NEb&#39;mov     dword ptr [ebp-8], &#39;=8lR&#39;…………lea     eax, [ebx+8]push    eaxcall    ecx第五步：首先进行加密列表的初始化，得到：kvtu`C4h”o。mov     dword ptr [ebp-0Ch], &#39;utvk&#39;push    esipush    edimov     dword ptr [ebp-8], &#39;h4C`&#39;or      edx, 0FFFFFFFFhmov     word ptr [ebp-4], &#39;o&quot;&#39;之后将输入值的第18位的地址传入esi中，esi+edi为加密列表的地址，即比较ecx与eax。并且ecx=加密列表每一个字符减一的值，eax=为输入第18位开始的值。循环比较10次，相等则继续，不等则退出。为得到明文，只要将密文6B 76 74 75 60 43 34 68 22 每一位都减一即可，得到6A 75 73 74 5F 42 33 67 21 ，即为：just_B3g!movsx   ecx, byte ptr [edi+esi]movsx   eax, byte ptr [esi]dec     ecxcmp     eax, ecxjnz     short loc_4032EAinc     ebxinc     esicmp     ebx, edxjl      short loc_4032D8综上，得到flag{The_realCtF_just_B3g!n}。PWN我太菜了，完全不会啊。">
  <meta name="twitter:url" content="https://zjgcjy.github.io/posts/2018-08/2017cumtctf%E5%86%B3%E8%B5%9B-writeup.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2018-08-18T23:12:00+08:00">





  

  


<link rel="canonical" href="https://zjgcjy.github.io/posts/2018-08/2017cumtctf%E5%86%B3%E8%B5%9B-writeup.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "https://zjgcjy.github.io/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/apple-touch-icon.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about.html" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fa fa-map-marker" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fa fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fa fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="2017cumtctf决赛 Writeup">
    <meta itemprop="description" content="  本次比赛历时10个小时，我们队最终取得了第二名的成绩，还算不错吧。感谢3位队友的努力付出，也感谢各位学长的认真出题与提示（笑）。以下是我们队的writeup。本人才疏学浅,不周不对之处,望乞见谅。      MISC    CRYPTO    WEB    MOBILE    REVERSE    PWN  MISC签到题School song使用16进制文本分析器直接打开wav文件，发现文件最后部分存在异常。.../-/./--./..../../-.././-....-/.--./.-/.../.../-....-/../.../-....-/..-./.-../...-..-/--.这是是一段摩斯电码，使用翻译器得到：STEGHIDE-PASS-IS-FL$G。说明wav文件采用steghide加密，密码为FL$G。steghide extract -sf cumt.wavcumtctf{Lu0Ti@NY1_s0_Cut3}Digital Image Processing 1打开后，由题目意思和文件信息格式知道，这是一张图片，根据每个点的值，画出这张图片即可得到flag。在比赛中，我们认为图片格式是RGB，但是RGB只有3位，显然不对，但是使用RGB的Python脚本画图却成功了。但是图片颜色不对，只能说运气还不错吧。#-*- coding:utf-8 -*-from PIL import Imageimport rex = 250y = 250image = Image.new(&quot;RGB&quot;,(x,y))f = open(&#39;cumt.txt&#39;)for i in range(0,x):    for j in range(0,y):        l = f.readline()        r = l.split(&quot;,&quot;)        image.putpixel((i,j),(int(r[0]),int(r[1]),int(r[2])))image.save(&#39;image1.jpg&#39;)得到flag。cumtctf{CMYK_ExC1t3d}Digital Image Processing 2这道题，题目提示是傅里叶变换，由此想到数字水印，网上苦苦寻觅，只有matlab能处理，但是队友三人都没用matlab，无奈。最后使用photoshop进行简单的处理，依稀能看到flag，剩下的一位看不清，于是开始猜，虽然最后猜对了，但是提交时比赛已经结束。。。cumtctf{666_to_you}Hacker本题给了个抓包文件，还有一个加密的zip。打开wireshark，追踪TCP，查看各文件头，存在一个linux下可执行文件，提取出来后找到zip密码为：int_main_bxs。解密zip后得到mini.pcap，打开继续分析，发现flag.tar.gz文件，仔细追踪TCP，在其中一个发现了该文件的文件头，恢复文件，得到flag.txt。cumtctf{CaiDao_@nd_B4ckDoor_so_c00l!}LSB Picture这个题目首先给了个mp3，但是分析知道里面有个PNG文件，提取出来之后，首先根据题目意思LSB，分析了半天，没什么用，然后放了HINT，在mp3里面，也就是PNG文件最后，发现一段代码。。。aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyaW5jL2Nsb2Fja2VkLXBpeGVsKHBhc3N3b3JkOmZsYWcp最后发现是Base64加密，解密后得到：https://github.com/cyberinc/cloacked-pixel(password:flag)然后去这个地址找工具。。。下载下来后。python lsb.py extract 0.png-1.png flag得到一个文件。名曰：LDR.asm。。。00010554~00010674E52DB004 E28DB000E24DD01C E50B0018E3A03000 E50B3010EA000022 E3A03000E50B3008 E3A03000E50B300C EA000013E51B300C E51B2018E0823003 E5D33000E1A00003 E59F10C8E51B2010 E1A03002E1A03203 E0433002E51B200C E0833002E7913103 E0030390E51B2008 E0823003E50B3008 E51B300CE2833001 E50B300CE51B300C E353000EDAFFFFE8 E59F1084E51B3010 E51B2008E7812103 E51B3010E2833001 E50B3010E51B3010 E353000EDAFFFFD9 E3A03000E50B3010 EA00000CE59F2050 E51B3010E7922103 E59F1048E51B3010 E7913103E1520003 0A000001E3E03000 EA000006E51B3010 E2833001E50B3010 E51B3010E353000E DAFFFFEFE3A03000 E1A00003E24BD000 E49DB004E12FFF1E 0002103400021400 000213B8=================0002102C~0002146C00000000 0000000000000024 0000000E00000011 0000002000000008 0000000600000001 0000000C0000004C 0000005500000031 0000001200000039 0000000200000002 0000002100000010 000000100000001E 0000000600000004 000000020000000A 0000004800000054 0000002F00000013 0000003900000001 000000010000001C 0000000F0000000F 0000001B00000006 0000000400000001 0000000900000040 0000004D0000002B 0000001200000035 0000000100000002 000000130000000C 0000000B00000013 0000000500000001 0000000100000005 0000002B00000037 0000001C0000000E 0000002700000001 0000000100000019 0000000A0000000B 0000001400000006 0000000400000001 0000000800000031 000000370000001E 0000000D00000026 0000000100000001 0000001A0000000E 0000000F0000001B 0000000400000005 000000000000000B 0000003F0000004D 0000002C0000000F 0000003300000003 000000030000001F 0000001000000010 0000001C00000007 0000000200000002 0000000800000042 0000004F0000002A 0000001300000037 0000000100000001 0000000F00000006 0000000800000010 0000000200000002 0000000000000005 0000002500000029 0000001A00000007 0000001A00000001 0000000100000028 0000000C00000011 0000002100000007 0000000700000002 0000000D00000051 0000005300000033 0000001000000036 0000000100000001 000000230000000C 0000001100000020 0000000600000006 000000010000000C 0000004C00000052 000000320000000F 0000003500000002 0000000200000018 000000080000000B 0000001500000004 0000000400000001 0000000800000033 0000003600000021 0000000A00000023 0000000100000001 0000001E0000000E 0000000D00000019 0000000700000002 0000000200000007 0000003D00000046 0000002600000012 0000003100000000 0000000000000020 0000000E00000010 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000002 0000001D0000000F 0000000F0000001B 0000000700000005 000000010000000A 000000400000004E 0000002A00000012 0000003600000002 0000000300000020 0000000E00000011 0000001C00000007 0000000300000002 0000000800000044 0000004D0000002C 0000001200000035 0000000000000003 00008ED100008921 00007CD80000570C 00005D8700007B78 0000800E0000428D 0000906500008A65 00005BCF00007343 00007FB000007F03 0000805500000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 00000000显然是一个ARM汇编，但是鄙人不懂ARM平台汇编。更不用说直接给机器码和数据了。（学长够狠的，一个LSB出成这样。。。）CRYPTOBase都说是base了，先将hex转成text，再base64解密54553479567A493152455250556C524956314655516B394E576C593257564E4254303554566A5A4F56454A48566C4E594D6A303950513D3D-&gt; TU4yVzI1RERPUlRIV1FUQk9NWlY2WVNBT05TVjZOVEJHVlNYMj09PQ==-&gt; MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===最后出现3个=，应该不是base64了，推测是base32MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===-&gt; cumtctf{Bas3_b@se_6a5e}我都不好意思说这是加密密文最后有6个等号，肯定不是base64了，是base32OFQXC5DTM5PWG6LSMJPWQ2LINB5W63LLMZPWG43XPU======-&gt; qaqtsg_cyrb_hihh{omkf_csw}这又是常见的套路。一般就是栅栏，凯撒，最多还有ROT13这几个混着用。。。qaqtsg_cyrb_hihh{omkf_csw}-&gt; qiahqht{sogm_kcfy_rcbs_wh}-&gt; cumtctf{easy_work_done_it}超超超简单的RSA题目很明显给出了rsa的攻击，打开文件发现两个txt文档，打开任意一个文档发现里面均存在有n 与 e，所以知道本题目是两个rsa文件（即两个被加密的文件），所以想办法得到每个文件的私钥才可以解题。对第一个A文本中的n用质数分解发现分解不出来（对了，我不懂16进制怎么去处理，所以用py全部转成10进制了，花了一些时间。。。。）所以很复杂。想了好久猜想两个文本A与B中的N也许有联系，所以用py处理了一下两个质数得出了他们的最大公约数，所以以这个公约数C作为P，即得出Q=N/P。有P有Q然后用小工具（下图）得出私钥D。之后有私钥利用A文本里给的公钥与小工具,将密文等数据填写进去得到即明文得出来了。不过B文件的内容我没有去尝试解，大家可以去解下试试。模数N=29418132766062200053827508724246843105374637443595563658353636901180985530454564748758954022059769968982002140853896779902444989762754829021500174009685317744797202131791952882245156752602275951380571602331788950944361654561540811865247443070852205987517914882270234145588910167329180689201693364463939325045996426086956404110646487321752453515607959864012257125599952218384912758492278760212475418527633763779623723297398616758881690569134708160861225121310386258262233845349929832236096958219199090596331413929196303615488618826471077896979729621018914864133480510063685383380281751344618122905355446455152052146107私钥D=5276569622169127583335396030174609377842679457826382876886732018555136943898524693377979534161711823815512184943455864784707258401816484897185891483275856469930223821580727295178409526710404020255132334411694676322006535535546302259515681376235707488042647120486202926845339494431016269464963898657451334903848837250871373477682894250164643619602539540167941126569254100541247071088029518267294673136150590137761627750871598184521964595130415894447450203665799780203794291800387632230796502586420060307704968798926230993933417456137261862838342423360539764609700124237130276870839075369086314306378124788811184527308864016188670758147951657948794726339811014447072181868238689002340820729878182691215125098872623119560093174867103561051579057密文=16100055693360522322921904559463506095804777561229411389210562116776123887118032506500785234735650863266120870039583905903640748310769171758726776231272365756600955133373377424528798613667972612939112952739492634777392213118214538310023716791113397548161112585724810411650439986941834109983323315567262092245187889800878232402966804760965881216269022049586892968822789422135384021734622276346902887808132752808716548024992278042957487218505559297871159990210141047554025964806293617142183951888549982800751775892257499574146183538611011708642419473426914866890982026974237403676735705451473230887885053941067076232393公钥e=0x10001此外，根据A和B文本得到的最大公约数Q=176619317803996218465829943540526296076867590914430196106340551568870328156449028441778892112662362916940116161090362718242443676528799588976770654437504474997568793583909264900680213577430229171890593572386841798207200784823655954364900051437142324539709060542879468781584230692448457677803389650254712030259P=166562373424571003644969210886957594935507861087984296297058666148455412078457690109851370986660882279126361524191566223822671452404569269819830903808012097953053534590353386995492143954050309296677311577678675327620326594657482392410288368865181591208513290907483245868756146614333721689500461074105692470873cumtctf{GCD_is_Useful_in_Rsa}WEB暴打出题人上来给了一个留言板,然后提示用XSS平台.网上找了一个XSS平台,通过最简单的使用得到了cookie。在最开始的留言板的页面加入XSS平台得到的cookie即得flag。just trick这个题涉及到几个小技巧  首先进入页面查看源代码得到的提示,然后打开这个文本得到代码。&lt;?phpecho &quot;&lt;!--index.txt--&gt;&quot;;if(!$_GET[&#39;id&#39;]){    header(&#39;Location: index.php?id=1&#39;);    exit();}$id=$_GET[&#39;id&#39;];if($id==0)  {      if(isset($_COOKIE[&#39;token&#39;]))      {        $key=$_GET[&#39;key&#39;];        $token =$_COOKIE[&#39;token&#39;];        if(isset($key)&amp;&amp;(file_get_contents($key,&#39;r&#39;)===&quot;I want flag!!!&quot;))        {          echo &quot;hello Hacker!&lt;br&gt;&quot;;          include(&quot;include.php&quot;);          echo cumtctf_unserialize($token);        }        else        {            echo &quot;You are not Hacker ! &quot;;          }        }  }?&gt;  PHP中可以看到首先get方式提交一个id的值,在if(!$_GET[‘id’])的地方需要值不为空跳过if,后面if($id==0)的地方需要id的值为0进入if,如果id=0第一个if语句无法跳过,所以让id=’0’这两个地方就都能过去.  看到需要get方式提交一个key.想让file_get_contents($key,’r’)===”I want flag!!!”可以用PHP的封装协议php://input,它可以得到原始的POST数据.  这里我想了好久怎么才能看到include.php的内容= =,也没有文件包含什么的,最后发现和看index.php一下,看一下include.txt就得到了内容。&lt;?phpecho &quot;&lt;!--include.txt--&gt;&quot;;class Read{//flag.php    public $file;    public function __toString(){        if(isset($this-&gt;file)){            if(&quot;flag.php&quot;===$this-&gt;file||stripos($this-&gt;file,&quot;://&quot;)&gt;-1)            {                exit();              }            else            {                echo file_get_contents($this-&gt;file);            }                      }        return &quot;you are big Hacker&quot;;    }}function cumtctf_unserialize($value)    {        preg_match(&#39;/[oc]:\d+:/i&#39;, $value,$matches);        if(count($matches)){            return false;        }        return unserialize($value);    }?&gt;  最后就是读flag.php的内容了,这里可以通过反序列化去读,但是有两个过滤,一个是过滤了协议的使用,php://filter/convert.base64-encode/resource=flag.php就不能用了,因为不是严格的查找字符串所以./flag.php,后面还有一个对于你传入的序列化字符串有一个正则的过滤,PHP序列化字符串中对象长度前加一个+号仍可正常反序列化,可用此来绕过正则.将这个的序列化字符串作为cookie里面token的值提交得flag.TextWall进去随便提交了一个东西然后看到有一个lists的cookie,其中值为24c5889e00902d6bcc65073f0e91ea30bbe203c2 a:1:{i:0;s:9:”hiehiehie”;},字符串前一段为后一段序列化字符串的SHA1.一般构造反序列化一般都需要源码，所以找到了源码泄露点：http://textwall.bxsteam.xyz/.index.php.swo。&lt;?php$lists = [];Class filelist{    public function __toString()    {        return highlight_file(&#39;hiehiehie.txt&#39;, true).highlight_file($this-&gt;source, true);    }}........?&gt;构造序列化的串（反序列化后是一个filelist类，$sorce值是我们想查找的路径，这样在反序列化后）这里我们构造如下:$a = new filelist();$b= new filelist();$b-&gt;source = &#39;index.php&#39;;$a-&gt;source=$b;$d=serialize($a);$e=sha1($d).$d;echo urlencode($e).&quot;&lt;br&gt;&quot;;得到16d8c3c46653e89932859dd7a2eb12fa59df777aO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3B%7D%7D作为cookie提交得到源码(贴部分):233333333333333333333333333333333333333333333333333333333333333333 &lt;?php//flag in Fl4444444444g.phpsession_start();$lists = [];Class filelist{    public $source;    public function __toString()在上面的过程中将路径改为Fl4444444444g.php,读取即得到flag.简单的盲注这个题第一个hint是请关注图片,抓包发现是get请求发送图片对应的id来获取图片,这里id就是注入点,当id=1”的时候会报错,说明sql语句中使用的是”,接下来就是盲注密码,构造的为id=1”and ord(mid((password),1,1))&lt;48#,跑出来密码为8211d7b4ba2828919651,是DEDECMS的20位MD5加密,账号admin然后登陆进去一个上传文件的地方.文件后缀是白名单过滤,我查了好久都没有结果,后来得知是phps后缀(不知道在哪里找的这种后缀…),然后还是传不上去是因为有关于PHP标识的过滤,改为比较不常见的脚本类型可以绕过。(开始时候我把language拼错了导致半天没过…)。MOBILE多谢款待这题很坑，因为我android版本的原因，这个APK运行不了。而且很奇怪，是因为加保护了，还是其他原因，用Android_Killer无法反编译。无奈之下，用APKtools，对Main先转dex，再转java。直接看源码。。但是也很奇怪，这样转出来的string，都是十六进制的数字，不是ascii表示，也不是其他的。什么编码，卡在这里半天。。。后来学长指点说用Jeb可以看。于是我就去下载了。之后进行反编译。以下是伪Java代码。private boolean check(String arg10, int arg11){    int v0[] = new int[]{125, 108, 97, 103, 123, 51, 108, 51, 99, 116, 101, 57, 114, 65, 104, 99, 95, 99, 49, 114, 102};    //  数组的值是：}lag{3l3cte9rAhc_c1rf    int v2 = 0;    int v3 = 0;    char v5[]  = arg10.toCharArray();    if(arg10 != null &amp;&amp; arg11 != 0)    {        if(v5[0] == v0[arg10.length() - 1] &amp;&amp; v5[arg10.length() - 1] == v0[0])        {            v2 = 1;        }        int v1;        for(v1 = 1; v1 &lt; arg10.length() / 2; ++v1)        {            if(v5[v1] != v0[v1])            {                break;            }            if(v1 == arg10.length() / 2 - 1)            {                v3 = 1;            }        }        while(v1 &lt; arg10.length() - 1)        {            if(v5[v1] != v0[arg10.length() - v1])            {                break;            }            ++v1;        }    }return v2 &amp; v3;}public void onClick(View arg5){    String v0 = this.editText.getText().toString().trim();    if(!this.check(v0, v0.length()))    {        Toast.makeText(((Context)this), &quot;It\&#39;s not smell good!&quot;, 0).show();    }    else    {        Toast.makeText(((Context)this), &quot;Good, you got it!&quot;, 0).show();    }}为得到flag，只要check返回1就行，即在check中v2和v3都是1，发现check只是进行简单的替换，将最后一位和第一位替换。还原只要将}lag{3l3cte9rAhc_c1rf中第一位和最后一位对调即可，当然，长度相同也行，只要第一位是f，最后一位是}。这时候v2=1，而此时v3根据程序的推进必等于1，所以得到flag。flag{3l3cte9rAhc_c1r}助人为乐这题，和第一题一样，我直接用Jeb分析了，Android_Killer同样失效了。程序的关键部分如下： public static String encode(String password) {        int v11 = 6;        int v10 = 2;        if(password != null &amp;&amp; password.length() != 0)			{            char[] pass = password.toCharArray();            StringBuilder v2 = new StringBuilder();            int i;            for(i = 0; i &lt; pass.length; ++i) {                String v0;                for(v0 = Integer.toBinaryString(pass[i]); v0.length() &lt; 8; v0 = &quot;0&quot; + v0) {                }                v2.append(v0);            }            while(v2.length() % 6 != 0) {                v2.append(&quot;0&quot;);            }            String v1 = String.valueOf(v2);            char[] v4 = new char[v1.length() / 6];            for(i = 0; i &lt; v4.length; ++i) {                int v6 = Integer.parseInt(v1.substring(0, v11), v10);                v1 = v1.substring(v11);                v4[i] = Code.CodeText.charAt(v6);            }            StringBuilder v3 = new StringBuilder(String.valueOf(v4));            if(password.length() % 3 == 1) {                v3.append(&quot;1&quot;);            }            else if(password.length() % 3 == v10) {                v3.append(&quot;23&quot;);            }            for(i = 76; i &lt; v3.length(); i += 76) {                v3.insert(i, &quot;\r\n&quot;);            }            v3.append(&quot;\r\n&quot;);            password = String.valueOf(v3);        }        return password;    }这其中有两个列表，一个是加密列表：（长度为64=2^6）abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#\$%^&amp;*()+/另一个是密文：zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1本题就是要求我们解密出明文。加密过程大致如下：首先将输入的字符串对应的ascii码转换成二进制，每一字符是8bit，得到一串比特流。之后检测总长度是否为6的倍数，不是的话在后面补0，之后将比特流每6个一组，得到一串数字，数字均小于63(2^6-1)，将这串数字作为加密列表的下标查找对应字符，实现加密。所以解法如下： 首先查找密文每一位在加密列表中的下标。int main(){    char pass[] = &quot;zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1&quot;;	char name[] = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()+/&quot;;	for (int i = 0; i &lt; 47; i++)	{		for (int j = 0; j &lt; 65; j++)		{			if (pass[i] == name[j])			{				cout &lt;&lt; j &lt;&lt; &quot; &quot;;				break;			}			else				continue;		}	 }	return 0;}得到的即为下标：25 38 49 33 25 55 44 49 29 5 61 44 28 53 61 46 27 55 17 31 24 21 61 35 12 6 53 55 25 22 57 31 24 38 5 51 25 22 13 47 25 4 20 33 31 16再转成二进制，注意补0对齐，6个一组。再去掉空格连起来。011001 100110 110001 100001 011001 110111 101100 110001 011101 000101 111101 101100 011100 110101 111101 101110 011011 110111 010001 011111 011000 010101 111101 100011 001100 000110 110101 110111 011001 010110 111001 011111 011000 100110 000101 110011 011001 010110 001101 101111 011001 000100 010100 100001 011111 010000-&gt;011001100110110001100001011001110111101100110001011101000101111101101100011100110101111101101110011011110111010001011111011000010101111101100011001100000110110101110111011001010110111001011111011000100110000101110011011001010110001101101111011001000100010100100001011111010000之后再8个一组，作为字符，查ascii表。得到flag。01100110 01101100 01100001 01100111 01111011 00110001 01110100 01011111 01101100 01110011 01011111 01101110 01101111 01110100 01011111 01100001 01011111 01100011 00110000 01101101 01110111 01100101 01101110 01011111 01100010 01100001 01110011 01100101 01100011 01101111 01100100 01000101 00100001 01111101 000-&gt;flag{1t_ls_not_a_c0mwen_basecodE!}REVERSEreverse1别想多了，这题就是看汇编。（哭）第一步：首先判断输入字符串长度是否为0x1C。用ecx作为累加器，一次处理一个字节，累加和与1Ch作比较，相等则跳转。之后判断最后一位是否是}，是则call eax 进行下一步加密。mov     al, [ecx]inc     ecxtest    al, aljnz     short loc_401030sub     ecx, edxcmp     ecx, 1Chjz      short loc_40104B…………cmp     [ebp+var_49], &#39;}&#39;jnz     short loc_401070…………lea     eax, [ebp+var_64]push    offset byte_403068push    eaxmov     eax, offset loc_403020call    eax ; loc_403020第二步：执行 call eax，之后，来到一段数据区，显然实际为代码，手动转成代码后，进行以下逻辑判断。即判断输入的前5个字符是否为flag{，是就进行call edx 下一轮加密。cmp     byte ptr [eax], &#39;f&#39;jnz     short loc_40305Fcmp     byte ptr [eax+1], &#39;l&#39;jnz     short loc_40305Fcmp     byte ptr [eax+2], &#39;a&#39;jnz     short loc_40305Fcmp     byte ptr [eax+3], &#39;g&#39;jnz     short loc_40305Fcmp     byte ptr [eax+4], &#39;{&#39;jnz     short loc_40305F…………push    offset unk_403110push    eaxcall    edx第三步：异或加密，注意到此时的基址指针ebp+8为输入的第6位的地址，而ebp-8是一个加密列表所在地址。通过赋值语句，和Intel小段结构，知道加密列表为 98 A4 A9 93。之后的运算表明，从输入的第6位开始和0xCC进行异或，再与加密的每一位依次对比，相等则继续，不等则退出，循环比较次数为4次。由于异或的可逆性，解除这段明文是：The_。最后取ebx+4则是取输入的第10位的地址进行下一轮加密。mov     ebx, [ebp+8]lea     eax, [ebp-8]push    esipush    edixor     edx, edxmov     dword ptr [ebp-8], 93A9A498h…………lea     ecx, [ebp-8]add     ecx, esimov     al, [edi+ecx]xor     al, 0CChcmp     al, [ecx]jnz     short loc_4030B9inc     esicmp     esi, 4jl      short loc_403088…………lea     eax, [ebx+4]push    offset unk_4032A0push    eaxcall    ecx第四步：Base64加密，首先进行初始化，初始加密列表为4部分：ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 +/mov     dl, &#39;A&#39;xor     ecx, ecxmov     eax, ecx…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;Z&#39;jle     short loc_40311Cmov     dl, &#39;a&#39;…………mov     [ebp+eax-64h], dlinc     dlinc     eaxcmp     dl, &#39;z&#39;jle     short loc_40312Amov     dl, &#39;0&#39;…………mov     [ebp+eax-100], dlinc     dlinc     eaxcmp     dl, &#39;9&#39;jle     short loc_403138push    ebxpush    esipush    edimov     word ptr [ebp+eax-64h], &#39;/+&#39;因为为避免明文泄露，肯定会有Base64加密后的密文出现，即cmVhbEN0Rl8=。之后会将输入的第10位开始的8位进行Base64加密，与该密文进行对比。由于开启了优化，这段代码是纯数学运算，因此跳过，直接解密密文后得到realCtF_。至此前17位已经得到：flag{The_realCtF_xxxxxxxxxx}。ebx+8为输入的第18位，eax取该地址后，再进行下一步加密。mov     dword ptr [ebp-10h], &#39;hVmc&#39;mov     dword ptr [ebp-0Ch], &#39;0NEb&#39;mov     dword ptr [ebp-8], &#39;=8lR&#39;…………lea     eax, [ebx+8]push    eaxcall    ecx第五步：首先进行加密列表的初始化，得到：kvtu`C4h”o。mov     dword ptr [ebp-0Ch], &#39;utvk&#39;push    esipush    edimov     dword ptr [ebp-8], &#39;h4C`&#39;or      edx, 0FFFFFFFFhmov     word ptr [ebp-4], &#39;o&quot;&#39;之后将输入值的第18位的地址传入esi中，esi+edi为加密列表的地址，即比较ecx与eax。并且ecx=加密列表每一个字符减一的值，eax=为输入第18位开始的值。循环比较10次，相等则继续，不等则退出。为得到明文，只要将密文6B 76 74 75 60 43 34 68 22 每一位都减一即可，得到6A 75 73 74 5F 42 33 67 21 ，即为：just_B3g!movsx   ecx, byte ptr [edi+esi]movsx   eax, byte ptr [esi]dec     ecxcmp     eax, ecxjnz     short loc_4032EAinc     ebxinc     esicmp     ebx, edxjl      short loc_4032D8综上，得到flag{The_realCtF_just_B3g!n}。PWN我太菜了，完全不会啊。">
    <meta itemprop="datePublished" content="August 18, 2018">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">2017cumtctf决赛 Writeup
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  14 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#misc">MISC</a>
    <ul>
      <li><a href="#签到题">签到题</a></li>
      <li><a href="#school-song">School song</a></li>
      <li><a href="#digital-image-processing-1">Digital Image Processing 1</a></li>
      <li><a href="#digital-image-processing-2">Digital Image Processing 2</a></li>
      <li><a href="#hacker">Hacker</a></li>
      <li><a href="#lsb-picture">LSB Picture</a></li>
    </ul>
  </li>
  <li><a href="#crypto">CRYPTO</a>
    <ul>
      <li><a href="#base">Base</a></li>
      <li><a href="#我都不好意思说这是加密">我都不好意思说这是加密</a></li>
      <li><a href="#超超超简单的rsa">超超超简单的RSA</a></li>
    </ul>
  </li>
  <li><a href="#web">WEB</a>
    <ul>
      <li><a href="#暴打出题人">暴打出题人</a></li>
      <li><a href="#just-trick">just trick</a></li>
      <li><a href="#textwall">TextWall</a></li>
      <li><a href="#简单的盲注">简单的盲注</a></li>
    </ul>
  </li>
  <li><a href="#mobile">MOBILE</a>
    <ul>
      <li><a href="#多谢款待">多谢款待</a></li>
      <li><a href="#助人为乐">助人为乐</a></li>
    </ul>
  </li>
  <li><a href="#reverse">REVERSE</a>
    <ul>
      <li><a href="#reverse1">reverse1</a></li>
    </ul>
  </li>
  <li><a href="#pwn">PWN</a></li>
</ul>
            </nav>
          </aside>
        
        <hr />

<blockquote>
  <p>本次比赛历时10个小时，我们队最终取得了第二名的成绩，还算不错吧。感谢3位队友的努力付出，也感谢各位学长的认真出题与提示（笑）。以下是我们队的writeup。本人才疏学浅,不周不对之处,望乞见谅。</p>
  <ul>
    <li>MISC</li>
    <li>CRYPTO</li>
    <li>WEB</li>
    <li>MOBILE</li>
    <li>REVERSE</li>
    <li>PWN</li>
  </ul>
</blockquote>

<h2 id="misc">MISC</h2>

<h3 id="签到题">签到题</h3>

<h3 id="school-song">School song</h3>

<p>使用16进制文本分析器直接打开wav文件，发现文件最后部分存在异常。</p>

<pre><code class="language-code">.../-/./--./..../../-.././-....-/.--./.-/.../.../-....-/../.../-....-/..-./.-../...-..-/--.
</code></pre>

<p>这是是一段摩斯电码，使用翻译器得到：STEGHIDE-PASS-IS-FL$G。说明wav文件采用steghide加密，密码为FL$G。</p>

<pre><code class="language-code">steghide extract -sf cumt.wav
cumtctf{Lu0Ti@NY1_s0_Cut3}
</code></pre>

<h3 id="digital-image-processing-1">Digital Image Processing 1</h3>

<p>打开后，由题目意思和文件信息格式知道，这是一张图片，根据每个点的值，画出这张图片即可得到flag。在比赛中，我们认为图片格式是RGB，但是RGB只有3位，显然不对，但是使用RGB的Python脚本画图却成功了。但是图片颜色不对，只能说运气还不错吧。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#-*- coding:utf-8 -*-
</span><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">250</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">250</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s">"RGB"</span><span class="p">,(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">'cumt.txt'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">putpixel</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
<span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">'image1.jpg'</span><span class="p">)</span>
</code></pre></div></div>

<p>得到flag。</p>

<pre><code class="language-code">cumtctf{CMYK_ExC1t3d}
</code></pre>

<h3 id="digital-image-processing-2">Digital Image Processing 2</h3>

<p>这道题，题目提示是傅里叶变换，由此想到数字水印，网上苦苦寻觅，只有matlab能处理，但是队友三人都没用matlab，无奈。最后使用photoshop进行简单的处理，依稀能看到flag，剩下的一位看不清，于是开始猜，虽然最后猜对了，但是提交时比赛已经结束。。。</p>

<pre><code class="language-code">cumtctf{666_to_you}
</code></pre>

<h3 id="hacker">Hacker</h3>
<p>本题给了个抓包文件，还有一个加密的zip。打开wireshark，追踪TCP，查看各文件头，存在一个linux下可执行文件，提取出来后找到zip密码为：int_main_bxs。解密zip后得到mini.pcap，打开继续分析，发现flag.tar.gz文件，仔细追踪TCP，在其中一个发现了该文件的文件头，恢复文件，得到flag.txt。</p>

<pre><code class="language-code">cumtctf{CaiDao_@nd_B4ckDoor_so_c00l!}
</code></pre>

<h3 id="lsb-picture">LSB Picture</h3>

<p>这个题目首先给了个mp3，但是分析知道里面有个PNG文件，提取出来之后，首先根据题目意思LSB，分析了半天，没什么用，然后放了HINT，在mp3里面，也就是PNG文件最后，发现一段代码。。。</p>

<pre><code class="language-code">aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyaW5jL2Nsb2Fja2VkLXBpeGVsKHBhc3N3b3JkOmZsYWcp
</code></pre>

<p>最后发现是Base64加密，解密后得到：</p>

<pre><code class="language-code">https://github.com/cyberinc/cloacked-pixel(password:flag)
</code></pre>

<p>然后去这个地址找工具。。。下载下来后。</p>

<pre><code class="language-code">python lsb.py extract 0.png-1.png flag
</code></pre>

<p>得到一个文件。名曰：LDR.asm。。。</p>

<pre><code class="language-code">00010554~00010674
E52DB004 E28DB000
E24DD01C E50B0018
E3A03000 E50B3010
EA000022 E3A03000
E50B3008 E3A03000
E50B300C EA000013
E51B300C E51B2018
E0823003 E5D33000
E1A00003 E59F10C8
E51B2010 E1A03002
E1A03203 E0433002
E51B200C E0833002
E7913103 E0030390
E51B2008 E0823003
E50B3008 E51B300C
E2833001 E50B300C
E51B300C E353000E
DAFFFFE8 E59F1084
E51B3010 E51B2008
E7812103 E51B3010
E2833001 E50B3010
E51B3010 E353000E
DAFFFFD9 E3A03000
E50B3010 EA00000C
E59F2050 E51B3010
E7922103 E59F1048
E51B3010 E7913103
E1520003 0A000001
E3E03000 EA000006
E51B3010 E2833001
E50B3010 E51B3010
E353000E DAFFFFEF
E3A03000 E1A00003
E24BD000 E49DB004
E12FFF1E 00021034
00021400 000213B8
=================
0002102C~0002146C
00000000 00000000
00000024 0000000E
00000011 00000020
00000008 00000006
00000001 0000000C
0000004C 00000055
00000031 00000012
00000039 00000002
00000002 00000021
00000010 00000010
0000001E 00000006
00000004 00000002
0000000A 00000048
00000054 0000002F
00000013 00000039
00000001 00000001
0000001C 0000000F
0000000F 0000001B
00000006 00000004
00000001 00000009
00000040 0000004D
0000002B 00000012
00000035 00000001
00000002 00000013
0000000C 0000000B
00000013 00000005
00000001 00000001
00000005 0000002B
00000037 0000001C
0000000E 00000027
00000001 00000001
00000019 0000000A
0000000B 00000014
00000006 00000004
00000001 00000008
00000031 00000037
0000001E 0000000D
00000026 00000001
00000001 0000001A
0000000E 0000000F
0000001B 00000004
00000005 00000000
0000000B 0000003F
0000004D 0000002C
0000000F 00000033
00000003 00000003
0000001F 00000010
00000010 0000001C
00000007 00000002
00000002 00000008
00000042 0000004F
0000002A 00000013
00000037 00000001
00000001 0000000F
00000006 00000008
00000010 00000002
00000002 00000000
00000005 00000025
00000029 0000001A
00000007 0000001A
00000001 00000001
00000028 0000000C
00000011 00000021
00000007 00000007
00000002 0000000D
00000051 00000053
00000033 00000010
00000036 00000001
00000001 00000023
0000000C 00000011
00000020 00000006
00000006 00000001
0000000C 0000004C
00000052 00000032
0000000F 00000035
00000002 00000002
00000018 00000008
0000000B 00000015
00000004 00000004
00000001 00000008
00000033 00000036
00000021 0000000A
00000023 00000001
00000001 0000001E
0000000E 0000000D
00000019 00000007
00000002 00000002
00000007 0000003D
00000046 00000026
00000012 00000031
00000000 00000000
00000020 0000000E
00000010 0000001C
00000007 00000003
00000002 00000008
00000044 0000004D
0000002C 00000012
00000035 00000000
00000002 0000001D
0000000F 0000000F
0000001B 00000007
00000005 00000001
0000000A 00000040
0000004E 0000002A
00000012 00000036
00000002 00000003
00000020 0000000E
00000011 0000001C
00000007 00000003
00000002 00000008
00000044 0000004D
0000002C 00000012
00000035 00000000
00000003 00008ED1
00008921 00007CD8
0000570C 00005D87
00007B78 0000800E
0000428D 00009065
00008A65 00005BCF
00007343 00007FB0
00007F03 00008055
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
00000000 00000000
</code></pre>

<p>显然是一个ARM汇编，但是鄙人不懂ARM平台汇编。更不用说直接给机器码和数据了。（学长够狠的，一个LSB出成这样。。。）</p>

<h2 id="crypto">CRYPTO</h2>

<h3 id="base">Base</h3>

<p>都说是base了，先将hex转成text，再base64解密</p>

<pre><code class="language-code">54553479567A493152455250556C524956314655516B394E576C593257564E4254303554566A5A4F56454A48566C4E594D6A303950513D3D
-&gt; TU4yVzI1RERPUlRIV1FUQk9NWlY2WVNBT05TVjZOVEJHVlNYMj09PQ==
-&gt; MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===
</code></pre>

<p>最后出现3个=，应该不是base64了，推测是base32</p>

<pre><code class="language-code">MN2W25DDORTHWQTBOMZV6YSAONSV6NTBGVSX2===
-&gt; cumtctf{Bas3_b@se_6a5e}
</code></pre>

<h3 id="我都不好意思说这是加密">我都不好意思说这是加密</h3>

<p>密文最后有6个等号，肯定不是base64了，是base32</p>

<pre><code class="language-code">OFQXC5DTM5PWG6LSMJPWQ2LINB5W63LLMZPWG43XPU======
-&gt; qaqtsg_cyrb_hihh{omkf_csw}
</code></pre>

<p>这又是常见的套路。一般就是栅栏，凯撒，最多还有ROT13这几个混着用。。。</p>

<pre><code class="language-code">qaqtsg_cyrb_hihh{omkf_csw}
-&gt; qiahqht{sogm_kcfy_rcbs_wh}
-&gt; cumtctf{easy_work_done_it}
</code></pre>

<h3 id="超超超简单的rsa">超超超简单的RSA</h3>

<p>题目很明显给出了rsa的攻击，打开文件发现两个txt文档，打开任意一个文档发现里面均存在有n 与 e，所以知道本题目是两个rsa文件（即两个被加密的文件），所以想办法得到每个文件的私钥才可以解题。对第一个A文本中的n用质数分解发现分解不出来（对了，我不懂16进制怎么去处理，所以用py全部转成10进制了，花了一些时间。。。。）所以很复杂。想了好久猜想两个文本A与B中的N也许有联系，所以用py处理了一下两个质数得出了他们的最大公约数，所以以这个公约数C作为P，即得出Q=N/P。有P有Q然后用小工具（下图）得出私钥D。</p>

<p>之后有私钥利用A文本里给的公钥与小工具,将密文等数据填写进去得到
即明文得出来了。不过B文件的内容我没有去尝试解，大家可以去解下试试。</p>

<p>模数
N=29418132766062200053827508724246843105374637443595563658353636901180985530454564748758954022059769968982002140853896779902444989762754829021500174009685317744797202131791952882245156752602275951380571602331788950944361654561540811865247443070852205987517914882270234145588910167329180689201693364463939325045996426086956404110646487321752453515607959864012257125599952218384912758492278760212475418527633763779623723297398616758881690569134708160861225121310386258262233845349929832236096958219199090596331413929196303615488618826471077896979729621018914864133480510063685383380281751344618122905355446455152052146107</p>

<p>私钥D=5276569622169127583335396030174609377842679457826382876886732018555136943898524693377979534161711823815512184943455864784707258401816484897185891483275856469930223821580727295178409526710404020255132334411694676322006535535546302259515681376235707488042647120486202926845339494431016269464963898657451334903848837250871373477682894250164643619602539540167941126569254100541247071088029518267294673136150590137761627750871598184521964595130415894447450203665799780203794291800387632230796502586420060307704968798926230993933417456137261862838342423360539764609700124237130276870839075369086314306378124788811184527308864016188670758147951657948794726339811014447072181868238689002340820729878182691215125098872623119560093174867103561051579057</p>

<p>密文=16100055693360522322921904559463506095804777561229411389210562116776123887118032506500785234735650863266120870039583905903640748310769171758726776231272365756600955133373377424528798613667972612939112952739492634777392213118214538310023716791113397548161112585724810411650439986941834109983323315567262092245187889800878232402966804760965881216269022049586892968822789422135384021734622276346902887808132752808716548024992278042957487218505559297871159990210141047554025964806293617142183951888549982800751775892257499574146183538611011708642419473426914866890982026974237403676735705451473230887885053941067076232393
公钥e=0x10001</p>

<p>此外，根据A和B文本得到的最大公约数Q=176619317803996218465829943540526296076867590914430196106340551568870328156449028441778892112662362916940116161090362718242443676528799588976770654437504474997568793583909264900680213577430229171890593572386841798207200784823655954364900051437142324539709060542879468781584230692448457677803389650254712030259</p>

<p>P=166562373424571003644969210886957594935507861087984296297058666148455412078457690109851370986660882279126361524191566223822671452404569269819830903808012097953053534590353386995492143954050309296677311577678675327620326594657482392410288368865181591208513290907483245868756146614333721689500461074105692470873</p>

<pre><code class="language-code">cumtctf{GCD_is_Useful_in_Rsa}
</code></pre>

<h2 id="web">WEB</h2>

<h3 id="暴打出题人">暴打出题人</h3>
<p>上来给了一个留言板,然后提示用XSS平台.网上找了一个XSS平台,通过最简单的使用得到了cookie。在最开始的留言板的页面加入XSS平台得到的cookie即得flag。</p>

<h3 id="just-trick">just trick</h3>

<p>这个题涉及到几个小技巧</p>

<ol>
  <li>首先进入页面查看源代码得到<!--index.txt-->的提示,然后打开这个文本得到代码。</li>
</ol>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="k">echo</span> <span class="s2">"&lt;!--index.txt--&gt;"</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">'id'</span><span class="p">])</span>
<span class="p">{</span>
    <span class="nb">header</span><span class="p">(</span><span class="s1">'Location: index.php?id=1'</span><span class="p">);</span>
    <span class="k">exit</span><span class="p">();</span>
<span class="p">}</span>
<span class="nv">$id</span><span class="o">=</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">'id'</span><span class="p">];</span>
<span class="k">if</span><span class="p">(</span><span class="nv">$id</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$_COOKIE</span><span class="p">[</span><span class="s1">'token'</span><span class="p">]))</span>
      <span class="p">{</span>
        <span class="nv">$key</span><span class="o">=</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">'key'</span><span class="p">];</span>
        <span class="nv">$token</span> <span class="o">=</span><span class="nv">$_COOKIE</span><span class="p">[</span><span class="s1">'token'</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="nb">file_get_contents</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span><span class="s1">'r'</span><span class="p">)</span><span class="o">===</span><span class="s2">"I want flag!!!"</span><span class="p">))</span>
        <span class="p">{</span>
          <span class="k">echo</span> <span class="s2">"hello Hacker!&lt;br&gt;"</span><span class="p">;</span>
          <span class="k">include</span><span class="p">(</span><span class="s2">"include.php"</span><span class="p">);</span>
          <span class="k">echo</span> <span class="nx">cumtctf_unserialize</span><span class="p">(</span><span class="nv">$token</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>  
          <span class="k">echo</span> <span class="s2">"You are not Hacker ! "</span><span class="p">;</span>  
        <span class="p">}</span>  
      <span class="p">}</span>
  <span class="p">}</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<ol>
  <li>PHP中可以看到首先get方式提交一个id的值,在if(!$_GET[‘id’])的地方需要值不为空跳过if,后面if($id==0)的地方需要id的值为0进入if,如果id=0第一个if语句无法跳过,所以让id=’0’这两个地方就都能过去.</li>
  <li>看到需要get方式提交一个key.想让file_get_contents($key,’r’)===”I want flag!!!”可以用PHP的封装协议php://input,它可以得到原始的POST数据.</li>
  <li>这里我想了好久怎么才能看到include.php的内容= =,也没有文件包含什么的,最后发现和看index.php一下,看一下include.txt就得到了内容。</li>
</ol>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="k">echo</span> <span class="s2">"&lt;!--include.txt--&gt;"</span><span class="p">;</span>
<span class="kd">class</span> <span class="nc">Read</span><span class="p">{</span><span class="c1">//flag.php</span>
    <span class="k">public</span> <span class="nv">$file</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">__toString</span><span class="p">(){</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">file</span><span class="p">)){</span>
            <span class="k">if</span><span class="p">(</span><span class="s2">"flag.php"</span><span class="o">===</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">file</span><span class="o">||</span><span class="nb">stripos</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">file</span><span class="p">,</span><span class="s2">"://"</span><span class="p">)</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">exit</span><span class="p">();</span>  
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">echo</span> <span class="nb">file_get_contents</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">file</span><span class="p">);</span>
            <span class="p">}</span>              
        <span class="p">}</span>
        <span class="k">return</span> <span class="s2">"you are big Hacker"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">function</span> <span class="nf">cumtctf_unserialize</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nb">preg_match</span><span class="p">(</span><span class="s1">'/[oc]:\d+:/i'</span><span class="p">,</span> <span class="nv">$value</span><span class="p">,</span><span class="nv">$matches</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">count</span><span class="p">(</span><span class="nv">$matches</span><span class="p">)){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">unserialize</span><span class="p">(</span><span class="nv">$value</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span>
</code></pre></div></div>

<ol>
  <li>最后就是读flag.php的内容了,这里可以通过反序列化去读,但是有两个过滤,一个是过滤了协议的使用,php://filter/convert.base64-encode/resource=flag.php就不能用了,因为不是严格的查找字符串所以./flag.php,后面还有一个对于你传入的序列化字符串有一个正则的过滤,PHP序列化字符串中对象长度前加一个+号仍可正常反序列化,可用此来绕过正则.将这个的序列化字符串作为cookie里面token的值提交得flag.</li>
</ol>

<h3 id="textwall">TextWall</h3>

<p>进去随便提交了一个东西然后看到有一个lists的cookie,其中值为24c5889e00902d6bcc65073f0e91ea30bbe203c2 a:1:{i:0;s:9:”hiehiehie”;},字符串前一段为后一段序列化字符串的SHA1.一般构造反序列化一般都需要源码，所以找到了源码泄露点：http://textwall.bxsteam.xyz/.index.php.swo。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="nv">$lists</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">Class</span> <span class="nx">filelist</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">__toString</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">highlight_file</span><span class="p">(</span><span class="s1">'hiehiehie.txt'</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span><span class="o">.</span><span class="nb">highlight_file</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">source</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">........</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>构造序列化的串（反序列化后是一个filelist类，$sorce值是我们想查找的路径，这样在反序列化后）这里我们构造如下:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">filelist</span><span class="p">();</span>
<span class="nv">$b</span><span class="o">=</span> <span class="k">new</span> <span class="nx">filelist</span><span class="p">();</span>
<span class="nv">$b</span><span class="o">-&gt;</span><span class="na">source</span> <span class="o">=</span> <span class="s1">'index.php'</span><span class="p">;</span>
<span class="nv">$a</span><span class="o">-&gt;</span><span class="na">source</span><span class="o">=</span><span class="nv">$b</span><span class="p">;</span>
<span class="nv">$d</span><span class="o">=</span><span class="nb">serialize</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
<span class="nv">$e</span><span class="o">=</span><span class="nb">sha1</span><span class="p">(</span><span class="nv">$d</span><span class="p">)</span><span class="o">.</span><span class="nv">$d</span><span class="p">;</span>
<span class="k">echo</span> <span class="nb">urlencode</span><span class="p">(</span><span class="nv">$e</span><span class="p">)</span><span class="o">.</span><span class="s2">"&lt;br&gt;"</span><span class="p">;</span>
</code></pre></div></div>

<p>得到16d8c3c46653e89932859dd7a2eb12fa59df777aO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3BO%3A8%3A%22filelist%22%3A1%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3B%7D%7D作为cookie提交得到源码(贴部分):</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>233333333333333333333333333333333333333333333333333333333333333333 <span class="cp">&lt;?php</span>
<span class="c1">//flag in Fl4444444444g.php</span>
<span class="nb">session_start</span><span class="p">();</span>
<span class="nv">$lists</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">Class</span> <span class="nx">filelist</span><span class="p">{</span>
    <span class="k">public</span> <span class="nv">$source</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">__toString</span><span class="p">()</span>
</code></pre></div></div>

<p>在上面的过程中将路径改为Fl4444444444g.php,读取即得到flag.</p>

<h3 id="简单的盲注">简单的盲注</h3>

<p>这个题第一个hint是请关注图片,抓包发现是get请求发送图片对应的id来获取图片,这里id就是注入点,当id=1”的时候会报错,说明sql语句中使用的是”,接下来就是盲注密码,构造的为id=1”and ord(mid((password),1,1))&lt;48#,跑出来密码为8211d7b4ba2828919651,是DEDECMS的20位MD5加密,账号admin然后登陆进去一个上传文件的地方.<br />
文件后缀是白名单过滤,我查了好久都没有结果,后来得知是phps后缀(不知道在哪里找的这种后缀…),然后还是传不上去是因为有关于PHP标识的过滤,改为比较不常见的脚本类型<script language="php"></script>可以绕过。(开始时候我把language拼错了导致半天没过…)。</p>

<h2 id="mobile">MOBILE</h2>

<h3 id="多谢款待">多谢款待</h3>

<p>这题很坑，因为我android版本的原因，这个APK运行不了。而且很奇怪，是因为加保护了，还是其他原因，用Android_Killer无法反编译。无奈之下，用APKtools，对Main先转dex，再转java。直接看源码。。但是也很奇怪，这样转出来的string，都是十六进制的数字，不是ascii表示，也不是其他的。什么编码，卡在这里半天。。。后来学长指点说用Jeb可以看。于是我就去下载了。之后进行反编译。以下是伪Java代码。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="nc">String</span> <span class="n">arg10</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg11</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">v0</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">125</span><span class="o">,</span> <span class="mi">108</span><span class="o">,</span> <span class="mi">97</span><span class="o">,</span> <span class="mi">103</span><span class="o">,</span> <span class="mi">123</span><span class="o">,</span> <span class="mi">51</span><span class="o">,</span> <span class="mi">108</span><span class="o">,</span> <span class="mi">51</span><span class="o">,</span> <span class="mi">99</span><span class="o">,</span> <span class="mi">116</span><span class="o">,</span> <span class="mi">101</span><span class="o">,</span> <span class="mi">57</span><span class="o">,</span> <span class="mi">114</span><span class="o">,</span> <span class="mi">65</span><span class="o">,</span> <span class="mi">104</span><span class="o">,</span> <span class="mi">99</span><span class="o">,</span> <span class="mi">95</span><span class="o">,</span> <span class="mi">99</span><span class="o">,</span> <span class="mi">49</span><span class="o">,</span> <span class="mi">114</span><span class="o">,</span> <span class="mi">102</span><span class="o">};</span>
    <span class="c1">//  数组的值是：}lag{3l3cte9rAhc_c1rf</span>
    <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">v3</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">char</span> <span class="n">v5</span><span class="o">[]</span>  <span class="o">=</span> <span class="n">arg10</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="k">if</span><span class="o">(</span><span class="n">arg10</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">arg11</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">v5</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">v0</span><span class="o">[</span><span class="n">arg10</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">v5</span><span class="o">[</span><span class="n">arg10</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">v0</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
        <span class="o">{</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">v1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">v1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="n">arg10</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">v1</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">v5</span><span class="o">[</span><span class="n">v1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">v0</span><span class="o">[</span><span class="n">v1</span><span class="o">])</span>
            <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">v1</span> <span class="o">==</span> <span class="n">arg10</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="n">v3</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">arg10</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">v5</span><span class="o">[</span><span class="n">v1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">v0</span><span class="o">[</span><span class="n">arg10</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">v1</span><span class="o">])</span>
            <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="o">++</span><span class="n">v1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="k">return</span> <span class="n">v2</span> <span class="o">&amp;</span> <span class="n">v3</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="nc">View</span> <span class="n">arg5</span><span class="o">)</span>
<span class="o">{</span>
    <span class="nc">String</span> <span class="n">v0</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">editText</span><span class="o">.</span><span class="na">getText</span><span class="o">().</span><span class="na">toString</span><span class="o">().</span><span class="na">trim</span><span class="o">();</span>
    <span class="k">if</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="n">v0</span><span class="o">,</span> <span class="n">v0</span><span class="o">.</span><span class="na">length</span><span class="o">()))</span>
    <span class="o">{</span>
        <span class="nc">Toast</span><span class="o">.</span><span class="na">makeText</span><span class="o">(((</span><span class="nc">Context</span><span class="o">)</span><span class="k">this</span><span class="o">),</span> <span class="s">"It\'s not smell good!"</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">else</span>
    <span class="o">{</span>
        <span class="nc">Toast</span><span class="o">.</span><span class="na">makeText</span><span class="o">(((</span><span class="nc">Context</span><span class="o">)</span><span class="k">this</span><span class="o">),</span> <span class="s">"Good, you got it!"</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>为得到flag，只要check返回1就行，即在check中v2和v3都是1，发现check只是进行简单的替换，将最后一位和第一位替换。还原只要将}lag{3l3cte9rAhc_c1rf中第一位和最后一位对调即可，当然，长度相同也行，只要第一位是f，最后一位是}。这时候v2=1，而此时v3根据程序的推进必等于1，所以得到flag。</p>

<pre><code class="language-code">flag{3l3cte9rAhc_c1r}
</code></pre>

<h3 id="助人为乐">助人为乐</h3>

<p>这题，和第一题一样，我直接用Jeb分析了，Android_Killer同样失效了。程序的关键部分如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">encode</span><span class="o">(</span><span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">v11</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">v10</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">password</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">password</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
			<span class="o">{</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
            <span class="nc">StringBuilder</span> <span class="n">v2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pass</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">v0</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="n">v0</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">pass</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="n">v0</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">v0</span> <span class="o">=</span> <span class="s">"0"</span> <span class="o">+</span> <span class="n">v0</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span>

                <span class="n">v2</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">v0</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">while</span><span class="o">(</span><span class="n">v2</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">6</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">v2</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nc">String</span> <span class="n">v1</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">v2</span><span class="o">);</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">v4</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">v1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">/</span> <span class="mi">6</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v4</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">v6</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">v1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">v11</span><span class="o">),</span> <span class="n">v10</span><span class="o">);</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">v11</span><span class="o">);</span>
                <span class="n">v4</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Code</span><span class="o">.</span><span class="na">CodeText</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">v6</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nc">StringBuilder</span> <span class="n">v3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">v4</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">password</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">v3</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">password</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="n">v10</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">v3</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"23"</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">76</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v3</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">76</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">v3</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="s">"\r\n"</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="n">v3</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\r\n"</span><span class="o">);</span>
            <span class="n">password</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">v3</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">password</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>这其中有两个列表，一个是加密列表：（长度为64=2^6）</p>

<pre><code class="language-code">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#\$%^&amp;*()+/
</code></pre>

<p>另一个是密文：</p>

<pre><code class="language-code">zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1
</code></pre>

<p>本题就是要求我们解密出明文。加密过程大致如下：首先将输入的字符串对应的ascii码转换成二进制，每一字符是8bit，得到一串比特流。之后检测总长度是否为6的倍数，不是的话在后面补0，之后将比特流每6个一组，得到一串数字，数字均小于63(2^6-1)，将这串数字作为加密列表的下标查找对应字符，实现加密。
所以解法如下： 首先查找密文每一位在加密列表中的下标。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">pass</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"zMXHz$SXDf)SC@)UB$rFyv)Jmg@$zw^FyMfZzwnVzeuHFq1"</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()+/"</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">47</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	 <span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>得到的即为下标：</p>

<pre><code class="language-code">25 38 49 33 25 55 44 49 29 5 61 44 28 53 61 46 27 55 17 31 24 21 61 35 12 6 53 55 25 22 57 31 24 38 5 51 25 22 13 47 25 4 20 33 31 16
</code></pre>

<p>再转成二进制，注意补0对齐，6个一组。再去掉空格连起来。</p>

<pre><code class="language-code">011001 100110 110001 100001 011001 110111 101100 110001 011101 000101 111101 101100 011100 110101 111101 101110 011011 110111 010001 011111 011000 010101 111101 100011 001100 000110 110101 110111 011001 010110 111001 011111 011000 100110 000101 110011 011001 010110 001101 101111 011001 000100 010100 100001 011111 010000
-&gt;011001100110110001100001011001110111101100110001011101000101111101101100011100110101111101101110011011110111010001011111011000010101111101100011001100000110110101110111011001010110111001011111011000100110000101110011011001010110001101101111011001000100010100100001011111010000
</code></pre>

<p>之后再8个一组，作为字符，查ascii表。得到flag。</p>

<pre><code class="language-code">01100110 01101100 01100001 01100111 01111011 00110001 01110100 01011111 01101100 01110011 01011111 01101110 01101111 01110100 01011111 01100001 01011111 01100011 00110000 01101101 01110111 01100101 01101110 01011111 01100010 01100001 01110011 01100101 01100011 01101111 01100100 01000101 00100001 01111101 000
-&gt;flag{1t_ls_not_a_c0mwen_basecodE!}
</code></pre>

<h2 id="reverse">REVERSE</h2>

<h3 id="reverse1">reverse1</h3>

<p>别想多了，这题就是看汇编。（哭）
第一步：首先判断输入字符串长度是否为0x1C。用ecx作为累加器，一次处理一个字节，累加和与1Ch作比较，相等则跳转。之后判断最后一位是否是}，是则call eax 进行下一步加密。</p>

<pre><code class="language-asm">mov     al, [ecx]
inc     ecx
test    al, al
jnz     short loc_401030
sub     ecx, edx
cmp     ecx, 1Ch
jz      short loc_40104B
…………
cmp     [ebp+var_49], '}'
jnz     short loc_401070
…………
lea     eax, [ebp+var_64]
push    offset byte_403068
push    eax
mov     eax, offset loc_403020
call    eax ; loc_403020
</code></pre>

<p>第二步：执行 call eax，之后，来到一段数据区，显然实际为代码，手动转成代码后，进行以下逻辑判断。即判断输入的前5个字符是否为flag{，是就进行call edx 下一轮加密。</p>

<pre><code class="language-asm">cmp     byte ptr [eax], 'f'
jnz     short loc_40305F
cmp     byte ptr [eax+1], 'l'
jnz     short loc_40305F
cmp     byte ptr [eax+2], 'a'
jnz     short loc_40305F
cmp     byte ptr [eax+3], 'g'
jnz     short loc_40305F
cmp     byte ptr [eax+4], '{'
jnz     short loc_40305F
…………
push    offset unk_403110
push    eax
call    edx
</code></pre>

<p>第三步：异或加密，注意到此时的基址指针ebp+8为输入的第6位的地址，而ebp-8是一个加密列表所在地址。通过赋值语句，和Intel小段结构，知道加密列表为 98 A4 A9 93。之后的运算表明，从输入的第6位开始和0xCC进行异或，再与加密的每一位依次对比，相等则继续，不等则退出，循环比较次数为4次。由于异或的可逆性，解除这段明文是：The_。最后取ebx+4则是取输入的第10位的地址进行下一轮加密。</p>

<pre><code class="language-asm">mov     ebx, [ebp+8]
lea     eax, [ebp-8]
push    esi
push    edi
xor     edx, edx
mov     dword ptr [ebp-8], 93A9A498h
…………
lea     ecx, [ebp-8]
add     ecx, esi
mov     al, [edi+ecx]
xor     al, 0CCh
cmp     al, [ecx]
jnz     short loc_4030B9
inc     esi
cmp     esi, 4
jl      short loc_403088
…………
lea     eax, [ebx+4]
push    offset unk_4032A0
push    eax
call    ecx
</code></pre>

<p>第四步：Base64加密，首先进行初始化，初始加密列表为4部分：ABCD
EFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 +/</p>

<pre><code class="language-asm">mov     dl, 'A'
xor     ecx, ecx
mov     eax, ecx
…………
mov     [ebp+eax-64h], dl
inc     dl
inc     eax
cmp     dl, 'Z'
jle     short loc_40311C
mov     dl, 'a'
…………
mov     [ebp+eax-64h], dl
inc     dl
inc     eax
cmp     dl, 'z'
jle     short loc_40312A
mov     dl, '0'
…………
mov     [ebp+eax-100], dl
inc     dl
inc     eax
cmp     dl, '9'
jle     short loc_403138
push    ebx
push    esi
push    edi
mov     word ptr [ebp+eax-64h], '/+'
</code></pre>

<p>因为为避免明文泄露，肯定会有Base64加密后的密文出现，即cmVhbEN0Rl8=。之后会将输入的第10位开始的8位进行Base64加密，与该密文进行对比。由于开启了优化，这段代码是纯数学运算，因此跳过，直接解密密文后得到realCtF_。至此前17位已经得到：flag{The_realCtF_xxxxxxxxxx}。ebx+8为输入的第18位，eax取该地址后，再进行下一步加密。</p>

<pre><code class="language-code">mov     dword ptr [ebp-10h], 'hVmc'
mov     dword ptr [ebp-0Ch], '0NEb'
mov     dword ptr [ebp-8], '=8lR'
…………
lea     eax, [ebx+8]
push    eax
call    ecx
</code></pre>

<p>第五步：首先进行加密列表的初始化，得到：kvtu`C4h”o。</p>

<pre><code class="language-code">mov     dword ptr [ebp-0Ch], 'utvk'
push    esi
push    edi
mov     dword ptr [ebp-8], 'h4C`'
or      edx, 0FFFFFFFFh
mov     word ptr [ebp-4], 'o"'
</code></pre>

<p>之后将输入值的第18位的地址传入esi中，esi+edi为加密列表的地址，即比较ecx与eax。并且ecx=加密列表每一个字符减一的值，eax=为输入第18位开始的值。循环比较10次，相等则继续，不等则退出。为得到明文，只要将密文6B 76 74 75 60 43 34 68 22 每一位都减一即可，得到6A 75 73 74 5F 42 33 67 21 ，即为：just_B3g!</p>

<pre><code class="language-code">movsx   ecx, byte ptr [edi+esi]
movsx   eax, byte ptr [esi]
dec     ecx
cmp     eax, ecx
jnz     short loc_4032EA
inc     ebx
inc     esi
cmp     ebx, edx
jl      short loc_4032D8
</code></pre>

<p>综上，得到flag{The_realCtF_just_B3g!n}。</p>

<h2 id="pwn">PWN</h2>

<p>我太菜了，完全不会啊。</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#writeup" class="page__taxonomy-item" rel="tag">writeup</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fa fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2018-08-18T23:12:00+08:00">August 18, 2018</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=2017cumtctf%E5%86%B3%E8%B5%9B+Writeup%20https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2018-08%2F2017cumtctf%25E5%2586%25B3%25E8%25B5%259B-writeup.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fa fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2018-08%2F2017cumtctf%25E5%2586%25B3%25E8%25B5%259B-writeup.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fa fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2018-08%2F2017cumtctf%25E5%2586%25B3%25E8%25B5%259B-writeup.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2018-08/2018cumtctf%E9%80%86%E5%90%91%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF.html" class="pagination--pager" title="2018cumtctf逆向出题思路
">Previous</a>
    
    
      <a href="/posts/2018-12/Git_Learning-1.html" class="pagination--pager" title="Git_learning 1
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/Dirary_November/" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/%E5%8D%81%E6%9C%88%E6%97%A5%E8%AE%B0.html" rel="permalink">十月日记
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




10月1日

周日，上课前最后一天，算是给自己放了最后一天假期

10月2日

上了第一天的课，主要是os，一脸蒙蔽。
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/1d25d6ba93.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <div id="disqus_thread"></div>
  <script>
    /**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
    */
    /*
    var disqus_config = function () {
      this.page.url = "https://zjgcjy.github.io/posts/2018-08/2017cumtctf%E5%86%B3%E8%B5%9B-writeup.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2018-08/2017cumtctf决赛-writeup"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
