<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>2018cumtctf逆向出题思路  -  My way, though far away</title>
<meta name="description" content="  初赛刚刚结束，总体来说，这一次比赛re的难度不大，后面几个题难度也只是中等偏容易。我主要考虑到受众有许多17级的同学(可能是想多了-_-)，出这几个题目的时候，没有为难大家。本来以为后面几个题能困倒大家，没想到还是有大佬冲了出来，倍感欣慰，看来我差不多也该退役了。以下是我出题的思路：  多框架  多语言  算法简单  解法多样  32位Release版本  无加壳保护  无混淆代码  基本无反调试A piece of cake - 50  As the title said. Nothing else.VS2012编译 C语言 Release版本 32位签到题，不用多说吧。解法解法如下图所示，或者你用IDA之类的逆向工具打开就能看到了。(若有童鞋不懂稍微讲一下：将输入字符串和flag进行比较，正确就Congratulations)cumtctf{We1cOme_t0_cUmtCtf_IeVe1_0ne_SO_eaSy!}Uncomplicated - 50  Probably, this is the most common algorithm in software reversing.VS2012编译 C语言 Release版本 32位入门签到题，如果是刚入门的同学的话，第一次做这个可能有点吃力。正如题目所说的，该算法是逆向工程中最常见的算法，其实更是密码学最常见算法之一，那就是异或⊕或者叫模2加法，其基于的原则就是 二进制不带进位加法运算：  0+1=1  0+0=0  1+0=1  1+1=0回到题目中来，我们直接使用IDA分析程序，自动分析完成后，因为大部分同学不懂汇编，这里我就直接F5看伪C代码了。上图所示的是输入部分，可以看到对输入字符串的每一个值循环和i进行异或操作，将结果保存在cinXor中。下面将判断输入的字符串是否正确。上图所示的就是比较的部分，实际上这段代码是memcmp函数的具体实现。先取出两个数组的首地址，逐个比较，变量每次加四代表比较的大小是一次32位，也就是4字节。最后才进入if判断条件，比较最后2个，所以很明显，比较长度是4的倍数余2。解法为了获取需要对比的字符串，我们查看该flag变量。如下图所示。现在我们需要做的就是将该数组的每个值，和i异或就行了。用python写脚本求解。#coding:utf-8__author__ = &#39;zjgcjy&#39;flag =&#39;&#39;strXor = &quot;\x63\x74\x6f\x77\x67\x71\x60\x7c\x50\x39&quot; \         &quot;\x78\x54\x3d\x7e\x51\x6c\x20\x7c\x5f\x5c&quot; \         &quot;\x7a\x4a\x22\x79\x7c\x46\x74\x2b\x68\x42&quot; \         &quot;\x76\x2b\x52\x45\x7d\x51\x15\x42\x4e\x53\x17\x54&quot;for index, ch in enumerate(strXor):	flag += chr(index ^ ord(ch))print flag由此得到flag。cumtctf{X0r_1s_c0mMOn_4nd_n0t_h4rd_r1ght?}re0: beginning - 100  Watch out the order please.VS2012编译 C语言 Release版本 32位这题才算是一个逆向的题目，不过也很简单，平时比赛的话最高50分。使用IDA分析好了。就主函数中对输入进行了操作，通过上图我们可以看到，当输入字符串长度是36时，将每四个作为一组。高位的作为高位，低位的作为低位。意思就是说，将4个8bit的char变量转成1个32bit的int变量，其中高地址存放高字节，而且左移8位不会影响其低字节，最后和0x12341234异或，再和flag进行比较。然后我们来查看一下flag变量。解法知道了过程写脚本就容易了。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciiarray = [0x75557E52,0x2351454F,0x57592257,0x4D7B466B,0x4D515A40,0x77427766,0x7C582746,0x22434D53,0x6F503346]result = &#39;&#39;for i in xrange(len(array)):	result += binascii.a2b_hex(hex(array[i] ^ 0x12341234)[2:])[::-1]print result由此得到flag。flag{We1c0mE_TO_tHe_Rever5lng_w0r!d}Stay in observation - 150  Well, you ought to be familiar with this language.VS2012编译  C# .Net Framework4.0 Release版本 64位这是一道.Net逆向，考虑到很多同学没有接触过C#，所以我给了150分，其实和Java是差不多的，一个是CLR，一个是JVM。其中的算法也很简单，我没用加壳进行保护，所以用.Net的工具就能直接看到源码了，甚至能动态调试。做出来这道题目的同学主要的思路有2种，和我预想的差不多。  使用动态调试，获取鼠标的位置，根据题目手动修改，之后自动解密出flag。  不用动态调试，直接看后面的解密代码，发现是AES，写脚本解出flag。  既使用调试，同时又跟踪AES，最后发现，flag被自动解出来了。WoW!解法调试的方式我就不说了，这里我将一下第二种方式。题目我是用了一张图片，检测鼠标的点击事件，当点击三次后。进行判断，点击的位置和规定的位置是否相同，这里的3个位置是我随机选的，所以用户点击一次就成功的可能性是个极小概率事件，更别说3次了。当判断不同时，直接弹框失败，否则进入MIX类中的Crypt方法进行解密。下面我们来看一下这个MIX类。可以看到，该类中定义了一个计算MD5的方法，和一个解密的方法，当然还有一共byte转string的方法，这里没有列出来。其实这个MD5方法根本没有用到，就是混淆视听用的，而下面的System.Security.Cryptography.RijndaelManaged类就是Rijndael密码算法，也就是AES。下面直接写脚本解AES就行了。#coding:utf-8@需要Crypto库支持__author__=&#39;zjgcjy&#39;from Crypto.Cipher import AESfrom base64 import *IV = &quot;Oityj1sok1yksiWeqtddYQ==&quot;key = &quot;epWRCdxC79zuea4ZnxEacCMMmIzo0tn/Ah+ENEWOYOY=&quot;c = &quot;NAaswR+u94wyIGDUifYSIfznIt0VXoR/NWoJoSjyWJ0=&quot;cipher = AES.new(b64decode(key), AES.MODE_CBC, b64decode(IV))plain = cipher.decrypt(b64decode(c))print plain注意该AES有IV，可能是CBC、CFB、OFB三种模式，而在C#中，有IV情况下又未指定模式，一般是指CBC模式，由此得到flag。flag{reVer5e_1n_C5harP_or_ae5}Shuttle - 200  Randomization is not terrible, trust me.VS2012编译 C语言 Release版本 32位C语言写的控制台程序，直接用IDA吧，打开后主函数流程如下。先输入字符串，没什么好说的，但是看下面。很明显，这里用了rand函数，同时加入了时间作为种子，产生4个伪随机数作为密钥key。再来看接下来的步骤，用随机的key当作密钥流和数组进行异或，最后和flag进行比较，若相等则Congratulations。所以我们要做的就是爆破一个4字节的key，然后和原始数组进行亦或，最后得到一个有意义的字符串。脚本如下。解法# coding:utf-8__author__=&#39;zjgcjy&#39;import reimport stringimport itertools as its#[0-9a-zA-Z_]{23,}words = string.lowercasetable = [0x33,0x11,0x1a,0x1c,0x2e,0x1d,0x2b,0x49,0x12,0x2f,0x1,0x4d,0x4,0x1c,0x11,0x2b,0x12,0x2f,0x3d,0xb,0x8,0x4,0x2b,0x47]r = its.product(words,repeat=4)for i in r:	key = &quot;&quot;.join(i)	flag =&quot;&quot;	for i in xrange(len(table)):		flag += chr(table[i] ^ ord(key[i%4]))	if re.search(&#39;[0-9a-zA-Z_?]{24,}&#39;,flag) and flag.count(&#39;_&#39;)&gt;3:		print key,flag有几点需要注意。  key一般是可见字符，而后期我放了提示说key是字母，这里爆破的范围可以减少，可以分别爆破小写和大写尝试。  更明显的是，flag中只会包含数字、大小写字母和以下划线为代表的特殊字符，所以这里可以结合正则表达式求解。  正则表达式的条件不唯一，这里也需要试多次，一开始可以试[0-9a-zA-Z_]{23,}，发现最后一位只有=&gt;?三种情况了，再分别尝试，同时可以结合下划线出现次数来提高效率。最后得到flag如下。flag{RandOm_1s_u5eleSs_Isit_?}Symmetric Cipher - 250  Have you ever heard of Microsoft Foundation Classes ?VS2017编译 MFC 静态链接 Release版本 32位这道题是一个MFC的程序，由于是静态链接，程序体积很大，有3MB多。在如此大量的代码下能找到关键的Check函数是比较重要的。这里我贴上关于MFC如何交叉应用查找控件ID的方法，也是由唐师傅在暑假培训的时候讲过的内容。想要深入的同学需要自己学习了，这里我就详细讲了。基于MFC的教程1基于MFC的教程2基于MFC的教程3解法现在我们打开IDA，追踪到该关键函数。IDA自动生成的sub_402510函数则是确定按钮点击的消息处理，但是一开始确定按钮是点击不了的，原因是长度不满足条件，具体的条件则在sub_4024C0中，如下图所示。也就是说，当输入字符串长度是30的时候，确定按钮将被激活，即flag长度是30。所以现在我们再来看sub_402510函数的流程。如下图所示。可以看到，点击确定后，首先进行反调试，若程序正在被调试，则直接退出。mov     ebx, large fs:30hmov     eax, [ebx+68h]cmp     eax, 70h关于该反调试的原理，很简单。相当于是自己实现简单的反调试检测，和微软的API接口IsDebuggerPresent()有点不同的是：IsDebuggerPresent()是通过访问程序PEB的BeingDebugged标志检测反调试。而该段汇编是通过检测NTGlobalFlag，是PEB结构偏移量0x68处的一个未公开位置，该位置决定了程序在调试和正常情况下不同的创建内存堆的方式。如果是0x70，则程序正在被调试。要跳过的方式很简单，直接nop判断方法或者改跳转(汇编模式下操作)。当然这个题我不是考大家这个的。我们直接进入Check函数好了。有点基础的同学进入这个函数就能发现下面会有一个rc4的加密。而密钥流由National_Basketball_Association来生成。这里我就不多说了，上面的截图是rc4的KSA函数，先将密钥流初始化，再进行混乱。接下来就是rc4的第二部分，伪随机生成密钥流并和字符串进行异或，得到密文。如上图所示。之后的代码就是比较了，这里不多说了。由于rc4加密和解密是同一个函数，解密时，我们只需要将密文通过同一个key即可恢复得到明文了。下面是程序中的常量字符串，可能有童鞋没找到，我这里列出来了。这里我直接引用Orzk队的脚本了，也可以自己写，不是很难。最后得到flag如下。cumtctf{Mfc_1s_VerY_difflcUIt}Windows Cracker - 300  Would you want to be a Windows craker ? Try your best !!!VS2012编译 Windows 动态链接 Release版本 32位最后一题是一个Windows下的GUI程序，程序本身很简单，就是弹出一个对话框，根据输入计算flag。主要还是找到Check函数，但是这个程序本身很小，你也可以一个一个找，很快也能找到-_-。关于Win32程序是如何加载的，推荐大家看windows系列的书籍，里面会详细讲。我简单说明一下。首先看一下程序中所有的字符串常量，相关的函数也可以在这里查找交叉引用。其次我们从主函数开始分析。要注意，GUI程序是从WinMain开始的，首先是定义注册窗口类并调用RegisterClassW()，其次就可以依据该窗口类来创建窗口，调用CreateWindowExW()，之后开始进入整个消息循环中，进行消息的分发与更新。而整个框架中最重要的是注册窗口类的回调函数，也就是窗口过程。他是tagWNDCLASSW结构体中的lpfnWndProc，函数类型为WNDPROC 。窗口过程的参数与分别是窗口句柄，消息标识符，2个DWORD的消息参数。在这个程序中，窗口过程首先接受WM_CREATE消息，进行窗口控件的创建，即上图中的case 1的情况，创建了一个文本框和一个确定按钮。对于确定按钮，定义了HMENU参数是250。控件ID和HMENU是共用的，当作为子窗口时，往往不需要菜单，该值用来区分控件。而对于接受到的按钮子窗口的WM_COMMAND消息，wParam参数的低位是子窗口ID，高位是消息，lParam参数是接收消息的子窗口的句柄。一句话，也就是说在点击按钮后，产生wParam消息的低位是250，直接进入sub_401350()函数中进行判断。下面我们来看一下这个函数。可以看到，直接调用GetWindowTextA()API来判断输入长度，当输入长度不是41的时候，直接通过SendMessageW()向窗口过程发送消息，且wParam参数是1111，我们回到窗口过程可以看到，此时会直接调用MessageBoxW(hWnd, L&quot;flag错误&quot;, L&quot;FAIL&quot;, 0x40u)即弹框，flag错误。所以我们可以确定flag长度就是41。接下来进入核心的Check函数验证算法。看着很简单，其实不然。其中的loc_401050是一大段汇编，由于IDA反汇编插件出错，是需要看汇编的。这种情况经常会有，请大家习惯看汇编，而且F5经常会出错当然这题是我手动造成的情况，由于IDA采用了递归下降的扫描方式，想要让其出错并不难。请大家自己移步到链接。线性扫描算法分析递归下降算法分析知道了这些后，直接nop部分指令就行了。出错的位置是.text:00401050和.text:004010B6，之后需要手动建立函数。最后函数流程如下图所示。发现就是不停的取第二个参数的2个值，然后相加放在第一个参数列表中。下面我们重新回到Check函数，重新反编译，如下图所示。第一步，进入第一个函数sub_401000分析。这里我就不贴图了，这个函数没有什么实质的作用，就是把原来的字符串进行打乱，类似于第二个密钥是0的仿射密码，左右两端同时进行。cinShuttle[(i * 33) % 41] = cin[(i * 23) % 41]打乱后进入第二个函数，而第二个函数就是不停的相加，就结束了。最后是用strcmp和flag进行对比。解法既然核心的算法都求出来了，逆向就变得比较简单了，所以我们就是要先逆向sub_401050()这个函数，之后再将顺序还原。  第二个函数创建了41个加法等式，就构成了一个41元一次方程组，且线性无关，只有唯一解。只需要解方程即可。  第一个函数的逆向，如果看出来是单表代换密码，直接求33模41的逆元和23模41的逆元，即可还原明文。          如果看不懂移位怎么逆向，直接输入有序数组，动态调试，打印出结果，构建一一映射关系。      如果即看不懂，也不会动态调试，那就直接爆破，在不考虑逆元是否存在的条件下，也只需要爆破41*41次。      下面贴出我的解法，这里解41元方程组使用python的z3库来求解，当然同样可以使用Mathematica，或者python的numpy库来求解。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciifrom z3 import *def solver():	res = &#39;&#39;	cipher = &quot;97b1c8cdd5d29694b8b4c5daa471718fbe94a4d0def3d5d4d4c4d9e5c1c4d5daf4e7c1bed7c196646a&quot;	mat = [Int(&#39;mat%d&#39;% i)for i in xrange(41)]	auth = [ord(i) for i in binascii.a2b_hex(cipher)]	s = Solver()	s.add(And(		auth[0] == mat[7] + mat[24],		auth[1] == mat[24] + mat[0],		auth[2] == mat[0] + mat[17],		auth[3] == mat[17] + mat[34],		auth[4] == mat[34] + mat[10],		auth[5] == mat[10] + mat[27],		auth[6] == mat[27] + mat[3],		auth[7] == mat[3] + mat[20],		auth[8] == mat[20] + mat[37],		auth[9] == mat[37] + mat[13],		auth[10] == mat[13] + mat[30],		auth[11] == mat[30] + mat[6],		auth[12] == mat[6] + mat[23],		auth[13] == mat[23] + mat[40],		auth[14] == mat[40] + mat[16],		auth[15] == mat[16] + mat[33],		auth[16] == mat[33] + mat[9],		auth[17] == mat[9] + mat[26],		auth[18] == mat[26] + mat[2],		auth[19] == mat[2] + mat[19],		auth[20] == mat[19] + mat[36],		auth[21] == mat[36] + mat[12],		auth[22] == mat[12] + mat[29],		auth[23] == mat[29] + mat[5],		auth[24] == mat[5] + mat[22],		auth[25] == mat[22] + mat[39],		auth[26] == mat[39] + mat[15],		auth[27] == mat[15] + mat[32],		auth[28] == mat[32] + mat[8],		auth[29] == mat[8] + mat[25],		auth[30] == mat[25] + mat[1],		auth[31] == mat[1] + mat[18],		auth[32] == mat[18] + mat[35],		auth[33] == mat[35] + mat[11],		auth[34] == mat[11] + mat[28],		auth[35] == mat[28] + mat[4],		auth[36] == mat[4] + mat[21],		auth[37] == mat[21] + mat[38],		auth[38] == mat[38] + mat[14],		auth[39] == mat[14] + mat[31],		auth[40] == mat[31] + mat[7],))	for i in xrange(41):		s.add(mat[i] &gt; 0x20)		s.add(mat[i] &lt; 0x80)	if(s.check() == sat):		m = s.model()		for i in xrange(41):			res += chr(m[mat[i]].as_long())	print resif __name__ == &#39;__main__&#39;:	main()通过z3求解出结果是cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA。再求出33和23模41的逆元分别是5和-16，还原即可。def decode():	mat = [i for i in xrange(41)]	str1 = r&#39;&#39;&#39;cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA&#39;&#39;&#39;	for i in xrange(41):		mat[(i * 5) % 41] = str1[(i * (-16)) % 41]	print &#39;&#39;.join(mat)最后得到flag。cumtctf{Ai_CaN_he1P_y0U_SoIve_eqUatl0n5!}">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="2018cumtctf逆向出题思路">
<meta property="og:url" content="https://zjgcjy.github.io/posts/2018-08/2018cumtctf%E9%80%86%E5%90%91%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF.html">


  <meta property="og:description" content="  初赛刚刚结束，总体来说，这一次比赛re的难度不大，后面几个题难度也只是中等偏容易。我主要考虑到受众有许多17级的同学(可能是想多了-_-)，出这几个题目的时候，没有为难大家。本来以为后面几个题能困倒大家，没想到还是有大佬冲了出来，倍感欣慰，看来我差不多也该退役了。以下是我出题的思路：  多框架  多语言  算法简单  解法多样  32位Release版本  无加壳保护  无混淆代码  基本无反调试A piece of cake - 50  As the title said. Nothing else.VS2012编译 C语言 Release版本 32位签到题，不用多说吧。解法解法如下图所示，或者你用IDA之类的逆向工具打开就能看到了。(若有童鞋不懂稍微讲一下：将输入字符串和flag进行比较，正确就Congratulations)cumtctf{We1cOme_t0_cUmtCtf_IeVe1_0ne_SO_eaSy!}Uncomplicated - 50  Probably, this is the most common algorithm in software reversing.VS2012编译 C语言 Release版本 32位入门签到题，如果是刚入门的同学的话，第一次做这个可能有点吃力。正如题目所说的，该算法是逆向工程中最常见的算法，其实更是密码学最常见算法之一，那就是异或⊕或者叫模2加法，其基于的原则就是 二进制不带进位加法运算：  0+1=1  0+0=0  1+0=1  1+1=0回到题目中来，我们直接使用IDA分析程序，自动分析完成后，因为大部分同学不懂汇编，这里我就直接F5看伪C代码了。上图所示的是输入部分，可以看到对输入字符串的每一个值循环和i进行异或操作，将结果保存在cinXor中。下面将判断输入的字符串是否正确。上图所示的就是比较的部分，实际上这段代码是memcmp函数的具体实现。先取出两个数组的首地址，逐个比较，变量每次加四代表比较的大小是一次32位，也就是4字节。最后才进入if判断条件，比较最后2个，所以很明显，比较长度是4的倍数余2。解法为了获取需要对比的字符串，我们查看该flag变量。如下图所示。现在我们需要做的就是将该数组的每个值，和i异或就行了。用python写脚本求解。#coding:utf-8__author__ = &#39;zjgcjy&#39;flag =&#39;&#39;strXor = &quot;\x63\x74\x6f\x77\x67\x71\x60\x7c\x50\x39&quot; \         &quot;\x78\x54\x3d\x7e\x51\x6c\x20\x7c\x5f\x5c&quot; \         &quot;\x7a\x4a\x22\x79\x7c\x46\x74\x2b\x68\x42&quot; \         &quot;\x76\x2b\x52\x45\x7d\x51\x15\x42\x4e\x53\x17\x54&quot;for index, ch in enumerate(strXor):	flag += chr(index ^ ord(ch))print flag由此得到flag。cumtctf{X0r_1s_c0mMOn_4nd_n0t_h4rd_r1ght?}re0: beginning - 100  Watch out the order please.VS2012编译 C语言 Release版本 32位这题才算是一个逆向的题目，不过也很简单，平时比赛的话最高50分。使用IDA分析好了。就主函数中对输入进行了操作，通过上图我们可以看到，当输入字符串长度是36时，将每四个作为一组。高位的作为高位，低位的作为低位。意思就是说，将4个8bit的char变量转成1个32bit的int变量，其中高地址存放高字节，而且左移8位不会影响其低字节，最后和0x12341234异或，再和flag进行比较。然后我们来查看一下flag变量。解法知道了过程写脚本就容易了。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciiarray = [0x75557E52,0x2351454F,0x57592257,0x4D7B466B,0x4D515A40,0x77427766,0x7C582746,0x22434D53,0x6F503346]result = &#39;&#39;for i in xrange(len(array)):	result += binascii.a2b_hex(hex(array[i] ^ 0x12341234)[2:])[::-1]print result由此得到flag。flag{We1c0mE_TO_tHe_Rever5lng_w0r!d}Stay in observation - 150  Well, you ought to be familiar with this language.VS2012编译  C# .Net Framework4.0 Release版本 64位这是一道.Net逆向，考虑到很多同学没有接触过C#，所以我给了150分，其实和Java是差不多的，一个是CLR，一个是JVM。其中的算法也很简单，我没用加壳进行保护，所以用.Net的工具就能直接看到源码了，甚至能动态调试。做出来这道题目的同学主要的思路有2种，和我预想的差不多。  使用动态调试，获取鼠标的位置，根据题目手动修改，之后自动解密出flag。  不用动态调试，直接看后面的解密代码，发现是AES，写脚本解出flag。  既使用调试，同时又跟踪AES，最后发现，flag被自动解出来了。WoW!解法调试的方式我就不说了，这里我将一下第二种方式。题目我是用了一张图片，检测鼠标的点击事件，当点击三次后。进行判断，点击的位置和规定的位置是否相同，这里的3个位置是我随机选的，所以用户点击一次就成功的可能性是个极小概率事件，更别说3次了。当判断不同时，直接弹框失败，否则进入MIX类中的Crypt方法进行解密。下面我们来看一下这个MIX类。可以看到，该类中定义了一个计算MD5的方法，和一个解密的方法，当然还有一共byte转string的方法，这里没有列出来。其实这个MD5方法根本没有用到，就是混淆视听用的，而下面的System.Security.Cryptography.RijndaelManaged类就是Rijndael密码算法，也就是AES。下面直接写脚本解AES就行了。#coding:utf-8@需要Crypto库支持__author__=&#39;zjgcjy&#39;from Crypto.Cipher import AESfrom base64 import *IV = &quot;Oityj1sok1yksiWeqtddYQ==&quot;key = &quot;epWRCdxC79zuea4ZnxEacCMMmIzo0tn/Ah+ENEWOYOY=&quot;c = &quot;NAaswR+u94wyIGDUifYSIfznIt0VXoR/NWoJoSjyWJ0=&quot;cipher = AES.new(b64decode(key), AES.MODE_CBC, b64decode(IV))plain = cipher.decrypt(b64decode(c))print plain注意该AES有IV，可能是CBC、CFB、OFB三种模式，而在C#中，有IV情况下又未指定模式，一般是指CBC模式，由此得到flag。flag{reVer5e_1n_C5harP_or_ae5}Shuttle - 200  Randomization is not terrible, trust me.VS2012编译 C语言 Release版本 32位C语言写的控制台程序，直接用IDA吧，打开后主函数流程如下。先输入字符串，没什么好说的，但是看下面。很明显，这里用了rand函数，同时加入了时间作为种子，产生4个伪随机数作为密钥key。再来看接下来的步骤，用随机的key当作密钥流和数组进行异或，最后和flag进行比较，若相等则Congratulations。所以我们要做的就是爆破一个4字节的key，然后和原始数组进行亦或，最后得到一个有意义的字符串。脚本如下。解法# coding:utf-8__author__=&#39;zjgcjy&#39;import reimport stringimport itertools as its#[0-9a-zA-Z_]{23,}words = string.lowercasetable = [0x33,0x11,0x1a,0x1c,0x2e,0x1d,0x2b,0x49,0x12,0x2f,0x1,0x4d,0x4,0x1c,0x11,0x2b,0x12,0x2f,0x3d,0xb,0x8,0x4,0x2b,0x47]r = its.product(words,repeat=4)for i in r:	key = &quot;&quot;.join(i)	flag =&quot;&quot;	for i in xrange(len(table)):		flag += chr(table[i] ^ ord(key[i%4]))	if re.search(&#39;[0-9a-zA-Z_?]{24,}&#39;,flag) and flag.count(&#39;_&#39;)&gt;3:		print key,flag有几点需要注意。  key一般是可见字符，而后期我放了提示说key是字母，这里爆破的范围可以减少，可以分别爆破小写和大写尝试。  更明显的是，flag中只会包含数字、大小写字母和以下划线为代表的特殊字符，所以这里可以结合正则表达式求解。  正则表达式的条件不唯一，这里也需要试多次，一开始可以试[0-9a-zA-Z_]{23,}，发现最后一位只有=&gt;?三种情况了，再分别尝试，同时可以结合下划线出现次数来提高效率。最后得到flag如下。flag{RandOm_1s_u5eleSs_Isit_?}Symmetric Cipher - 250  Have you ever heard of Microsoft Foundation Classes ?VS2017编译 MFC 静态链接 Release版本 32位这道题是一个MFC的程序，由于是静态链接，程序体积很大，有3MB多。在如此大量的代码下能找到关键的Check函数是比较重要的。这里我贴上关于MFC如何交叉应用查找控件ID的方法，也是由唐师傅在暑假培训的时候讲过的内容。想要深入的同学需要自己学习了，这里我就详细讲了。基于MFC的教程1基于MFC的教程2基于MFC的教程3解法现在我们打开IDA，追踪到该关键函数。IDA自动生成的sub_402510函数则是确定按钮点击的消息处理，但是一开始确定按钮是点击不了的，原因是长度不满足条件，具体的条件则在sub_4024C0中，如下图所示。也就是说，当输入字符串长度是30的时候，确定按钮将被激活，即flag长度是30。所以现在我们再来看sub_402510函数的流程。如下图所示。可以看到，点击确定后，首先进行反调试，若程序正在被调试，则直接退出。mov     ebx, large fs:30hmov     eax, [ebx+68h]cmp     eax, 70h关于该反调试的原理，很简单。相当于是自己实现简单的反调试检测，和微软的API接口IsDebuggerPresent()有点不同的是：IsDebuggerPresent()是通过访问程序PEB的BeingDebugged标志检测反调试。而该段汇编是通过检测NTGlobalFlag，是PEB结构偏移量0x68处的一个未公开位置，该位置决定了程序在调试和正常情况下不同的创建内存堆的方式。如果是0x70，则程序正在被调试。要跳过的方式很简单，直接nop判断方法或者改跳转(汇编模式下操作)。当然这个题我不是考大家这个的。我们直接进入Check函数好了。有点基础的同学进入这个函数就能发现下面会有一个rc4的加密。而密钥流由National_Basketball_Association来生成。这里我就不多说了，上面的截图是rc4的KSA函数，先将密钥流初始化，再进行混乱。接下来就是rc4的第二部分，伪随机生成密钥流并和字符串进行异或，得到密文。如上图所示。之后的代码就是比较了，这里不多说了。由于rc4加密和解密是同一个函数，解密时，我们只需要将密文通过同一个key即可恢复得到明文了。下面是程序中的常量字符串，可能有童鞋没找到，我这里列出来了。这里我直接引用Orzk队的脚本了，也可以自己写，不是很难。最后得到flag如下。cumtctf{Mfc_1s_VerY_difflcUIt}Windows Cracker - 300  Would you want to be a Windows craker ? Try your best !!!VS2012编译 Windows 动态链接 Release版本 32位最后一题是一个Windows下的GUI程序，程序本身很简单，就是弹出一个对话框，根据输入计算flag。主要还是找到Check函数，但是这个程序本身很小，你也可以一个一个找，很快也能找到-_-。关于Win32程序是如何加载的，推荐大家看windows系列的书籍，里面会详细讲。我简单说明一下。首先看一下程序中所有的字符串常量，相关的函数也可以在这里查找交叉引用。其次我们从主函数开始分析。要注意，GUI程序是从WinMain开始的，首先是定义注册窗口类并调用RegisterClassW()，其次就可以依据该窗口类来创建窗口，调用CreateWindowExW()，之后开始进入整个消息循环中，进行消息的分发与更新。而整个框架中最重要的是注册窗口类的回调函数，也就是窗口过程。他是tagWNDCLASSW结构体中的lpfnWndProc，函数类型为WNDPROC 。窗口过程的参数与分别是窗口句柄，消息标识符，2个DWORD的消息参数。在这个程序中，窗口过程首先接受WM_CREATE消息，进行窗口控件的创建，即上图中的case 1的情况，创建了一个文本框和一个确定按钮。对于确定按钮，定义了HMENU参数是250。控件ID和HMENU是共用的，当作为子窗口时，往往不需要菜单，该值用来区分控件。而对于接受到的按钮子窗口的WM_COMMAND消息，wParam参数的低位是子窗口ID，高位是消息，lParam参数是接收消息的子窗口的句柄。一句话，也就是说在点击按钮后，产生wParam消息的低位是250，直接进入sub_401350()函数中进行判断。下面我们来看一下这个函数。可以看到，直接调用GetWindowTextA()API来判断输入长度，当输入长度不是41的时候，直接通过SendMessageW()向窗口过程发送消息，且wParam参数是1111，我们回到窗口过程可以看到，此时会直接调用MessageBoxW(hWnd, L&quot;flag错误&quot;, L&quot;FAIL&quot;, 0x40u)即弹框，flag错误。所以我们可以确定flag长度就是41。接下来进入核心的Check函数验证算法。看着很简单，其实不然。其中的loc_401050是一大段汇编，由于IDA反汇编插件出错，是需要看汇编的。这种情况经常会有，请大家习惯看汇编，而且F5经常会出错当然这题是我手动造成的情况，由于IDA采用了递归下降的扫描方式，想要让其出错并不难。请大家自己移步到链接。线性扫描算法分析递归下降算法分析知道了这些后，直接nop部分指令就行了。出错的位置是.text:00401050和.text:004010B6，之后需要手动建立函数。最后函数流程如下图所示。发现就是不停的取第二个参数的2个值，然后相加放在第一个参数列表中。下面我们重新回到Check函数，重新反编译，如下图所示。第一步，进入第一个函数sub_401000分析。这里我就不贴图了，这个函数没有什么实质的作用，就是把原来的字符串进行打乱，类似于第二个密钥是0的仿射密码，左右两端同时进行。cinShuttle[(i * 33) % 41] = cin[(i * 23) % 41]打乱后进入第二个函数，而第二个函数就是不停的相加，就结束了。最后是用strcmp和flag进行对比。解法既然核心的算法都求出来了，逆向就变得比较简单了，所以我们就是要先逆向sub_401050()这个函数，之后再将顺序还原。  第二个函数创建了41个加法等式，就构成了一个41元一次方程组，且线性无关，只有唯一解。只需要解方程即可。  第一个函数的逆向，如果看出来是单表代换密码，直接求33模41的逆元和23模41的逆元，即可还原明文。          如果看不懂移位怎么逆向，直接输入有序数组，动态调试，打印出结果，构建一一映射关系。      如果即看不懂，也不会动态调试，那就直接爆破，在不考虑逆元是否存在的条件下，也只需要爆破41*41次。      下面贴出我的解法，这里解41元方程组使用python的z3库来求解，当然同样可以使用Mathematica，或者python的numpy库来求解。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciifrom z3 import *def solver():	res = &#39;&#39;	cipher = &quot;97b1c8cdd5d29694b8b4c5daa471718fbe94a4d0def3d5d4d4c4d9e5c1c4d5daf4e7c1bed7c196646a&quot;	mat = [Int(&#39;mat%d&#39;% i)for i in xrange(41)]	auth = [ord(i) for i in binascii.a2b_hex(cipher)]	s = Solver()	s.add(And(		auth[0] == mat[7] + mat[24],		auth[1] == mat[24] + mat[0],		auth[2] == mat[0] + mat[17],		auth[3] == mat[17] + mat[34],		auth[4] == mat[34] + mat[10],		auth[5] == mat[10] + mat[27],		auth[6] == mat[27] + mat[3],		auth[7] == mat[3] + mat[20],		auth[8] == mat[20] + mat[37],		auth[9] == mat[37] + mat[13],		auth[10] == mat[13] + mat[30],		auth[11] == mat[30] + mat[6],		auth[12] == mat[6] + mat[23],		auth[13] == mat[23] + mat[40],		auth[14] == mat[40] + mat[16],		auth[15] == mat[16] + mat[33],		auth[16] == mat[33] + mat[9],		auth[17] == mat[9] + mat[26],		auth[18] == mat[26] + mat[2],		auth[19] == mat[2] + mat[19],		auth[20] == mat[19] + mat[36],		auth[21] == mat[36] + mat[12],		auth[22] == mat[12] + mat[29],		auth[23] == mat[29] + mat[5],		auth[24] == mat[5] + mat[22],		auth[25] == mat[22] + mat[39],		auth[26] == mat[39] + mat[15],		auth[27] == mat[15] + mat[32],		auth[28] == mat[32] + mat[8],		auth[29] == mat[8] + mat[25],		auth[30] == mat[25] + mat[1],		auth[31] == mat[1] + mat[18],		auth[32] == mat[18] + mat[35],		auth[33] == mat[35] + mat[11],		auth[34] == mat[11] + mat[28],		auth[35] == mat[28] + mat[4],		auth[36] == mat[4] + mat[21],		auth[37] == mat[21] + mat[38],		auth[38] == mat[38] + mat[14],		auth[39] == mat[14] + mat[31],		auth[40] == mat[31] + mat[7],))	for i in xrange(41):		s.add(mat[i] &gt; 0x20)		s.add(mat[i] &lt; 0x80)	if(s.check() == sat):		m = s.model()		for i in xrange(41):			res += chr(m[mat[i]].as_long())	print resif __name__ == &#39;__main__&#39;:	main()通过z3求解出结果是cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA。再求出33和23模41的逆元分别是5和-16，还原即可。def decode():	mat = [i for i in xrange(41)]	str1 = r&#39;&#39;&#39;cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA&#39;&#39;&#39;	for i in xrange(41):		mat[(i * 5) % 41] = str1[(i * (-16)) % 41]	print &#39;&#39;.join(mat)最后得到flag。cumtctf{Ai_CaN_he1P_y0U_SoIve_eqUatl0n5!}">



  <meta property="og:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="2018cumtctf逆向出题思路">
  <meta name="twitter:description" content="  初赛刚刚结束，总体来说，这一次比赛re的难度不大，后面几个题难度也只是中等偏容易。我主要考虑到受众有许多17级的同学(可能是想多了-_-)，出这几个题目的时候，没有为难大家。本来以为后面几个题能困倒大家，没想到还是有大佬冲了出来，倍感欣慰，看来我差不多也该退役了。以下是我出题的思路：  多框架  多语言  算法简单  解法多样  32位Release版本  无加壳保护  无混淆代码  基本无反调试A piece of cake - 50  As the title said. Nothing else.VS2012编译 C语言 Release版本 32位签到题，不用多说吧。解法解法如下图所示，或者你用IDA之类的逆向工具打开就能看到了。(若有童鞋不懂稍微讲一下：将输入字符串和flag进行比较，正确就Congratulations)cumtctf{We1cOme_t0_cUmtCtf_IeVe1_0ne_SO_eaSy!}Uncomplicated - 50  Probably, this is the most common algorithm in software reversing.VS2012编译 C语言 Release版本 32位入门签到题，如果是刚入门的同学的话，第一次做这个可能有点吃力。正如题目所说的，该算法是逆向工程中最常见的算法，其实更是密码学最常见算法之一，那就是异或⊕或者叫模2加法，其基于的原则就是 二进制不带进位加法运算：  0+1=1  0+0=0  1+0=1  1+1=0回到题目中来，我们直接使用IDA分析程序，自动分析完成后，因为大部分同学不懂汇编，这里我就直接F5看伪C代码了。上图所示的是输入部分，可以看到对输入字符串的每一个值循环和i进行异或操作，将结果保存在cinXor中。下面将判断输入的字符串是否正确。上图所示的就是比较的部分，实际上这段代码是memcmp函数的具体实现。先取出两个数组的首地址，逐个比较，变量每次加四代表比较的大小是一次32位，也就是4字节。最后才进入if判断条件，比较最后2个，所以很明显，比较长度是4的倍数余2。解法为了获取需要对比的字符串，我们查看该flag变量。如下图所示。现在我们需要做的就是将该数组的每个值，和i异或就行了。用python写脚本求解。#coding:utf-8__author__ = &#39;zjgcjy&#39;flag =&#39;&#39;strXor = &quot;\x63\x74\x6f\x77\x67\x71\x60\x7c\x50\x39&quot; \         &quot;\x78\x54\x3d\x7e\x51\x6c\x20\x7c\x5f\x5c&quot; \         &quot;\x7a\x4a\x22\x79\x7c\x46\x74\x2b\x68\x42&quot; \         &quot;\x76\x2b\x52\x45\x7d\x51\x15\x42\x4e\x53\x17\x54&quot;for index, ch in enumerate(strXor):	flag += chr(index ^ ord(ch))print flag由此得到flag。cumtctf{X0r_1s_c0mMOn_4nd_n0t_h4rd_r1ght?}re0: beginning - 100  Watch out the order please.VS2012编译 C语言 Release版本 32位这题才算是一个逆向的题目，不过也很简单，平时比赛的话最高50分。使用IDA分析好了。就主函数中对输入进行了操作，通过上图我们可以看到，当输入字符串长度是36时，将每四个作为一组。高位的作为高位，低位的作为低位。意思就是说，将4个8bit的char变量转成1个32bit的int变量，其中高地址存放高字节，而且左移8位不会影响其低字节，最后和0x12341234异或，再和flag进行比较。然后我们来查看一下flag变量。解法知道了过程写脚本就容易了。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciiarray = [0x75557E52,0x2351454F,0x57592257,0x4D7B466B,0x4D515A40,0x77427766,0x7C582746,0x22434D53,0x6F503346]result = &#39;&#39;for i in xrange(len(array)):	result += binascii.a2b_hex(hex(array[i] ^ 0x12341234)[2:])[::-1]print result由此得到flag。flag{We1c0mE_TO_tHe_Rever5lng_w0r!d}Stay in observation - 150  Well, you ought to be familiar with this language.VS2012编译  C# .Net Framework4.0 Release版本 64位这是一道.Net逆向，考虑到很多同学没有接触过C#，所以我给了150分，其实和Java是差不多的，一个是CLR，一个是JVM。其中的算法也很简单，我没用加壳进行保护，所以用.Net的工具就能直接看到源码了，甚至能动态调试。做出来这道题目的同学主要的思路有2种，和我预想的差不多。  使用动态调试，获取鼠标的位置，根据题目手动修改，之后自动解密出flag。  不用动态调试，直接看后面的解密代码，发现是AES，写脚本解出flag。  既使用调试，同时又跟踪AES，最后发现，flag被自动解出来了。WoW!解法调试的方式我就不说了，这里我将一下第二种方式。题目我是用了一张图片，检测鼠标的点击事件，当点击三次后。进行判断，点击的位置和规定的位置是否相同，这里的3个位置是我随机选的，所以用户点击一次就成功的可能性是个极小概率事件，更别说3次了。当判断不同时，直接弹框失败，否则进入MIX类中的Crypt方法进行解密。下面我们来看一下这个MIX类。可以看到，该类中定义了一个计算MD5的方法，和一个解密的方法，当然还有一共byte转string的方法，这里没有列出来。其实这个MD5方法根本没有用到，就是混淆视听用的，而下面的System.Security.Cryptography.RijndaelManaged类就是Rijndael密码算法，也就是AES。下面直接写脚本解AES就行了。#coding:utf-8@需要Crypto库支持__author__=&#39;zjgcjy&#39;from Crypto.Cipher import AESfrom base64 import *IV = &quot;Oityj1sok1yksiWeqtddYQ==&quot;key = &quot;epWRCdxC79zuea4ZnxEacCMMmIzo0tn/Ah+ENEWOYOY=&quot;c = &quot;NAaswR+u94wyIGDUifYSIfznIt0VXoR/NWoJoSjyWJ0=&quot;cipher = AES.new(b64decode(key), AES.MODE_CBC, b64decode(IV))plain = cipher.decrypt(b64decode(c))print plain注意该AES有IV，可能是CBC、CFB、OFB三种模式，而在C#中，有IV情况下又未指定模式，一般是指CBC模式，由此得到flag。flag{reVer5e_1n_C5harP_or_ae5}Shuttle - 200  Randomization is not terrible, trust me.VS2012编译 C语言 Release版本 32位C语言写的控制台程序，直接用IDA吧，打开后主函数流程如下。先输入字符串，没什么好说的，但是看下面。很明显，这里用了rand函数，同时加入了时间作为种子，产生4个伪随机数作为密钥key。再来看接下来的步骤，用随机的key当作密钥流和数组进行异或，最后和flag进行比较，若相等则Congratulations。所以我们要做的就是爆破一个4字节的key，然后和原始数组进行亦或，最后得到一个有意义的字符串。脚本如下。解法# coding:utf-8__author__=&#39;zjgcjy&#39;import reimport stringimport itertools as its#[0-9a-zA-Z_]{23,}words = string.lowercasetable = [0x33,0x11,0x1a,0x1c,0x2e,0x1d,0x2b,0x49,0x12,0x2f,0x1,0x4d,0x4,0x1c,0x11,0x2b,0x12,0x2f,0x3d,0xb,0x8,0x4,0x2b,0x47]r = its.product(words,repeat=4)for i in r:	key = &quot;&quot;.join(i)	flag =&quot;&quot;	for i in xrange(len(table)):		flag += chr(table[i] ^ ord(key[i%4]))	if re.search(&#39;[0-9a-zA-Z_?]{24,}&#39;,flag) and flag.count(&#39;_&#39;)&gt;3:		print key,flag有几点需要注意。  key一般是可见字符，而后期我放了提示说key是字母，这里爆破的范围可以减少，可以分别爆破小写和大写尝试。  更明显的是，flag中只会包含数字、大小写字母和以下划线为代表的特殊字符，所以这里可以结合正则表达式求解。  正则表达式的条件不唯一，这里也需要试多次，一开始可以试[0-9a-zA-Z_]{23,}，发现最后一位只有=&gt;?三种情况了，再分别尝试，同时可以结合下划线出现次数来提高效率。最后得到flag如下。flag{RandOm_1s_u5eleSs_Isit_?}Symmetric Cipher - 250  Have you ever heard of Microsoft Foundation Classes ?VS2017编译 MFC 静态链接 Release版本 32位这道题是一个MFC的程序，由于是静态链接，程序体积很大，有3MB多。在如此大量的代码下能找到关键的Check函数是比较重要的。这里我贴上关于MFC如何交叉应用查找控件ID的方法，也是由唐师傅在暑假培训的时候讲过的内容。想要深入的同学需要自己学习了，这里我就详细讲了。基于MFC的教程1基于MFC的教程2基于MFC的教程3解法现在我们打开IDA，追踪到该关键函数。IDA自动生成的sub_402510函数则是确定按钮点击的消息处理，但是一开始确定按钮是点击不了的，原因是长度不满足条件，具体的条件则在sub_4024C0中，如下图所示。也就是说，当输入字符串长度是30的时候，确定按钮将被激活，即flag长度是30。所以现在我们再来看sub_402510函数的流程。如下图所示。可以看到，点击确定后，首先进行反调试，若程序正在被调试，则直接退出。mov     ebx, large fs:30hmov     eax, [ebx+68h]cmp     eax, 70h关于该反调试的原理，很简单。相当于是自己实现简单的反调试检测，和微软的API接口IsDebuggerPresent()有点不同的是：IsDebuggerPresent()是通过访问程序PEB的BeingDebugged标志检测反调试。而该段汇编是通过检测NTGlobalFlag，是PEB结构偏移量0x68处的一个未公开位置，该位置决定了程序在调试和正常情况下不同的创建内存堆的方式。如果是0x70，则程序正在被调试。要跳过的方式很简单，直接nop判断方法或者改跳转(汇编模式下操作)。当然这个题我不是考大家这个的。我们直接进入Check函数好了。有点基础的同学进入这个函数就能发现下面会有一个rc4的加密。而密钥流由National_Basketball_Association来生成。这里我就不多说了，上面的截图是rc4的KSA函数，先将密钥流初始化，再进行混乱。接下来就是rc4的第二部分，伪随机生成密钥流并和字符串进行异或，得到密文。如上图所示。之后的代码就是比较了，这里不多说了。由于rc4加密和解密是同一个函数，解密时，我们只需要将密文通过同一个key即可恢复得到明文了。下面是程序中的常量字符串，可能有童鞋没找到，我这里列出来了。这里我直接引用Orzk队的脚本了，也可以自己写，不是很难。最后得到flag如下。cumtctf{Mfc_1s_VerY_difflcUIt}Windows Cracker - 300  Would you want to be a Windows craker ? Try your best !!!VS2012编译 Windows 动态链接 Release版本 32位最后一题是一个Windows下的GUI程序，程序本身很简单，就是弹出一个对话框，根据输入计算flag。主要还是找到Check函数，但是这个程序本身很小，你也可以一个一个找，很快也能找到-_-。关于Win32程序是如何加载的，推荐大家看windows系列的书籍，里面会详细讲。我简单说明一下。首先看一下程序中所有的字符串常量，相关的函数也可以在这里查找交叉引用。其次我们从主函数开始分析。要注意，GUI程序是从WinMain开始的，首先是定义注册窗口类并调用RegisterClassW()，其次就可以依据该窗口类来创建窗口，调用CreateWindowExW()，之后开始进入整个消息循环中，进行消息的分发与更新。而整个框架中最重要的是注册窗口类的回调函数，也就是窗口过程。他是tagWNDCLASSW结构体中的lpfnWndProc，函数类型为WNDPROC 。窗口过程的参数与分别是窗口句柄，消息标识符，2个DWORD的消息参数。在这个程序中，窗口过程首先接受WM_CREATE消息，进行窗口控件的创建，即上图中的case 1的情况，创建了一个文本框和一个确定按钮。对于确定按钮，定义了HMENU参数是250。控件ID和HMENU是共用的，当作为子窗口时，往往不需要菜单，该值用来区分控件。而对于接受到的按钮子窗口的WM_COMMAND消息，wParam参数的低位是子窗口ID，高位是消息，lParam参数是接收消息的子窗口的句柄。一句话，也就是说在点击按钮后，产生wParam消息的低位是250，直接进入sub_401350()函数中进行判断。下面我们来看一下这个函数。可以看到，直接调用GetWindowTextA()API来判断输入长度，当输入长度不是41的时候，直接通过SendMessageW()向窗口过程发送消息，且wParam参数是1111，我们回到窗口过程可以看到，此时会直接调用MessageBoxW(hWnd, L&quot;flag错误&quot;, L&quot;FAIL&quot;, 0x40u)即弹框，flag错误。所以我们可以确定flag长度就是41。接下来进入核心的Check函数验证算法。看着很简单，其实不然。其中的loc_401050是一大段汇编，由于IDA反汇编插件出错，是需要看汇编的。这种情况经常会有，请大家习惯看汇编，而且F5经常会出错当然这题是我手动造成的情况，由于IDA采用了递归下降的扫描方式，想要让其出错并不难。请大家自己移步到链接。线性扫描算法分析递归下降算法分析知道了这些后，直接nop部分指令就行了。出错的位置是.text:00401050和.text:004010B6，之后需要手动建立函数。最后函数流程如下图所示。发现就是不停的取第二个参数的2个值，然后相加放在第一个参数列表中。下面我们重新回到Check函数，重新反编译，如下图所示。第一步，进入第一个函数sub_401000分析。这里我就不贴图了，这个函数没有什么实质的作用，就是把原来的字符串进行打乱，类似于第二个密钥是0的仿射密码，左右两端同时进行。cinShuttle[(i * 33) % 41] = cin[(i * 23) % 41]打乱后进入第二个函数，而第二个函数就是不停的相加，就结束了。最后是用strcmp和flag进行对比。解法既然核心的算法都求出来了，逆向就变得比较简单了，所以我们就是要先逆向sub_401050()这个函数，之后再将顺序还原。  第二个函数创建了41个加法等式，就构成了一个41元一次方程组，且线性无关，只有唯一解。只需要解方程即可。  第一个函数的逆向，如果看出来是单表代换密码，直接求33模41的逆元和23模41的逆元，即可还原明文。          如果看不懂移位怎么逆向，直接输入有序数组，动态调试，打印出结果，构建一一映射关系。      如果即看不懂，也不会动态调试，那就直接爆破，在不考虑逆元是否存在的条件下，也只需要爆破41*41次。      下面贴出我的解法，这里解41元方程组使用python的z3库来求解，当然同样可以使用Mathematica，或者python的numpy库来求解。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciifrom z3 import *def solver():	res = &#39;&#39;	cipher = &quot;97b1c8cdd5d29694b8b4c5daa471718fbe94a4d0def3d5d4d4c4d9e5c1c4d5daf4e7c1bed7c196646a&quot;	mat = [Int(&#39;mat%d&#39;% i)for i in xrange(41)]	auth = [ord(i) for i in binascii.a2b_hex(cipher)]	s = Solver()	s.add(And(		auth[0] == mat[7] + mat[24],		auth[1] == mat[24] + mat[0],		auth[2] == mat[0] + mat[17],		auth[3] == mat[17] + mat[34],		auth[4] == mat[34] + mat[10],		auth[5] == mat[10] + mat[27],		auth[6] == mat[27] + mat[3],		auth[7] == mat[3] + mat[20],		auth[8] == mat[20] + mat[37],		auth[9] == mat[37] + mat[13],		auth[10] == mat[13] + mat[30],		auth[11] == mat[30] + mat[6],		auth[12] == mat[6] + mat[23],		auth[13] == mat[23] + mat[40],		auth[14] == mat[40] + mat[16],		auth[15] == mat[16] + mat[33],		auth[16] == mat[33] + mat[9],		auth[17] == mat[9] + mat[26],		auth[18] == mat[26] + mat[2],		auth[19] == mat[2] + mat[19],		auth[20] == mat[19] + mat[36],		auth[21] == mat[36] + mat[12],		auth[22] == mat[12] + mat[29],		auth[23] == mat[29] + mat[5],		auth[24] == mat[5] + mat[22],		auth[25] == mat[22] + mat[39],		auth[26] == mat[39] + mat[15],		auth[27] == mat[15] + mat[32],		auth[28] == mat[32] + mat[8],		auth[29] == mat[8] + mat[25],		auth[30] == mat[25] + mat[1],		auth[31] == mat[1] + mat[18],		auth[32] == mat[18] + mat[35],		auth[33] == mat[35] + mat[11],		auth[34] == mat[11] + mat[28],		auth[35] == mat[28] + mat[4],		auth[36] == mat[4] + mat[21],		auth[37] == mat[21] + mat[38],		auth[38] == mat[38] + mat[14],		auth[39] == mat[14] + mat[31],		auth[40] == mat[31] + mat[7],))	for i in xrange(41):		s.add(mat[i] &gt; 0x20)		s.add(mat[i] &lt; 0x80)	if(s.check() == sat):		m = s.model()		for i in xrange(41):			res += chr(m[mat[i]].as_long())	print resif __name__ == &#39;__main__&#39;:	main()通过z3求解出结果是cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA。再求出33和23模41的逆元分别是5和-16，还原即可。def decode():	mat = [i for i in xrange(41)]	str1 = r&#39;&#39;&#39;cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA&#39;&#39;&#39;	for i in xrange(41):		mat[(i * 5) % 41] = str1[(i * (-16)) % 41]	print &#39;&#39;.join(mat)最后得到flag。cumtctf{Ai_CaN_he1P_y0U_SoIve_eqUatl0n5!}">
  <meta name="twitter:url" content="https://zjgcjy.github.io/posts/2018-08/2018cumtctf%E9%80%86%E5%90%91%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2018-08-15T05:43:00+08:00">





  

  


<link rel="canonical" href="https://zjgcjy.github.io/posts/2018-08/2018cumtctf%E9%80%86%E5%90%91%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "https://zjgcjy.github.io/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/hacker-inside.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about.html" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fa fa-map-marker" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fa fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fa fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="2018cumtctf逆向出题思路">
    <meta itemprop="description" content="  初赛刚刚结束，总体来说，这一次比赛re的难度不大，后面几个题难度也只是中等偏容易。我主要考虑到受众有许多17级的同学(可能是想多了-_-)，出这几个题目的时候，没有为难大家。本来以为后面几个题能困倒大家，没想到还是有大佬冲了出来，倍感欣慰，看来我差不多也该退役了。以下是我出题的思路：  多框架  多语言  算法简单  解法多样  32位Release版本  无加壳保护  无混淆代码  基本无反调试A piece of cake - 50  As the title said. Nothing else.VS2012编译 C语言 Release版本 32位签到题，不用多说吧。解法解法如下图所示，或者你用IDA之类的逆向工具打开就能看到了。(若有童鞋不懂稍微讲一下：将输入字符串和flag进行比较，正确就Congratulations)cumtctf{We1cOme_t0_cUmtCtf_IeVe1_0ne_SO_eaSy!}Uncomplicated - 50  Probably, this is the most common algorithm in software reversing.VS2012编译 C语言 Release版本 32位入门签到题，如果是刚入门的同学的话，第一次做这个可能有点吃力。正如题目所说的，该算法是逆向工程中最常见的算法，其实更是密码学最常见算法之一，那就是异或⊕或者叫模2加法，其基于的原则就是 二进制不带进位加法运算：  0+1=1  0+0=0  1+0=1  1+1=0回到题目中来，我们直接使用IDA分析程序，自动分析完成后，因为大部分同学不懂汇编，这里我就直接F5看伪C代码了。上图所示的是输入部分，可以看到对输入字符串的每一个值循环和i进行异或操作，将结果保存在cinXor中。下面将判断输入的字符串是否正确。上图所示的就是比较的部分，实际上这段代码是memcmp函数的具体实现。先取出两个数组的首地址，逐个比较，变量每次加四代表比较的大小是一次32位，也就是4字节。最后才进入if判断条件，比较最后2个，所以很明显，比较长度是4的倍数余2。解法为了获取需要对比的字符串，我们查看该flag变量。如下图所示。现在我们需要做的就是将该数组的每个值，和i异或就行了。用python写脚本求解。#coding:utf-8__author__ = &#39;zjgcjy&#39;flag =&#39;&#39;strXor = &quot;\x63\x74\x6f\x77\x67\x71\x60\x7c\x50\x39&quot; \         &quot;\x78\x54\x3d\x7e\x51\x6c\x20\x7c\x5f\x5c&quot; \         &quot;\x7a\x4a\x22\x79\x7c\x46\x74\x2b\x68\x42&quot; \         &quot;\x76\x2b\x52\x45\x7d\x51\x15\x42\x4e\x53\x17\x54&quot;for index, ch in enumerate(strXor):	flag += chr(index ^ ord(ch))print flag由此得到flag。cumtctf{X0r_1s_c0mMOn_4nd_n0t_h4rd_r1ght?}re0: beginning - 100  Watch out the order please.VS2012编译 C语言 Release版本 32位这题才算是一个逆向的题目，不过也很简单，平时比赛的话最高50分。使用IDA分析好了。就主函数中对输入进行了操作，通过上图我们可以看到，当输入字符串长度是36时，将每四个作为一组。高位的作为高位，低位的作为低位。意思就是说，将4个8bit的char变量转成1个32bit的int变量，其中高地址存放高字节，而且左移8位不会影响其低字节，最后和0x12341234异或，再和flag进行比较。然后我们来查看一下flag变量。解法知道了过程写脚本就容易了。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciiarray = [0x75557E52,0x2351454F,0x57592257,0x4D7B466B,0x4D515A40,0x77427766,0x7C582746,0x22434D53,0x6F503346]result = &#39;&#39;for i in xrange(len(array)):	result += binascii.a2b_hex(hex(array[i] ^ 0x12341234)[2:])[::-1]print result由此得到flag。flag{We1c0mE_TO_tHe_Rever5lng_w0r!d}Stay in observation - 150  Well, you ought to be familiar with this language.VS2012编译  C# .Net Framework4.0 Release版本 64位这是一道.Net逆向，考虑到很多同学没有接触过C#，所以我给了150分，其实和Java是差不多的，一个是CLR，一个是JVM。其中的算法也很简单，我没用加壳进行保护，所以用.Net的工具就能直接看到源码了，甚至能动态调试。做出来这道题目的同学主要的思路有2种，和我预想的差不多。  使用动态调试，获取鼠标的位置，根据题目手动修改，之后自动解密出flag。  不用动态调试，直接看后面的解密代码，发现是AES，写脚本解出flag。  既使用调试，同时又跟踪AES，最后发现，flag被自动解出来了。WoW!解法调试的方式我就不说了，这里我将一下第二种方式。题目我是用了一张图片，检测鼠标的点击事件，当点击三次后。进行判断，点击的位置和规定的位置是否相同，这里的3个位置是我随机选的，所以用户点击一次就成功的可能性是个极小概率事件，更别说3次了。当判断不同时，直接弹框失败，否则进入MIX类中的Crypt方法进行解密。下面我们来看一下这个MIX类。可以看到，该类中定义了一个计算MD5的方法，和一个解密的方法，当然还有一共byte转string的方法，这里没有列出来。其实这个MD5方法根本没有用到，就是混淆视听用的，而下面的System.Security.Cryptography.RijndaelManaged类就是Rijndael密码算法，也就是AES。下面直接写脚本解AES就行了。#coding:utf-8@需要Crypto库支持__author__=&#39;zjgcjy&#39;from Crypto.Cipher import AESfrom base64 import *IV = &quot;Oityj1sok1yksiWeqtddYQ==&quot;key = &quot;epWRCdxC79zuea4ZnxEacCMMmIzo0tn/Ah+ENEWOYOY=&quot;c = &quot;NAaswR+u94wyIGDUifYSIfznIt0VXoR/NWoJoSjyWJ0=&quot;cipher = AES.new(b64decode(key), AES.MODE_CBC, b64decode(IV))plain = cipher.decrypt(b64decode(c))print plain注意该AES有IV，可能是CBC、CFB、OFB三种模式，而在C#中，有IV情况下又未指定模式，一般是指CBC模式，由此得到flag。flag{reVer5e_1n_C5harP_or_ae5}Shuttle - 200  Randomization is not terrible, trust me.VS2012编译 C语言 Release版本 32位C语言写的控制台程序，直接用IDA吧，打开后主函数流程如下。先输入字符串，没什么好说的，但是看下面。很明显，这里用了rand函数，同时加入了时间作为种子，产生4个伪随机数作为密钥key。再来看接下来的步骤，用随机的key当作密钥流和数组进行异或，最后和flag进行比较，若相等则Congratulations。所以我们要做的就是爆破一个4字节的key，然后和原始数组进行亦或，最后得到一个有意义的字符串。脚本如下。解法# coding:utf-8__author__=&#39;zjgcjy&#39;import reimport stringimport itertools as its#[0-9a-zA-Z_]{23,}words = string.lowercasetable = [0x33,0x11,0x1a,0x1c,0x2e,0x1d,0x2b,0x49,0x12,0x2f,0x1,0x4d,0x4,0x1c,0x11,0x2b,0x12,0x2f,0x3d,0xb,0x8,0x4,0x2b,0x47]r = its.product(words,repeat=4)for i in r:	key = &quot;&quot;.join(i)	flag =&quot;&quot;	for i in xrange(len(table)):		flag += chr(table[i] ^ ord(key[i%4]))	if re.search(&#39;[0-9a-zA-Z_?]{24,}&#39;,flag) and flag.count(&#39;_&#39;)&gt;3:		print key,flag有几点需要注意。  key一般是可见字符，而后期我放了提示说key是字母，这里爆破的范围可以减少，可以分别爆破小写和大写尝试。  更明显的是，flag中只会包含数字、大小写字母和以下划线为代表的特殊字符，所以这里可以结合正则表达式求解。  正则表达式的条件不唯一，这里也需要试多次，一开始可以试[0-9a-zA-Z_]{23,}，发现最后一位只有=&gt;?三种情况了，再分别尝试，同时可以结合下划线出现次数来提高效率。最后得到flag如下。flag{RandOm_1s_u5eleSs_Isit_?}Symmetric Cipher - 250  Have you ever heard of Microsoft Foundation Classes ?VS2017编译 MFC 静态链接 Release版本 32位这道题是一个MFC的程序，由于是静态链接，程序体积很大，有3MB多。在如此大量的代码下能找到关键的Check函数是比较重要的。这里我贴上关于MFC如何交叉应用查找控件ID的方法，也是由唐师傅在暑假培训的时候讲过的内容。想要深入的同学需要自己学习了，这里我就详细讲了。基于MFC的教程1基于MFC的教程2基于MFC的教程3解法现在我们打开IDA，追踪到该关键函数。IDA自动生成的sub_402510函数则是确定按钮点击的消息处理，但是一开始确定按钮是点击不了的，原因是长度不满足条件，具体的条件则在sub_4024C0中，如下图所示。也就是说，当输入字符串长度是30的时候，确定按钮将被激活，即flag长度是30。所以现在我们再来看sub_402510函数的流程。如下图所示。可以看到，点击确定后，首先进行反调试，若程序正在被调试，则直接退出。mov     ebx, large fs:30hmov     eax, [ebx+68h]cmp     eax, 70h关于该反调试的原理，很简单。相当于是自己实现简单的反调试检测，和微软的API接口IsDebuggerPresent()有点不同的是：IsDebuggerPresent()是通过访问程序PEB的BeingDebugged标志检测反调试。而该段汇编是通过检测NTGlobalFlag，是PEB结构偏移量0x68处的一个未公开位置，该位置决定了程序在调试和正常情况下不同的创建内存堆的方式。如果是0x70，则程序正在被调试。要跳过的方式很简单，直接nop判断方法或者改跳转(汇编模式下操作)。当然这个题我不是考大家这个的。我们直接进入Check函数好了。有点基础的同学进入这个函数就能发现下面会有一个rc4的加密。而密钥流由National_Basketball_Association来生成。这里我就不多说了，上面的截图是rc4的KSA函数，先将密钥流初始化，再进行混乱。接下来就是rc4的第二部分，伪随机生成密钥流并和字符串进行异或，得到密文。如上图所示。之后的代码就是比较了，这里不多说了。由于rc4加密和解密是同一个函数，解密时，我们只需要将密文通过同一个key即可恢复得到明文了。下面是程序中的常量字符串，可能有童鞋没找到，我这里列出来了。这里我直接引用Orzk队的脚本了，也可以自己写，不是很难。最后得到flag如下。cumtctf{Mfc_1s_VerY_difflcUIt}Windows Cracker - 300  Would you want to be a Windows craker ? Try your best !!!VS2012编译 Windows 动态链接 Release版本 32位最后一题是一个Windows下的GUI程序，程序本身很简单，就是弹出一个对话框，根据输入计算flag。主要还是找到Check函数，但是这个程序本身很小，你也可以一个一个找，很快也能找到-_-。关于Win32程序是如何加载的，推荐大家看windows系列的书籍，里面会详细讲。我简单说明一下。首先看一下程序中所有的字符串常量，相关的函数也可以在这里查找交叉引用。其次我们从主函数开始分析。要注意，GUI程序是从WinMain开始的，首先是定义注册窗口类并调用RegisterClassW()，其次就可以依据该窗口类来创建窗口，调用CreateWindowExW()，之后开始进入整个消息循环中，进行消息的分发与更新。而整个框架中最重要的是注册窗口类的回调函数，也就是窗口过程。他是tagWNDCLASSW结构体中的lpfnWndProc，函数类型为WNDPROC 。窗口过程的参数与分别是窗口句柄，消息标识符，2个DWORD的消息参数。在这个程序中，窗口过程首先接受WM_CREATE消息，进行窗口控件的创建，即上图中的case 1的情况，创建了一个文本框和一个确定按钮。对于确定按钮，定义了HMENU参数是250。控件ID和HMENU是共用的，当作为子窗口时，往往不需要菜单，该值用来区分控件。而对于接受到的按钮子窗口的WM_COMMAND消息，wParam参数的低位是子窗口ID，高位是消息，lParam参数是接收消息的子窗口的句柄。一句话，也就是说在点击按钮后，产生wParam消息的低位是250，直接进入sub_401350()函数中进行判断。下面我们来看一下这个函数。可以看到，直接调用GetWindowTextA()API来判断输入长度，当输入长度不是41的时候，直接通过SendMessageW()向窗口过程发送消息，且wParam参数是1111，我们回到窗口过程可以看到，此时会直接调用MessageBoxW(hWnd, L&quot;flag错误&quot;, L&quot;FAIL&quot;, 0x40u)即弹框，flag错误。所以我们可以确定flag长度就是41。接下来进入核心的Check函数验证算法。看着很简单，其实不然。其中的loc_401050是一大段汇编，由于IDA反汇编插件出错，是需要看汇编的。这种情况经常会有，请大家习惯看汇编，而且F5经常会出错当然这题是我手动造成的情况，由于IDA采用了递归下降的扫描方式，想要让其出错并不难。请大家自己移步到链接。线性扫描算法分析递归下降算法分析知道了这些后，直接nop部分指令就行了。出错的位置是.text:00401050和.text:004010B6，之后需要手动建立函数。最后函数流程如下图所示。发现就是不停的取第二个参数的2个值，然后相加放在第一个参数列表中。下面我们重新回到Check函数，重新反编译，如下图所示。第一步，进入第一个函数sub_401000分析。这里我就不贴图了，这个函数没有什么实质的作用，就是把原来的字符串进行打乱，类似于第二个密钥是0的仿射密码，左右两端同时进行。cinShuttle[(i * 33) % 41] = cin[(i * 23) % 41]打乱后进入第二个函数，而第二个函数就是不停的相加，就结束了。最后是用strcmp和flag进行对比。解法既然核心的算法都求出来了，逆向就变得比较简单了，所以我们就是要先逆向sub_401050()这个函数，之后再将顺序还原。  第二个函数创建了41个加法等式，就构成了一个41元一次方程组，且线性无关，只有唯一解。只需要解方程即可。  第一个函数的逆向，如果看出来是单表代换密码，直接求33模41的逆元和23模41的逆元，即可还原明文。          如果看不懂移位怎么逆向，直接输入有序数组，动态调试，打印出结果，构建一一映射关系。      如果即看不懂，也不会动态调试，那就直接爆破，在不考虑逆元是否存在的条件下，也只需要爆破41*41次。      下面贴出我的解法，这里解41元方程组使用python的z3库来求解，当然同样可以使用Mathematica，或者python的numpy库来求解。#coding:utf-8__author__=&#39;zjgcjy&#39;import binasciifrom z3 import *def solver():	res = &#39;&#39;	cipher = &quot;97b1c8cdd5d29694b8b4c5daa471718fbe94a4d0def3d5d4d4c4d9e5c1c4d5daf4e7c1bed7c196646a&quot;	mat = [Int(&#39;mat%d&#39;% i)for i in xrange(41)]	auth = [ord(i) for i in binascii.a2b_hex(cipher)]	s = Solver()	s.add(And(		auth[0] == mat[7] + mat[24],		auth[1] == mat[24] + mat[0],		auth[2] == mat[0] + mat[17],		auth[3] == mat[17] + mat[34],		auth[4] == mat[34] + mat[10],		auth[5] == mat[10] + mat[27],		auth[6] == mat[27] + mat[3],		auth[7] == mat[3] + mat[20],		auth[8] == mat[20] + mat[37],		auth[9] == mat[37] + mat[13],		auth[10] == mat[13] + mat[30],		auth[11] == mat[30] + mat[6],		auth[12] == mat[6] + mat[23],		auth[13] == mat[23] + mat[40],		auth[14] == mat[40] + mat[16],		auth[15] == mat[16] + mat[33],		auth[16] == mat[33] + mat[9],		auth[17] == mat[9] + mat[26],		auth[18] == mat[26] + mat[2],		auth[19] == mat[2] + mat[19],		auth[20] == mat[19] + mat[36],		auth[21] == mat[36] + mat[12],		auth[22] == mat[12] + mat[29],		auth[23] == mat[29] + mat[5],		auth[24] == mat[5] + mat[22],		auth[25] == mat[22] + mat[39],		auth[26] == mat[39] + mat[15],		auth[27] == mat[15] + mat[32],		auth[28] == mat[32] + mat[8],		auth[29] == mat[8] + mat[25],		auth[30] == mat[25] + mat[1],		auth[31] == mat[1] + mat[18],		auth[32] == mat[18] + mat[35],		auth[33] == mat[35] + mat[11],		auth[34] == mat[11] + mat[28],		auth[35] == mat[28] + mat[4],		auth[36] == mat[4] + mat[21],		auth[37] == mat[21] + mat[38],		auth[38] == mat[38] + mat[14],		auth[39] == mat[14] + mat[31],		auth[40] == mat[31] + mat[7],))	for i in xrange(41):		s.add(mat[i] &gt; 0x20)		s.add(mat[i] &lt; 0x80)	if(s.check() == sat):		m = s.model()		for i in xrange(41):			res += chr(m[mat[i]].as_long())	print resif __name__ == &#39;__main__&#39;:	main()通过z3求解出结果是cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA。再求出33和23模41的逆元分别是5和-16，还原即可。def decode():	mat = [i for i in xrange(41)]	str1 = r&#39;&#39;&#39;cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA&#39;&#39;&#39;	for i in xrange(41):		mat[(i * 5) % 41] = str1[(i * (-16)) % 41]	print &#39;&#39;.join(mat)最后得到flag。cumtctf{Ai_CaN_he1P_y0U_SoIve_eqUatl0n5!}">
    <meta itemprop="datePublished" content="August 15, 2018">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">2018cumtctf逆向出题思路
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#a-piece-of-cake---50">A piece of cake - 50</a>
    <ul>
      <li><a href="#解法">解法</a></li>
    </ul>
  </li>
  <li><a href="#uncomplicated---50">Uncomplicated - 50</a>
    <ul>
      <li><a href="#解法-1">解法</a></li>
    </ul>
  </li>
  <li><a href="#re0-beginning---100">re0: beginning - 100</a>
    <ul>
      <li><a href="#解法-2">解法</a></li>
    </ul>
  </li>
  <li><a href="#stay-in-observation---150">Stay in observation - 150</a>
    <ul>
      <li><a href="#解法-3">解法</a></li>
    </ul>
  </li>
  <li><a href="#shuttle---200">Shuttle - 200</a>
    <ul>
      <li><a href="#解法-4">解法</a></li>
    </ul>
  </li>
  <li><a href="#symmetric-cipher---250">Symmetric Cipher - 250</a>
    <ul>
      <li><a href="#解法-5">解法</a></li>
    </ul>
  </li>
  <li><a href="#windows-cracker---300">Windows Cracker - 300</a>
    <ul>
      <li><a href="#解法-6">解法</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <hr />

<blockquote>
  <p>初赛刚刚结束，总体来说，这一次比赛re的难度不大，后面几个题难度也只是中等偏容易。我主要考虑到受众有许多17级的同学(可能是想多了-_-)，出这几个题目的时候，没有为难大家。本来以为后面几个题能困倒大家，没想到还是有大佬冲了出来，倍感欣慰，看来我差不多也该退役了。以下是我出题的思路：</p>
</blockquote>

<ul>
  <li><strong>多框架</strong></li>
  <li><strong>多语言</strong></li>
  <li><strong>算法简单</strong></li>
  <li><strong>解法多样</strong></li>
  <li><strong>32位Release版本</strong></li>
  <li><strong>无加壳保护</strong></li>
  <li><strong>无混淆代码</strong></li>
  <li><strong>基本无反调试</strong></li>
</ul>

<h1 id="a-piece-of-cake---50">A piece of cake - 50</h1>

<blockquote>
  <p><strong>As the title said. Nothing else.</strong></p>
</blockquote>

<p><code class="highlighter-rouge">VS2012编译 C语言 Release版本 32位</code></p>

<p>签到题，不用多说吧。</p>

<h2 id="解法">解法</h2>

<p>解法如下图所示，或者你用IDA之类的逆向工具打开就能看到了。</p>

<p>(若有童鞋不懂稍微讲一下：将输入字符串和flag进行比较，正确就Congratulations)</p>

<p><img src="/img/2018-08/Snipaste_2018-01-14_22-48-08.png" alt="re1" /></p>

<pre><code class="language-flag">cumtctf{We1cOme_t0_cUmtCtf_IeVe1_0ne_SO_eaSy!}
</code></pre>

<h1 id="uncomplicated---50">Uncomplicated - 50</h1>

<blockquote>
  <p><strong>Probably, this is the most common algorithm in software reversing.</strong></p>
</blockquote>

<p><code class="highlighter-rouge">VS2012编译 C语言 Release版本 32位</code></p>

<p>入门签到题，如果是刚入门的同学的话，第一次做这个可能有点吃力。正如题目所说的，该算法是逆向工程中最常见的算法，其实更是密码学最常见算法之一，那就是异或⊕或者叫模2加法，其基于的原则就是 二进制不带进位加法运算：</p>

<ul>
  <li><strong>0+1=1</strong></li>
  <li><strong>0+0=0</strong></li>
  <li><strong>1+0=1</strong></li>
  <li><strong>1+1=0</strong></li>
</ul>

<p>回到题目中来，我们直接使用IDA分析程序，自动分析完成后，因为大部分同学不懂汇编，这里我就直接F5看伪C代码了。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_10-14-02.png" alt="re2" /></p>

<p>上图所示的是输入部分，可以看到对输入字符串的每一个值循环和i进行异或操作，将结果保存在<code class="highlighter-rouge">cinXor</code>中。下面将判断输入的字符串是否正确。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_10-21-33.png" alt="re2" /></p>

<p>上图所示的就是比较的部分，实际上这段代码是<code class="highlighter-rouge">memcmp</code>函数的具体实现。先取出两个数组的首地址，逐个比较，变量每次加四代表比较的大小是一次32位，也就是4字节。最后才进入<code class="highlighter-rouge">if</code>判断条件，比较最后2个，所以很明显，比较长度是4的倍数余2。</p>

<h2 id="解法-1">解法</h2>

<p>为了获取需要对比的字符串，我们查看该flag变量。如下图所示。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_10-30-50.png" alt="re2" /></p>

<p>现在我们需要做的就是将该数组的每个值，和i异或就行了。用python写脚本求解。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#coding:utf-8
</span><span class="n">__author__</span> <span class="o">=</span> <span class="s">'zjgcjy'</span>

<span class="n">flag</span> <span class="o">=</span><span class="s">''</span>
<span class="n">strXor</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x63\x74\x6f\x77\x67\x71\x60\x7c\x50\x39</span><span class="s">"</span> \
         <span class="s">"</span><span class="se">\x78\x54\x3d\x7e\x51\x6c\x20\x7c\x5f\x5c</span><span class="s">"</span> \
         <span class="s">"</span><span class="se">\x7a\x4a\x22\x79\x7c\x46\x74\x2b\x68\x42</span><span class="s">"</span> \
         <span class="s">"</span><span class="se">\x76\x2b\x52\x45\x7d\x51\x15\x42\x4e\x53\x17\x54</span><span class="s">"</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strXor</span><span class="p">):</span>
	<span class="n">flag</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">index</span> <span class="o">^</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
<span class="k">print</span> <span class="n">flag</span>
</code></pre></div></div>
<p>由此得到flag。</p>

<pre><code class="language-flag">cumtctf{X0r_1s_c0mMOn_4nd_n0t_h4rd_r1ght?}
</code></pre>

<h1 id="re0-beginning---100">re0: beginning - 100</h1>

<blockquote>
  <p><strong>Watch out the order please.</strong></p>
</blockquote>

<p><code class="highlighter-rouge">VS2012编译 C语言 Release版本 32位</code></p>

<p>这题才算是一个逆向的题目，不过也很简单，平时比赛的话最高50分。
使用IDA分析好了。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_10-52-53.png" alt="re3" /></p>

<p>就主函数中对输入进行了操作，通过上图我们可以看到，当输入字符串长度是36时，将每四个作为一组。高位的作为高位，低位的作为低位。意思就是说，将4个8bit的char变量转成1个32bit的int变量，其中高地址存放高字节，而且左移8位不会影响其低字节，最后和<code class="highlighter-rouge">0x12341234</code>异或，再和flag进行比较。然后我们来查看一下flag变量。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_11-02-52.png" alt="re3" /></p>

<h2 id="解法-2">解法</h2>

<p>知道了过程写脚本就容易了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#coding:utf-8
</span><span class="n">__author__</span><span class="o">=</span><span class="s">'zjgcjy'</span>
<span class="kn">import</span> <span class="nn">binascii</span>

<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x75557E52</span><span class="p">,</span><span class="mh">0x2351454F</span><span class="p">,</span><span class="mh">0x57592257</span><span class="p">,</span><span class="mh">0x4D7B466B</span><span class="p">,</span><span class="mh">0x4D515A40</span><span class="p">,</span><span class="mh">0x77427766</span><span class="p">,</span><span class="mh">0x7C582746</span><span class="p">,</span><span class="mh">0x22434D53</span><span class="p">,</span><span class="mh">0x6F503346</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="s">''</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">a2b_hex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="mh">0x12341234</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="k">print</span> <span class="n">result</span>
</code></pre></div></div>

<p>由此得到flag。</p>

<pre><code class="language-flag">flag{We1c0mE_TO_tHe_Rever5lng_w0r!d}
</code></pre>

<h1 id="stay-in-observation---150">Stay in observation - 150</h1>

<blockquote>
  <p><strong>Well, you ought to be familiar with this language.</strong></p>
</blockquote>

<p><code class="highlighter-rouge">VS2012编译  C# .Net Framework4.0 Release版本 64位</code></p>

<p>这是一道.Net逆向，考虑到很多同学没有接触过C#，所以我给了150分，其实和Java是差不多的，一个是CLR，一个是JVM。其中的算法也很简单，我没用加壳进行保护，所以用.Net的工具就能直接看到源码了，甚至能动态调试。做出来这道题目的同学主要的思路有2种，和我预想的差不多。</p>

<ul>
  <li>使用动态调试，获取鼠标的位置，根据题目手动修改，之后自动解密出flag。</li>
  <li>不用动态调试，直接看后面的解密代码，发现是AES，写脚本解出flag。</li>
  <li>既使用调试，同时又跟踪AES，最后发现，flag被自动解出来了。WoW!</li>
</ul>

<h2 id="解法-3">解法</h2>

<p>调试的方式我就不说了，这里我将一下第二种方式。题目我是用了一张图片，检测鼠标的点击事件，当点击三次后。进行判断，点击的位置和规定的位置是否相同，这里的3个位置是我随机选的，所以用户点击一次就成功的可能性是个极小概率事件，更别说3次了。当判断不同时，直接弹框失败，否则进入MIX类中的Crypt方法进行解密。下面我们来看一下这个MIX类。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_11-28-17.png" alt="re4" /></p>

<p>可以看到，该类中定义了一个计算MD5的方法，和一个解密的方法，当然还有一共byte转string的方法，这里没有列出来。其实这个MD5方法根本没有用到，就是混淆视听用的，而下面的<code class="highlighter-rouge">System.Security.Cryptography.RijndaelManaged</code>类就是Rijndael密码算法，也就是AES。下面直接写脚本解AES就行了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#coding:utf-8
</span><span class="o">@</span><span class="err">需要</span><span class="n">Crypto</span><span class="err">库支持</span>
<span class="n">__author__</span><span class="o">=</span><span class="s">'zjgcjy'</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">IV</span> <span class="o">=</span> <span class="s">"Oityj1sok1yksiWeqtddYQ=="</span>
<span class="n">key</span> <span class="o">=</span> <span class="s">"epWRCdxC79zuea4ZnxEacCMMmIzo0tn/Ah+ENEWOYOY="</span>
<span class="n">c</span> <span class="o">=</span> <span class="s">"NAaswR+u94wyIGDUifYSIfznIt0VXoR/NWoJoSjyWJ0="</span>

<span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">b64decode</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">AES</span><span class="o">.</span><span class="n">MODE_CBC</span><span class="p">,</span> <span class="n">b64decode</span><span class="p">(</span><span class="n">IV</span><span class="p">))</span>
<span class="n">plain</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">b64decode</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

<span class="k">print</span> <span class="n">plain</span>
</code></pre></div></div>

<p>注意该AES有IV，可能是CBC、CFB、OFB三种模式，而在C#中，有IV情况下又未指定模式，一般是指CBC模式，由此得到flag。</p>

<pre><code class="language-flag">flag{reVer5e_1n_C5harP_or_ae5}
</code></pre>

<h1 id="shuttle---200">Shuttle - 200</h1>

<blockquote>
  <p><strong>Randomization is not terrible, trust me.</strong></p>
</blockquote>

<p><code class="highlighter-rouge">VS2012编译 C语言 Release版本 32位</code></p>

<p>C语言写的控制台程序，直接用IDA吧，打开后主函数流程如下。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_12-35-13.png" alt="re5" /></p>

<p>先输入字符串，没什么好说的，但是看下面。很明显，这里用了<code class="highlighter-rouge">rand</code>函数，同时加入了时间作为种子，产生4个伪随机数作为密钥<code class="highlighter-rouge">key</code>。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_12-35-38.png" alt="re5" /></p>

<p>再来看接下来的步骤，用随机的key当作密钥流和数组进行异或，最后和<code class="highlighter-rouge">flag</code>进行比较，若相等则Congratulations。
所以我们要做的就是爆破一个4字节的key，然后和原始数组进行亦或，最后得到一个有意义的字符串。脚本如下。</p>

<h2 id="解法-4">解法</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># coding:utf-8
</span><span class="n">__author__</span><span class="o">=</span><span class="s">'zjgcjy'</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="n">its</span>
<span class="c1">#[0-9a-zA-Z_]{23,}
</span><span class="n">words</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">lowercase</span>
<span class="n">table</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x33</span><span class="p">,</span><span class="mh">0x11</span><span class="p">,</span><span class="mh">0x1a</span><span class="p">,</span><span class="mh">0x1c</span><span class="p">,</span><span class="mh">0x2e</span><span class="p">,</span><span class="mh">0x1d</span><span class="p">,</span><span class="mh">0x2b</span><span class="p">,</span><span class="mh">0x49</span><span class="p">,</span><span class="mh">0x12</span><span class="p">,</span><span class="mh">0x2f</span><span class="p">,</span><span class="mh">0x1</span><span class="p">,</span><span class="mh">0x4d</span><span class="p">,</span><span class="mh">0x4</span><span class="p">,</span><span class="mh">0x1c</span><span class="p">,</span><span class="mh">0x11</span><span class="p">,</span><span class="mh">0x2b</span><span class="p">,</span><span class="mh">0x12</span><span class="p">,</span><span class="mh">0x2f</span><span class="p">,</span><span class="mh">0x3d</span><span class="p">,</span><span class="mh">0xb</span><span class="p">,</span><span class="mh">0x8</span><span class="p">,</span><span class="mh">0x4</span><span class="p">,</span><span class="mh">0x2b</span><span class="p">,</span><span class="mh">0x47</span><span class="p">]</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">its</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">words</span><span class="p">,</span><span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
	<span class="n">key</span> <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	<span class="n">flag</span> <span class="o">=</span><span class="s">""</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="p">)):</span>
		<span class="n">flag</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="nb">ord</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="p">]))</span>
	<span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">'[0-9a-zA-Z_?]{24,}'</span><span class="p">,</span><span class="n">flag</span><span class="p">)</span> <span class="ow">and</span> <span class="n">flag</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">'_'</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
		<span class="k">print</span> <span class="n">key</span><span class="p">,</span><span class="n">flag</span>
</code></pre></div></div>

<p>有几点需要注意。</p>

<ul>
  <li>key一般是可见字符，而后期我放了提示说key是字母，这里爆破的范围可以减少，可以分别爆破小写和大写尝试。</li>
  <li>更明显的是，<code class="highlighter-rouge">flag</code>中只会包含数字、大小写字母和以下划线为代表的特殊字符，所以这里可以结合正则表达式求解。</li>
  <li>正则表达式的条件不唯一，这里也需要试多次，一开始可以试<code class="highlighter-rouge">[0-9a-zA-Z_]{23,}</code>，发现最后一位只有<code class="highlighter-rouge">=&gt;?</code>三种情况了，再分别尝试，同时可以结合下划线出现次数来提高效率。</li>
</ul>

<p>最后得到flag如下。</p>

<pre><code class="language-flag">flag{RandOm_1s_u5eleSs_Isit_?}
</code></pre>

<h1 id="symmetric-cipher---250">Symmetric Cipher - 250</h1>

<blockquote>
  <p><strong>Have you ever heard of Microsoft Foundation Classes ?</strong></p>
</blockquote>

<p><code class="highlighter-rouge">VS2017编译 MFC 静态链接 Release版本 32位</code></p>

<p>这道题是一个MFC的程序，由于是静态链接，程序体积很大，有3MB多。在如此大量的代码下能找到关键的Check函数是比较重要的。
这里我贴上关于MFC如何交叉应用查找控件ID的方法，也是由唐师傅在暑假培训的时候讲过的内容。想要深入的同学需要自己学习了，这里我就详细讲了。</p>

<p><a href="http://blog.csdn.net/SilverMagic/article/details/40621107">基于MFC的教程1</a>
<a href="http://blog.csdn.net/SilverMagic/article/details/40622413">基于MFC的教程2</a>
<a href="http://blog.csdn.net/SilverMagic/article/details/40623299">基于MFC的教程3</a></p>

<h2 id="解法-5">解法</h2>

<p>现在我们打开IDA，追踪到该关键函数。IDA自动生成的<code class="highlighter-rouge">sub_402510</code>函数则是<code class="highlighter-rouge">确定</code>按钮点击的消息处理，但是一开始<code class="highlighter-rouge">确定</code>按钮是点击不了的，原因是长度不满足条件，具体的条件则在<code class="highlighter-rouge">sub_4024C0</code>中，如下图所示。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_16-07-52.png" alt="re6" /></p>

<p>也就是说，当输入字符串长度是30的时候，<code class="highlighter-rouge">确定</code>按钮将被激活，即flag长度是30。</p>

<p>所以现在我们再来看<code class="highlighter-rouge">sub_402510</code>函数的流程。如下图所示。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_16-13-20.png" alt="re6" /></p>

<p>可以看到，点击<code class="highlighter-rouge">确定</code>后，首先进行反调试，若程序正在被调试，则直接退出。</p>

<pre><code class="language-asm">mov     ebx, large fs:30h
mov     eax, [ebx+68h]
cmp     eax, 70h
</code></pre>

<p>关于该反调试的原理，很简单。相当于是自己实现简单的反调试检测，和微软的API接口<code class="highlighter-rouge">IsDebuggerPresent()</code>有点不同的是：<code class="highlighter-rouge">IsDebuggerPresent()</code>是通过访问程序PEB的<code class="highlighter-rouge">BeingDebugged</code>标志检测反调试。而该段汇编是通过检测<code class="highlighter-rouge">NTGlobalFlag</code>，是PEB结构偏移量0x68处的一个未公开位置，该位置决定了程序在调试和正常情况下不同的创建内存堆的方式。如果是0x70，则程序正在被调试。要跳过的方式很简单，直接nop判断方法或者改跳转(汇编模式下操作)。当然这个题我不是考大家这个的。我们直接进入<code class="highlighter-rouge">Check</code>函数好了。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_16-37-39.png" alt="re6" /></p>

<p>有点基础的同学进入这个函数就能发现下面会有一个rc4的加密。而密钥流由<code class="highlighter-rouge">National_Basketball_Association</code>来生成。这里我就不多说了，上面的截图是rc4的KSA函数，先将密钥流初始化，再进行混乱。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_16-42-45.png" alt="re6" /></p>

<p>接下来就是rc4的第二部分，伪随机生成密钥流并和字符串进行异或，得到密文。如上图所示。之后的代码就是比较了，这里不多说了。
由于rc4加密和解密是同一个函数，解密时，我们只需要将密文通过同一个key即可恢复得到明文了。下面是程序中的常量字符串，可能有童鞋没找到，我这里列出来了。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_13-38-49.png" alt="re6" /></p>

<p>这里我直接引用Orzk队的脚本了，也可以自己写，不是很难。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_16-59-20.png" alt="re6" /></p>

<p>最后得到flag如下。</p>

<pre><code class="language-flag">cumtctf{Mfc_1s_VerY_difflcUIt}
</code></pre>

<h1 id="windows-cracker---300">Windows Cracker - 300</h1>

<blockquote>
  <p><strong>Would you want to be a Windows craker ? Try your best !!!</strong></p>
</blockquote>

<p><code class="highlighter-rouge">VS2012编译 Windows 动态链接 Release版本 32位</code></p>

<p>最后一题是一个Windows下的GUI程序，程序本身很简单，就是弹出一个对话框，根据输入计算flag。主要还是找到Check函数，但是这个程序本身很小，你也可以一个一个找，很快也能找到-_-。关于Win32程序是如何加载的，推荐大家看windows系列的书籍，里面会详细讲。我简单说明一下。首先看一下程序中所有的字符串常量，相关的函数也可以在这里查找交叉引用。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_17-54-06.png" alt="re7" /></p>

<p>其次我们从主函数开始分析。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_17-03-13.png" alt="re7" /></p>

<p>要注意，GUI程序是从WinMain开始的，首先是定义注册窗口类并调用<code class="highlighter-rouge">RegisterClassW()</code>，其次就可以依据该窗口类来创建窗口，调用<code class="highlighter-rouge">CreateWindowExW()</code>，之后开始进入整个消息循环中，进行消息的分发与更新。而整个框架中最重要的是注册窗口类的回调函数，也就是窗口过程。他是<code class="highlighter-rouge">tagWNDCLASSW</code>结构体中的<code class="highlighter-rouge">lpfnWndProc</code>，函数类型为<code class="highlighter-rouge">WNDPROC </code>。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_17-56-06.png" alt="re7" /></p>

<p>窗口过程的参数与分别是窗口句柄，消息标识符，2个DWORD的消息参数。在这个程序中，窗口过程首先接受<code class="highlighter-rouge">WM_CREATE</code>消息，进行窗口控件的创建，即上图中的<code class="highlighter-rouge">case 1</code>的情况，创建了一个文本框和一个确定按钮。对于确定按钮，定义了HMENU参数是250。控件ID和HMENU是共用的，当作为子窗口时，往往不需要菜单，该值用来区分控件。而对于接受到的按钮子窗口的<code class="highlighter-rouge">WM_COMMAND</code>消息，<code class="highlighter-rouge">wParam</code>参数的低位是子窗口ID，高位是消息，lParam参数是接收消息的子窗口的句柄。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_17-58-26.png" alt="re7" /></p>

<p>一句话，也就是说在点击按钮后，产生<code class="highlighter-rouge">wParam</code>消息的低位是250，直接进入<code class="highlighter-rouge">sub_401350()</code>函数中进行判断。下面我们来看一下这个函数。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_18-22-26.png" alt="re7" /></p>

<p>可以看到，直接调用<code class="highlighter-rouge">GetWindowTextA()</code>API来判断输入长度，当输入长度不是41的时候，直接通过<code class="highlighter-rouge">SendMessageW()</code>向窗口过程发送消息，且<code class="highlighter-rouge">wParam</code>参数是1111，我们回到窗口过程可以看到，此时会直接调用<code class="highlighter-rouge">MessageBoxW(hWnd, L"flag错误", L"FAIL", 0x40u)</code>即弹框，flag错误。所以我们可以确定flag长度就是41。接下来进入核心的Check函数验证算法。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_18-30-49.png" alt="re7" /></p>

<p>看着很简单，其实不然。其中的<code class="highlighter-rouge">loc_401050</code>是一大段汇编，由于IDA反汇编插件出错，是需要看汇编的。</p>

<p><strong>这种情况经常会有，请大家习惯看汇编，而且F5经常会出错</strong></p>

<p>当然这题是我手动造成的情况，由于IDA采用了递归下降的扫描方式，想要让其出错并不难。请大家自己移步到链接。</p>

<p><a href="http://blog.csdn.net/breaksoftware/article/details/7893422">线性扫描算法分析</a>
<a href="http://blog.csdn.net/breaksoftware/article/details/7893871">递归下降算法分析</a></p>

<p>知道了这些后，直接nop部分指令就行了。出错的位置是<code class="highlighter-rouge">.text:00401050</code>和<code class="highlighter-rouge">.text:004010B6</code>，之后需要手动建立函数。最后函数流程如下图所示。发现就是不停的取第二个参数的2个值，然后相加放在第一个参数列表中。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_18-53-20.png" alt="re7" /></p>

<p>下面我们重新回到Check函数，重新反编译，如下图所示。</p>

<p><img src="/img/2018-08/Snipaste_2018-01-15_18-54-24.png" alt="re7" /></p>

<p>第一步，进入第一个函数<code class="highlighter-rouge">sub_401000</code>分析。这里我就不贴图了，这个函数没有什么实质的作用，就是把原来的字符串进行打乱，类似于第二个密钥是0的仿射密码，左右两端同时进行。<strong>cinShuttle[(i * 33) % 41] = cin[(i * 23) % 41]</strong>
打乱后进入第二个函数，而第二个函数就是不停的相加，就结束了。最后是用<code class="highlighter-rouge">strcmp</code>和flag进行对比。</p>

<h2 id="解法-6">解法</h2>

<p>既然核心的算法都求出来了，逆向就变得比较简单了，所以我们就是要先逆向<code class="highlighter-rouge">sub_401050()</code>这个函数，之后再将顺序还原。</p>

<ul>
  <li>第二个函数创建了41个加法等式，就构成了一个41元一次方程组，且线性无关，只有唯一解。只需要解方程即可。</li>
  <li>第一个函数的逆向，如果看出来是单表代换密码，直接求33模41的逆元和23模41的逆元，即可还原明文。
    <ul>
      <li>如果看不懂移位怎么逆向，直接输入有序数组，动态调试，打印出结果，构建一一映射关系。</li>
      <li>如果即看不懂，也不会动态调试，那就直接爆破，在不考虑逆元是否存在的条件下，也只需要爆破41*41次。</li>
    </ul>
  </li>
</ul>

<p>下面贴出我的解法，这里解41元方程组使用python的z3库来求解，当然同样可以使用Mathematica，或者python的numpy库来求解。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#coding:utf-8
</span><span class="n">__author__</span><span class="o">=</span><span class="s">'zjgcjy'</span>
<span class="kn">import</span> <span class="nn">binascii</span>
<span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">():</span>
	<span class="n">res</span> <span class="o">=</span> <span class="s">''</span>
	<span class="n">cipher</span> <span class="o">=</span> <span class="s">"97b1c8cdd5d29694b8b4c5daa471718fbe94a4d0def3d5d4d4c4d9e5c1c4d5daf4e7c1bed7c196646a"</span>
	<span class="n">mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">Int</span><span class="p">(</span><span class="s">'mat</span><span class="si">%</span><span class="s">d'</span><span class="o">%</span> <span class="n">i</span><span class="p">)</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">41</span><span class="p">)]</span>
	<span class="n">auth</span> <span class="o">=</span> <span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">binascii</span><span class="o">.</span><span class="n">a2b_hex</span><span class="p">(</span><span class="n">cipher</span><span class="p">)]</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
	<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">And</span><span class="p">(</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">24</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">34</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">34</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">27</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">20</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">37</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">37</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">30</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">23</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">40</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">33</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">26</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">19</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">36</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">29</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">22</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">39</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">18</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">35</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">35</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">34</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">28</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">35</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">21</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">37</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">38</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">38</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">38</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">31</span><span class="p">],</span>
		<span class="n">auth</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">==</span> <span class="n">mat</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">7</span><span class="p">],))</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">41</span><span class="p">):</span>
		<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mh">0x20</span><span class="p">)</span>
		<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x80</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">):</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">41</span><span class="p">):</span>
			<span class="n">res</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">as_long</span><span class="p">())</span>
	<span class="k">print</span> <span class="n">res</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
	<span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>通过z3求解出结果是<code class="highlighter-rouge">cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA</code>。再求出33和23模41的逆元分别是5和-16，还原即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decode</span><span class="p">():</span>
	<span class="n">mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">41</span><span class="p">)]</span>
	<span class="n">str1</span> <span class="o">=</span> <span class="s">r'''cao1iutIP_mlv_Ct0eyacn_0Nt5eU_f!q_h{}USeA'''</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">41</span><span class="p">):</span>
		<span class="n">mat</span><span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">41</span><span class="p">]</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">))</span> <span class="o">%</span> <span class="mi">41</span><span class="p">]</span>
	<span class="k">print</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
</code></pre></div></div>

<p>最后得到flag。</p>

<pre><code class="language-flag">cumtctf{Ai_CaN_he1P_y0U_SoIve_eqUatl0n5!}
</code></pre>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#writeup" class="page__taxonomy-item" rel="tag">writeup</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fa fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2018-08-15T05:43:00+08:00">August 15, 2018</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=2018cumtctf%E9%80%86%E5%90%91%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF%20https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2018-08%2F2018cumtctf%25E9%2580%2586%25E5%2590%2591%25E5%2587%25BA%25E9%25A2%2598%25E6%2580%259D%25E8%25B7%25AF.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fa fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2018-08%2F2018cumtctf%25E9%2580%2586%25E5%2590%2591%25E5%2587%25BA%25E9%25A2%2598%25E6%2580%259D%25E8%25B7%25AF.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fa fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2018-08%2F2018cumtctf%25E9%2580%2586%25E5%2590%2591%25E5%2587%25BA%25E9%25A2%2598%25E6%2580%259D%25E8%25B7%25AF.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2018-08/IDApython%E5%AE%9E%E7%8E%B0dump%E5%BE%AE%E4%BF%A1GIF%E8%A1%A8%E6%83%85%E5%8C%85.html" class="pagination--pager" title="Idapython实现dump微信gif表情包
">Previous</a>
    
    
      <a href="/posts/2018-08/2017cumtctf%E5%86%B3%E8%B5%9B-writeup.html" class="pagination--pager" title="2017cumtctf决赛 Writeup
">Next</a>
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">Leave a comment</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-12/diary_notes.html" rel="permalink">Diary_notes
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  最近很浮躁，日记好久没写了，书也没看，论文也没看，运动也是断断续续。


12月5日

打算重新开blog，找了很久，从stackedit到blogger，从hexo到wordpress再到jekyll。因为图片的缘故，还在vps上搭了rclone来同步onedrive当图床用，后来又用git repo来当...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-11/Dirary_November.html" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-github-square" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fa fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fa fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/1d25d6ba93.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <div id="disqus_thread"></div>
  <script>
    /**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
    */
    /*
    var disqus_config = function () {
      this.page.url = "https://zjgcjy.github.io/posts/2018-08/2018cumtctf%E9%80%86%E5%90%91%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2018-08/2018cumtctf逆向出题思路"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
