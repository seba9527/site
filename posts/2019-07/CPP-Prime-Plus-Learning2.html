<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Cpp Prime Plus Learning2  -  My way, though far away</title>
<meta name="description" content="  C++ Prime Plus 读书笔记2第4章到第6章 包括复杂数据格式，循环以及条件结构数组sizeof返回的是对象的大小。使用sizeof(array)/sizeof(int)可以求数组大小。可以使用初始化列表对变量进行初始化，不设置的元素默认值是0。当然STL提供的vectror和C++11提供的Array更好用。字符串字符串主要通过字符数组或者string类进行存储。字符数组以空字符结尾，所以长度比设置的长度小1。直接使用双引号对字符数组进行初始化的字符串称为字符串常量。需要注意的是：字符串这个整体表示的是字符串的所在地址char a = &#39;s&#39;; //字符char a[] = &quot;s&quot;; //字符串字符串输入的问题用到了cin对象的2个方法，getline和get。都是读取一行，但是getline会丢弃换行符，get将保留换行符。getline的方法是cin.getline(array, len)，而get因为保留换行符，所以第二次输入会有换行符，这里需要处理。通常的方法是cin.get(array, len).get()因为get返回的还是一个cin对象。getline也是一样，可以通过连续调用来接受2个数组cin.getline(array1, len1).getline(array2, len2)。用get对程序的输入更方便处理，而getline则使用更简单。关于读取空行的读取过多的数据，getline和get的情况不太同。空行：getline读取换行符给目标数组。空行：get读取设置失效位，后续读取将关闭，需要通过cin.clear()开启过长：getline保留输入序列，设置失效位，关闭输入过长：get也保留输入序列，下一次继续读取。string类使用初始化列表进行初始化。string p{&quot;fsdfsd&quot;}对于string类来说，如果需要读取一行，使用istream的类方法，即getline(cin, str)//各种变量初始化方法char p[]{&quot;sdfsdfsdf&quot;};string aa{&quot;dfsdf&quot;};wchar_t a[]{L&quot;aerwere&quot;};char16_t b[]{u&quot;basdfsd&quot;};char32_t c[]{U&quot;cwgwe&quot;};关于原始字符串，这种字符串中不考虑转义字符的问题。用R前缀和小括号来表示，如果需要表示括号，可以自定义标识符，R可以和u、L等一起使用。// 使用*+*记号来标记char dfsfdd[]{R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;)*+*&quot;};cout&lt;&lt;R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;, she whispered.\n)*+*&quot;&lt;&lt;endl;结构体struct  helloworld{    char  name[10];    int   index;    double grade;}aaa, *pp;    //直接申明变量helloworld x{&quot;dfdsfd&quot;,6,9.9};  //申明变量struct    //匿名结构体{    char  name[20];    int index;}*ppp;结构体允许直接进行成员赋值，应该是设置了对应的复制构造函数。关于结构体数组的初始化方法如下:struct mystruct{    char name[10];    int index;    double grade;}guests[2]{    {&quot;chen&quot;, 1, 95.5},    {&quot;dong&quot;, 2, 2.6},};结构体中的位字段这个结构说明的比较少，C++允许指定占用特有位数的结构成员，字段的类型为整形或枚举，然后是冒号，后面是数字指定了占用的位数。可以使用没有名称的字段来提供占位符。每个成员被称为位字段。struct{    unsigned int SN : 4;    unsigned int : 4; //占位符    bool good1 : 1;    bool good2 : 1;}tr{14,true,false};共用体共用体的长度是最大成员的长度。通常设置匿名共用体，结合结构体来表示一些特殊数据。struct widget{    char baudrate[10];    int type;    union {    // 匿名共用体，可以通过test.id_num直接访问对应的变量        long id_num;        char id[20];    };} test;枚举枚举的关键词是enum，这能创建符号常量。枚举值能参与算术运算，但所有的值会进行整形提升，转换成int值，且不能给enum赋值，但可以通过强制类型转换进行赋值。enum    //匿名枚举变量{    red = 1,    orange = 5,    green = 8,    blue = 200,    indigo = 200,    puple = 201,    black = 300}test; //可以不指定变量，即只创建符号常量，相当于const通过强制类型转换，可以将任意值赋值给枚举变量，但是是有范围的，枚举的取值范围取决于已经初始化的值的范围，最大值是大于当前最大值的最小的2的次方减1。最小值如果初始化的值都非负，则是0，否则是小于当前最小值的最小的2的次方加1。指针int* p = (int*)0x12345678;//强制指向特定地址数组名等价于数组的首地址。指针可以加减，但是数组名不行。关于数组的地址，表述如下数组名表示的是一个元素占内存的地址，数组取地址表示的是整个数组占内存块的大小。所以p是一个整形的指针，而&amp;p是这样这个指针，即指向一个包含n个元素的int数组。int p[] = {1, 2, 3, 4, 5, 6};cout &lt;&lt; p &lt;&lt; endl;//和&amp;p[0]等价，表示第一个元素的地址cout &lt;&lt; &amp;p &lt;&lt; endl;//整个数组的地址cout &lt;&lt; p +  1  &lt;&lt; endl;//下一个元素cout &lt;&lt;  &amp;p +  1  &lt;&lt; endl;//数组结束地址int(*pp)[6] =  &amp;p;//创建一个指向6个int元素的指针cout &lt;&lt; pp &lt;&lt; endl;//整个数组大小，和&amp;p等价cout &lt;&lt;  *pp &lt;&lt; endl;//整个数组中第一个元素的地址。和p以及&amp;p[0]等价cout &lt;&lt;  **pp &lt;&lt; endl;//第一个元素cout &lt;&lt; (*pp) +  1  &lt;&lt; endl;//第二个元素的地址，和&amp;p[1]等价cout &lt;&lt;  *((*pp) +  1) &lt;&lt; endl;//第二个元素的值上面这几行反汇编的结果如下所示。伪代码很奇怪。直接上汇编代码。直接看汇编的话就会发现，前面2个是一样的。即pp和&amp;pp，在实现是一样的。第三个多了一行mov指令，mov     eax, [rax]所以是第一个元素。第四个多了一行add     rax, 4，所以是取第二个元素的地址。第五个则是多了上面两行，所以是第二个元素。类型组合主要是指针数组比较难理解。指针数组是数组，每一个成员都是指针，可以创建一个二级指针指向该数组可以采用auto类型自动判断类型。// 结构体数组helloworld p1[]{s1, s2, s3};// 结构体数组访问方式p1[0].year;(*(p1 + 1)).year;// 指针数组，指向结构体的指针helloworld *p2[]{&amp;s1, &amp;s2, &amp;s3};//指针数组访问方式p2[0]-&gt;year;(*(p2 + 1))-&gt;year;(**(p2 + 1)).year;//二级指针，指向指针数组auto p3{p2};//二级指针访问方式(*p3 + 1)-&gt;year;//*p3表示第一个元素，同时也是指针，先解引用，得到的是&amp;s1，但是+1得到的不一定是下一个元素地址，可能不连续(*(*p3 + 1)).year;(*(p3 + 1))-&gt;year;//p3表示&amp;p2的地址，先+1得到的是下一个元素的地址，然后解引用得到结构体地址，是正确的访问思路(*(*(p3 + 1))).year;//*(*p4)[3]类型指针，指向整个指针数组auto p4{&amp;p2};cout &lt;&lt; p4 &lt;&lt; endl;//和&amp;p2等价，整个指针数组的地址，是一个整体cout &lt;&lt; *p4 + 1 &lt;&lt; endl;//先解引用，和p2以及&amp;p2[0]等价，数组首地址，+1得到第二个元素地址cout &lt;&lt; *(*p4 + 1) &lt;&lt; endl;//再一次解引用，得到第二个元素的值，就是&amp;s2的值cout &lt;&lt; (*(*p4 + 1))-&gt;year &lt;&lt; endl;//访问结构体的值正确的二级指针访问的汇编代码如下所示：mov     rax, [rbp+p1]add     rax, 8mov     rax, [rax]mov     eax, [rax+8]数组模板主要是vector和array两个模板类，都定义在std命名空间中，使用需要包含相应头文件。vector存储在heap，大小可变。array存储在stack，大小不可变。array对象可以直接进行对象赋值。使用at方法可以检查index是否越界。vector&lt;int&gt; vt{5, 4, 3, 2, 1};//vector&lt;int&gt; vt(5);array&lt;int, 5&gt; ai{1, 2, 3, 4, 5};for循环结构for循环的组成部分。  设置初始值。  执行测试条件，判断循环是否继续。  执行循环操作。  更新值。声明语句表达式，关于这个概念，是指在for循环的初始化部分可以是表达式语句，也可以是声明。前缀和后缀前缀表达式的效率比后缀表达式的效率高因为前缀函数直接运算后返回结果。而后缀首先复制一个副本，然后计算表达式，最后返回副本。如果递增运算符和指针结合，需要考虑到运算符的优先级和结合顺序。前缀运算符和解引用优先级相同，从右向左结合；后缀运算符优先级更高，从左向右结合。关于逗号表达式：逗号表达式首先计算第一个表达式，然后计算第二个表达式。整个逗号表达式的值是最后部分的值。cata = 17, 140;//等价于(cata = 17) , 140; cata值为17cata = (17, 140);//括号优先级最高，cata值为140关于延时循环，使用clock函数，直接贴代码。//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;using namespace std;int main(){    float secs{5.0};    clock_t delay = secs * CLOCKS_PER_SEC;// 将延时秒数乘以宏，得到以系统时间为单位的时间    cout &lt;&lt; &quot;starting!&quot; &lt;&lt; endl;    clock_t start = clock();//返回的是系统时间    while (clock() - start &lt; delay);//死循环延时    cout &lt;&lt; &quot;done&quot; &lt;&lt; endl;    return 0;}别名C++使用两种方式定义别名。分别是预处理器和typedef关键字。尽量用typedef，预处理器错误太多了。#define  BYTE1 chartypedef char byte1, *charptr;C++11循环for (auto i : {4.99, 10.99, 6.87, 7.99, 8.49})//或者用引用类型，可以修改变量的值  cout &lt;&lt; i &lt;&lt; endl;循环和文本输入文件尾条件，称为EOF，操作系统都支持重定向，允许用文件替换键盘输入。比如get.exe &lt; test.txt可以将文件输入至该程序中。小于号是重定向运算符。cin对象在检测到EOF之后，设置eofbit和failbit为true。可以通过对应的成员函数cin.eof()和cin.fail()查看。所以在循环输入的时候，可以通过这个方法检测输入是否完成，这是常规的做法。char ch;cin.get(ch);while(cin.fail() == false)// 常见的做法{  cin.get(ch);}while(cin.get(ch)) // 更有效的做法{  }第二种如代码所示，istream类提供了一个istream对象转换成bool类型的函数，即cin可以作为while的测试条件，这比检测fail更有效，因为能检测磁盘故障等问题。鉴于get方法返回的还是cin对象，所以可以直接精简成上面的测试条件。cin.get()和cout.put()，以及getchar()和putchar()类似。在iostream中，EOF被定义为-1。可以使用cin.get()和cout.put()代替上面的函数，然后用EOF代替cin.fail()。注意cin.get()返回的是int类型的值，不是char。后面输出的时候也要强制转换。// 普通版本，g++编译其实没问题int ch;ch = cin.get();while(ch != EOF){  cout.put(ch);  ch = cin.get();}// 更好的版本int ch;while ((ch =  cin.get()) != EOF){  cout.put(char(ch));}主要是因为两套不一样的函数，分别是cin.get(ch)和cin.get()。cin.get(ch)返回的是istream对象，即cin，可以连续读取。而cin.get()返回的是int类型的值。嵌套循环和二维数组int  maxtmps[2][3]{    {96, 13, 58},    {23, 684, 83}};初始化方式如上所示。分支语句取反运算符的优先级高于所有关系运算符和算术运算符。逻辑与运算符优先级高于逻辑或运算符。C++保留了and、or和not关键字。cctype引入头文件cctype。其中_ISbit宏如下。# define _ISbit(bit) ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8))读取数字如果没有正确读取到数字，变量的值将不变，输入将保留在输入流中，cin将设置错误标记，同时返回false。后续需要使用clear()方法重置错误标记。常见的做法是while(cin&gt;&gt;x)通过cin对象判断输入是否成功，失败则退出，否则继续。如果失败还需要继续读取，则需要重置，设置cin.clear()来接受新的输入，然后删除错误的输入序列，再进行新的输入。int x;while (!(cin &gt;&gt; x))//判断读取是否成功{    cin.clear();//重置输入    while (cin.get() != &#39;\n&#39;)//删除输入序列    {        continue;    }    cout &lt;&lt; &quot;please input&quot; &lt;&lt; endl;}文件输入输出这里讨论的主要是文本文件的输出。需要引入头文件fstream和ofstream类的对象，通过open和close方法进行文件输出。最后使用«输出到文件中。输入也是相同的方法，定义ifstream的对象，然后调用方法进行输入。通过good方法，能检测所有的问题，包括磁盘错误，文件受损，读取EOF，类型不匹配等等。#include &lt;fstream&gt;//输出ofstream fout;fout.open(&quot;out.txt&quot;);fout &lt;&lt; endl;fout.close();//输入char cintext[50];ifstream fin;fin.open(&quot;in.txt&quot;);if (!fin.is_open())//判断是否打开成功{    exit(EXIT_FAILURE);}fin &gt;&gt; cintext;fin.getline(cintext, 50);fin.close();//最好的输入检测方式while(fin &gt;&gt; value)//自动调用good方法判断是否成功{  ...}混合输入的时候，cin.getline(array, len)读字符串，cin&gt;&gt;x读数字，然后cin.get()读换行符。">


  <meta name="author" content="zjgcjy">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="My way, though far away">
<meta property="og:title" content="Cpp Prime Plus Learning2">
<meta property="og:url" content="https://zjgcjy.github.io/posts/2019-07/CPP-Prime-Plus-Learning2.html">


  <meta property="og:description" content="  C++ Prime Plus 读书笔记2第4章到第6章 包括复杂数据格式，循环以及条件结构数组sizeof返回的是对象的大小。使用sizeof(array)/sizeof(int)可以求数组大小。可以使用初始化列表对变量进行初始化，不设置的元素默认值是0。当然STL提供的vectror和C++11提供的Array更好用。字符串字符串主要通过字符数组或者string类进行存储。字符数组以空字符结尾，所以长度比设置的长度小1。直接使用双引号对字符数组进行初始化的字符串称为字符串常量。需要注意的是：字符串这个整体表示的是字符串的所在地址char a = &#39;s&#39;; //字符char a[] = &quot;s&quot;; //字符串字符串输入的问题用到了cin对象的2个方法，getline和get。都是读取一行，但是getline会丢弃换行符，get将保留换行符。getline的方法是cin.getline(array, len)，而get因为保留换行符，所以第二次输入会有换行符，这里需要处理。通常的方法是cin.get(array, len).get()因为get返回的还是一个cin对象。getline也是一样，可以通过连续调用来接受2个数组cin.getline(array1, len1).getline(array2, len2)。用get对程序的输入更方便处理，而getline则使用更简单。关于读取空行的读取过多的数据，getline和get的情况不太同。空行：getline读取换行符给目标数组。空行：get读取设置失效位，后续读取将关闭，需要通过cin.clear()开启过长：getline保留输入序列，设置失效位，关闭输入过长：get也保留输入序列，下一次继续读取。string类使用初始化列表进行初始化。string p{&quot;fsdfsd&quot;}对于string类来说，如果需要读取一行，使用istream的类方法，即getline(cin, str)//各种变量初始化方法char p[]{&quot;sdfsdfsdf&quot;};string aa{&quot;dfsdf&quot;};wchar_t a[]{L&quot;aerwere&quot;};char16_t b[]{u&quot;basdfsd&quot;};char32_t c[]{U&quot;cwgwe&quot;};关于原始字符串，这种字符串中不考虑转义字符的问题。用R前缀和小括号来表示，如果需要表示括号，可以自定义标识符，R可以和u、L等一起使用。// 使用*+*记号来标记char dfsfdd[]{R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;)*+*&quot;};cout&lt;&lt;R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;, she whispered.\n)*+*&quot;&lt;&lt;endl;结构体struct  helloworld{    char  name[10];    int   index;    double grade;}aaa, *pp;    //直接申明变量helloworld x{&quot;dfdsfd&quot;,6,9.9};  //申明变量struct    //匿名结构体{    char  name[20];    int index;}*ppp;结构体允许直接进行成员赋值，应该是设置了对应的复制构造函数。关于结构体数组的初始化方法如下:struct mystruct{    char name[10];    int index;    double grade;}guests[2]{    {&quot;chen&quot;, 1, 95.5},    {&quot;dong&quot;, 2, 2.6},};结构体中的位字段这个结构说明的比较少，C++允许指定占用特有位数的结构成员，字段的类型为整形或枚举，然后是冒号，后面是数字指定了占用的位数。可以使用没有名称的字段来提供占位符。每个成员被称为位字段。struct{    unsigned int SN : 4;    unsigned int : 4; //占位符    bool good1 : 1;    bool good2 : 1;}tr{14,true,false};共用体共用体的长度是最大成员的长度。通常设置匿名共用体，结合结构体来表示一些特殊数据。struct widget{    char baudrate[10];    int type;    union {    // 匿名共用体，可以通过test.id_num直接访问对应的变量        long id_num;        char id[20];    };} test;枚举枚举的关键词是enum，这能创建符号常量。枚举值能参与算术运算，但所有的值会进行整形提升，转换成int值，且不能给enum赋值，但可以通过强制类型转换进行赋值。enum    //匿名枚举变量{    red = 1,    orange = 5,    green = 8,    blue = 200,    indigo = 200,    puple = 201,    black = 300}test; //可以不指定变量，即只创建符号常量，相当于const通过强制类型转换，可以将任意值赋值给枚举变量，但是是有范围的，枚举的取值范围取决于已经初始化的值的范围，最大值是大于当前最大值的最小的2的次方减1。最小值如果初始化的值都非负，则是0，否则是小于当前最小值的最小的2的次方加1。指针int* p = (int*)0x12345678;//强制指向特定地址数组名等价于数组的首地址。指针可以加减，但是数组名不行。关于数组的地址，表述如下数组名表示的是一个元素占内存的地址，数组取地址表示的是整个数组占内存块的大小。所以p是一个整形的指针，而&amp;p是这样这个指针，即指向一个包含n个元素的int数组。int p[] = {1, 2, 3, 4, 5, 6};cout &lt;&lt; p &lt;&lt; endl;//和&amp;p[0]等价，表示第一个元素的地址cout &lt;&lt; &amp;p &lt;&lt; endl;//整个数组的地址cout &lt;&lt; p +  1  &lt;&lt; endl;//下一个元素cout &lt;&lt;  &amp;p +  1  &lt;&lt; endl;//数组结束地址int(*pp)[6] =  &amp;p;//创建一个指向6个int元素的指针cout &lt;&lt; pp &lt;&lt; endl;//整个数组大小，和&amp;p等价cout &lt;&lt;  *pp &lt;&lt; endl;//整个数组中第一个元素的地址。和p以及&amp;p[0]等价cout &lt;&lt;  **pp &lt;&lt; endl;//第一个元素cout &lt;&lt; (*pp) +  1  &lt;&lt; endl;//第二个元素的地址，和&amp;p[1]等价cout &lt;&lt;  *((*pp) +  1) &lt;&lt; endl;//第二个元素的值上面这几行反汇编的结果如下所示。伪代码很奇怪。直接上汇编代码。直接看汇编的话就会发现，前面2个是一样的。即pp和&amp;pp，在实现是一样的。第三个多了一行mov指令，mov     eax, [rax]所以是第一个元素。第四个多了一行add     rax, 4，所以是取第二个元素的地址。第五个则是多了上面两行，所以是第二个元素。类型组合主要是指针数组比较难理解。指针数组是数组，每一个成员都是指针，可以创建一个二级指针指向该数组可以采用auto类型自动判断类型。// 结构体数组helloworld p1[]{s1, s2, s3};// 结构体数组访问方式p1[0].year;(*(p1 + 1)).year;// 指针数组，指向结构体的指针helloworld *p2[]{&amp;s1, &amp;s2, &amp;s3};//指针数组访问方式p2[0]-&gt;year;(*(p2 + 1))-&gt;year;(**(p2 + 1)).year;//二级指针，指向指针数组auto p3{p2};//二级指针访问方式(*p3 + 1)-&gt;year;//*p3表示第一个元素，同时也是指针，先解引用，得到的是&amp;s1，但是+1得到的不一定是下一个元素地址，可能不连续(*(*p3 + 1)).year;(*(p3 + 1))-&gt;year;//p3表示&amp;p2的地址，先+1得到的是下一个元素的地址，然后解引用得到结构体地址，是正确的访问思路(*(*(p3 + 1))).year;//*(*p4)[3]类型指针，指向整个指针数组auto p4{&amp;p2};cout &lt;&lt; p4 &lt;&lt; endl;//和&amp;p2等价，整个指针数组的地址，是一个整体cout &lt;&lt; *p4 + 1 &lt;&lt; endl;//先解引用，和p2以及&amp;p2[0]等价，数组首地址，+1得到第二个元素地址cout &lt;&lt; *(*p4 + 1) &lt;&lt; endl;//再一次解引用，得到第二个元素的值，就是&amp;s2的值cout &lt;&lt; (*(*p4 + 1))-&gt;year &lt;&lt; endl;//访问结构体的值正确的二级指针访问的汇编代码如下所示：mov     rax, [rbp+p1]add     rax, 8mov     rax, [rax]mov     eax, [rax+8]数组模板主要是vector和array两个模板类，都定义在std命名空间中，使用需要包含相应头文件。vector存储在heap，大小可变。array存储在stack，大小不可变。array对象可以直接进行对象赋值。使用at方法可以检查index是否越界。vector&lt;int&gt; vt{5, 4, 3, 2, 1};//vector&lt;int&gt; vt(5);array&lt;int, 5&gt; ai{1, 2, 3, 4, 5};for循环结构for循环的组成部分。  设置初始值。  执行测试条件，判断循环是否继续。  执行循环操作。  更新值。声明语句表达式，关于这个概念，是指在for循环的初始化部分可以是表达式语句，也可以是声明。前缀和后缀前缀表达式的效率比后缀表达式的效率高因为前缀函数直接运算后返回结果。而后缀首先复制一个副本，然后计算表达式，最后返回副本。如果递增运算符和指针结合，需要考虑到运算符的优先级和结合顺序。前缀运算符和解引用优先级相同，从右向左结合；后缀运算符优先级更高，从左向右结合。关于逗号表达式：逗号表达式首先计算第一个表达式，然后计算第二个表达式。整个逗号表达式的值是最后部分的值。cata = 17, 140;//等价于(cata = 17) , 140; cata值为17cata = (17, 140);//括号优先级最高，cata值为140关于延时循环，使用clock函数，直接贴代码。//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;using namespace std;int main(){    float secs{5.0};    clock_t delay = secs * CLOCKS_PER_SEC;// 将延时秒数乘以宏，得到以系统时间为单位的时间    cout &lt;&lt; &quot;starting!&quot; &lt;&lt; endl;    clock_t start = clock();//返回的是系统时间    while (clock() - start &lt; delay);//死循环延时    cout &lt;&lt; &quot;done&quot; &lt;&lt; endl;    return 0;}别名C++使用两种方式定义别名。分别是预处理器和typedef关键字。尽量用typedef，预处理器错误太多了。#define  BYTE1 chartypedef char byte1, *charptr;C++11循环for (auto i : {4.99, 10.99, 6.87, 7.99, 8.49})//或者用引用类型，可以修改变量的值  cout &lt;&lt; i &lt;&lt; endl;循环和文本输入文件尾条件，称为EOF，操作系统都支持重定向，允许用文件替换键盘输入。比如get.exe &lt; test.txt可以将文件输入至该程序中。小于号是重定向运算符。cin对象在检测到EOF之后，设置eofbit和failbit为true。可以通过对应的成员函数cin.eof()和cin.fail()查看。所以在循环输入的时候，可以通过这个方法检测输入是否完成，这是常规的做法。char ch;cin.get(ch);while(cin.fail() == false)// 常见的做法{  cin.get(ch);}while(cin.get(ch)) // 更有效的做法{  }第二种如代码所示，istream类提供了一个istream对象转换成bool类型的函数，即cin可以作为while的测试条件，这比检测fail更有效，因为能检测磁盘故障等问题。鉴于get方法返回的还是cin对象，所以可以直接精简成上面的测试条件。cin.get()和cout.put()，以及getchar()和putchar()类似。在iostream中，EOF被定义为-1。可以使用cin.get()和cout.put()代替上面的函数，然后用EOF代替cin.fail()。注意cin.get()返回的是int类型的值，不是char。后面输出的时候也要强制转换。// 普通版本，g++编译其实没问题int ch;ch = cin.get();while(ch != EOF){  cout.put(ch);  ch = cin.get();}// 更好的版本int ch;while ((ch =  cin.get()) != EOF){  cout.put(char(ch));}主要是因为两套不一样的函数，分别是cin.get(ch)和cin.get()。cin.get(ch)返回的是istream对象，即cin，可以连续读取。而cin.get()返回的是int类型的值。嵌套循环和二维数组int  maxtmps[2][3]{    {96, 13, 58},    {23, 684, 83}};初始化方式如上所示。分支语句取反运算符的优先级高于所有关系运算符和算术运算符。逻辑与运算符优先级高于逻辑或运算符。C++保留了and、or和not关键字。cctype引入头文件cctype。其中_ISbit宏如下。# define _ISbit(bit) ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8))读取数字如果没有正确读取到数字，变量的值将不变，输入将保留在输入流中，cin将设置错误标记，同时返回false。后续需要使用clear()方法重置错误标记。常见的做法是while(cin&gt;&gt;x)通过cin对象判断输入是否成功，失败则退出，否则继续。如果失败还需要继续读取，则需要重置，设置cin.clear()来接受新的输入，然后删除错误的输入序列，再进行新的输入。int x;while (!(cin &gt;&gt; x))//判断读取是否成功{    cin.clear();//重置输入    while (cin.get() != &#39;\n&#39;)//删除输入序列    {        continue;    }    cout &lt;&lt; &quot;please input&quot; &lt;&lt; endl;}文件输入输出这里讨论的主要是文本文件的输出。需要引入头文件fstream和ofstream类的对象，通过open和close方法进行文件输出。最后使用«输出到文件中。输入也是相同的方法，定义ifstream的对象，然后调用方法进行输入。通过good方法，能检测所有的问题，包括磁盘错误，文件受损，读取EOF，类型不匹配等等。#include &lt;fstream&gt;//输出ofstream fout;fout.open(&quot;out.txt&quot;);fout &lt;&lt; endl;fout.close();//输入char cintext[50];ifstream fin;fin.open(&quot;in.txt&quot;);if (!fin.is_open())//判断是否打开成功{    exit(EXIT_FAILURE);}fin &gt;&gt; cintext;fin.getline(cintext, 50);fin.close();//最好的输入检测方式while(fin &gt;&gt; value)//自动调用good方法判断是否成功{  ...}混合输入的时候，cin.getline(array, len)读字符串，cin&gt;&gt;x读数字，然后cin.get()读换行符。">



  <meta property="og:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">



  <meta name="twitter:site" content="@zjgcjy">
  <meta name="twitter:title" content="Cpp Prime Plus Learning2">
  <meta name="twitter:description" content="  C++ Prime Plus 读书笔记2第4章到第6章 包括复杂数据格式，循环以及条件结构数组sizeof返回的是对象的大小。使用sizeof(array)/sizeof(int)可以求数组大小。可以使用初始化列表对变量进行初始化，不设置的元素默认值是0。当然STL提供的vectror和C++11提供的Array更好用。字符串字符串主要通过字符数组或者string类进行存储。字符数组以空字符结尾，所以长度比设置的长度小1。直接使用双引号对字符数组进行初始化的字符串称为字符串常量。需要注意的是：字符串这个整体表示的是字符串的所在地址char a = &#39;s&#39;; //字符char a[] = &quot;s&quot;; //字符串字符串输入的问题用到了cin对象的2个方法，getline和get。都是读取一行，但是getline会丢弃换行符，get将保留换行符。getline的方法是cin.getline(array, len)，而get因为保留换行符，所以第二次输入会有换行符，这里需要处理。通常的方法是cin.get(array, len).get()因为get返回的还是一个cin对象。getline也是一样，可以通过连续调用来接受2个数组cin.getline(array1, len1).getline(array2, len2)。用get对程序的输入更方便处理，而getline则使用更简单。关于读取空行的读取过多的数据，getline和get的情况不太同。空行：getline读取换行符给目标数组。空行：get读取设置失效位，后续读取将关闭，需要通过cin.clear()开启过长：getline保留输入序列，设置失效位，关闭输入过长：get也保留输入序列，下一次继续读取。string类使用初始化列表进行初始化。string p{&quot;fsdfsd&quot;}对于string类来说，如果需要读取一行，使用istream的类方法，即getline(cin, str)//各种变量初始化方法char p[]{&quot;sdfsdfsdf&quot;};string aa{&quot;dfsdf&quot;};wchar_t a[]{L&quot;aerwere&quot;};char16_t b[]{u&quot;basdfsd&quot;};char32_t c[]{U&quot;cwgwe&quot;};关于原始字符串，这种字符串中不考虑转义字符的问题。用R前缀和小括号来表示，如果需要表示括号，可以自定义标识符，R可以和u、L等一起使用。// 使用*+*记号来标记char dfsfdd[]{R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;)*+*&quot;};cout&lt;&lt;R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;, she whispered.\n)*+*&quot;&lt;&lt;endl;结构体struct  helloworld{    char  name[10];    int   index;    double grade;}aaa, *pp;    //直接申明变量helloworld x{&quot;dfdsfd&quot;,6,9.9};  //申明变量struct    //匿名结构体{    char  name[20];    int index;}*ppp;结构体允许直接进行成员赋值，应该是设置了对应的复制构造函数。关于结构体数组的初始化方法如下:struct mystruct{    char name[10];    int index;    double grade;}guests[2]{    {&quot;chen&quot;, 1, 95.5},    {&quot;dong&quot;, 2, 2.6},};结构体中的位字段这个结构说明的比较少，C++允许指定占用特有位数的结构成员，字段的类型为整形或枚举，然后是冒号，后面是数字指定了占用的位数。可以使用没有名称的字段来提供占位符。每个成员被称为位字段。struct{    unsigned int SN : 4;    unsigned int : 4; //占位符    bool good1 : 1;    bool good2 : 1;}tr{14,true,false};共用体共用体的长度是最大成员的长度。通常设置匿名共用体，结合结构体来表示一些特殊数据。struct widget{    char baudrate[10];    int type;    union {    // 匿名共用体，可以通过test.id_num直接访问对应的变量        long id_num;        char id[20];    };} test;枚举枚举的关键词是enum，这能创建符号常量。枚举值能参与算术运算，但所有的值会进行整形提升，转换成int值，且不能给enum赋值，但可以通过强制类型转换进行赋值。enum    //匿名枚举变量{    red = 1,    orange = 5,    green = 8,    blue = 200,    indigo = 200,    puple = 201,    black = 300}test; //可以不指定变量，即只创建符号常量，相当于const通过强制类型转换，可以将任意值赋值给枚举变量，但是是有范围的，枚举的取值范围取决于已经初始化的值的范围，最大值是大于当前最大值的最小的2的次方减1。最小值如果初始化的值都非负，则是0，否则是小于当前最小值的最小的2的次方加1。指针int* p = (int*)0x12345678;//强制指向特定地址数组名等价于数组的首地址。指针可以加减，但是数组名不行。关于数组的地址，表述如下数组名表示的是一个元素占内存的地址，数组取地址表示的是整个数组占内存块的大小。所以p是一个整形的指针，而&amp;p是这样这个指针，即指向一个包含n个元素的int数组。int p[] = {1, 2, 3, 4, 5, 6};cout &lt;&lt; p &lt;&lt; endl;//和&amp;p[0]等价，表示第一个元素的地址cout &lt;&lt; &amp;p &lt;&lt; endl;//整个数组的地址cout &lt;&lt; p +  1  &lt;&lt; endl;//下一个元素cout &lt;&lt;  &amp;p +  1  &lt;&lt; endl;//数组结束地址int(*pp)[6] =  &amp;p;//创建一个指向6个int元素的指针cout &lt;&lt; pp &lt;&lt; endl;//整个数组大小，和&amp;p等价cout &lt;&lt;  *pp &lt;&lt; endl;//整个数组中第一个元素的地址。和p以及&amp;p[0]等价cout &lt;&lt;  **pp &lt;&lt; endl;//第一个元素cout &lt;&lt; (*pp) +  1  &lt;&lt; endl;//第二个元素的地址，和&amp;p[1]等价cout &lt;&lt;  *((*pp) +  1) &lt;&lt; endl;//第二个元素的值上面这几行反汇编的结果如下所示。伪代码很奇怪。直接上汇编代码。直接看汇编的话就会发现，前面2个是一样的。即pp和&amp;pp，在实现是一样的。第三个多了一行mov指令，mov     eax, [rax]所以是第一个元素。第四个多了一行add     rax, 4，所以是取第二个元素的地址。第五个则是多了上面两行，所以是第二个元素。类型组合主要是指针数组比较难理解。指针数组是数组，每一个成员都是指针，可以创建一个二级指针指向该数组可以采用auto类型自动判断类型。// 结构体数组helloworld p1[]{s1, s2, s3};// 结构体数组访问方式p1[0].year;(*(p1 + 1)).year;// 指针数组，指向结构体的指针helloworld *p2[]{&amp;s1, &amp;s2, &amp;s3};//指针数组访问方式p2[0]-&gt;year;(*(p2 + 1))-&gt;year;(**(p2 + 1)).year;//二级指针，指向指针数组auto p3{p2};//二级指针访问方式(*p3 + 1)-&gt;year;//*p3表示第一个元素，同时也是指针，先解引用，得到的是&amp;s1，但是+1得到的不一定是下一个元素地址，可能不连续(*(*p3 + 1)).year;(*(p3 + 1))-&gt;year;//p3表示&amp;p2的地址，先+1得到的是下一个元素的地址，然后解引用得到结构体地址，是正确的访问思路(*(*(p3 + 1))).year;//*(*p4)[3]类型指针，指向整个指针数组auto p4{&amp;p2};cout &lt;&lt; p4 &lt;&lt; endl;//和&amp;p2等价，整个指针数组的地址，是一个整体cout &lt;&lt; *p4 + 1 &lt;&lt; endl;//先解引用，和p2以及&amp;p2[0]等价，数组首地址，+1得到第二个元素地址cout &lt;&lt; *(*p4 + 1) &lt;&lt; endl;//再一次解引用，得到第二个元素的值，就是&amp;s2的值cout &lt;&lt; (*(*p4 + 1))-&gt;year &lt;&lt; endl;//访问结构体的值正确的二级指针访问的汇编代码如下所示：mov     rax, [rbp+p1]add     rax, 8mov     rax, [rax]mov     eax, [rax+8]数组模板主要是vector和array两个模板类，都定义在std命名空间中，使用需要包含相应头文件。vector存储在heap，大小可变。array存储在stack，大小不可变。array对象可以直接进行对象赋值。使用at方法可以检查index是否越界。vector&lt;int&gt; vt{5, 4, 3, 2, 1};//vector&lt;int&gt; vt(5);array&lt;int, 5&gt; ai{1, 2, 3, 4, 5};for循环结构for循环的组成部分。  设置初始值。  执行测试条件，判断循环是否继续。  执行循环操作。  更新值。声明语句表达式，关于这个概念，是指在for循环的初始化部分可以是表达式语句，也可以是声明。前缀和后缀前缀表达式的效率比后缀表达式的效率高因为前缀函数直接运算后返回结果。而后缀首先复制一个副本，然后计算表达式，最后返回副本。如果递增运算符和指针结合，需要考虑到运算符的优先级和结合顺序。前缀运算符和解引用优先级相同，从右向左结合；后缀运算符优先级更高，从左向右结合。关于逗号表达式：逗号表达式首先计算第一个表达式，然后计算第二个表达式。整个逗号表达式的值是最后部分的值。cata = 17, 140;//等价于(cata = 17) , 140; cata值为17cata = (17, 140);//括号优先级最高，cata值为140关于延时循环，使用clock函数，直接贴代码。//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;using namespace std;int main(){    float secs{5.0};    clock_t delay = secs * CLOCKS_PER_SEC;// 将延时秒数乘以宏，得到以系统时间为单位的时间    cout &lt;&lt; &quot;starting!&quot; &lt;&lt; endl;    clock_t start = clock();//返回的是系统时间    while (clock() - start &lt; delay);//死循环延时    cout &lt;&lt; &quot;done&quot; &lt;&lt; endl;    return 0;}别名C++使用两种方式定义别名。分别是预处理器和typedef关键字。尽量用typedef，预处理器错误太多了。#define  BYTE1 chartypedef char byte1, *charptr;C++11循环for (auto i : {4.99, 10.99, 6.87, 7.99, 8.49})//或者用引用类型，可以修改变量的值  cout &lt;&lt; i &lt;&lt; endl;循环和文本输入文件尾条件，称为EOF，操作系统都支持重定向，允许用文件替换键盘输入。比如get.exe &lt; test.txt可以将文件输入至该程序中。小于号是重定向运算符。cin对象在检测到EOF之后，设置eofbit和failbit为true。可以通过对应的成员函数cin.eof()和cin.fail()查看。所以在循环输入的时候，可以通过这个方法检测输入是否完成，这是常规的做法。char ch;cin.get(ch);while(cin.fail() == false)// 常见的做法{  cin.get(ch);}while(cin.get(ch)) // 更有效的做法{  }第二种如代码所示，istream类提供了一个istream对象转换成bool类型的函数，即cin可以作为while的测试条件，这比检测fail更有效，因为能检测磁盘故障等问题。鉴于get方法返回的还是cin对象，所以可以直接精简成上面的测试条件。cin.get()和cout.put()，以及getchar()和putchar()类似。在iostream中，EOF被定义为-1。可以使用cin.get()和cout.put()代替上面的函数，然后用EOF代替cin.fail()。注意cin.get()返回的是int类型的值，不是char。后面输出的时候也要强制转换。// 普通版本，g++编译其实没问题int ch;ch = cin.get();while(ch != EOF){  cout.put(ch);  ch = cin.get();}// 更好的版本int ch;while ((ch =  cin.get()) != EOF){  cout.put(char(ch));}主要是因为两套不一样的函数，分别是cin.get(ch)和cin.get()。cin.get(ch)返回的是istream对象，即cin，可以连续读取。而cin.get()返回的是int类型的值。嵌套循环和二维数组int  maxtmps[2][3]{    {96, 13, 58},    {23, 684, 83}};初始化方式如上所示。分支语句取反运算符的优先级高于所有关系运算符和算术运算符。逻辑与运算符优先级高于逻辑或运算符。C++保留了and、or和not关键字。cctype引入头文件cctype。其中_ISbit宏如下。# define _ISbit(bit) ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8))读取数字如果没有正确读取到数字，变量的值将不变，输入将保留在输入流中，cin将设置错误标记，同时返回false。后续需要使用clear()方法重置错误标记。常见的做法是while(cin&gt;&gt;x)通过cin对象判断输入是否成功，失败则退出，否则继续。如果失败还需要继续读取，则需要重置，设置cin.clear()来接受新的输入，然后删除错误的输入序列，再进行新的输入。int x;while (!(cin &gt;&gt; x))//判断读取是否成功{    cin.clear();//重置输入    while (cin.get() != &#39;\n&#39;)//删除输入序列    {        continue;    }    cout &lt;&lt; &quot;please input&quot; &lt;&lt; endl;}文件输入输出这里讨论的主要是文本文件的输出。需要引入头文件fstream和ofstream类的对象，通过open和close方法进行文件输出。最后使用«输出到文件中。输入也是相同的方法，定义ifstream的对象，然后调用方法进行输入。通过good方法，能检测所有的问题，包括磁盘错误，文件受损，读取EOF，类型不匹配等等。#include &lt;fstream&gt;//输出ofstream fout;fout.open(&quot;out.txt&quot;);fout &lt;&lt; endl;fout.close();//输入char cintext[50];ifstream fin;fin.open(&quot;in.txt&quot;);if (!fin.is_open())//判断是否打开成功{    exit(EXIT_FAILURE);}fin &gt;&gt; cintext;fin.getline(cintext, 50);fin.close();//最好的输入检测方式while(fin &gt;&gt; value)//自动调用good方法判断是否成功{  ...}混合输入的时候，cin.getline(array, len)读字符串，cin&gt;&gt;x读数字，然后cin.get()读换行符。">
  <meta name="twitter:url" content="https://zjgcjy.github.io/posts/2019-07/CPP-Prime-Plus-Learning2.html">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://zjgcjy.github.io/assets/images/bio-photo.jpg">
    
  

  



  <meta property="article:published_time" content="2019-07-26T14:30:00+08:00">





  

  


<link rel="canonical" href="https://zjgcjy.github.io/posts/2019-07/CPP-Prime-Plus-Learning2.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Blogger",
      "url": "https://zjgcjy.github.io/",
      "sameAs": ["https://twitter.com/","https://github.com/"]
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="My way, though far away Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/apple-touch-icon.png" alt=""></a>
        
        <a class="site-title" href="/">
          ZJGCJY
          <span class="site-subtitle">My way, though far away</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/year-archive/" >Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/" >Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/" >Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/" >Collections</a>
            </li><li class="masthead__menu-item">
              <a href="/about/" >About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="https://zjgcjy.github.io/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#posts" itemprop="item"><span itemprop="name">Posts</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#2019-07" itemprop="item"><span itemprop="name">2019 07</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">Cpp Prime Plus Learning2</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/me.jpg" alt="zjgcjy" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">zjgcjy</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>IIE UCAS, CTFer, Binarian</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">BeiJing China</span>
        </li>
      

      
        
          
            <li><a href="https://zjgcjy.github.io" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> Website</a></li>
          
        
          
            <li><a href="mailto:zjgcjy@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email</a></li>
          
        
          
            <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Cpp Prime Plus Learning2">
    <meta itemprop="description" content="  C++ Prime Plus 读书笔记2第4章到第6章 包括复杂数据格式，循环以及条件结构数组sizeof返回的是对象的大小。使用sizeof(array)/sizeof(int)可以求数组大小。可以使用初始化列表对变量进行初始化，不设置的元素默认值是0。当然STL提供的vectror和C++11提供的Array更好用。字符串字符串主要通过字符数组或者string类进行存储。字符数组以空字符结尾，所以长度比设置的长度小1。直接使用双引号对字符数组进行初始化的字符串称为字符串常量。需要注意的是：字符串这个整体表示的是字符串的所在地址char a = &#39;s&#39;; //字符char a[] = &quot;s&quot;; //字符串字符串输入的问题用到了cin对象的2个方法，getline和get。都是读取一行，但是getline会丢弃换行符，get将保留换行符。getline的方法是cin.getline(array, len)，而get因为保留换行符，所以第二次输入会有换行符，这里需要处理。通常的方法是cin.get(array, len).get()因为get返回的还是一个cin对象。getline也是一样，可以通过连续调用来接受2个数组cin.getline(array1, len1).getline(array2, len2)。用get对程序的输入更方便处理，而getline则使用更简单。关于读取空行的读取过多的数据，getline和get的情况不太同。空行：getline读取换行符给目标数组。空行：get读取设置失效位，后续读取将关闭，需要通过cin.clear()开启过长：getline保留输入序列，设置失效位，关闭输入过长：get也保留输入序列，下一次继续读取。string类使用初始化列表进行初始化。string p{&quot;fsdfsd&quot;}对于string类来说，如果需要读取一行，使用istream的类方法，即getline(cin, str)//各种变量初始化方法char p[]{&quot;sdfsdfsdf&quot;};string aa{&quot;dfsdf&quot;};wchar_t a[]{L&quot;aerwere&quot;};char16_t b[]{u&quot;basdfsd&quot;};char32_t c[]{U&quot;cwgwe&quot;};关于原始字符串，这种字符串中不考虑转义字符的问题。用R前缀和小括号来表示，如果需要表示括号，可以自定义标识符，R可以和u、L等一起使用。// 使用*+*记号来标记char dfsfdd[]{R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;)*+*&quot;};cout&lt;&lt;R&quot;*+*(&quot;(Who wouldn&#39;t?)&quot;, she whispered.\n)*+*&quot;&lt;&lt;endl;结构体struct  helloworld{    char  name[10];    int   index;    double grade;}aaa, *pp;    //直接申明变量helloworld x{&quot;dfdsfd&quot;,6,9.9};  //申明变量struct    //匿名结构体{    char  name[20];    int index;}*ppp;结构体允许直接进行成员赋值，应该是设置了对应的复制构造函数。关于结构体数组的初始化方法如下:struct mystruct{    char name[10];    int index;    double grade;}guests[2]{    {&quot;chen&quot;, 1, 95.5},    {&quot;dong&quot;, 2, 2.6},};结构体中的位字段这个结构说明的比较少，C++允许指定占用特有位数的结构成员，字段的类型为整形或枚举，然后是冒号，后面是数字指定了占用的位数。可以使用没有名称的字段来提供占位符。每个成员被称为位字段。struct{    unsigned int SN : 4;    unsigned int : 4; //占位符    bool good1 : 1;    bool good2 : 1;}tr{14,true,false};共用体共用体的长度是最大成员的长度。通常设置匿名共用体，结合结构体来表示一些特殊数据。struct widget{    char baudrate[10];    int type;    union {    // 匿名共用体，可以通过test.id_num直接访问对应的变量        long id_num;        char id[20];    };} test;枚举枚举的关键词是enum，这能创建符号常量。枚举值能参与算术运算，但所有的值会进行整形提升，转换成int值，且不能给enum赋值，但可以通过强制类型转换进行赋值。enum    //匿名枚举变量{    red = 1,    orange = 5,    green = 8,    blue = 200,    indigo = 200,    puple = 201,    black = 300}test; //可以不指定变量，即只创建符号常量，相当于const通过强制类型转换，可以将任意值赋值给枚举变量，但是是有范围的，枚举的取值范围取决于已经初始化的值的范围，最大值是大于当前最大值的最小的2的次方减1。最小值如果初始化的值都非负，则是0，否则是小于当前最小值的最小的2的次方加1。指针int* p = (int*)0x12345678;//强制指向特定地址数组名等价于数组的首地址。指针可以加减，但是数组名不行。关于数组的地址，表述如下数组名表示的是一个元素占内存的地址，数组取地址表示的是整个数组占内存块的大小。所以p是一个整形的指针，而&amp;p是这样这个指针，即指向一个包含n个元素的int数组。int p[] = {1, 2, 3, 4, 5, 6};cout &lt;&lt; p &lt;&lt; endl;//和&amp;p[0]等价，表示第一个元素的地址cout &lt;&lt; &amp;p &lt;&lt; endl;//整个数组的地址cout &lt;&lt; p +  1  &lt;&lt; endl;//下一个元素cout &lt;&lt;  &amp;p +  1  &lt;&lt; endl;//数组结束地址int(*pp)[6] =  &amp;p;//创建一个指向6个int元素的指针cout &lt;&lt; pp &lt;&lt; endl;//整个数组大小，和&amp;p等价cout &lt;&lt;  *pp &lt;&lt; endl;//整个数组中第一个元素的地址。和p以及&amp;p[0]等价cout &lt;&lt;  **pp &lt;&lt; endl;//第一个元素cout &lt;&lt; (*pp) +  1  &lt;&lt; endl;//第二个元素的地址，和&amp;p[1]等价cout &lt;&lt;  *((*pp) +  1) &lt;&lt; endl;//第二个元素的值上面这几行反汇编的结果如下所示。伪代码很奇怪。直接上汇编代码。直接看汇编的话就会发现，前面2个是一样的。即pp和&amp;pp，在实现是一样的。第三个多了一行mov指令，mov     eax, [rax]所以是第一个元素。第四个多了一行add     rax, 4，所以是取第二个元素的地址。第五个则是多了上面两行，所以是第二个元素。类型组合主要是指针数组比较难理解。指针数组是数组，每一个成员都是指针，可以创建一个二级指针指向该数组可以采用auto类型自动判断类型。// 结构体数组helloworld p1[]{s1, s2, s3};// 结构体数组访问方式p1[0].year;(*(p1 + 1)).year;// 指针数组，指向结构体的指针helloworld *p2[]{&amp;s1, &amp;s2, &amp;s3};//指针数组访问方式p2[0]-&gt;year;(*(p2 + 1))-&gt;year;(**(p2 + 1)).year;//二级指针，指向指针数组auto p3{p2};//二级指针访问方式(*p3 + 1)-&gt;year;//*p3表示第一个元素，同时也是指针，先解引用，得到的是&amp;s1，但是+1得到的不一定是下一个元素地址，可能不连续(*(*p3 + 1)).year;(*(p3 + 1))-&gt;year;//p3表示&amp;p2的地址，先+1得到的是下一个元素的地址，然后解引用得到结构体地址，是正确的访问思路(*(*(p3 + 1))).year;//*(*p4)[3]类型指针，指向整个指针数组auto p4{&amp;p2};cout &lt;&lt; p4 &lt;&lt; endl;//和&amp;p2等价，整个指针数组的地址，是一个整体cout &lt;&lt; *p4 + 1 &lt;&lt; endl;//先解引用，和p2以及&amp;p2[0]等价，数组首地址，+1得到第二个元素地址cout &lt;&lt; *(*p4 + 1) &lt;&lt; endl;//再一次解引用，得到第二个元素的值，就是&amp;s2的值cout &lt;&lt; (*(*p4 + 1))-&gt;year &lt;&lt; endl;//访问结构体的值正确的二级指针访问的汇编代码如下所示：mov     rax, [rbp+p1]add     rax, 8mov     rax, [rax]mov     eax, [rax+8]数组模板主要是vector和array两个模板类，都定义在std命名空间中，使用需要包含相应头文件。vector存储在heap，大小可变。array存储在stack，大小不可变。array对象可以直接进行对象赋值。使用at方法可以检查index是否越界。vector&lt;int&gt; vt{5, 4, 3, 2, 1};//vector&lt;int&gt; vt(5);array&lt;int, 5&gt; ai{1, 2, 3, 4, 5};for循环结构for循环的组成部分。  设置初始值。  执行测试条件，判断循环是否继续。  执行循环操作。  更新值。声明语句表达式，关于这个概念，是指在for循环的初始化部分可以是表达式语句，也可以是声明。前缀和后缀前缀表达式的效率比后缀表达式的效率高因为前缀函数直接运算后返回结果。而后缀首先复制一个副本，然后计算表达式，最后返回副本。如果递增运算符和指针结合，需要考虑到运算符的优先级和结合顺序。前缀运算符和解引用优先级相同，从右向左结合；后缀运算符优先级更高，从左向右结合。关于逗号表达式：逗号表达式首先计算第一个表达式，然后计算第二个表达式。整个逗号表达式的值是最后部分的值。cata = 17, 140;//等价于(cata = 17) , 140; cata值为17cata = (17, 140);//括号优先级最高，cata值为140关于延时循环，使用clock函数，直接贴代码。//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;using namespace std;int main(){    float secs{5.0};    clock_t delay = secs * CLOCKS_PER_SEC;// 将延时秒数乘以宏，得到以系统时间为单位的时间    cout &lt;&lt; &quot;starting!&quot; &lt;&lt; endl;    clock_t start = clock();//返回的是系统时间    while (clock() - start &lt; delay);//死循环延时    cout &lt;&lt; &quot;done&quot; &lt;&lt; endl;    return 0;}别名C++使用两种方式定义别名。分别是预处理器和typedef关键字。尽量用typedef，预处理器错误太多了。#define  BYTE1 chartypedef char byte1, *charptr;C++11循环for (auto i : {4.99, 10.99, 6.87, 7.99, 8.49})//或者用引用类型，可以修改变量的值  cout &lt;&lt; i &lt;&lt; endl;循环和文本输入文件尾条件，称为EOF，操作系统都支持重定向，允许用文件替换键盘输入。比如get.exe &lt; test.txt可以将文件输入至该程序中。小于号是重定向运算符。cin对象在检测到EOF之后，设置eofbit和failbit为true。可以通过对应的成员函数cin.eof()和cin.fail()查看。所以在循环输入的时候，可以通过这个方法检测输入是否完成，这是常规的做法。char ch;cin.get(ch);while(cin.fail() == false)// 常见的做法{  cin.get(ch);}while(cin.get(ch)) // 更有效的做法{  }第二种如代码所示，istream类提供了一个istream对象转换成bool类型的函数，即cin可以作为while的测试条件，这比检测fail更有效，因为能检测磁盘故障等问题。鉴于get方法返回的还是cin对象，所以可以直接精简成上面的测试条件。cin.get()和cout.put()，以及getchar()和putchar()类似。在iostream中，EOF被定义为-1。可以使用cin.get()和cout.put()代替上面的函数，然后用EOF代替cin.fail()。注意cin.get()返回的是int类型的值，不是char。后面输出的时候也要强制转换。// 普通版本，g++编译其实没问题int ch;ch = cin.get();while(ch != EOF){  cout.put(ch);  ch = cin.get();}// 更好的版本int ch;while ((ch =  cin.get()) != EOF){  cout.put(char(ch));}主要是因为两套不一样的函数，分别是cin.get(ch)和cin.get()。cin.get(ch)返回的是istream对象，即cin，可以连续读取。而cin.get()返回的是int类型的值。嵌套循环和二维数组int  maxtmps[2][3]{    {96, 13, 58},    {23, 684, 83}};初始化方式如上所示。分支语句取反运算符的优先级高于所有关系运算符和算术运算符。逻辑与运算符优先级高于逻辑或运算符。C++保留了and、or和not关键字。cctype引入头文件cctype。其中_ISbit宏如下。# define _ISbit(bit) ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8))读取数字如果没有正确读取到数字，变量的值将不变，输入将保留在输入流中，cin将设置错误标记，同时返回false。后续需要使用clear()方法重置错误标记。常见的做法是while(cin&gt;&gt;x)通过cin对象判断输入是否成功，失败则退出，否则继续。如果失败还需要继续读取，则需要重置，设置cin.clear()来接受新的输入，然后删除错误的输入序列，再进行新的输入。int x;while (!(cin &gt;&gt; x))//判断读取是否成功{    cin.clear();//重置输入    while (cin.get() != &#39;\n&#39;)//删除输入序列    {        continue;    }    cout &lt;&lt; &quot;please input&quot; &lt;&lt; endl;}文件输入输出这里讨论的主要是文本文件的输出。需要引入头文件fstream和ofstream类的对象，通过open和close方法进行文件输出。最后使用«输出到文件中。输入也是相同的方法，定义ifstream的对象，然后调用方法进行输入。通过good方法，能检测所有的问题，包括磁盘错误，文件受损，读取EOF，类型不匹配等等。#include &lt;fstream&gt;//输出ofstream fout;fout.open(&quot;out.txt&quot;);fout &lt;&lt; endl;fout.close();//输入char cintext[50];ifstream fin;fin.open(&quot;in.txt&quot;);if (!fin.is_open())//判断是否打开成功{    exit(EXIT_FAILURE);}fin &gt;&gt; cintext;fin.getline(cintext, 50);fin.close();//最好的输入检测方式while(fin &gt;&gt; value)//自动调用good方法判断是否成功{  ...}混合输入的时候，cin.getline(array, len)读字符串，cin&gt;&gt;x读数字，然后cin.get()读换行符。">
    <meta itemprop="datePublished" content="July 26, 2019">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Cpp Prime Plus Learning2
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  3 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#数组">数组</a></li>
  <li><a href="#字符串">字符串</a>
    <ul>
      <li><a href="#字符串输入的问题">字符串输入的问题</a></li>
      <li><a href="#string类">string类</a></li>
    </ul>
  </li>
  <li><a href="#结构体">结构体</a></li>
  <li><a href="#共用体">共用体</a></li>
  <li><a href="#枚举">枚举</a></li>
  <li><a href="#指针">指针</a></li>
  <li><a href="#类型组合">类型组合</a></li>
  <li><a href="#数组模板">数组模板</a></li>
  <li><a href="#for循环结构">for循环结构</a>
    <ul>
      <li><a href="#前缀和后缀">前缀和后缀</a></li>
      <li><a href="#别名">别名</a></li>
    </ul>
  </li>
  <li><a href="#c11循环">C++11循环</a></li>
  <li><a href="#循环和文本输入">循环和文本输入</a></li>
  <li><a href="#嵌套循环和二维数组">嵌套循环和二维数组</a></li>
  <li><a href="#分支语句">分支语句</a></li>
  <li><a href="#cctype">cctype</a></li>
  <li><a href="#读取数字">读取数字</a></li>
  <li><a href="#文件输入输出">文件输入输出</a></li>
</ul>
            </nav>
          </aside>
        
        <blockquote>
  <p>C++ Prime Plus 读书笔记2
第4章到第6章 包括复杂数据格式，循环以及条件结构</p>
</blockquote>

<hr />

<h1 id="数组">数组</h1>

<p>sizeof返回的是对象的大小。使用<code class="highlighter-rouge">sizeof(array)/sizeof(int)</code>可以求数组大小。可以使用初始化列表对变量进行初始化，不设置的元素默认值是0。
当然STL提供的vectror和C++11提供的Array更好用。</p>

<h1 id="字符串">字符串</h1>

<p>字符串主要通过字符数组或者string类进行存储。字符数组以空字符结尾，所以长度比设置的长度小1。
直接使用双引号对字符数组进行初始化的字符串称为字符串常量。需要注意的是：<strong>字符串这个整体表示的是字符串的所在地址</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'s'</span><span class="p">;</span> <span class="c1">//字符</span>
<span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"s"</span><span class="p">;</span> <span class="c1">//字符串</span>
</code></pre></div></div>

<h2 id="字符串输入的问题">字符串输入的问题</h2>

<p>用到了cin对象的2个方法，getline和get。都是读取一行，但是getline会丢弃换行符，get将保留换行符。getline的方法是<code class="highlighter-rouge">cin.getline(array, len)</code>，而get因为保留换行符，所以第二次输入会有换行符，这里需要处理。通常的方法是<code class="highlighter-rouge">cin.get(array, len).get()</code>因为get返回的还是一个cin对象。getline也是一样，可以通过连续调用来接受2个数组<code class="highlighter-rouge">cin.getline(array1, len1).getline(array2, len2)</code>。</p>

<p>用get对程序的输入更方便处理，而getline则使用更简单。关于读取空行的读取过多的数据，getline和get的情况不太同。
空行：getline读取换行符给目标数组。
空行：get读取设置失效位，后续读取将关闭，需要通过cin.clear()开启
过长：getline保留输入序列，设置失效位，关闭输入
过长：get也保留输入序列，下一次继续读取。</p>

<h2 id="string类">string类</h2>

<p>使用初始化列表进行初始化。<code class="highlighter-rouge">string p{"fsdfsd"}</code>
对于string类来说，如果需要读取一行，使用istream的类方法，即<code class="highlighter-rouge">getline(cin, str)</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//各种变量初始化方法</span>
<span class="kt">char</span> <span class="n">p</span><span class="p">[]{</span><span class="s">"sdfsdfsdf"</span><span class="p">};</span>
<span class="n">string</span> <span class="n">aa</span><span class="p">{</span><span class="s">"dfsdf"</span><span class="p">};</span>
<span class="kt">wchar_t</span> <span class="n">a</span><span class="p">[]{</span><span class="s">L"aerwere"</span><span class="p">};</span>
<span class="kt">char16_t</span> <span class="n">b</span><span class="p">[]{</span><span class="s">u"basdfsd"</span><span class="p">};</span>
<span class="kt">char32_t</span> <span class="n">c</span><span class="p">[]{</span><span class="s">U"cwgwe"</span><span class="p">};</span>
</code></pre></div></div>

<p>关于原始字符串，这种字符串中不考虑转义字符的问题。用R前缀和小括号来表示，如果需要表示括号，可以自定义标识符，R可以和u、L等一起使用。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用*+*记号来标记</span>
<span class="kt">char</span> <span class="n">dfsfdd</span><span class="p">[]{</span><span class="s">R"*+*("(Who wouldn't?)")*+*"</span><span class="p">};</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">R"*+*("(Who wouldn't?)", she whispered.\n)*+*"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="结构体">结构体</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span>  <span class="n">helloworld</span>
<span class="p">{</span>
    <span class="kt">char</span>  <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span>   <span class="n">index</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">grade</span><span class="p">;</span>
<span class="p">}</span><span class="n">aaa</span><span class="p">,</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>    <span class="c1">//直接申明变量</span>

<span class="n">helloworld</span> <span class="n">x</span><span class="p">{</span><span class="s">"dfdsfd"</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mf">9.9</span><span class="p">};</span>  <span class="c1">//申明变量</span>

<span class="k">struct</span>    <span class="c1">//匿名结构体</span>
<span class="p">{</span>
    <span class="kt">char</span>  <span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span><span class="o">*</span><span class="n">ppp</span><span class="p">;</span>
</code></pre></div></div>

<p>结构体允许直接进行成员赋值，应该是设置了对应的复制构造函数。</p>

<p>关于结构体数组的初始化方法如下:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">mystruct</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">grade</span><span class="p">;</span>
<span class="p">}</span><span class="n">guests</span><span class="p">[</span><span class="mi">2</span><span class="p">]{</span>
    <span class="p">{</span><span class="s">"chen"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">95.5</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"dong"</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.6</span><span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>结构体中的位字段</strong>这个结构说明的比较少，C++允许指定占用特有位数的结构成员，字段的类型为整形或枚举，然后是冒号，后面是数字指定了占用的位数。可以使用没有名称的字段来提供占位符。每个成员被称为位字段。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SN</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">//占位符</span>
    <span class="kt">bool</span> <span class="n">good1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">good2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="n">tr</span><span class="p">{</span><span class="mi">14</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="nb">false</span><span class="p">};</span>
</code></pre></div></div>

<h1 id="共用体">共用体</h1>

<p>共用体的长度是最大成员的长度。
通常设置匿名共用体，结合结构体来表示一些特殊数据。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">widget</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">baudrate</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>    <span class="c1">// 匿名共用体，可以通过test.id_num直接访问对应的变量</span>
        <span class="kt">long</span> <span class="n">id_num</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="n">test</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="枚举">枚举</h1>

<p>枚举的关键词是enum，这能创建符号常量。
枚举值能参与算术运算，但所有的值会进行整形提升，转换成int值，且不能给enum赋值，但可以通过强制类型转换进行赋值。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span>    <span class="c1">//匿名枚举变量</span>
<span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">orange</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">green</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">indigo</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">puple</span> <span class="o">=</span> <span class="mi">201</span><span class="p">,</span>
    <span class="n">black</span> <span class="o">=</span> <span class="mi">300</span>
<span class="p">}</span><span class="n">test</span><span class="p">;</span> <span class="c1">//可以不指定变量，即只创建符号常量，相当于const</span>
</code></pre></div></div>

<p>通过强制类型转换，可以将任意值赋值给枚举变量，但是是有范围的，枚举的取值范围取决于已经初始化的值的范围，最大值是大于当前最大值的最小的2的次方减1。最小值如果初始化的值都非负，则是0，否则是小于当前最小值的最小的2的次方加1。</p>

<h1 id="指针">指针</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="mh">0x12345678</span><span class="p">;</span><span class="c1">//强制指向特定地址</span>
</code></pre></div></div>

<p>数组名等价于数组的首地址。指针可以加减，但是数组名不行。
<strong>关于数组的地址，表述如下</strong>数组名表示的是一个元素占内存的地址，数组取地址表示的是整个数组占内存块的大小。所以p是一个整形的指针，而&amp;p是这样这个指针，即指向一个包含n个元素的int数组。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">p</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//和&amp;p[0]等价，表示第一个元素的地址</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//整个数组的地址</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">+</span>  <span class="mi">1</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//下一个元素</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="o">&amp;</span><span class="n">p</span> <span class="o">+</span>  <span class="mi">1</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//数组结束地址</span>


<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span>  <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span><span class="c1">//创建一个指向6个int元素的指针</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//整个数组大小，和&amp;p等价</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="o">*</span><span class="n">pp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//整个数组中第一个元素的地址。和p以及&amp;p[0]等价</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="o">**</span><span class="n">pp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//第一个元素</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span> <span class="o">+</span>  <span class="mi">1</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//第二个元素的地址，和&amp;p[1]等价</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span> <span class="o">+</span>  <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//第二个元素的值</span>
</code></pre></div></div>

<p>上面这几行反汇编的结果如下所示。伪代码很奇怪。</p>

<p><img src="images/Snipaste_2019-07-28_10-52-40.png" alt="Snipaste_2019-07-28_10-52-40" /></p>

<p>直接上汇编代码。</p>

<p><img src="images/Snipaste_2019-07-28_10-54-59.png" alt="Snipaste_2019-07-28_10-54-59" /></p>

<p>直接看汇编的话就会发现，前面2个是一样的。即pp和&amp;pp，在实现是一样的。第三个多了一行mov指令，<code class="highlighter-rouge">mov     eax, [rax]</code>所以是第一个元素。第四个多了一行<code class="highlighter-rouge">add     rax, 4</code>，所以是取第二个元素的地址。第五个则是多了上面两行，所以是第二个元素。</p>

<h1 id="类型组合">类型组合</h1>

<p>主要是指针数组比较难理解。<strong>指针数组是数组，每一个成员都是指针，可以创建一个二级指针指向该数组</strong>可以采用auto类型自动判断类型。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 结构体数组</span>
<span class="n">helloworld</span> <span class="n">p1</span><span class="p">[]{</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">};</span>
<span class="c1">// 结构体数组访问方式</span>
<span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">year</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)).</span><span class="n">year</span><span class="p">;</span>

<span class="c1">// 指针数组，指向结构体的指针</span>
<span class="n">helloworld</span> <span class="o">*</span><span class="n">p2</span><span class="p">[]{</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s3</span><span class="p">};</span>
<span class="c1">//指针数组访问方式</span>
<span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">year</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">year</span><span class="p">;</span>
<span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="n">p2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)).</span><span class="n">year</span><span class="p">;</span>

<span class="c1">//二级指针，指向指针数组</span>
<span class="k">auto</span> <span class="n">p3</span><span class="p">{</span><span class="n">p2</span><span class="p">};</span>
<span class="c1">//二级指针访问方式</span>
<span class="p">(</span><span class="o">*</span><span class="n">p3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">year</span><span class="p">;</span><span class="c1">//*p3表示第一个元素，同时也是指针，先解引用，得到的是&amp;s1，但是+1得到的不一定是下一个元素地址，可能不连续</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">p3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)).</span><span class="n">year</span><span class="p">;</span>

<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">year</span><span class="p">;</span><span class="c1">//p3表示&amp;p2的地址，先+1得到的是下一个元素的地址，然后解引用得到结构体地址，是正确的访问思路</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))).</span><span class="n">year</span><span class="p">;</span>

<span class="c1">//*(*p4)[3]类型指针，指向整个指针数组</span>
<span class="k">auto</span> <span class="n">p4</span><span class="p">{</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//和&amp;p2等价，整个指针数组的地址，是一个整体</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p4</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//先解引用，和p2以及&amp;p2[0]等价，数组首地址，+1得到第二个元素地址</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">p4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//再一次解引用，得到第二个元素的值，就是&amp;s2的值cout &lt;&lt; (*(*p4 + 1))-&gt;year &lt;&lt; endl;//访问结构体的值</span>
</code></pre></div></div>

<p>正确的二级指针访问的汇编代码如下所示：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rbp</span><span class="o">+</span><span class="n">p1</span><span class="p">]</span>
<span class="n">add</span>     <span class="n">rax</span><span class="p">,</span> <span class="mi">8</span>
<span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
<span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
</code></pre></div></div>

<h1 id="数组模板">数组模板</h1>

<p>主要是vector和array两个模板类，都定义在std命名空间中，使用需要包含相应头文件。vector存储在heap，大小可变。array存储在stack，大小不可变。array对象可以直接进行对象赋值。使用at方法可以检查index是否越界。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vt</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="c1">//vector&lt;int&gt; vt(5);</span>

<span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">ai</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</code></pre></div></div>

<h1 id="for循环结构">for循环结构</h1>

<p>for循环的组成部分。</p>

<ol>
  <li>设置初始值。</li>
  <li>执行测试条件，判断循环是否继续。</li>
  <li>执行循环操作。</li>
  <li>更新值。</li>
</ol>

<p>声明语句表达式，关于这个概念，是指在for循环的初始化部分可以是表达式语句，也可以是声明。</p>

<h2 id="前缀和后缀">前缀和后缀</h2>

<p><strong>前缀表达式的效率比后缀表达式的效率高</strong>因为前缀函数直接运算后返回结果。而后缀首先复制一个副本，然后计算表达式，最后返回副本。
<strong>如果递增运算符和指针结合，需要考虑到运算符的优先级和结合顺序。前缀运算符和解引用优先级相同，从右向左结合；后缀运算符优先级更高，从左向右结合。</strong></p>

<p>关于逗号表达式：逗号表达式首先计算第一个表达式，然后计算第二个表达式。整个逗号表达式的值是最后部分的值。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cata</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">140</span><span class="p">;</span><span class="c1">//等价于(cata = 17) , 140; cata值为17</span>
<span class="n">cata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">140</span><span class="p">);</span><span class="c1">//括号优先级最高，cata值为140</span>
</code></pre></div></div>

<p>关于延时循环，使用clock函数，直接贴代码。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//#include &lt;bits/stdc++.h&gt;</span>
<span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;array&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">secs</span><span class="p">{</span><span class="mf">5.0</span><span class="p">};</span>
    <span class="kt">clock_t</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">secs</span> <span class="o">*</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span><span class="c1">// 将延时秒数乘以宏，得到以系统时间为单位的时间</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"starting!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="kt">clock_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span><span class="c1">//返回的是系统时间</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">delay</span><span class="p">);</span><span class="c1">//死循环延时</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"done"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="别名">别名</h2>

<p>C++使用两种方式定义别名。分别是预处理器和typedef关键字。尽量用typedef，预处理器错误太多了。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define  BYTE1 char
</span><span class="k">typedef</span> <span class="kt">char</span> <span class="n">byte1</span><span class="p">,</span> <span class="o">*</span><span class="n">charptr</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="c11循环">C++11循环</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="p">{</span><span class="mf">4.99</span><span class="p">,</span> <span class="mf">10.99</span><span class="p">,</span> <span class="mf">6.87</span><span class="p">,</span> <span class="mf">7.99</span><span class="p">,</span> <span class="mf">8.49</span><span class="p">})</span><span class="c1">//或者用引用类型，可以修改变量的值</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="循环和文本输入">循环和文本输入</h1>

<p>文件尾条件，称为EOF，操作系统都支持重定向，允许用文件替换键盘输入。比如<code class="highlighter-rouge">get.exe &lt; test.txt</code>可以将文件输入至该程序中。小于号是重定向运算符。cin对象在检测到EOF之后，设置eofbit和failbit为true。可以通过对应的成员函数cin.eof()和cin.fail()查看。所以在循环输入的时候，可以通过这个方法检测输入是否完成，这是常规的做法。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
<span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">fail</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span><span class="c1">// 常见的做法</span>
<span class="p">{</span>
  <span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="c1">// 更有效的做法</span>
<span class="p">{</span>
  
<span class="p">}</span>
</code></pre></div></div>

<p>第二种如代码所示，istream类提供了一个istream对象转换成bool类型的函数，即cin可以作为while的测试条件，这比检测fail更有效，因为能检测磁盘故障等问题。鉴于get方法返回的还是cin对象，所以可以直接精简成上面的测试条件。</p>

<p>cin.get()和cout.put()，以及getchar()和putchar()类似。在iostream中，EOF被定义为-1。可以使用cin.get()和cout.put()代替上面的函数，然后用EOF代替cin.fail()。注意cin.get()返回的是int类型的值，不是char。后面输出的时候也要强制转换。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 普通版本，g++编译其实没问题</span>
<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="k">while</span><span class="p">(</span><span class="n">ch</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
  <span class="n">ch</span> <span class="o">=</span> <span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 更好的版本</span>
<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">ch</span> <span class="o">=</span>  <span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="kt">char</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>主要是因为两套不一样的函数，分别是cin.get(ch)和cin.get()。cin.get(ch)返回的是istream对象，即cin，可以连续读取。而cin.get()返回的是int类型的值。</p>

<h1 id="嵌套循环和二维数组">嵌套循环和二维数组</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>  <span class="n">maxtmps</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]{</span>
    <span class="p">{</span><span class="mi">96</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">58</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">23</span><span class="p">,</span> <span class="mi">684</span><span class="p">,</span> <span class="mi">83</span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>初始化方式如上所示。</p>

<h1 id="分支语句">分支语句</h1>

<p>取反运算符的优先级高于所有关系运算符和算术运算符。
逻辑与运算符优先级高于逻辑或运算符。
C++保留了and、or和not关键字。</p>

<h1 id="cctype">cctype</h1>

<p>引入头文件cctype。</p>

<p><img src="images/Snipaste_2019-07-29_15-54-04.png" alt="Snipaste_2019-07-29_15-54-04" /></p>

<p>其中_ISbit宏如下。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># define _ISbit(bit) ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8))
</span></code></pre></div></div>

<h1 id="读取数字">读取数字</h1>

<p>如果没有正确读取到数字，变量的值将不变，输入将保留在输入流中，cin将设置错误标记，同时返回false。后续需要使用clear()方法重置错误标记。常见的做法是<code class="highlighter-rouge">while(cin&gt;&gt;x)</code>通过cin对象判断输入是否成功，失败则退出，否则继续。如果失败还需要继续读取，则需要重置，设置<code class="highlighter-rouge">cin.clear()</code>来接受新的输入，然后删除错误的输入序列，再进行新的输入。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">))</span><span class="c1">//判断读取是否成功</span>
<span class="p">{</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//重置输入</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'\n'</span><span class="p">)</span><span class="c1">//删除输入序列</span>
    <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"please input"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="文件输入输出">文件输入输出</h1>

<p>这里讨论的主要是文本文件的输出。需要引入头文件fstream和ofstream类的对象，通过open和close方法进行文件输出。最后使用«输出到文件中。输入也是相同的方法，定义ifstream的对象，然后调用方法进行输入。通过good方法，能检测所有的问题，包括磁盘错误，文件受损，读取EOF，类型不匹配等等。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;fstream&gt;
</span><span class="c1">//输出</span>
<span class="n">ofstream</span> <span class="n">fout</span><span class="p">;</span>
<span class="n">fout</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"out.txt"</span><span class="p">);</span>
<span class="n">fout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">fout</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

<span class="c1">//输入</span>
<span class="kt">char</span> <span class="n">cintext</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">ifstream</span> <span class="n">fin</span><span class="p">;</span>
<span class="n">fin</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"in.txt"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fin</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span><span class="c1">//判断是否打开成功</span>
<span class="p">{</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">fin</span> <span class="o">&gt;&gt;</span> <span class="n">cintext</span><span class="p">;</span>
<span class="n">fin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">cintext</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="n">fin</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

<span class="c1">//最好的输入检测方式</span>
<span class="k">while</span><span class="p">(</span><span class="n">fin</span> <span class="o">&gt;&gt;</span> <span class="n">value</span><span class="p">)</span><span class="c1">//自动调用good方法判断是否成功</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>混合输入的时候，<code class="highlighter-rouge">cin.getline(array, len)</code>读字符串，<code class="highlighter-rouge">cin&gt;&gt;x</code>读数字，然后<code class="highlighter-rouge">cin.get()</code>读换行符。</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#c" class="page__taxonomy-item" rel="tag">C++</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-07-26T14:30:00+08:00">July 26, 2019</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=zjgcjy&text=Cpp+Prime+Plus+Learning2%20https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-07%2FCPP-Prime-Plus-Learning2.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-07%2FCPP-Prime-Plus-Learning2.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fzjgcjy.github.io%2Fposts%2F2019-07%2FCPP-Prime-Plus-Learning2.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/posts/2019-07/CPP_Prime_Plus_Learning1.html" class="pagination--pager" title="Cpp_prime_plus_learning1
">Previous</a>
    
    
      <a href="/posts/2019-07/VScode_configuration.html" class="pagination--pager" title="Vscode_configuration
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-11/Dirary_November.html" rel="permalink">Dirary_november
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




11月1日
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Software_Security_Project.html" rel="permalink">Software_security_project
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  Malware
vs2010




InfoCollection

configure



warning



</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/Pacman_Helper.html" rel="permalink">Pacman_helper
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  pacman 手册




archlinux pacman 命令
arch wiki

pacman -Sy 仅同步源

pacman -Syu 同步源，并更新系统

pacman -Su –ignore foo 升级时不升级包foo

pacman -S abc 从本地数据库中得到abc的信息，下载安装...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/posts/2019-10/%E5%8D%81%E6%9C%88%E6%97%A5%E8%AE%B0.html" rel="permalink">十月日记
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">
  每日所作所得




10月1日

周日，上课前最后一天，算是给自己放了最后一天假期

10月2日

上了第一天的课，主要是os，一脸蒙蔽。
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://github.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://twitter.com/zjgcjy" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Blogger. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    
  <script>
    var disqus_config = function () {
      this.page.url = "https://zjgcjy.github.io/posts/2019-07/CPP-Prime-Plus-Learning2.html";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/posts/2019-07/CPP-Prime-Plus-Learning2"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://zjgcjy-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  </body>
</html>
